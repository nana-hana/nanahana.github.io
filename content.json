[{"title":"coding 部署前后端分离项目","date":"2020-08-13T03:47:56.000Z","path":"posts/c42f8baa/","text":"后端代码部署 coding 部署 SpringBoot 项目执行流程(使用持续集成中的构建计划执行) git 提交代码到后台仓库触发自动部署触发器。 coding 读取代码仓库的 Jenkinsfile 文件，执行 Jenkinsfile 文件中的部署流程。 coding 读取代码仓库的代码并打成 jar 包。 coding 读取代码仓库的 Dockerfile 文件将 jar 包包装成 docker 镜像文件(jdk)并上传至制品库。 coding 通过远端服务器的 docker 拉取制品库中的 docker 镜像文件并运行。 托管仓库目录结构 构建计划环境变量 变量名 默认值 注释 DOCKER_IMAGE_NAME docker 镜像名 DOCKERFILE_PATH Dockerfile Dockerfile 文件位置 DOCKER_BUILD_CONTEXT . Docker 构建目录 DOCKER_IMAGE_VERSION ${GIT_LOCAL_BRANCH:-branch}-${GIT_COMMIT} Docker 镜像版本 DOCKER_REPO_NAME 当前项目下的 Docker 制品仓库名 REMOTE_USER_NAME SSH 用户名 REMOTE_SSH_PORT SSH 端口 REMOTE_HOST 目标服务地址(IP) REMOTE_CRED SSH 登陆凭据 TOMCAT_PORT 8080 tomcat 端口 Jenkinsfile 文件 pipeline { agent any stages { stage('检出') { steps { checkout([$class: 'GitSCM', branches: [[name: env.GIT_BUILD_REF]], userRemoteConfigs: [[ url: env.GIT_REPO_URL, credentialsId: env.CREDENTIALS_ID ]]]) } } stage('编译') { steps { sh 'mvn install' echo '编译完成.' archiveArtifacts(artifacts: '**/target/*.jar', fingerprint: true) } } stage('构建 Docker 镜像') { steps { sh \"docker build -f ${env.DOCKERFILE_PATH} -t ${env.CODING_DOCKER_IMAGE_NAME}:${env.DOCKER_IMAGE_VERSION} ${env.DOCKER_BUILD_CONTEXT}\" } } stage('推送到 CODING Docker 制品库') { steps { script { docker.withRegistry( \"${env.CCI_CURRENT_WEB_PROTOCOL}://${env.CODING_DOCKER_REG_HOST}\", \"${env.CODING_ARTIFACTS_CREDENTIALS_ID}\" ) { docker.image(\"${CODING_DOCKER_IMAGE_NAME}:${env.DOCKER_IMAGE_VERSION}\").push() } } } } stage('部署到远端服务') { steps { script { def remoteConfig = [:] remoteConfig.name = \"my-remote-server\" remoteConfig.host = \"${env.REMOTE_HOST}\" remoteConfig.port = \"${env.REMOTE_SSH_PORT}\".toInteger() remoteConfig.allowAnyHosts = true withCredentials([ sshUserPrivateKey( credentialsId: \"${env.REMOTE_CRED}\", keyFileVariable: \"privateKeyFilePath\" ), usernamePassword( credentialsId: \"${env.CODING_ARTIFACTS_CREDENTIALS_ID}\", usernameVariable: 'CODING_DOCKER_REG_USERNAME', passwordVariable: 'CODING_DOCKER_REG_PASSWORD' ) ]) { // SSH 登陆用户名 remoteConfig.user = \"${env.REMOTE_USER_NAME}\" // SSH 私钥文件地址 remoteConfig.identityFile = privateKeyFilePath // 请确保远端环境中有 Docker 环境 sshCommand( remote: remoteConfig, command: \"docker login -u ${CODING_DOCKER_REG_USERNAME} -p ${CODING_DOCKER_REG_PASSWORD} ${CODING_DOCKER_REG_HOST}\", sudo: true, ) sshCommand( remote: remoteConfig, command: \"docker rm -f ${CODING_DOCKER_IMAGE_NAME} | true\", sudo: true, ) // DOCKER_IMAGE_VERSION 中涉及到 GIT_LOCAL_BRANCH / GIT_TAG / GIT_COMMIT 的环境变量的使用 // 需要在本地完成拼接后，再传入到远端服务器中使用 DOCKER_IMAGE_URL = sh( script: \"echo ${CODING_DOCKER_REG_HOST}/${CODING_DOCKER_IMAGE_NAME}:${env.DOCKER_IMAGE_VERSION}\", returnStdout: true ) sshCommand( remote: remoteConfig, command: \"docker run -d -p ${env.TOMCAT_PORT}:${env.TOMCAT_PORT} --name ${CODING_DOCKER_IMAGE_NAME} ${DOCKER_IMAGE_URL}\", sudo: true, ) echo \"部署成功，请到 http://${env.REMOTE_HOST}:${env.TOMCAT_PORT} 预览效果\" } } } } } environment { CODING_DOCKER_REG_HOST = \"${env.CCI_CURRENT_TEAM}-docker.pkg.${env.CCI_CURRENT_DOMAIN}\" CODING_DOCKER_IMAGE_NAME = \"${env.PROJECT_NAME.toLowerCase()}/${env.DOCKER_REPO_NAME}/${env.DOCKER_IMAGE_NAME}\" } } Dockerfile 文件 FROM openjdk:8-jdk-alpine3.9 VOLUME /tmp ADD target/engineering_certification-1.0.jar main-project.jar ADD src/main/resources/application.yml application.yml ADD src/main/resources/application-dev.yml application-dev.yml EXPOSE 80 # 需要注意 docker 打包 springboot 项目不会自动读取配置文件，需要外部引入 ENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom --spring.config.location=classpath:file:/application.yml\",\"-jar\", \"/main-project.jar\"] 前端代码部署 coding 部署 angular 项目执行流程(使用持续集成中的构建计划执行) git 提交代码到后台仓库触发自动部署触发器。 coding 读取代码仓库的 Jenkinsfile 文件，执行 Jenkinsfile 文件中的部署流程。 coding 读取代码仓库的代码通过 npm 生成静态文件。 coding 读取代码仓库的 Dockerfile 文件将静态文件夹包装成 docker 镜像文件(nginx)并上传至制品库。 coding 通过远端服务器的 docker 拉取制品库中的 docker 镜像文件并运行。 托管仓库目录结构 构建计划环境变量 变量名 默认值 注释 DOCKER_IMAGE_NAME docker 镜像名 DOCKERFILE_PATH Dockerfile Dockerfile 文件位置 DOCKER_BUILD_CONTEXT . Docker 构建目录 DOCKER_IMAGE_VERSION ${GIT_LOCAL_BRANCH:-branch}-${GIT_COMMIT} Docker 镜像版本 DOCKER_REPO_NAME 当前项目下的 Docker 制品仓库名 REMOTE_USER_NAME SSH 用户名 REMOTE_SSH_PORT SSH 端口 REMOTE_HOST 目标服务地址(IP) REMOTE_CRED SSH 登陆凭据 NGINX_PORT 80 nginx 端口 NGINX_CONFIG nginx.conf nginx配置文件 Jenkinsfile 文件 pipeline { agent any stages { stage('检出') { steps { checkout([$class: 'GitSCM', branches: [[name: env.GIT_BUILD_REF]], userRemoteConfigs: [[ url: env.GIT_REPO_URL, credentialsId: env.CREDENTIALS_ID ]]]) } } stage('安装依赖') { steps { sh 'npm install' echo '安装依赖完成.' } } stage('编译') { steps { sh 'npm run build' echo '编译完成.' } } stage('构建 Docker 镜像') { steps { sh \"docker build -f ${env.DOCKERFILE_PATH} -t ${env.CODING_DOCKER_IMAGE_NAME}:${env.DOCKER_IMAGE_VERSION} ${env.DOCKER_BUILD_CONTEXT}\" } } stage('推送到 CODING Docker 制品库') { steps { script { docker.withRegistry( \"${env.CCI_CURRENT_WEB_PROTOCOL}://${env.CODING_DOCKER_REG_HOST}\", \"${env.CODING_ARTIFACTS_CREDENTIALS_ID}\" ) { docker.image(\"${CODING_DOCKER_IMAGE_NAME}:${env.DOCKER_IMAGE_VERSION}\").push() } } } } stage('部署到远端服务') { steps { script { def remoteConfig = [:] remoteConfig.name = \"my-remote-server\" remoteConfig.host = \"${env.REMOTE_HOST}\" remoteConfig.port = \"${env.REMOTE_SSH_PORT}\".toInteger() remoteConfig.allowAnyHosts = true withCredentials([ sshUserPrivateKey( credentialsId: \"${env.REMOTE_CRED}\", keyFileVariable: \"privateKeyFilePath\" ), usernamePassword( credentialsId: \"${env.CODING_ARTIFACTS_CREDENTIALS_ID}\", usernameVariable: 'CODING_DOCKER_REG_USERNAME', passwordVariable: 'CODING_DOCKER_REG_PASSWORD' ) ]) { // SSH 登陆用户名 remoteConfig.user = \"${env.REMOTE_USER_NAME}\" // SSH 私钥文件地址 remoteConfig.identityFile = privateKeyFilePath // 请确保远端环境中有 Docker 环境 sshCommand( remote: remoteConfig, command: \"docker login -u ${CODING_DOCKER_REG_USERNAME} -p ${CODING_DOCKER_REG_PASSWORD} ${CODING_DOCKER_REG_HOST}\", sudo: true, ) sshCommand( remote: remoteConfig, command: \"docker rm -f ${env.DOCKER_IMAGE_NAME} | true\", sudo: true, ) // DOCKER_IMAGE_VERSION 中涉及到 GIT_LOCAL_BRANCH / GIT_TAG / GIT_COMMIT 的环境变量的使用 // 需要在本地完成拼接后，再传入到远端服务器中使用 DOCKER_IMAGE_URL = sh( script: \"echo ${CODING_DOCKER_REG_HOST}/${CODING_DOCKER_IMAGE_NAME}:${env.DOCKER_IMAGE_VERSION}\", returnStdout: true ) sshCommand( remote: remoteConfig, command: \"docker run -d -p ${env.NGINX_PORT}:${env.NGINX_PORT} --name ${env.DOCKER_IMAGE_NAME} ${DOCKER_IMAGE_URL}\", sudo: true, ) echo \"部署成功，请到 http://${env.REMOTE_HOST}:${env.NGINX_PORT} 预览效果\" } } } } } environment { CODING_DOCKER_REG_HOST = \"${env.CCI_CURRENT_TEAM}-docker.pkg.${env.CCI_CURRENT_DOMAIN}\" CODING_DOCKER_IMAGE_NAME = \"${env.PROJECT_NAME.toLowerCase()}/${env.DOCKER_REPO_NAME}/${env.DOCKER_IMAGE_NAME}\" } } Dockerfile 文件 FROM nginx:stable-alpine-perl COPY dist /usr/share/nginx/html COPY nginx.conf /etc/nginx/nginx.conf EXPOSE 80 CMD [\"nginx\", \"-g\", \"daemon off;\"] nginx.conf 文件 worker_processes 1; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,DELETE,PUT,OPTIONS; server { listen 80; server_name localhost; # angular-cos 是 angular 的项目名称 location / { root /usr/share/nginx/html/angular-cos; index index.html index.htm; } # 此处 engineering 是 springboot 项目的 context-path 配置，需要注意 proxy_pass 就不需要配置 context-path 的路劲了 location /engineering { proxy_pass http://118.31.15.147:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 100m; } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"coding","slug":"coding","permalink":"https://blog.kuukokawaii.com/tags/coding/"},{"name":"docker","slug":"docker","permalink":"https://blog.kuukokawaii.com/tags/docker/"},{"name":"jenkins","slug":"jenkins","permalink":"https://blog.kuukokawaii.com/tags/jenkins/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.kuukokawaii.com/tags/nginx/"}]},{"title":"redis","date":"2020-07-14T01:00:26.000Z","path":"posts/7b25d017/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MySQL","date":"2020-05-05T07:51:30.000Z","path":"posts/c24675b4/","text":"存储引擎InnoDB是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。 实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC) + Next-Key Locking 防止幻影读。 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。 MyISAM设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。 提供了大量的特性，包括压缩表、空间数据索引等。 不支持事务。 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。 数据类型整型 数据类型 存储空间(位) TINYINT 8 SMALLINT 16 MEDIUMINT 24 INT 32 BIGINT 64 其中 INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。 浮点数FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。 字符串主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。 日期时间MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。 DATETIME 能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它与时区无关。默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 TIMESTAMP 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。它和时区有关。MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 索引索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 索引的优点： 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。 索引的使用条件： 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。 对于中到大型的表，索引就非常有效。 对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 索引的优化： 独立的列：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 多列索引：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。 索引列的顺序：让选择性最强(索引值和记录值的比接近或等于1)的索引列放在前面。 前缀索引：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 覆盖索引：索引包含所有需要查询的字段的值。其索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。而且可以在内存中仅缓存索引，而数据依赖于操作系统来缓存。 B+ Tree 索引B+ Tree 索引是大多数 MySQL 存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。根据 B+ Tree 的有序性，索引除了用于查找，还可以用于排序和分组。 可以指定多个列作为索引列，多个索引列共同组成键。适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。 哈希索引哈希索引能以 O(1) 时间进行查找，但是失去了有序性，且无法用于排序与分组，只能进行精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 全文索引InnoDB 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引(通过表记录关键字在第几页第几行)实现，它记录着关键词到其所在文档的映射。 空间索引MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。但必须使用 GIS 相关的函数来维护数据。 查询性能优化优化数据访问 减少请求的数据量：只返回必要的列(不使用 SELECT *)；只返回必要的行(使用 LIMIT)；缓存重复查询的数据。 减少服务器端扫描的行数：最有效的方式是使用索引来覆盖查询。 重构查询方式一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。可以通过将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联。 切分水平切分水平切分(Sharding)将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。 Sharding 策略： 哈希取模：hash(key) % N； 范围：可以是 ID 范围也可以是时间范围； 映射表：使用单独的一个数据库来存储映射关系。 Sharding 存在的问题： 事务问题：使用分布式事务来解决，比如 XA 接口。 连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。 ID 唯一性：使用全局唯一 ID(GUID)；为每个分片指定一个 ID 范围；分布式 ID 生成器。 垂直切分垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。 复制主从复制主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。 binlog 线程 ：负责将主服务器上的数据更改写入二进制日志(Binary log)中。 I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志(Relay log)。 SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放(Replay)。 读写分离主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。读写分离能提高性能的原因在于： 主从服务器负责各自的读和写，极大程度缓解了锁的争用； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性。 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL 基础","date":"2020-05-05T05:08:11.000Z","path":"posts/f416b295/","text":"基础结构化查询语言(Structured Query Language)简称 SQL，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。 SQL 中主键的值不允许修改，也不允许复用，即不能将已经删除的主键值赋给新数据行的主键。 SQL 支持以下三种注释： # 注释1 -- 注释2 /* 注释3 注释4 */ 数据库创建与使用： CREATE DATABASE test; USE test; 建表与改表 创建表 CREATE TABLE mytable ( # int 类型，不为空，自增 id INT NOT NULL AUTO_INCREMENT, # int 类型，不可为空，默认值为 1 col1 INT NOT NULL DEFAULT 1, # 变长字符串类型，最长为 45 个字符，可以为空 col2 VARCHAR(45) NULL, # 日期类型，可为空 col3 DATE NULL, # 设置主键为 id PRIMARY KEY (`id`) ); 添加列 ALTER TABLE mytable ADD col4 CHAR(20); 删除列 ALTER TABLE mytable DROP COLUMN col4; 删除表 DROP TABLE mytable; CRUD 增加(Create) # 普通插入 INSERT INTO mytable(col1, col2) VALUES(val1, val2); # 插入检索出来的数据 INSERT INTO mytable1(col1, col2) SELECT col1, col2 FROM mytable2; # 将一个表的内容插入到一个新表 CREATE TABLE newtable AS SELECT * FROM mytable; 读取(Retrieve) # DISTINCT 相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。 SELECT DISTINCT col1, col2 FROM mytable; # LIMIT 限制返回的行数。一个参数返回前 x 行，两个参数返回从 x 开始共 y 行。 SELECT * FROM mytable LIMIT 0, 5; 更新(Update) UPDATE mytable SET col = val WHERE id = 1; 删除(Delete) # 删除指定行数据 DELETE FROM mytable WHERE id = 1; # 清空表即删除所有行数据 TRUNCATE TABLE mytable; 排序可以按多个列进行排序，并且为每个列指定不同的排序方式(ASC：升序，默认；DESC：降序)。 SELECT * FROM mytable ORDER BY col1 DESC, col2 ASC; 过滤可以使用 WHERE 关键字过滤数据。例如： SELECT * FROM mytable WHERE col IS NULL; 其中 WHERE 可用的操作符有： 操作符 说明 = 等于 &lt; 小于 &gt; 大于 &lt;&gt; 或 != 不等于 &lt;= 或 !&gt; 小于等于 &gt;= 或 !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为 NULL 值 需要注意的是NULL 与 0、空字符串都不同。 AND 和 OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件。 通配符通配符也是用在过滤语句中，但它只能用于文本字段。 % 匹配大于等于 0 个任意字符； _ 匹配一个任意字符； 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。还可以使用脱字符 ^ 对其进行否定，也就是不匹配集合内的字符。 需要使用 LIKE 关键字来进行通配符匹配。但是不要滥用通配符，通配符位于开头处匹配会非常慢。 SELECT * FROM mytable WHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本 计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。例如： SELECT col1 * col2 AS alias FROM mytable; CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。例如： SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_col FROM mytable; 函数各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。 汇总 函数 说明 AVG() 返回某列的平均值(会忽略 NULL 行) COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 使用 DISTINCT 可以汇总不同的值。 SELECT AVG(DISTINCT col1) AS avg_col FROM mytable; 文本处理 函数 说明 LEFT() 从左边开始截取字符串，格式为(字符串, 长度) RIGHT() 从右边开始截取字符串 SUBSTRING() 截取特定长度的字符串，格式为(字符串, 开始截取位置)或(字符串, 开始截取位置, 长度) LOWER() 转换为小写字符 UPPER() 转换为大写字符 LTRIM() 去除左边的空格 RTRIM() 去除右边的空格 LENGTH() 长度 SOUNDEX() 转换为语音值 SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。例如查找发音类似于 apple 的数据行： SELECT * FROM mytable WHERE SOUNDEX(col1) = SOUNDEX('apple') 日期和时间处理日期格式：YYYY-MM-DD；时间格式：HH:MM:SS 函数 说明 ADDDATE() 增加一个日期（天、周等） ADDTIME() 增加一个时间（时、分等） CURDATE() 返回当前日期 CURTIME() 返回当前时间 DATE() 返回日期时间的日期部分 DATEDIFF() 计算两个日期之差 DATE_ADD() 高度灵活的日期运算函数 DATE_FORMAT() 返回一个格式化的日期或时间串 DAY() 返回一个日期的天数部分 DAYOFWEEK() 对于一个日期，返回对应的星期几 HOUR() 返回一个时间的小时部分 MINUTE() 返回一个时间的分钟部分 MONTH() 返回一个日期的月份部分 NOW() 返回当前日期和时间 SECOND() 返回一个时间的秒部分 TIME() 返回一个日期时间的时间部分 YEAR() 返回一个日期的年份部分 # 查询当前日期+时间 SELECT NOW(); 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 分组把具有相同的数据值的行放在同一组中。可以对同一分组数据使用汇总函数进行处理。指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出(除了汇总字段)； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 SELECT col, COUNT(*) AS num FROM mytable WHERE col > 2 GROUP BY col HAVING num >= 2 ORDER BY num; 子查询子查询中只能返回一个字段的数据。可以将子查询的结果作为 WHRER 语句的过滤条件，例如： SELECT * FROM mytable WHERE col IN ( SELECT col1 FROM mytable1 ); 连接连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON。连接可以替换子查询，并且比子查询的效率一般会更快。 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 SELECT A.value, B.value FROM tablea AS A INNER JOIN tableb AS B ON A.key = B.key; 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 SELECT A.value, B.value FROM tablea AS A, tableb AS B WHERE A.key = B.key; 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 # 子查询版本 SELECT name FROM employee WHERE department = ( SELECT department FROM employee WHERE name = \"Jim\" ); # 自连接版本 SELECT e1.name FROM employee AS e1 INNER JOIN employee AS e2 ON e1.department = e2.department AND e2.name = \"Jim\"; 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。 SELECT A.value, B.value FROM tablea AS A NATURAL JOIN tableb AS B; 外连接外连接保留了没有关联的那些行。分为左外连接(LEFT OUTER JOIN 或 LEFT JOIN)，右外连接(RIGHT OUTER JOIN 或 RIGHT JOIN)以及全外连接(FULL OUTER JOIN 或 FULL JOIN)，左外连接就是保留左表没有关联的行。 SELECT Customers.cust_id, Orders.order_num FROM Customers LEFT OUTER JOIN Orders ON Customers.cust_id = Orders.cust_id; 组合查询使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。需要注意的是： 每个查询必须包含相同的列、表达式和聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 SELECT col FROM mytable WHERE col = 1 UNION SELECT col FROM mytable WHERE col =2; 视图视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。视图具有如下好处： 简化复杂的 SQL 操作，比如复杂的连接； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 CREATE VIEW myview AS SELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col FROM mytable WHERE col5 = val; 存储过程存储过程可以看成是对一系列 SQL 操作的批处理。使用存储过程的好处： 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 需要注意： 包含 IN、存；OUT 和 INOUT 三种参数。 给变量赋值都需要用 SELECT INTO 语句。 每次只能给一个变量赋值，不支持集合的操作。 # 声明语句结束符 DELIMITER // # IN 存；OUT 取；INOUT 存取 CREATE PROCEDURE myprocedure(OUT ret int) BEGIN # 声明变量 y DECLARE y int; # 存入 y SELECT sum(col1) FROM mytable INTO y; # 取出 y 计算存入 ret SELECT y*y INTO ret; END // DELIMITER ; # 调用存储过程 call myprocedure(@ret); # 取参 select @ret; 游标在存储过程中使用游标可以对一个结果集进行移动遍历。游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； DELIMITER // CREATE PROCEDURE myprocedure(OUT ret int) BEGIN # 结束标记 done DECLARE done boolean DEFAULT 0; DECLARE mycursor CURSOR FOR SELECT col1 FROM mytable; # 将结束标志绑定到游标，定义一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1 DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1; # 打开游标 OPEN mycursor; REPEAT # 用指定的打开游标读取下一行 FETCH mycursor INTO ret; SELECT ret; UNTIL done END REPEAT; # 关闭游标 CLOSE mycursor; END // DELIMITER ; 触发器触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。 INSERT 触发器包含一个名为 NEW 的虚拟表。例如： CREATE TRIGGER mytrigger AFTER INSERT ON mytable FOR EACH ROW SELECT NEW.col INTO @result; # 获取结果 SELECT @result; DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。 UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。 MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。 事务管理 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。 如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。例如： START TRANSACTION // ... SAVEPOINT delete1 // ... ROLLBACK TO delete1 // ... COMMIT 字符集基本术语： 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。 除了给表指定字符集和校对外，也可以给列指定： CREATE TABLE mytable ( # 指定行 col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci ) # 整个表 DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对： SELECT * FROM mytable ORDER BY col COLLATE latin1_general_ci; 权限管理MySQL 的账户信息保存在 mysql 这个数据库中。 USE mysql; SELECT user FROM user; 创建账号 # 新创建的账户没有任何权限。 CREATE USER myuser IDENTIFIED BY 'mypassword'; 修改账户名 RENAME USER myuser TO newuser; 删除账户 DROP USER myuser; 查看权限 SHOW GRANTS FOR myuser; 授予权限 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 GRANT SELECT, INSERT ON mydatabase.* TO myuser; 删除权限 GRANT(授予) 和 REVOKE(撤回) 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 更改密码 必须使用 Password() 函数进行加密。 SET PASSWROD FOR myuser = Password('new_password'); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库系统概念","date":"2020-05-03T03:35:07.000Z","path":"posts/4e003d05/","text":"事务事务是指逻辑上满足 ACID 的一组操作，要么都执行，要么都不执行。 原子性(Atomicity)：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。通过回滚可以使修改的操作失效，回滚可以用回滚日志(Undo Log)来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 一致性(Consistency)：执行事务前后，数据保持一致，所有事务对同一个数据的读取结果都是相同的。 隔离性(Isolation)：一个事务所做的修改在最终提交以前，对其它事务是不可见的。 持久性(Durability)：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。系统发生奔溃可以用重做日志(Redo Log)进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。 并发一致性问题在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。并发控制可以可以满足一致性，它通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂，所以数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。 丢失修改：两个事务同时读取修改同一数据，后提交事务的修改结果覆盖了先提交事务的修改结果，导致先提交事务的修改被丢失。 读脏数据：当一个事务读取到另一个事务正在进行修改却还没有提交到数据库中的数据便称为脏读，而读取到的数据被称为脏数据，依据脏数据所做的操作可能是不对的(例如可能回滚了)。 不可重复读：事务 A 读取了数据还未进行提交操作时，事务 B 也读取了该数据并对其数据进行了修改、提交操作，导致事务两次读取同一数据其结果却不一样。常发生于 update 操作之上。 幻影读：事务 A 读取了数据还未进行提交操作时，事务 B 也读取了该数据并对其数据进行了插入、提交操作，导致事务 A 再次读取该数据时发现多出了一些不存在的记录。常发生于 insert 操作之上。 封锁封锁粒度MySQL 中提供了三种封锁粒度：行级锁定(row-level)、表级锁定(table-level)和页级锁定(page-level)。封锁颗粒度越大，发生锁定资源争用的概率越高，并发程度降低；封锁颗粒度越小，发生锁定资源争用的概率越小，并发程度提升，但是会带来额外开销(锁操作及实现算法复杂)。 行级锁定：行级锁定是 MySQL 各存储引擎中最小颗粒度的锁定机制。由于行级锁定只锁定需要修改的那部分数据，增大了锁操作开销且很容易发生死锁，使用行级锁定的主要是 InnoDB 存储引擎。 表级锁定：表级锁定是 MySQL 各存储引擎中最大颗粒度的锁定机制。由于表级锁定一次会将整个表锁定，所以可以很好的避免死锁问题。使用表级锁定的主要是 MyISAM、MEMORY 和 CSV 等一些非事务性存储引擎。 页级锁定：开销和加锁时间界于表级锁定和行级锁定之间，会出现死锁，且锁定粒度也界于表级锁定和行级锁定之间，并发程度一般。使用页级锁定的主要是 BerkeleyDB 存储引擎。 封锁类型 读写锁： 互斥锁(Exclusive)：简写为 X 锁，又称写锁。一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 共享锁(Shared)：简写为 S 锁，又称读锁。一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 意向锁(Intention Locks)：意向锁可以更容易地支持多粒度封锁。意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有如下两个规定： 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 需要注意的是任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。且表级的 IS 锁和行级的 S 锁兼容。 封锁协议 三级封锁协议： 一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题。 二级封锁协议：在一级封锁协议的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题(修改时加 X 锁，此时就不能上 S 锁，也就是说修改时不能读取)。 三级封锁协议：在二级封锁协议的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题(读取时其它事务不能对 A 加 X 锁，避免了在读期间数据发生改变)。 两段锁协议：加锁和解锁分为两个阶段进行。可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。 MySQL 隐式与显示锁定 MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。 InnoDB 也可以使用特定的语句进行显示锁定。 隔离级别 读未提交(Read uncommitted)：一个事务可以读取另一个未提交事务的数据。没有解决任何并发一致性问题。 读已提交(Read committed)：一个事务要等另一个事务提交后才能读取数据。解决了脏读的问题。 可重复读(Repeatable read)：在事务开始读取数据时不再允许修改操作。解决了丢失修改、不可重复读和脏读的问题。 序列化(Serializable)：也称为可串行化，是最高的事务隔离级别，在该级别下事务串行化顺序执行。解决了所有并发一致性问题。 多版本并发控制多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现读已提交和可重复读这两种隔离级别(读未提交太简单不需要使用 MVCC，序列化太复杂单独使用 MVCC 不能解决)。MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。在 MVCC 中事务的修改操作(DELETE、INSERT、UPDATE)会为数据行新增一个版本快照，且只能读取已经提交的快照。 快照读：MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。 当前读：MVCC 其它会对数据库进行修改的操作(INSERT、UPDATE、DELETE)需要进行加锁操作，从而读取最新的数据。 Next-Key LocksNext-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现，在可重复读(REPEATABLE READ)隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。通过索引锁(Record Locks)和间隙锁(Gap Locks)锁定一个记录上的索引并锁定索引之间的间隙(锁定前开后闭区间)。例如1、3和5，锁定间隙为(-∞, 1]、(1, 3]和(3, 5]。 关系数据库设计理论函数依赖 A-&gt;B 表示 A 决定 B 或 B 依赖于 A。 {A1, A2, ……, An} 是关系的一个或多个属性的集合且该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。 A-&gt;B，若有A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。 若 A-&gt;B, B-&gt;C 则 A-&gt;C 是一个传递函数依赖。 范式不符合范式的关系，会产生很多异常，主要有四种异常：冗余数据、修改异常、删除异常和插入异常。而范式理论是为了解决以上提到的四种异常。高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。 第一范式 (1NF)：属性不可分。 第二范式 (2NF)：每个非主属性完全函数依赖于键码，可以通过分解来满足。 第三范式 (3NF)：非主属性不传递函数依赖于键码，可以通过分解来满足。 E-R 图实体-联系图(Entity Relationship Diagram)用来进行关系型数据库系统的概念设计，它由三部分组成：实体(方框)、属性(菱形)和联系(线段)。表示方法如下： 出现多次的关系：一个实体在联系中出现几次，就要用几条线段连接。 联系的多向性：例如虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。 子类：用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。 一对一关系：画两个带箭头的线段。 一对多关系：如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B。 多对多关系：画两个不带箭头的线段。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"计算机操作系统","date":"2020-04-06T05:00:17.000Z","path":"posts/f55dd124/","text":"功能并发与并行并发：两个或多个事件在同一时间间隔发生。例如引入进程和线程使得程序并发运行。并行：两个或多个事件在同一时刻发生，需要硬件支持。例如多核处理器和分布式计算系统可以并行运行。 共享共享是指系统中的资源可以被多个并发进程共同使用。共享分为互斥共享和同时共享： 互斥共享：在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。 同时共享：能被多个进程同时访问。 虚拟虚拟技术把一个物理实体转换为多个逻辑实体。常用虚拟技术有时分复用技术和空分复用技术： 时分复用技术：多个进程并发执行即每个进程轮流占用同一个处理器，每次只执行一小个时间片并快速切换。 空分复用技术：虚拟内存让应用程序觉得自己在使用一个连续完整的地址空间，每个进程都有各自的地址空间。使用虚拟内存时，地址空间的页会被映射至物理内存中(看起来连续实际上可能不连续)。根据程序的局部性，虚拟内存只会调用所需的程序段进入内存，然后通过页面置换算法不断替换所需程序段进入内存执行。 异步异步性是指进程以不可预知的速度向前推进。进程是并发执行的，并且因为资源的问题不同进程之间存在着不同的相互制约关系，内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，程序总共需要多少时间才能完成等，都是不可预知的。 系统调用进程在用户态时候如果需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。 大内核与微内核 大内核：将操作系统功能作为一个紧密结合的整体放到内核，由于各模块共享信息因此有很高的性能。 微内核：由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。通常只有微内核这一个模块运行在内核态，其余模块运行在用户态。由于需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。 中断 外中断：由 CPU 执行指令以外的事件引起，如 I/O 完成中断、时钟中断和控制台中断等。 异常：由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 陷入：在用户程序中使用系统调用。 管理 进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等。 内存管理：内存分配、地址映射、内存保护与共享、虚拟内存等。 文件管理：文件存储空间的管理、目录管理、文件读写管理和保护等。 设备管理：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等。 进程管理进程与线程 进程：进程是资源分配的基本单位。进程控制块(Process Control Block, PCB)描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 线程：线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。 区别： 进程拥有资源，线程不拥有资源但是可以访问隶属进程的资源。 同一进程中的线程切换不会引起进程切换。 由于创建或撤销进程时系统都需要分配或回收资源，因此所付出的开销远大于线程。进程的切换需要保存当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程的切换只需要保存和设置少量寄存器的内容，开销较小。 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC(Inter-Process Communication)。 进程状态的切换 状态 作用 就绪状态(ready) 等待被调度。 运行状态(running) 正在运行。 阻塞状态(waiting) 等待资源。 ready 的进程通过调度算法从而获得 CPU 时间，转为 running；running 的进程在分配给它的 CPU 时间片用完之后就会转为 ready，等待下一次调度。 waiting 是缺少需要的资源(不包括 CPU 时间)从而由 running 转换而来，当获得相应资源就会转为 ready。 进程调度算法不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 批处理系统：用于批量完成任务，因此调度算法目标是保证吞吐量和周转时间(即从提交到终止的时间)。 先来先服务 FCFS(first-come first-serverd)：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，短作业必须一直等待前面的长作业执行完毕才能执行。 短作业优先 SJF(shortest job first)：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。如果一直有短作业到来，那么长作业永远得不到调度。 最短剩余时间优先 SRTN(shortest remaining time next)：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。 交互式系统：拥有有大量用户交互操作的系统，因此调度算法目标是快速地进行响应。 时间片轮转：根据 FCFS 原则将进程排列成一个队列，进程按队列顺序依次执行一个时间片。时间片轮转算法的效率和时间片的大小有很大关系，例如进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁；而如果时间片过长，那么实时性就不能得到保证。 优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 多级反馈队列：多级队列是为长作业进程考虑的算法，它设置了多个队列，每个队列时间片大小都不同(例如越往后的队列时间片越大)。进程在第一个队列没执行完，就会被移到下一个队列。每个队列优先权也不同，最前面的优先权最高。因此只有前一个队列没有进程在排队，才能调度当前队列上的进程。 实时系统：实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定程度的超时。 进程同步 临界区：对临界资源(一次仅允许一个进程使用的资源)进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 同步与互斥： 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。 信号量：信号量(Semaphore)是一个整型变量，可以对其执行 P(通过) 和 V(释放) 操作，PV 操作被设计成原语，因此执行 PV 操作时屏蔽中断。若信号量的取值只能为 0 或者 1，那么就成为了互斥量(Mutex)，0 表示临界区已经加锁，1 表示临界区解锁。 P 操作：执行 S-1 操作后，若 S 仍大于或等于 0，则进程继续执行；否则该进程睡眠并等待 S 大于 0。 V 操作：执行 S+1 操作后，若 S 仍大于 0，则进程继续执行；否则唤醒睡眠的进程让其完成 P 操作。 管程：将使用信号量实现的程序中的控制代码独立出来，使得程序调用更容易。 在一个时刻只能有一个进程使用管程，且进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。 引入 wait() 和 signal() 来实现同步操作，其中 wait() 用于睡眠进程，而 signal() 用于唤醒睡眠的进程。 进程通信进程同步(控制多个进程按一定顺序执行)需要通过进程通信(进程间传输信息)传输一些进程同步所需要的信息。进程通信常用方法如下： 管道：通过调用 pipe 函数创建，其中fd[0]用于读，fd[1]用于写。管道只支持半双工通信(单向交替传输)且只能在父子进程或者兄弟进程中使用。 FIFO：也称为命名管道，去除了管道只能在父子进程中使用的限制且严格遵守先进先出原则。 消息队列：相比于 FIFO，消息队列可以独立于读写进程存在，可以根据消息类型有选择地接收消息(FIFO 只能默认接收)，并且消息队列包括消息优先级和消息到达通知等功能。 信号量：用于为多个进程提供对共享数据对象的访问。 共享存储：因为数据不需要在进程之间复制，所以允许多个进程共享一个给定的存储区，可以使用信号量来同步对共享存储的访问。可以通过多个进程将同一个文件映射到它们的地址空间从而实现共享内存。 套接字：上面的通信机制都只是用于进程之间的通信，而套接字可用于不同机器间的进程通信。 死锁在一组进程发生死锁的情况下，这组死锁进程中的每一个进程都在等待另一个死锁进程所占有的资源。 必要条件 互斥条件：在一段时间内，某资源只能被一个进程占用。 请求和保持条件：进程保持至少一个资源，又请求一个被其它进程占用的资源，此时请求进程被阻塞但又不释放自己持有的资源。 不可抢占条件：进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放。 循环等待条件：两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 处理方法 鸵鸟策略：当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略(忽略死锁)。 死锁检测和解除：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行解除。 每种类型一个资源的死锁检测：通过检测有向图是否存在环来实现，有环则产生了死锁，无环则没有死锁。 每种类型多个资源的死锁检测：每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。例如1.寻找一个没有标记的进程 Pi，它所请求的资源小于等于资源剩余量；2.如果找到了这样一个进程，执行该进程结束后，将该进程所拥有的资源释放(现在资源=该进程原来拥有的资源+剩余的资源)，标记该进程并转回第一步；3.如果没有这样一个进程，算法终止。 死锁解除：利用抢占恢复；利用回滚恢复；通过杀死进程恢复。 死锁预防：在程序运行之前预防发生死锁。 破坏互斥条件：假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 破坏请求和保持条件：可以规定所有进程在开始执行前请求所需要的全部资源；或者允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到 的已经使用完毕的资源，然后再去请求新的资源。 破坏不可抢占条件：让不可抢占的资源变得可以抢占，效率极低。 破坏循环等待条件：给资源统一编号，进程只能按编号顺序来请求资源。 死锁避免：在程序运行时避免发生死锁。 安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 单个资源的银行家算法：一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 多个资源的银行家算法：查找剩余资源量是否满足至少一个进程所需的资源，若不存在这样一个进程则状态是不安全的；假若找到这样一行，将该进程标记为终止，并将其已分配资源加到剩余资源中；重复以上两步，直到所有进程都标记为终止，则状态是安全的。 内存管理虚拟内存虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。在操作系统中将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。 分页系统地址映射内存管理单元(Memory Management Unit, MMU)管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。一个虚拟地址分成两个部分，一部分存储页面号(前 4 位，最后一位表是否存在内存中)，一部分存储偏移量(后 12 位)。 页面置换算法在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。页面置换算法的主要目标是使页面置换频率最低(也可以说缺页率最低)。 最佳(Optimal replacement algorithm, OPT)：所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率(理论算法，无法知道一个页面多长时间不再被访问)。 最近最久未使用(Least Recently Used, LRU)：为了实现 LRU 需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。 最近未使用(Not Recently Used, NRU)：每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。当发生缺页中断时，NRU 算法随机地从(R, M)=0,0、0,1、1,0、1,1 中挑选一个页面将它换出。NRU 优先换出已经被修改的脏页面(R=0，M=1)，而不是被频繁使用的干净页面(R=1，M=0)。 先进先出(First In First Out, FIFO)：选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 第二次机会算法：FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题对该算法做一个修改。当页面被访问时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。 时钟(Clock)：第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 分段虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。分页仅仅是由于系统管理的需要，而分段是为了能更好的满足用户的需要。分页的作业地址空间是一维的，分段的作业地址空间是二维的，既需给出段名，又需给出段内地址。 段页式程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。 设备管理磁盘结构 盘面(Platter)：一个磁盘有多个盘面； 磁道(Track)：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区(Track Sector)：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512bytes 与 4K 两种大小； 磁头(Head)：与盘面非常接近，能够将盘面上的磁场转换为电信号(读)，或者将电信号转换为盘面的磁场(写)； 制动手臂(Actuator arm)：用于在磁道之间移动磁头； 主轴(Spindle)：使整个盘面转动。 磁盘调度算法读写一个磁盘块的时间的影响因素有：旋转时间(旋转到适当的扇区上)、寻道时间(移动到适当的磁道上)和实际的数据传输时间，其中寻道时间最长。 先来先服务(First Come First Served, FCFS)：按照磁盘请求的顺序进行调度。因为未对寻道做任何优化，平均的寻道时间可能较长。 最短寻道时间优先(Shortest Seek Time First, SSTF)：优先调度与当前磁头所在磁道距离最近的磁道。虽然平均寻道时间比较低，但是可能导致两端的磁道请求更容易出现饥饿现象。 电梯算法(SCAN)：总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。改进版本是不进行方向改变，直接移动到最开始的位置继续进行电梯算法，解决了需要访问位置在当前访问位置前面一点时，平均寻道时间过长的问题。 链接编译过程 预处理阶段：处理以 # 开头的预处理命令； 编译阶段：翻译成汇编文件； 汇编阶段：将汇编文件翻译成可重定位目标文件(二进制代码和数据)； 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。 目标文件 可执行目标文件：可以直接在内存中执行。 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件。 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接。 静态链接静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务： 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 动态链接静态库有以下两个问题： 当静态库更新时那么整个程序都要重新进行链接； 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点： 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中； 在内存中一个共享库的已编译程序的机器代码的一个副本可以被不同的正在运行的进程共享。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"HTTP 协议","date":"2020-04-05T02:00:23.000Z","path":"posts/1e0873bb/","text":"URI 和 URLURI 是包含具体路径(不一定含文件)，URL 是包含具体文件路径(还必须是对应到路径下面的具体文件名称)。所以 URL 是 URI 的一个子集，URI是粗框架，URL是详细定位。 HTTP 请求报文和响应报文HTTP 协议是一种不保存状态，即无状态的的协议，也就是说 HTTP 协议对于发送过的请求或相应不做持久化处理，因此可以更快的处理大量事务。但随着 Web 的不断发展，有些业务需要使用状态信息例如登陆，于是引入了 Cookie 技术，有了 Cookie 再使用 HTTP 协议进行通信，就可以管理状态了。 请求报文：(如果只是对服务器本身发起请求，URI 可以使用 * 代替)响应报文： HTTP 方法HTTP 请求报文中请求行的方法字段。 方法 作用 GET 获取资源，请求访问已被 URI 识别的资源。 POST 传输实体主体，GET 也可以但是一般不用。 PUT 传输文件，方法自身不带验证机制，因此任何人都可上传有安全隐患，常用于 REST 架构网站。 HEAD 获取报文首部，与 GET 类似但是不返回报文主体部分，用于确认 URI 的有效性和资源更新的日期时间。 DELETE 删除文件，与 PUT 一样自身不带验证机制有安全隐患。 OPTIONS 询问支持的方法，用于查询请求 URI 指定的资源支持的方法。 TRACE 追踪路径，例如客户端到服务端之间有多个代理服务器，Trace 在 Max-Forwards 字段中填入数值，没经过一个服务器该数字减一，当达到0时该服务器返回状态码200响应。可以查询发送出去的请求是怎样被代理服务器修改的。由于容易引发 XST(Cross-Site Tracing，跨站追踪) 因此几乎不会使用。 CONNECT 要求用隧道协议连接代理，实现用隧道协议进行 TCP 通信。主要使用 SSL(Secure Sokcets Layer，安全套接层) 和 TLS(Transport Layer Security，传输层安全) 协议把通信内容加密后经网络隧道传输。 HTTP 状态码状态码的第一位指定了响应类别，分为如下5种： 状态码 类别 原因短语 1XX Informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 经常使用的状态码： 1XX 信息 100(Continue)：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2XX 成功 200(OK)：请求被正常处理。 204(No Content)：代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。 206(Partial Content)：表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。例如图片加载完成一半发生了错误，可以不用重头加载，直接请求未加载的另一半。 3XX 重定向 301(Moved Permanently)：永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。 302(Found)：临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户(本次)能使用新的 URI 访问。 303(See Other)：该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。和302类似，但303强调使用 GET 方法获取资源。 304(Not Modified)：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，也就是说找到了资源，但是这个资源并不符合附带的条件。 307(Temporary Redirect)：临时重定向，与302类似。307强制不准从 POST 变成 GET，302虽然禁止，但是其实可以实行。 4XX 客户端错误 400(Bad Request)：表示请求报文中存在语法错误。 401(Unauthorized)：表示发送的请求需要有通过 HTTP 认证，若之前已进行过1次请求，则当前返回的401表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。 403(Forbidden)：表明对请求资源的访问被服务器拒绝了。 404(Not Found)：表明服务器上无法找到请求的资源。 5XX 服务器错误 500(Internal Server Error)：表明服务器端在执行请求时发生了错误。 503(Service Unavailable)：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。 代理、网关、隧道 代理 代理是一种有转发功能的应用程序，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。 每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息。 缓存代理：代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。 透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy)。反之，对报文内容进行加工的代理被称为非透明代理。 网关 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。 利用网关可以由 HTTP 请求转化为其他协议通信。 利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全(例如通过网关连接数据库并使用 SQL 语句查询数据)。 隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。 HTTP 首部HTTP 首部包含4种 HTTP 首部字段类型，分别为通用首部字段、请求首部字段、响应首部字段和实体首部字段。 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段(例如 Connection: Upgrade 会删除 Upgrade 字段)、管理持久连接 Date 创建报文的日期时间 Pragma 报文指令，例如不缓存 Trailer 报文末端的首部一览，常用于分块传输，在报文末端显示首部。 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知，通常会告知用户一些与缓存相关的问题的警告。 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言(自然语言) Authorization Web认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器，常用于虚拟服务器(一个 IP 对应多个域名，使用 Host 指定域名) If-Match 比较实体标记(ETag) If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记(与 If-Match 相反) If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间(与If-Modified-Since相反) Max-Forwards 最大传输逐跳数(可经过多少代理服务器) Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小(单位：字节) Content-Location 替代对应资源的URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 HTTPSHTTP 主要不足如下： 通信使用明文，内容可能会被窃听。 不验证通信方的身份，因此有可能遭遇伪装。 无法证明报文的完整性，所以有可能已遭篡改。 通过和 SSL 或 TLS(TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL) 组合使用可以加密 HTTP 的通信内容。HTTP 与 SSL 组合使用被称为 HTTPS(HTTP Secure，超文本传输安全协议)，是一种隧道通信技术。HTTPS 具有加密、认证和完整性保护的特性。 加密 对称密钥加密：加密和解密使用同一密钥，但是面临着无法安全地将密钥传输给通信方的问题。 非对称密钥加密：加密和解密使用不同的密钥，公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密，但是无法证明非对称密钥加密的公开密钥是否被人篡改。 混合加密机制：非对称密钥加密速度比较慢，对称密钥加密相对较快，因此 HTTP 采用非对称密钥加密和对称密钥加密一起使用的混合加密机制。通过使用非对称加密方式传输对称密钥加密方式的密钥，之后通过对称密钥加密进行数据传输。 认证为了确认非对称密钥加密的公开密钥没有被篡改，可以通过使用证书来对通信方进行认证。证书由数字证书认证机构(CA，Certificate Authority)颁发，它是客户端与服务器双方都可信赖的第三方机构。其认证过程如下： 服务器将自己的公开密钥登陆至数字证书认证机构，数字认证机构使用自己的私有密钥向服务器的公开密码署数字签名并颁发公钥证书。 服务器向客户端发送公钥证书(包含服务器公开密钥和数字证书认证机构的数字签名)。 客户端接收到公钥证书，通过事先植入到浏览器中的可信数字证书认证机构的公开密钥进行验证，确认公钥证书的真实性。之后通过确认通过的公钥证书中的服务器公开密钥进行数据加密并传送给服务器。 完整性保护HTTP 提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。而 SSL 提供了安全的报文摘要功能来进行完整性保护，在进行 SSL 握手时应用层发送数据会附加一种叫做 MAC(Message Authentication Code)的报文摘要，MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络之应用层","date":"2020-04-04T01:53:37.000Z","path":"posts/41158dda/","text":"不同的网络应用的应用进程之间需要不同的通信规则，因此需要使用应用层协议。 域名系统 DNS域名系统(Domain Name System，DNS)是互联网使用的命名系统，用于提供主机名字和 IP 地址之间互相转换的服务。域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名等等。 DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，但在两种情况下会使用 TCP 进行传输： 如果返回的响应超过了 512 字节(UDP 最大只支持 512 字节的数据)。 区域传送(区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据)。 文件传输协议 FTPFTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。 网络文件系统 NFS 允许应用进程打开一个远地文件并能在该文件的某一个特定的位置上开始读写数据。 简单文件传送协议 TFTP 使用 UDP 进行文件传输，但不支持交互。 远程终端协议 TELNETTELNET 能将用户的输入传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。TELNET 能够适应虚度哦计算机和操作系统的差异，使用了网络虚拟终端(Network Virtual Terminal，NVT)，客户将输入转换成 NVT 格式传送至服务器，服务器把收到的输入从 NVT 格式转换成远地系统所需的格式，向用户返回数据时，服务器将远地系统的格式转换成 NVT 格式，本地客户再从 NVT 格式转换成本地系统所需的格式。 超文本传输协议 HTTPHTTP 协议定义了浏览器咋样向万维网服务器请求万维网文档以及服务器咋样把文档传送给浏览器。 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 SMTP：SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 POP3：POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除，但最新版本的 POP3 可以不删除邮件。 IMAP：IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 动态主机配置协议 DHCP动态主机配置协议(Dynamic Host Configuration Protocol，DHCP) 提供了即插即用的连网方式，这种机制允许一台计算机加入新的网络和获取 IP 地址不用手工参与。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。DHCP 工作过程如下(客户端使用 UDP 端口68，DHCP 服务器使用 UDP 端口67)： 客户端发送 DHCPDISCOVER 报文(封装于 UDP)，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68。将报文被广播到同一个子网的所有主机上。 DHCP 服务器收到 DHCPDISCOVER 报文之后，发送 DHCPOFFER 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 DHCPREQUEST 报文给该 DHCP 服务器。 DHCP 服务器发送 DHCPACK 报文，表示客户端此时可以使用提供给它的信息，拒绝则发送 DHCPNACK 报文。 客户端可以提前终止 DHCP 服务器提供的服务，只需要向 DHCP 服务器发送 DHCPRELEASE 报文即可。 常用协议 应用 应用层协议 端口号 传输层协议 附加 域名解析 DNS 53 UDP/TCP 长度超过 512 字节时使用 TCP 文件传送协议 FTP 20/21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP 动态主机配置协议 DHCP 67/68 UDP 客户端 UDP 端口68，DHCP 服务器 UDP 端口67 简单网络管理协议 SNMP 161 UDP 用于网络资源监控、测试、配置和分析之类的 Web 页面请求过程 DHCP 配置主机信息 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 DNS 解析域名 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络之传输层","date":"2020-04-03T07:10:06.000Z","path":"posts/9120eb8f/","text":"两台主机进行通信就是两台主机中的应用进程互相通信，IP 协议只是将分组送到了目的主机，还需要传输层将分组搬运到适应的目标进程中。也就是说网络层提供主机之间的逻辑通信，而运输层提供应用进程间的逻辑通信。 UDP用户数据报协议 UDP(User Datagram Protocol)是无连接的，尽最大可能交付，没有拥塞控制，面向报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)，支持一对一、一对多、多对一和多对多的交互通信。 TCP传输控制协议 TCP(Transmission Control Protocol)是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流(把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)，每一条 TCP 连接只能是点对点的(一对一)。 ACK：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 SYN：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 三次握手第三次握手是为了防止失效的连接请求到达服务器(第一个发送的连接未到达时发送了第二个连接，两个链接一起到达打开了两个连接)，让服务器错误打开连接。若 A 为客户端，B 为服务端。 A 向 B 发送连接请求报文(SYN=1, ACK=0)，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接则向 A 发送连接确认报文(SYN=1, ACK=1)，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 四次挥手客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。四次挥手即 TCP 释放连接。若 A 为客户端，B 为服务端。 A 发送连接释放报文(FIN=1)。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文(FIN=1)。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离；接收窗口左部字节已经发送确认并交付主机(接收窗口只会对窗口内最后一个按序到达的字节进行确认)，就向右滑动接收窗口。 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率降低整个网络的拥塞程度。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 慢开始与拥塞避免 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍。这样 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快重传与快恢复 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络之网络层","date":"2020-04-01T12:14:55.000Z","path":"posts/bc654c1/","text":"网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。在网络层提供连接服务的计算机网络称为虚电路网络，在网络层提供无连接服务的计算机网络称为数据报网络。 网际协议 IP网际协议 IP(Internet Protocol) 可以使互连起来的多台计算机网络能够进行通信。与 IP 协议配套使用的有三个协议： 地址解析协议 ARP地址解析协议 ARP(Address Resolution Protocol)通过 IP 地址就能获悉该 IP 地址对应的 MAC 地址，ARP 存在于主机的 ARP 高速缓存中，且只能解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题，因此此时需要通过路由器与路由器之间进行通信获取不同网络的 MAC 地址。逆地址解析 RARP 就是通过 MAC 地址就能获悉 IP 地址，DHCP 协议中包含 RARP 协议。 网际控制报文协议 ICMP网际控制报文协议 ICMP(Internet Control Message Protocol)ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 并不是高层协议，因为它封装在 IP 数据报中作为其中的数据部分。ICMP 报文分为差错报告报文和询问报文(回送请求或时间戳请求)。 ICMP 有两个非常重要的应用，分别是 Ping 和 Traceroute。 Ping 用于测试两台主机之间的连通性。其原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 Traceroute 用于跟踪一个分组从源点到终点的路径。其原理是发送无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。如源主机 A 到目的主机 D，中间经过 B、C 路由器，首先源主机 A 发送 TTL 为1的 IP 数据报，B 收到后将 TTL 减1，由于此时 TTL 为0所以将数据报丢弃并向源主机返回一个 ICMP 时间超过差错报告报文。然后源主机 A 发送 TTL 为2的 IP 数据报，此时能够被 C 路由器接收，C 路由器采取和 B 路由器一样的做法。如果经过 n 台路由器，则依次发送 TTL 为1至 n 的 IP 数据报。当达到目的主机时，目的主机要向源主机发送 ICMP 终点不可达差错报告报文。因此源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 网际组管理协议 IGMP网际组管理协议 IGMP(Internet Group Management Protocol)是应用于 IP 多播的一种协议，其实质为让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或退出了某个多播组。该协议必须和多播路由选择协议一起时候，多播路由选择协议使得连接在局域网上的多播路由器必须和互联网上的其它多播路由器协同工作，以便把多播数据报以最小代价传送给所有的组成员。 IP 地址编址方式IP 地址的三种编制方法：分类、子网划分和无分类编址。 分类IP 地址是一个全世界范围内唯一的32位标识符，其定义为 IP 地址 ::= {&lt;网络号&gt;, &lt;主机号&gt;}，网络号标志主机所连接到的网络，主机号标志该主机。一个 IP 地址在整个互联网范围内是唯一的。 特殊网络号和主机号： IP 地址中的全0表示当前网络。 网络号为 127 保留作为本地软件环回测试本主机的进程之间的通信之用。 128.0.0.0 和 192.0.0.0 是不指派的网络号。 主机号全0表示本主机，全1表示这个网络上的所有主机。 子网划分通过在 IP 地址中增加子网号字段(使用主机号的一部分)，使两级 IP 地址变成三级 IP 地址。 子网划分后的 IP 地址定义为 IP 地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}，要使用子网，必须配置子网掩码，子网掩码的位数即占用的主机号位数，其值为占用的位数的值都置为1。若某一 C 类地址的子网掩码为 255.255.255.192，意思为网络号占三个字节，子网号占2位，主机号占6位，因为192的二进制为11000000。 无分类编址无分类编址使用无分类域间路由选择 CIDR(Classless Inter-Domain Routing) 构造超网(supernetting)，消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念。 CIDR 把 IP 地址划分为网络前缀和主机号两部分，其定义为 IP 地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}，可以使用 CIDR 记法在主机号后用/网络号前缀号位数的方式标识前缀号位数。例如 192.168.1.20/16 表示网络前缀号为前16位。 CIDR 地址块(网络前缀指定的网络)中有很多地址，所以在路由表中利用 CIDR 地址快来查找目的网络，通常这种地址的聚合被称为路由聚合(route aggregation)，使得路由表中的一个项目可以表示原来传统分类地址的很多个路由，因此路由聚合也被称为构成超网。 在路由表中的项目由网络前缀和下一跳地址组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 IPV6IPV6 的地址增大到128位，可用地址空间随之增大。IPV6 会自动配置，因此不需要使用 DHCP。IPV6 使用冒号十六进制记法，如 68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF，一共8组共32个16进制数，也就是128个二进制数。 路由器路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。路由器的转发分组正是网络层的主要工作。 结构路由器从功能上可以划分为：路由选择部分(根据所选定的路由选择协议构造出路由表并更新和维护路由表)和分组转发部分。分组转发结构由三个部分组成：交换结构(根据路由表对分组进行处理)、一组输入端口和一组输出端口。 分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 否则报告转发分组出错。 路由选择协议互联网采用的路由选择协议主要是自适应的(动态的)、分布式路由选择协议。将整个互联网划分为多个较小的自治系统(AS，autonomous system)，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把路由选择协议划分为两大类：内部网关协议(Interior Gateway Protocol，IGP)和外部网关协议(External Gateway Protocol，EGP)。 路由信息协议 RIP路由信息协议(Routing Information Protocol，RIP)是内部网关协议的一种，是一种分布式的基于距离向量的路由选择协议。 RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。从一路由器到直接连接的网络距离定义为1跳，从以路由器到非直接连接的网络的距离定义为所经过的路由器数加1跳。RIP 只允许一条路径最多只能包含15个路由器，因此 RIP 只适合于小型互联网，且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 开放最短路径优先 OSPF开放最短路径优先(Open Shortest Path First，OSPF)是为了解决 RIP 坏消息传播慢和适用规模小的缺点开发出来的，也是内部网关协议的一种。它使用了 Dijkstra 的最短路径算法 SPF，并通过分布式的链路状态协议(link state protocol)实现。因此具有如下特点： 向本自治系统中的所有路由器发送信息(洪泛法)。 发送的信息是与本路由器相邻的所有路由器的链路状态(本路由器与哪些路由器相邻及该链路的度量，也就是费用、距离、时延等)。 只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。 因此所有的路由器最终都能获得全网的拓扑结构图，且这个拓扑结构图在全网范围内是一致的，所以 OSPF 的更新过程收敛的快。 边界网关协议 BGP边界网关协议(Border Gateway Protocol，BGP)是外部网关协议的一种，解决了如下问题： 互联网的规模太大，使得 AS 之间的路由选择非常困难。 AS 之间的路由选择必须考虑有关策略，例如有些 AS 不愿意其它 AS 经过。 各个 AS 内部使用不同路由选择协议，无法准确定义路径的度量。 BGP 采用了路径向量路由选择协议力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 虚拟专用网指明了一些专用地址，这些地址只能用于一个机构的内部通信，而不能用于和互联网上的主机通信。专用地址如下： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。例如机构内的主机需要和机构外的公用网进行通信，可以通过将数据发送给机构内的出入口(某个路由器)，该出入口会加密数据，并增加首部其源地址为出入口的地址(也就是出入口在公用网的 IP 地址)，当到达目的地址的路由器后，该路由器解密加密的数据，恢复原本的数据报，并发送给目的主机。 网络地址转换 NAT采用网络地址转换(Network Address Translation，NAT)可以让专用网内部已经分配到了本地 IP 地址的一些主机与互联网上的主机进行通信(不需要加密)。通过为路由器安装 NAT 软件，使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换(Network Address and Port Translation，NAPT)。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络之数据链路层","date":"2020-04-01T06:57:47.000Z","path":"posts/c9d999de/","text":"数据链路层提供的服务数据链路层把网络层交付下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。数据链路层的传输单元为帧。因此链路层协议能够提供的服务包括： 封装成帧：将网络层交付下来的数据根据链路层协议封装成相应的帧进行传输。 链路接入：媒体访问控制(Medium Access Control，MAC)协议规定帧在链路上的传输规则。 可靠交付：当链路层协议提供可靠交付时，它保证无差错地经链路层移动每个网络层数据报。如果是尽最大努力交付，当发现数据错误时不进行重发只是丢弃差错数据，可靠性由上层判断。高差错率链路提供可靠交付，否则只是检测差错进行尽最大努力交付。 差错检测：当传输的数据出现了差错时，可以通过差错检测出来。常见的差错检测有循环冗余检测(CRC 检验，对数据比特进行模2运算获得的余数加在数据尾作为校验码)和奇偶校验(通过一个附加比特记录1或0，使得数据加附加比特中1的总数为偶数个)。 链路层信道链路层使用的信道有两大类：点对点信道和广播信道。 点对点信道：一对一通信，不会发生碰撞，常用 PPP 协议进行控制。 广播信道：一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到，容易发生碰撞，需要使用多路访问协议进行协调。 链路层协议点对点协议互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，点对点协议(Point-to-Point Protocol，PPP)是用户计算机和 ISP 进行通信时所使用的数据链路层协议。PPP 协议是尽最大努力交付的协议，还有一种高级数据链路控制(high-level data link control，HDLC)协议是可靠交付的协议，但是因为如今链路差错率较低，所以几乎不使用。 多路访问协议多路访问协议通常分为三类：信道划分协议、随机接入协议和轮流协议。 信道划分协议：通过信道进行划分通常使用时分多路复用或频分多路复用在所有共享信道结点之间划分广播信道带宽。 随机接入协议：一个传输结点总是以信道的全部速率进行发送，当发生碰撞时，碰撞的结点反复的重发它的帧直至无碰撞为止，通常使用 CSMA 协议。 轮流协议：常用的有轮询协议和令牌传递协议，轮询协议是主结点以循环的方式轮询每个结点，而令牌传递协议用一个称为令牌的小的特殊帧在结点之间以某种固定的次序进行交换，获得令牌的可以发送数据，如果没有数据要发送，则赶紧将令牌传递给下一个结点。 载波监听多点接入/碰撞检测(Carrier Sense Multiple Access with Collision Detection，CSMA/CD)协议： 多点接入：说明是总线型网络，计算机以多点接入的方式连接在一根总线上。 载波监听：不断检测信道，如果信道一直被使用则只能等待，否则进行数据发送。 碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。此时发生碰撞的主机等待一个随机时间重新发送帧。 链路层寻址和 ARP MAC 地址：又称为硬件地址或物理地址，长度为48位全球地址，用于唯一标识网络适配器，存在于适配器的 ROM 中。 ARP(地址解析协议)：通过 ARP 表进行 IP 地址到 MAC 地址的转化，表中 IP 地址和 MAC 地址有一一映射的关系，并且有一个 TTL 值记载其寿命，寿命一到就会删除映射。 MAC帧：包含目的地址、源地址、类型(上一层使用的协议类型)、数据和 FCS 帧检验序列(使用 CRC 检验)。 局域网和以太网 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限，以太网是一种星型拓扑结构局域网，目前以太网占领着有线局域网市场。 集线器：以太网早期使用集线器进行连接，集线器是一种物理层设备，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 网桥(代替集线器)：网桥对收到的帧根据其 MAC 帧的目的地址进行转发和过滤。接收到帧时，根据帧的目的 MAC 地址，查找网桥中的地址表，然后从合适的发送接口发送，但是接收到两个不同接口的帧还是会发生碰撞。 交换机(代替网桥)：交换机相当于多接口的网桥，是一种即插即用设备，其内部的地址表是通过自学习算法自动地逐渐建立起来的。当地址表中没有目的地址时候会发送广播，否则进行单播。 虚拟局域网(VLAN，Virtual LAN)：虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络之物理层","date":"2020-04-01T06:01:51.000Z","path":"posts/18784b9d/","text":"信号模拟信号(连续信号)：即消息的参数的取值是连续的，如调制解调器到电话网之间的信号。数字信号(离散信号)：即消息的参数的取值是离散的，如计算机到调制解调器之间的信号。 通信方式单向通信(单工通信)：只能单向通信。双向交替通信(半双工通信)：双方不能同时发送和接收消息。双向同时通信(全双工通信)：双方可以同时发送和接收消息。 调制基带调制：对基带信号(来自信源的信号)进行调制，将数字信号1或0直接用两种不同的电压来表示，然后送到线路上去传输，该过程常被称为编码。带通调制：是将基带信号进行调制后形成的频分复用模拟信号。 信道复用技术 技术 作用 频分复用(FDM，Frequency Division Multiplexing) 用户在相同时间内占用不同的频带宽度。 时分复用(TDM，Time Division Multiplexing) 用户在不同的时间内占用同样的频带宽度。 统计时分复用(STDM，Statistic TDM) 与时分复用类似，但是使用集中器作为输入缓存，当集中器存满了1帧(不是数据链路层的帧)数据就会真正的发送出去。 波分复用(WDM，Wavelength Division Multiplexing) 相当于光的频分复用，例如应用于光纤技术。 码分复用(CDM，Code Division Multiplexing) 用户可以在同样的时间使用同样的频带进行通信。因为每个用户使用经过特殊挑选的不同码型，所以不会互相干扰。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络概述","date":"2020-03-31T05:15:52.000Z","path":"posts/7c4ca347/","text":"计算机网络网络把许多计算机连接在一起，而互联网则把许多网络连接在一起，因此互联网被称为”网络的网络”。 ISP互联网服务提供者 ISP(Internet Service Provider)，又称为互联网服务提供商，互联网交换点 IXP(Internet eXchange Point)主要作用就是允许两个网络(通常是两个同层网络)直接相连并交换分组，而不需要再通过第三个网络来转发分组。如今的互联网是一种多层次的 ISP 结构。较低层的 ISP 与较高层的 ISP 相连，较高层的 ISP 彼此互联。用户和内容提供商是较低层 ISP 的客户，较低层 ISP 是叫高层 ISP 的客户。如下图所示： 网络边缘部分网络边缘部分由所有连接在互联网上的主机组成。主机又称为端系统，在网络边缘的端系统之间的通信方式通常可划分为两大类：客户-服务器方式(C/S 方式，Client/Server)和对等方式(P2P 方式，Peer-to-Peer)。 C/S 方式：客户是服务请求方，服务器是服务提供方。 P2P 方式：本质上与 C/S 方式差不多，只是对等连接中的每一台主机既是客户又同时是服务器。 网络核心部分网络核心部分由大量网络和连接这些网络的路由器组成，通过使用路由器转发收到的分组为边缘部分提供连通性服务。转发数据的方法有两种分别为电路交换和分组交换。 电路交换：用一个交换机连接许多部电话并通过交换机使用交换方法(按照某种方式动态地分配传输线路的资源)，让通话双方始终占用端到端的通信资源直至挂断。当将电路交换应用于传输计算机数据时，其线路的传输效率往往很低，因为用户不用一直占用资源。简单说电路交换需要先建立连接再传输报文，适用于连续传送大量的数据。 分组交换：主要用处为转发收到的分组，通常由路由器实现。分组交换采用存储转发技术，将一个报文(需要发送的整块数据)划分为几个分组(等长数据段加上由控制信息组成的首部，若分组称为包，则首部称为包头)后再进行传送。路由器在接收到分组时会先存储分组，检查其首部获得该分组目的地址并在查找转发表后从合适的接口转发出去交给下一个路由器。简单说分组交换不需要建立连接，直接传输分组，因此时延小，灵活性很好。 网络性能 速率(理论速度)：指的是数据的传送速率，常称为数据率或比特率，其单位为 bit/s 或 bps。 带宽(最高速度)：表示在单位时间内网络中的某信道所能通过的”最高数据率”，其单位为 bit/s。 吞吐量(实际传输量)：表示在单位时间内通过某个网络的实际的数据量。 时延(实际传输耗时)：指数据从网络的一端传送到另一端所需的时间。总时延=发送时延+传播时延+处理时延+排队时延。 发送时延：主机或路由器发送数据帧所需要的时间。发送时延=数据帧长度/发送速率。 传播时延：电磁波在信道中传播一定的距离需要花费的时间。传播时延=信道长度/电磁波在信道上的传播速率。 处理时延：主机或路由器在收到分组时需要花费一定的时间进行处理。 排队时延：分组在经过网络传输时，进入路由器需要在输入队列中排队等待处理，处理完成后还要再输出队列中排队等待转发。 时延带宽积：带宽可以看成一条路的宽度，而传播时延可以堪称长度，因此时延带宽积可以表示这段链路可容纳多少个比特。时延带宽积=传播时延*带宽。 往返时间：RTT(Round-Trip Time)=发送时间+返回时间，发送时间=数据长度/发送速率。应用场景当 A 向 B 发送数据后，B 向 A 发送确认，A 才会继续发送数据。 利用率：分信道利用率和网络利用率。信道利用率指某信道有百分之几的时间是被利用的(有数据通过的)，而网络利用率则是全网络的信道利用率的加权平均值，网络当前时延=网络空闲时延/(1-利用率)。 计算机网络体系结构各体系比对： OSI 体系结构复杂不实用。 TCP/IP 体系结构得到了广泛的应用，但是其网络接口层用于解决不同网络的互联问题，但实际没有什么具体的内容。 五层协议：对 OSI 和 TCP/IP 体系结构进行折中，能更好的体现计算机网络的原理。 体系结构的构造： 为了进行通信，需要端到端连接，所以要先设计网。已知有电路交换和分组交换两种网，电路交换在现实生活中的场景是很久以前的拨号连接，需要通过电话线连接网络，一打电话就无法上网，一上网就无法打电话，非常的不适用，而且建立连接代价太高，所以抛弃。而分组交换又分为虚电路和数据报两种，虚电路的特点是实时性且实现复杂，互联网没有这个需求，所以使用数据报。此处可以使用物理电路传输数据报，因此需要一个可以将数据与物理信号相互转化的层，也就是物理层。 当连接的主机变多了，就不知道要发送数据给哪个主机了，而每个主机出场时有一个全球唯一的 MAC 地址，因此可以通过 MAC 地址来寻址发送数据，这就是物理链路层。 主机越来越多，通过 MAC 地址寻址已经变得很困难了，因为 MAC 地址分布无规律，无法通过 MAC 地址得知该主机所处的大概位置。因此出现了新的逻辑地址 IP，通过 IP 确认唯一的主机进行寻址。此时网络层就诞生了。 因为对数据连接的需求不同，有些人想要速度更快，不介意数据丢失，因此出现了 UDP，有些人不介意速度慢点，但是要求数据必须是可靠的，因此出现了 TCP，而且一台主机不可能就和一个服务器进行通信，为了实现并行通信，因此有了端口号，这就是运输层。 为了应对越来越多不同的需求，对这些常用需求进行封装，因此诞生了应用层。 各层 作用 物理层 在物理层上所传数据的单位是比特。 数据链路层 在两个相邻结点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息(同步信息、地址信息、差错控制等)。 网络层 负责为分组交换(分组在 TCP/IP 中常称为数据包)网上的不同主机提供通信服务(IP)。 运输层 负责向两台主机之间的通信提供通用的的数据传输服务(TCP 或 UDP)。 应用层 通过应用进程间的交互来完成特定网络应用。 各层之间通过不同的协议(控制两个或多个通信实体进行通信的规则)进行通信。常见的协议： 网络层协议：IP 协议、ICMP 协议、ARP 协议、RARP 协议。 传输层协议：TCP 协议、UDP 协议。 应用层协议：FTP 协议、Telnet 协议、SMTP 协议、HTTP 协议、RIP 协议、NFS 协议、DNS 协议、RSTP 协议。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Java I/O体系","date":"2020-03-30T05:32:21.000Z","path":"posts/9185735d/","text":"Java I/O 流大致可以分成如下五类： 对象操作：Serializable 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 网络操作：Socket 和 Datagram 新 I/O 流操作：NIO Java I/O 流使用了装饰器模式作为其设计模式，此处以 InputStream 为例，InputSteam 是一个抽象组件，FileInputStream、ByteArrayInputStream 等类都是可以被装饰者包起来的具体组件，而 FilterInputStream 就是一个抽象的装饰者，其具体的装饰者有 PushbackInputStream、BufferedInputStream、DataInputStream 和 LineNumberInputStream 等，它们都是在装饰类的基础上新增一些功能，例如当需要一个具有缓存功能的字节流对象时，只需要使用 BufferedInputStream 包裹 FileInputStream 类即可实现。 实现 AutoCloseable 接口不需要手动关闭流。 对象操作序列化：将一个对象转换成字节序列，方便存储和传输。通常使用 ObjectOutputStream.writeObject() 进行序列化，使用 ObjectInputStream.readObject() 反序列化。序列化不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。 Serializable：序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。 transient：transient 关键字可以使一些属性不会被序列化。 磁盘操作File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。Java7 开始可以使用 Paths 和 Files，而 Path 可以直接取代 File。Path 可以通过 Paths 的 get 方法获取文件路径(字符串或 URI 形式都可)。 常用的 Files 方法： 方法 作用 createDirectories() 创建一个完整的路径，即包括所有的上层目录。 createFile() 创建新文件。 exists() 文件是否存在。 copy() 可以从文件复制到文件或文件复制到输出流或者输入流复制到文件，还有一个可选 CopyOption 选项拥有三个参数：ATOMIC_MOVE(将文件作为原子文件系统操作移动。)、COPY_ATTRIBUTES(将属性复制到新文件。)、REPLACE_EXISTING(替换现有文件，如果存在)。 isDirectory() 是否是一个文件夹。 readAttributes() 读取文件权限，可以通过 PosixFileAttributes 类修改。 newBufferedWriter() 带缓冲区的文件读写。 newDirectoryStream() 遍历一个文件夹。 walkFileTree() 遍历整个文件目录。 字节操作字节操作即对文件数据以字节的形式进行读取操作。如下是一个文件字节读入输出的小例子： File src = new File(\"D:\\\\blog\"); File dis = new File(\"D:\\\\\"); FileInputStream fileInputStream = new FileInputStream(src); FileOutputStream fileOutputStream = new FileOutputStream(dis); BufferedInputStream in = new BufferedInputStream(fileInputStream); BufferedOutputStream out = new BufferedOutputStream(fileOutputStream); int cnt; while ((cnt = in.read()) != -1) { out.write(cnt); } out.flush(); in.close(); out.close(); 字符操作编码编码与解码：编码即将字符转化成字节，而解码就是把字节重新组合成字符。若编码和解码使用的编码方式不一致会出现乱码。常用的编码有如下三种： GBK 编码：中文字符占2个字节，英文字符占1个字节； UTF-8 编码：中文字符占3个字节，英文字符占1个字节； UTF-16BE 编码：中文字符和英文字符都占3个字节。BE(big-endian)即大端(将高位的字节放在低地址表示)的意思，相应的有 LE(little-endian)即小端(将高位的字节放在高地址表示)的意思。UTF-16 没有指定后缀，则开始的两个字节表示该字节数组是大端(FE FF)还是小端(FF FE)。 Java 的内存编码使用双字节编码 UTF-16be，因为 char 类型 16 位即两个字节，所以通过双字节编码可以使用一个 char 存储一个中文或一个英文。 String 使用byte[] bytes = getBytes();方法进行编码，不带参则是使用默认的编码方式，默认编码方式与平台有关通常为 UTF-8，解码使用new String(bytes, \"UTF-8\");的方式。 Reader 与 Writer不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此 Java 提供了对字符进行操作的方法。InputStreamReader 实现从字节流解码成字符流，而 OutputStreamWriter 实现字符流编码成为字节流。如下是一个文件字节读入输出的小例子： File src = new File(\"D:\\\\nana\\\\桌面\\\\note.txt\"); File dis = new File(\"D:\\\\nana\\\\桌面\\\\note1.txt\"); FileReader fileReader = new FileReader(src); FileWriter fileWriter = new FileWriter(dis); BufferedReader bufferedReader = new BufferedReader(fileReader); BufferedWriter bufferedWriter = new BufferedWriter(fileWriter); String line; while ((line = bufferedReader.readLine()) != null) { bufferedWriter.write(line); bufferedWriter.newLine(); } bufferedWriter.flush(); bufferedReader.close(); bufferedWriter.close(); 网络操作 InetAddress 类表示Internet协议(IP)地址，其常用方法如下： 方法 作用 getLocalHost() 返回本地主机的地址。 getByName(String host) 根据域名创建 InetAddress。 getByAddress(String host, byte[] addr) 根据提供的主机名和 IP 地址(只提供 IP 地址也可以)创建 InetAddress。 getAddress() 返回此 InetAddress 对象的原始 IP 地址。 URL 表示统一资源定位符，可以当成是指向万维网上的”资源”的指针。如下是从 URL 指向的资源中读取数据的小例子： URL url = new URL(\"http://www.baidu.com\"); InputStream inputStream = url.openStream(); // 此处可以指定编码方式 InputStreamReader inputStreamReader = new InputStreamReader(inputStream, StandardCharsets.UTF_8); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } bufferedReader.close(); Socket(TCP 通信) 是一个抽象层，应用程序可以通过它发送或接收数据，对其进行操作如同操作 I/O 流一样。Java 中 Socket 类作为客户端，ServerSocket 类作为服务端，并通过 InputStream 和 OutputStream 进行通信。简单例子如下： /** * @Author 喵粮都输光了 * @Date 2020/3/30 20:46 * @Description 服务端 */ public class SocketServer { public static void main(String[] args) throws IOException { int port = 50000; ServerSocket serverSocket = new ServerSocket(port); while (true) { // 开启服务端监听等待接收消息，使用客户端回复消息或者获取消息 Socket socket = serverSocket.accept(); InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream, StandardCharsets.UTF_8); OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter); // 接收数据 String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } // 发送数据 bufferedWriter.write(\"连接成功\"); bufferedWriter.flush(); // 即关闭了数据发送，之后只能接收数据，如果不是用这个或者socket关闭则会出现SocketException socket.shutdownOutput(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/30 20:59 * @Description 客户端 */ public class SocketClient { public static void main(String[] args) throws IOException { InetAddress disHost = InetAddress.getLocalHost(); int disPort = 50000; // 参数分别为服务端ip，服务端端口 Socket socket = new Socket(disHost, disPort); InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream, StandardCharsets.UTF_8); OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter); // 发送数据 String message = \"测试连接\"; bufferedWriter.write(message); bufferedWriter.flush(); // 即关闭了数据发送，之后只能接收数据，如果不是用这个或者socket关闭则会出现SocketException socket.shutdownOutput(); // 接收数据 String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } // 当关闭socket的时候，该socket的输入/输出流也会关闭，如果关闭输出流，socket也会被关闭。 socket.close(); } } Datagram(UDP 通信)，Java 通过 DatagramSocket(通信类) 和 DatagramPacket(数据包类) 实现 UDP 通信。简单例子如下： /** * @Author 喵粮都输光了 * @Date 2020/3/30 21:42 * @Description 客户端 */ public class DatagramClient { public static void main(String[] args) throws IOException { // 创建数据报套接字 int port = 40000; DatagramSocket datagramSocket = new DatagramSocket(port); byte[] content1 = \"发送！\".getBytes(); // 需要发送的数据包参数：数据，数据长度，目标ip地址，目标端口 DatagramPacket datagramPacket1 = new DatagramPacket(content1, content1.length, InetAddress.getLocalHost(), 50000); // 发送数据 datagramSocket.send(datagramPacket1); // 创建数据报包，发送用 byte[] content = new byte[1024]; DatagramPacket datagramPacket = new DatagramPacket(content, content.length); // 接收数据报包 datagramSocket.receive(datagramPacket); // 从数据报包中获取数据 byte[] data = datagramPacket.getData(); System.out.println(new String(data, StandardCharsets.UTF_8)); datagramSocket.close(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/30 21:41 * @Description 服务端 */ public class DatagramServer { public static void main(String[] args) throws IOException { // 创建数据报套接字 int port = 50000; DatagramSocket datagramSocket = new DatagramSocket(port); // 创建数据报包，发送用 byte[] content = new byte[1024]; DatagramPacket datagramPacket = new DatagramPacket(content, content.length); // 接收数据报包 datagramSocket.receive(datagramPacket); // 从数据报包中获取数据 byte[] data = datagramPacket.getData(); System.out.println(new String(data, StandardCharsets.UTF_8)); byte[] content1 = \"发送！\".getBytes(); // 需要发送的数据包参数：数据，数据长度，目标ip地址，目标端口 DatagramPacket datagramPacket1 = new DatagramPacket(content1, content1.length, InetAddress.getLocalHost(), 40000); // 发送数据 datagramSocket.send(datagramPacket1); datagramSocket.close(); } } NIONIO 即新 I/O，弥补了原 I/O 流的不足，提供了高速和面向块的 I/O。面向流的 I/O 一次处理一个字节数据，其速度较慢，而面向块的 NIO 一次处理一个数据块，速度比按流处理数据快很多。Java 以 NIO 为基础重新实现了 java.io.*，包中的一些类包含以块的形式读写数据的方法，因此即使是在面向流的系统中，处理速度也很快。 通道与缓冲区 通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。常用的通道有如下四种： FileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都创建一个 SocketChannel。 发送给一个通道的所有数据都必须首先放到缓冲区中，从通道中读取的任何数据都要先读到缓冲区中。常用缓冲区有 ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer 和 DoubleBuffer。缓冲区拥有三个变量：capacity(最大容量)、position(当前已经读写的字节数) 和 limit(还可以读写的字节数)。初始时，position 为0，limit 等于 capacity。将数据读入缓冲区时，将 position 的位置增加读入数据的大小，limit 不变。当需要将缓冲区数据输出至通道时，需要先调用 flip() 方法，该方法将 limit 设置为当前 position，再将 position 置为0，没输出一个字节 position 就自增1，position 等于 limit 时缓冲区无数据。最后数据输出完成时，需要调用 clear() 方法将 position 和 limit 的值归位(position=0，limit=capacity)。 使用 NIO 的通道缓和冲区进行文件复制案例如下： File src = new File(\"D:\\\\note.txt\"); File dis = new File(\"D:\\\\note1.txt\"); FileInputStream fileInputStream = new FileInputStream(src); FileOutputStream fileOutputStream = new FileOutputStream(dis); FileChannel in = fileInputStream.getChannel(); FileChannel out = fileOutputStream.getChannel(); // 分配一个新的直接字节缓冲区，其大小为1024 ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024); while (true) { int r = in.read(byteBuffer); if (r == -1) { break; } // 将读切换成写 byteBuffer.flip(); out.write(byteBuffer); // 清空缓冲区，相当于将写切换成读 byteBuffer.clear(); } 选择器NIO 实现了 IO 多路复用中的 Reactor 模型(可以处理一个或多个输入源，通过 Service Handler 同步的将输入事件采用多路复用分发给多个相应的 Request Handler 处理)，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。只有 套接字 Channel 才能配置为非阻塞。因此 NIO 常常被叫做非阻塞 IO。 NIO 套接字小例子： /** * @Author 喵粮都输光了 * @Date 2020/3/30 22:52 * @Description NIO 实现服务端 */ public class NioSocketServer { public static void main(String[] args) throws IOException { // 创建选择器 Selector selector = Selector.open(); // 将通道注册至选择器中 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 将通道设置成非阻塞模式 serverSocketChannel.configureBlocking(false); // 指定注册事件，可以使用或操作符选择多个。OP_ACCEPT：用于接受操作(如接收到一个客户端的请求就会触发)；OP_CONNECT：用于套接字连接；OP_READ：读操作；OP_WRITE：写操作 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); // 设置服务端地址，此处使用服务端套接字通道创建服务端socket ServerSocket serverSocket = serverSocketChannel.socket(); // 服务端socket绑定地址 InetSocketAddress address = new InetSocketAddress(\"127.0.0.1\", 8888); serverSocket.bind(address); while (true) { // 设置监听，阻塞直至监听到一个事件为止 selector.select(); // 获取到达的事件 Set&lt;SelectionKey> keys = selector.selectedKeys(); Iterator&lt;SelectionKey> keyIterator = keys.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isAcceptable()) { // 相应接受操作，将请求客户端注册制selector ServerSocketChannel tempServerSocketChannel = (ServerSocketChannel) key.channel(); // 服务器为每个新连接创建一个 SocketChannel，用于从读取客户端发送的数据 SocketChannel socketChannel = tempServerSocketChannel.accept(); socketChannel.configureBlocking(false); // 将发起请求的客户端注册至selector，并设置为读操作，在第二轮循环中可以对其发送的数据进行读取 socketChannel.register(selector, SelectionKey.OP_READ); } else if (key.isReadable()) { // 相应读操作 SocketChannel socketChannel = (SocketChannel) key.channel(); System.out.println(readDataFromSocketChannel(socketChannel)); socketChannel.close(); } // 删除最近一次next的对象 keyIterator.remove(); } } } /** * 读取数据 * @param socketChannel 客户端通道 * @return 返回解码的数据 * @throws IOException io异常 */ private static String readDataFromSocketChannel(SocketChannel socketChannel) throws IOException { ByteBuffer byteBuffer = ByteBuffer.allocate(1024); StringBuilder data = new StringBuilder(); while (true) { byteBuffer.clear(); int r = socketChannel.read(byteBuffer); if (r == -1) { break; } byteBuffer.flip(); data.append(StandardCharsets.UTF_8.decode(byteBuffer)); byteBuffer.clear(); } return data.toString(); } } public static void main(String[] args) throws IOException { Socket socket = new Socket(\"127.0.0.1\", 8888); OutputStream out = socket.getOutputStream(); String s = \"测试连接\"; out.write(s.getBytes()); out.close(); } 内存映射文件内存映射文件是由一个文件到一块内存的映射，因为真个文件都在内存中，所以可以把文件当成一个非常大的数组进行随机访问。其速度比 I/O 流和 NIO 都要快。 File file = new File(\"D:\\\\nana\\\\桌面\\\\note1.txt\"); // 只读 // FileChannel fileChannel = FileChannel.open(file.toPath()); // 可读可写 FileChannel fileChannel = new RandomAccessFile(file, \"rw\").getChannel(); // 通过通道的map方法映射内存，READ_WRITE：读/写映射；READ_ONLY：只读映射；PRIVATE：私有（写时复制）映射模式，相当于复制一份不会影响文件 MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, file.length()); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://blog.kuukokawaii.com/tags/java/"}]},{"title":"Java 容器","date":"2020-03-30T02:22:38.000Z","path":"posts/f431e3b/","text":"Collectionjava.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。当多个线程对同一个集合的内容进行操作时，可能会产生 Fail-Fast 异常，即在迭代过程中如果集合对象的结构发生变化例如添加或删除了一个元素或调整了集合的大小就会改变 modCount(用于记录结构发生变化的次数) 的值，此时会抛 ConcurrentModificationException 异常，此时使用线程安全的集合即可解决问题。 ListList 称为有序集合，允许包含重复元素。 ArrayList：基于动态数组实现，查找快，增删慢，线程不安全。如果要使用线程安全的 ArrayList 可以考虑使用 CopyOnWriteArrayList 类，该类的写操作在复制的数组中进行(需要加锁)，读操作则在原始数组中进行，当写操作完成时把原始数组指向新的数组，因为其实现了读写分离，所以很适合读多写少的应用场景，但是复制的数组多占用了一倍的存储空间，读操作也不能读取实时性的数据，因此不适合内存敏感以及实时性要求高的场景。 Vector：和 ArrayList 类似，尾音它是线程安全的，所以效率比 ArrayList 低。Stack 类继承拓展了 Vector 的操作。 LinkedList：基于双向链表实现，查找慢，增删快，线程不安全。而且可以用作栈、队列和双向队列。 查找多增删少用 ArrayList，反过来用 LinkedList，如果是多线程使用则使用 Vector。 Queue LinkedList：如果 Queue 使用 LinkedList 实现，可以使用它实现双向队列。 PriorityQueue：基于堆结构实现，可以用它实现优先队列(队头是最小元素)，不允许使用 null，其容量会自动增大减少始终保持和队列中拥有的元素一样大，但是它的线程是不安全的。 ConcurrentLinkedQueue：线程安全的队列，队头保存最长元素，队尾是最短元素，不允许使用 null。 SetSet 称为无序集合，不允许包含重复元素，最多只能拥有一个空元素。 TreeSet：基于红黑树实现，且实现了 SortedSet 接口，因此支持有序性操作(排序)，但线程是不安全的，其查找时间复杂度为O(logn)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作，不允许有相同值存在(会自动覆盖)，其线程是不安全的，查找时间复杂度为O(1)。 LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序即插入顺序是可预测的，但是线程是不安全的。 需要排序用 TreeSet， 否则 HashSet，如果不需要排序但是需要保持插入顺序则使用 LinkedHashSet。 MapMap 是一个接口，它是以键值对的形式进行存储的，且不能包含重复的键，每个键只能对应一个值。 TreeMap：基于红黑树实现，其线程是不安全的。 HashMap：基于采用了拉链法解决碰撞冲突的哈希表(数组+链表，链表超过一定值改用数组+红黑树，减少链表查询时间)实现，其线程是不安全的，允许使用 null 键值。 LinkedHashMap：使用双向链表来维护元素的插入顺序即插入顺序是可预测的，顺序为插入顺序或者最少使用(LRU)顺序，其线程是不安全的。 Hashtable 与 ConcurrentHashMap：和 HashMap 类似，但是它是线程安全的且不允许使用 null 键值。但是 Hashtable 是 Java 的一个遗留类，所以不应该去使用它，可以通过使用 ConcurrentHashMap 来支持线程安全，且 ConcurrentHashMap 引入了分段锁，因此效率很高，但同样不允许使用 null 键值。 WeakHashMap：和 HashMap 类似，其线程也是不安全的。WeakHashMap 具有弱键，当 WeakHashMap 中的键值对不再普通使用时会在下一次垃圾回收时自动被回收。常用于实现缓存，通过 WeakHashMap 来引用缓存对象，而 JVM 对这部分缓存进行回收。Tomcat 中的 ConcurrentCache 就使用了 WeakHashMap 来实现缓存，常用对象放入 eden 中不会被回收，不常用的对象放入 longterm(使用 WeakHashMap 实现) 中，longterm 中不用的对象会被回收，put 方法会优先添加 eden，若 eden 存储容量超过了将 eden 的所有对象存储在 longterm 中，而 get 方法会先从 eden 中读取若没找到则在 longterm 中寻找并将其放入 eden。 需要排序使用 TreeMap，否则 HashMap，如果不需要排序但是需要保持插入顺序则使用 LinkedHashMap。如果是多线程使用则使用 ConcurrentHashMap，不要使用 Hashtable。 IterableCollection 继承了 Iterable 接口，其中的 iterator 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。同样的也可以使用高级 for 直接遍历集合。此处使用了迭代器模式。 utilArraysjava.util.Arrays 是一个工具类，主要包含了操纵数组的各种方法。常用的方法有如下： 常用方法 作用 Arrays.sort(Object[] array) 对数组进行升序排序。 fill(Object[] array, Object object) 为数组元素填充相同的值。 toString(Object[] array) 返回数组的字符串形式。 deepToString(Object[][] arrays) 返回多维数组的字符串形式。 asList(T… a) 将数组转换成 List。(使用了适配器模式) Collectionsjava.util.Collections 是一个工具类。它包含有各种有关集合操作的静态多态方法。常用的方法有如下： 常用方法 作用 shuffle(Collection) 洗牌即将当前集合内的数据进行随机排序。 reverse(Collection) 逆序排序即对当前集合的元素按照相反的顺序进行排序。 sort(Collection) 对当前集合进行升序排序。 binarySearch(Collection, Object o) 二分查找指定集合中的元素，返回所查找元素的索引。 replaceAll(List list, Object old, Object new) 替换指定元素为其它元素，若要替换的值存在则返回 true，否则返回 false。 copy(List m, List n) 将集合n中的元素全部复制到m中,并且覆盖相应索引的元素。 swap(List list, int i, int j) 交换集合中指定的元素。 fill(List list, Object o) 为数组元素填充相同的值。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://blog.kuukokawaii.com/tags/java/"}]},{"title":"Java 基础","date":"2020-03-29T02:37:16.000Z","path":"posts/a019e08c/","text":"数据类型基本数据类型 数据类型 位数 默认值 包装类 byte 8 0 Byte short 16 0 Short int 32 0 Integer long 64 0L Long float 32 0.0f Float double 64 0.0d Double char 16 ‘\\u0000’ Character boolean 8 false Boolean 包装类基本类型都有包装类型，对应的包装类型表参照上表，基本类型与其对应的包装类型之间的赋值使用自动装箱(Integer.valueof(num))与拆箱完成(x.intValue())。包装类都被声明为 final，所以都不能被继承。 缓存池Integer.valueOf() 方法会优先使用缓冲池中的对象，而 new Integer() 方法每次都会新建一个对象。但是也并不是说当Integer a = Integer.valueOf(num);Integer b = Integer.valueOf(num);时两者就一定相等。这里的缓冲池还有大小之分，若 num 在缓冲池大小内则会优先使用缓冲池中的 num 对象，否则会新建一个对象。例如 Integer 的缓冲池大小为 -128~127，所以当num超过这个大小时，a 不会等于 b。这里有一点特殊的是 Integer 的上界可以在启动 JVM 时通过输入参数-XX:AutoBoxCacheMax=&lt;size&gt;手动更改。 基本类型对应的缓冲池大小如下： boolean 为 true 或 false。 int、short 和 byte 在 -128~127 之间。 char 在 \\u0000 到 \\u007F 之间。 String不可变String 类被声明为 final，因此 String 类同样不可被继承。在 Java8 中 String 类通过private final char value[]存储数据，但是在 Java9 中 String 类的实现改用private final byte[] value存储数据，同时使用private final byte coder来标识使用了哪种编码。因为 String 类中的 value 数组都被声明为了 final，且内部没有改变 value 数组的方法，保证了 String 是不可变的。 String 不可变带来的好处： String 的 hash 值也不会改变，因此 String 只需计算一次 hash 值。 若有内容相等的的 String 可以从字符串常量池中直接获取(相当于缓冲区了)。 当多个线程调用 String 时也不会产生问题，是线程安全的。 String 作为参数传递时也可以保证参数不会被改变，安全性高。例如一个类使用了值为 “A” 的 String，该 String 的值被改变成 “B” 时，使用 String 的那个类仍然将这个 String 当作 “A”，但是改变 String 以及后来使用 String 的类都会将 String 当作 “B” 看待，会产生一系列的问题。 String、StringBuilder 和 StringBufferString 是不可变的；StringBuilder 和 StringBuffer 是可变的。 String 是线程安全的；StringBuilder 是线程不安全的；StringBuffer 通过使用 synchronized 进行同步，因此线程是安全的。 在 Java 中字符串的拼接默认使用的其实是 StringBuffer。 String Pool字符串常量池(String Pool)保存着所有字符串字面量(literal strings)，这些字面量在编译时期就确定。使用 String Pool 有两种方法： 直接使用双引号声明出来的 String 对象会直接存储在常量池中。 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串存入常量池中。 在 Java7 之前，String Pool 被放在运行时常量池中，属于永久代，但是因为其存储空间有限，在大量使用字符串的情况下会导致内存溢出错误，所以在 Java7 中，String Pool 被移到堆中。 new String()String s = new String(\"xxx\")的方法会在编译时创建”xxx”字符串字面量并将其保存在字符串常量池中(如果”xxx”不存在于常量池中的话)，然后 new String(“xxx”)会在堆中创建一个 String s 的对象，并赋值为”xxx”(从常量池中引用)。 运算隐式类型转换Java 不能隐式执行向下转型，因为这会造成精度降低。例如float f = 1.1，其中1.1是 double 型，占用64位，而 float 占用32位，将64位转换成32位会导致精度降低。但是如果使用算术运算符例如f += 1或f++之类的，Java 会自动执行隐式类型转换，相当于f = (short) (f + 1)，整体进行向下转型。 关键字final 数据：声明数据为常量，可以是编译时常量，也可以是运行时初始化后不能被改变的常量。对于基本类型，final 使数值不能改变；对于引用类型，final 使引用不能改变，但是被引用的对象本身可以修改。 方法：声明方法则该方法无法被子类重写。(private 方法隐式地被指定为 final) 类：声明类则该类无法被继承。 static 静态变量：又称为类变量，可以通过类名调用。与实例变量不同在于，实例变量每创建一个实例就会产生一个实例变量，实例摧毁则实例变量摧毁。 静态方法：类加载时静态方法就存在了，不需要依赖任何实例。静态方法不能是抽象方法，同样的不能使用 this 和 super 关键字。 静态语句块：类加载时静态语句块会执行一次。 静态内部类：非静态内部类依赖于外部类的实例，需要先创建外部类的实例才能用这个实例去创建非静态内部类，而静态内部类可以直接调用不用这么复杂。静态内部类不能访问外部类的非静态变量和方法。 静态导包：例如import java.lang.Math.*;调用方法为Math.sqrt(1);，使用静态导包import static java.lang.Math.*;调用方法为sqrt(1);。 初始化顺序：先静态(静态变量、静态语句块)，后普通(实例变量、普通语句块)，最后构造函数。例如父类(静态)→子类(静态)→父类(普通)→父类(构造函数)→子类(普通)→子类(构造函数)。 transient该关键字标记的成员变量不参与序列化过程。 Object 通用方法euqals()equals()即判断两个引用对象是否等价，其实现为： 如果传入对象为 null，返回 false； 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型(getClass())，如果不是，直接返回 false； 将 Object 对象进行转型，判断每个关键域是否相等。 hashCode()两个等价的对象其散列值一定相同，但是散列值相同的两个对象不一定等价，所以再覆写 equals() 方法时应当总是 hashCode() 方法。 理想的哈希函数应当具有均匀性即将不相等的对象均匀分布到所有可能的哈希值上。这就要求哈希函数对所有域的值都进行考虑，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。 R 一般取奇数，如果是偶数，当乘法溢出时最高位会丢失(乘2等于向左移动1位)。由于 Java 地址值的位数关系，R 一般取31。当31乘以 x 时编译器会自动优化为(x&lt;&lt;5) - x提升效率。 继承访问权限 作用域 当前类 同一包 子孙类 其他包 public √ √ √ √ protected √ √ √ × friendly(不加访问修饰符即默认) √ √ × × private √ × × × 需要注意的是默认权限和保护权限：默认权限同包不同类可以访问，不同包不同类不可以访问；保护权限同包不同类可以访问，不同包情况下子类可以访问。 子类如果要重写父类的方法，则子类中该方法的访问级别不能低于父类中该方法的访问级别，这是为了确保使用父类实例的时候可以用子类实例去代替，确保满足里氏替换原则。 抽象类抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类不能被实例化，只能被继承。 接口类接口类是抽象类的延申，解决了 Java 不能多继承的问题。接口类在 Java8 之前只能看成是一个完全抽象的类，它不能有任何的方法实现，但是从 Java8 开始，接口类通过关键字 default 也可以拥有默认的方法实现。 接口的字段必须是 static 和 final 类型的，且访问权限必须是 public。 super、重写和重载super 可以让子类访问父类的构造函数，或者调用父类的方法。 重写指子类实现了与父类在方法声明上完全相同的一个方法。需要注意如下三点： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 重载指同一个类中方法名相同，但是参数类型、参数个数或者参数顺序至少有一个不同的方法。若只有返回值不同，方法名、参数类型、参数个数和参数顺序都相同的方法不算重载。 反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载，通过Class c = 类名.class或Class = Class.forName(\"类名\")进行加载。 反射主要提供了如下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法 简单说就是反射可以动态地获取创建实例的类信息。通过反射获取所需实例的类信息可以极大程度地降低程序的耦合性。反射常用于调试器或测试工具获取私有成员等。虽然反射非常强大，但是其性能开销也大，反射涉及动态类型的解析，所以 JVM 无法对反射代码进行优化，因此反射操作的效率比非反射操作低很多。而且反射只能在一个没有安全限制的环境中运行。反射能够操作私有属性及方法，因此使用反射可能会导致意料之外的问题发生。通过以上种种可知，当一个功能可以不使用反射完成时最好就不使用。 Class 和 java.lang.reflect 都对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field：操作类的属性。 Method：操作类的方法。 Constructor：提供了一个类的单个构造函数的信息和访问权限。 异常所有异常类型都是内置类 Throwable 的子类，Throwable 有两个不同的分支，一个分支是 Error，它表示不希望被程序捕获或是程序无法处理的错误，例如 JVM 运行错误的栈溢出异常和内存溢出异常等；另一个分支是 Exception，而 Exception 又可以细分为不受检查异常(Unchecked Exception)和检查异常(Checked Exception)： 不受检查异常：运行时异常(Runtime Exception)是不受检查异常，在程序中可以选择捕获处理或者不处理，通常这些异常都是逻辑错误引起的，程序应该从逻辑角度尽量避免这类异常的发生，例如空指针异常，数组下标越界等。 受检查异常：Runtime Exception 以外的异常统称为非运行时异常，例如 I/O 异常、 SQL 异常以及用户自定义的异常(一般步自定义受检查异常)，这类异常必须进行处理，否则程序无法通过编译。 用户可以通过继承 Exception 或者其子类创建自定义异常类。 泛型在集合中存储对象并在使用前进行类型转换是非常的不方便的，所以 Java 提供了泛型防止了那种情况的发生。泛型提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出 ClassCastException。 泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List&lt;String&gt;在运行时仅用一个 List 来表示，这样做是为了和旧版本的 Java 进行兼容。 限定通配符和非限定通配符：限定通配符对类型进行了限制，限定通配符有两种，一种是&lt;? extends T&gt;它通过确保类型必须是 T 的子类来设定类型的上界，另一种是&lt;? super T&gt;它通过确保类型必须是 T 的父类来设定类型的下界；非限定通配符&lt;?&gt;表示可以用任意类型来替代。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。 注解Java 注解(Annotation)是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明和配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。注解和修饰符有些类似，应用于包、类型、构造方法、方法、成员变量、参数以及本地变量的声明语句中。例如@param、@override等，前者用于文档生成，后者用于编译时检测是否是覆盖了超类方法。 注解本质是一个继承了Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。通过反射获取注解可以获得动态代理对象，利用代理对象调用自定义注解(接口)的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法。该方法会从 memberValues 这个 map 中索引出对应的值。而 memberValues 的来源是Java 常量池。 java.lang.annotation 提供了四种元注解，专门注解其他的注解(在自定义注解的时候，需要使用到元注解)： @Documented – 注解是否将包含在 JavaDoc 中。 @Retention – 什么时候使用该注解。 RetentionPolicy.SOURCE : 在编译阶段丢弃，例如检测类注解@override等。 RetentionPolicy.CLASS : 在类加载的时候丢弃，在字节码文件的处理中有用，注解默认使用这种方式。 RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式。 @Target – 注解用于什么地方。 ElementType.CONSTRUCTOR: 用于描述构造器。 ElementType.FIELD: 成员变量、对象、属性(包括 enum 实例)。 ElementType.LOCAL_VARIABLE: 用于描述局部变量。 ElementType.METHOD: 用于描述方法。 ElementType.PACKAGE: 用于描述包。 ElementType.PARAMETER: 用于描述参数。 ElementType.TYPE: 用于描述类、接口(包括注解类型)或 enum 声明。 @Inherited – 是否允许子类继承该注解。 自定义注解： Annotation 型定义为@interface, 所有的 Annotation 会自动继承 java.lang.Annotation 这一接口,并且不能再去继承别的类或是接口。 参数成员只能用 public 或默认(friendly) 这两个访问权限修饰。 参数成员只能用基本类型 byte、short、char、int、long、float、double、boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组。 要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象。 注解也可以没有定义成员，不过这样注解就没啥用了。 例如： /** * @Author 喵粮都输光了 * @Date 2020/3/29 19:33 * @Description 动物注解 */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Animal { enum Color { /** * 动物颜色 */ DEFAULT(\"白色\"), RED(\"红色\"), BLACK(\"黑色\"); /** * 颜色 */ private String color; Color(String color) { this.color = color; } public String getColor() { return color; } } /** * 动物名称 * @return 动物名称 */ String name() default \"动物\"; Color color() default Color.DEFAULT; } /** * @Author 喵粮都输光了 * @Date 2020/3/29 19:52 * @Description 动物信息注解 */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface AnimalInfor { /** * 国家 * @return 国家 */ String country() default \"国家\"; /** * 价格 * @return 价格 */ double price() default 0.0; } /** * @Author 喵粮都输光了 * @Date 2020/3/29 20:11 * @Description 自定义注解测试 */ public class Main { public static void main(String[] args) throws Exception { Class&lt;?> dogClass = Dog.class; Dog dog = (Dog) dogClass.newInstance(); Field[] fields = dogClass.getDeclaredFields(); for (Field field : fields) { if (field.isAnnotationPresent(Animal.class)) { Animal animal = field.getAnnotation(Animal.class); dog.setName(animal.name()); dog.setColor(animal.color().getColor()); } else if (field.isAnnotationPresent(AnimalInfor.class)) { AnimalInfor animalInfor = field.getAnnotation(AnimalInfor.class); dog.setInfo(animalInfor.country() + animalInfor.price()); } } dog.print(); } } Java 特点 Java 是存粹的面向对象的语言。 Java 通过虚拟机从而实现跨平台特性。 Java 没有指针，它的引用可以理解为安全指针。 Java 支持自动垃圾回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的。 Java 不支持操作符重载(把已经定义的、有一定功能的操作符进行重新定义，来完成更为细致具体的运算等功能)。 Java 的 goto 是保留字，但是不可用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://blog.kuukokawaii.com/tags/java/"}]},{"title":"算法之字符串","date":"2020-03-28T02:17:33.000Z","path":"posts/45407bae/","text":"字符串排序键索引计数法假设将一个班级的学生分5组，按组进行排序。 /** * 学生数组长度，共多少人 */ int n = a.length; /** * 学生分成的组数 */ int r = 5; /** * 辅助数组，用于排序 */ String[] aux = new String[n]; /** * 索引表，例如第一组3人，第二组5人，则第一组从0开始索引，第二组从3开始索引 */ int[] count = new int[r + 1]; /** * 计算出现频率，即每组多少人，方法key()为获得学生的组号 */ for (int i = 0; i &lt; n; i++) { count[a[i].key() + 1]++; } /** * 将频率转化成索引，即第一组从下标哪开始到哪，第二组从下标哪开始到哪等 */ for (int i = 0; i &lt; r; i++) { count[r + 1] += count[r]; } /** * 将学生按组分类，例如第二组学生第一个从下标3开始存，存了之后索引表第二组索引自增一，下一个第二组学生就从下标4开始存等 */ for (int i = 0; i &lt; n; i++) { aux[count[a[i].key()]++] = a[i]; } /** * 将数据从辅助数组复制回原数组 */ for (int i = 0; i &lt; n; i++) { a[i] = aux[i]; } 低位优先字符串排序低位优先(Least Significant Digit first, LSD)的字符串排序算法能够稳定地将定长字符串排序。若字符串的长度为 n，那么从右向左以每个位置的字符作为键，用键索引计数法将字符串排序 n 遍即可获得有序字符串。只能适用于字符串长度相同的情况。可以用于基数排序。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 11:31 * @Description 低位优先字符串排序 */ public class Lsd { /** * 低位优先排序字符串 * @param a 等长字符串数组 * @param w 字符串长度 */ public static void sort(String[] a, int w) { int n = a.length; int r = 256; String[] aux = new String[n]; // 从右往左每个字符当键 for (int i = w - 1; i >= 0; i--) { // 索引表 int[] count = new int[r + 1]; // 计算出现频率 for (String s : a) { // 遍历所有字符串，计算第i位键频率 count[s.charAt(i) + 1]++; } // 将频率转换为索引 for (int j = 0; j &lt; r; j++) { count[j + 1] += count[j]; } // 将元素分类 for (String s : a) { aux[count[s.charAt(i)]++] = s; } // 回写 for (int j = 0; j &lt; n; j++) { a[j] = aux[j]; } } } public static void main(String[] args) { String[] s = {\"345\", \"678\", \"123\"}; Lsd.sort(s, 3); for (String s1 : s) { System.out.println(s1); } } } 高位优先字符串排序高位优先(Most Significant Digit First，MSD)的字符串排序算法与低位优先字符串相反，高位优先算法从左向右遍历所有字符，首先使用索引计数法将所有字符串按照首字母排序，然后再递归的将每个首字母(忽略首字母)所对应的子数组排序。高位优先算法支持不同长度的字符串排序，为了防止字符串越界，规定索引表频率为0时表示字符串的结尾，为1时表示第一个字符等等。可以用于基数排序。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 12:25 * @Description 高位优先字符串排序 */ public class Msd { /** * ASCII 基数 */ private static final int R = 256; /** * 小数组的切换阈值 */ private static final int M = 125; /** * 辅助数组，用于排序 */ private static String[] aux; /** * 获取字符串第index个字符 * @param s 字符串s * @param index 下标 * @return 存在返回字符，不存在返回-1 */ private static int charAt(String s, int index) { if (index &lt; s.length()) { return s.charAt(index); } else { return -1; } } /** * 高位优先排序 * @param a 字符串数组a */ public static void sort(String[] a) { int n = a.length; aux = new String[n]; sort(a, 0, n - 1, 0); } /** * 排序所给字符串数组中从lo下标到hi下标的字符串，字符串根据index排序 * @param a 字符串数组a * @param lo 字符串数组开始下标 * @param hi 字符串数组结束下标 * @param index 字符下标 */ private static void sort(String[] a, int lo, int hi, int index) { // 从左往右每个字符当键 if (hi &lt;= lo + M) { insertion(a, lo, hi, index); return; } // 索引表 int[] count = new int[R + 2]; // 计算出现频率 for (int i = lo; i &lt;= hi; i++) { count[charAt(a[i], index) + 2]++; } // 将频率转换为索引 for (int i = 0; i &lt; R + 1; i++) { count[i + 1] += count[i]; } // 将元素分类 for (int i = lo; i &lt;= hi; i++) { aux[count[charAt(a[i], index) + 1]++] = a[i]; } // 回写 for (int i = lo; i &lt;= hi; i++) { a[i] = aux[i - lo]; } // 递归的以每个字符为键进行排序 for (int i = 0; i &lt; R; i++) { sort(a, lo + count[i], lo + count[i + 1] - 1, index + 1); } } /** * 从第d个字符开始进行插入排序 * @param a 字符串数组a * @param lo 开始下标 * @param hi 结束下标 * @param d 第几个字符 */ private static void insertion(String[] a, int lo, int hi, int d) { for (int i = lo; i &lt;= hi; i++) { for (int j = i; j > lo &amp;&amp; less(a[j], a[j - 1], d); j--) { swap(a, j, j - 1); } } } /** * 交换两字符串在数组中的位置 * @param a 字符串数组a * @param i 字符串i * @param j 字符串j */ private static void swap(String[] a, int i, int j) { String temp = a[i]; a[i] = a[j]; a[j] = temp; } /** * 判断字符串v的第d个字符是否比字符串w的小 * @param v 字符串v * @param w 字符串w * @param d 第d个字符 * @return true or false */ private static boolean less(String v, String w, int d) { for (int i = d; i &lt; Math.min(v.length(), w.length()); i++) { if (v.charAt(i) &lt; w.charAt(i)) { // 字符串v的第i个字符比字符串w的第i个字符小 return true; } if (v.charAt(i) > w.charAt(i)) { // 字符串v的第i个字符比字符串w的第i个字符大 return false; } } // 两串d个字符相同，根据长短判断 return v.length() &lt; w.length(); } public static void main(String[] args) { String[] s = {\"345465456\", \"678\", \"1239\"}; Msd.sort(s); for (String s1 : s) { System.out.println(s1); } } } 三向字符串快速排序三项字符串快速排序和三向快速排序类似，将字符串分成三部分进行排序。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 13:36 * @Description 三向字符串快速排序 */ public class Quick3String { /** * 获取字符串第index个字符 * @param s 字符串s * @param index 下标 * @return 存在返回字符，不存在返回-1 */ private static int charAt(String s, int index) { if (index &lt; s.length()) { return s.charAt(index); } else { return -1; } } /** * 三向字符串快速排序 * @param a 字符串数组a */ public static void sort(String[] a) { sort(a, 0, a.length - 1, 0); } /** * 排序所给字符串数组中从lo下标到hi下标的字符串，字符串根据index排序 * @param a 字符串数组a * @param lo 字符串数组开始下标 * @param hi 字符串数组结束下标 * @param index 字符下标 */ private static void sort(String[] a, int lo, int hi, int index) { if (hi &lt;= lo) { return; } int lt = lo, gt = hi; int letter = charAt(a[lo], index); int i = lo + 1; while (i &lt;= gt) { int t = charAt(a[i], index); if (t &lt; letter) { swap(a, lt++, i++); } else if (t > letter) { swap(a, i, gt--); } else { i++; } } // 首字母小于切分字符 sort(a, lo, lt - 1, index); if (letter >= 0) { // 等于 sort(a, lt, gt, index + 1); } // 大于 sort(a, gt + 1, hi, index); } /** * 交换两字符串在数组中的位置 * @param a 字符串数组a * @param i 字符串i * @param j 字符串j */ private static void swap(String[] a, int i, int j) { String temp = a[i]; a[i] = a[j]; a[j] = temp; } } 单词查找R 向单词查找树树的结点由字符串键中的所有字符构成，允许使用被查找键中的字符进行查找。根结点不包含任何字符，单词查找树查找可能终止于一个内部节点，即不一定总是到叶子结点。适用于较短的键和较小的字母表。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 14:00 * @Description 单词查找树 */ public class TrieSt&lt;Value> { /** * ASCII 基数 */ private static int R = 256; /** * 根结点 */ private Node root; private static class Node { /** * 该结点包含的字符 */ private Object val; /** * 该结点的子结点们 */ private Node[] nexts = new Node[R]; } /** * 根据单词(键)获得该单词对应结点种保存的值。 * @param key 键 * @return 值 */ public Value get(String key) { Node node = get(root, key, 0); if (node == null) { return null; } return (Value) node.val; } /** * 查找第d个字符对应的子单词查找树 * @param root 根结点 * @param key 单词(键) * @param d 第d个字符 * @return 子单词查找树的结点 */ private Node get(Node root, String key, int d) { if (root == null) { return null; } // 如果第d个字符和单词长度一样长，返回该结点 if (d == key.length()) { return root; } char letter = key.charAt(d); // 找到第d个字符对应的子树，并使d+1查找单词的下一个字符 return get(root.nexts[letter], key, d + 1); } /** * 向单词树中存单词 * @param key 单词(键) * @param value 值 */ public void put(String key, Value value) { // 确保根结点为空 root = put(root, key, value, 0); } /** * 根据所给键、值和当前字符存单词 * @param root 当前结点 * @param key 键 * @param value 值 * @param d 第d个字符 * @return 返回根结点 */ private Node put(Node root, String key, Value value, int d) { if (root == null) { root = new Node(); } // 如果第d个字符和单词长度一样长，该结点存value并返回该结点 if (d == key.length()) { root.val = value; return root; } char letter = key.charAt(d); root.nexts[letter] = put(root.nexts[letter], key, value, d + 1); return root; } public static void main(String[] args) { TrieSt&lt;Integer> st = new TrieSt&lt;>(); st.put(\"apple\", 1); st.put(\"app\", 2); System.out.println(st.get(\"app\") + \":\" + st.get(\"apple\")); } /** * 删除单词 * @param key 键 */ public void delete(String key) { root = delete(root, key, 0); } /** * 根据所给结点，键和当前字符删除单词 * @param root 当前结点 * @param key 键 * @param d 第d个字符 * @return 返回根结点 */ private Node delete(Node root, String key, int d) { if (root == null) { return null; } if (d == key.length()) { // 如果找到最后一个字符将其值置为空 root.val = null; } else { // 否则一直寻找该单词最后一个字符 char letter = key.charAt(d); root.nexts[letter] = delete(root.nexts[letter], key, d + 1); } // 如过当前结点的值不为空，直接返回该结点 if (root.val != null) { return root; } // 遍历当前结点的所有连接，如果连接都为空，返回null即删除该结点，否则直接返回当前结点 for (char letter = 0; letter &lt; R; letter++) { if (root.nexts[letter] != null) { return root; } } return null; } } 三向单词查找树单词查找树每个结点包含 r 个子结点，为了避免 r 过度的浪费空间，可以使用三向单词查找树。三向单词查找树每个结点含有一个字符，三条链接和一个值，着三条连接分别对应着当前字符小于、等于和大于结点字符的所有键。适用于非随机的键。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 15:12 * @Description 三向单词查找树 */ public class Tst&lt;Value> { /** * 根结点 */ private Node root; private class Node { /** * 字符 */ char letter; /** * 左中右连接 */ Node left, mid, right; /** * 值 */ Value val; } /** * 根据单词(键)获得该单词对应结点种保存的值。 * @param key 键 * @return 值 */ public Value get(String key) { Node node = get(root, key, 0); if (node == null) { return null; } return node.val; } /** * 查找第d个字符对应的子单词查找树 * @param root 根结点 * @param key 单词(键) * @param d 第d个字符 * @return 子单词查找树的结点 */ private Node get(Node root, String key, int d) { if (root == null) { return null; } char letter = key.charAt(d); if (letter &lt; root.letter) { // 当前字符小于结点字符 return get(root.left, key, d); } else if (letter > root.letter) { // 当前字符大于结点字符 return get(root.right, key, d); } else if (d &lt; key.length() - 1) { // 未达到查找单词最后一个字符，不大于不小于那就是等于了 return get(root.mid, key, d + 1); } else { // 达到查找单词最后一个字符，直接返回当前结点 return root; } } /** * 向单词树中存单词 * @param key 单词(键) * @param value 值 */ public void put(String key, Value value) { // 不需要确保根结点为空 root = put(root, key, value, 0); } /** * 根据所给键、值和当前字符存单词 * @param root 当前结点 * @param key 键 * @param value 值 * @param d 第d个字符 * @return 返回根结点 */ private Node put(Node root, String key, Value value, int d) { char letter = key.charAt(d); if (root == null) { // 如果根结点为空，直接向根结点存入第一个字符 root = new Node(); root.letter = letter; } if (letter &lt; root.letter) { // 当前字符小于结点字符 root.left = put(root.left, key, value, d); } else if (letter > root.letter) { // 当前字符大于结点字符 root.right = put(root.right, key, value, d); } else if (d &lt; key.length() - 1) { // 未达到查找单词最后一个字符，不大于不小于那就是等于了 root.mid = put(root.mid, key, value, d + 1); } else { // 达到查找单词最后一个字符，直接存储字符 root.val = value; } return root; } } 子串查找Brute-Force 字符串查找算法暴力子字符串查找算法，子串与主串一一匹配。 实现代码1(逐一匹配)： public static int search (String pat, String txt) { int n = txt.length(); int m = pat.length(); for (int i = 0; i &lt;= n - m; i++) { int j; for (j = 0; i &lt; m; j++) { // 主串与子串进行匹配 if (txt.charAt(i + j) != pat.charAt(j)) { break; } } // 找到匹配，返回匹配的初始位置 if (j == n) { return i; } } // 未找到匹配，返回主串的长度 return n; } 实现代码2(显示回退)： public static int search (String pat, String txt) { int i, n = txt.length(); int j, m = pat.length(); for (i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; i++) { if (txt.charAt(i) == pat.charAt(j)) { // 若匹配，则子串向后挪动1位 j++; } else { // 若不匹配，主串指针i回退子串完成匹配的j个位置，子串匹配指针j从0开始 i -= j; j = 0; } } if (j == m) { // 若子串指针匹配长度等于子串的长度匹配成功 return i - m; } else { // 未找到匹配，返回主串的长度 return n; } } Knuth-Morris-Pratt 字符串查找算法Knuth-Morris-Pratt 字符串查找算法即 KMP 算法，KMP 算法在匹配失败时不需要回退到最开始的位置重新进行匹配，可以有两种方法记录信息。 前缀表实现 前缀表：计算前缀表，例如模式串为 ababc，将其拆分成 a，ab，aba，abab 四子串，a 的公共部分为 0(前缀后缀不能为本身)，ab 的最大前缀为 a、最大后缀为 b，因此公共部分为 0； aba 的最大前缀为 ab， 最大后缀为 ba，不匹配则减少一位只进行一位匹配前缀 a 和 后缀 a 匹配，则公共部分为 1；abab 为 2。因此模式串 ababc 的状态就是 -1，0，0，1，2。为模式串标上 0，1，2，3，4的下标分别对应上其状态 -1，0，0，1，2。当匹配失败时，将匹配失败位置的模式串状态值当作下标在模式串中寻找其相应的位置，使用这个位置的字符与主串匹配失败位置的字符进行匹配。若匹配位置的状态值为-1则表示子串向右挪一位进行匹配。 计算 maxL, nextJ, nextVal的值： maxL：找出相等的前缀和后缀的个数，maxL 的值就是程序中 next 表的值。 nextJ：通过将 maxL 向右平移一位，在最前面添加一个-1，去掉最后一个数，然后整体加一可以获得。 nextVal：查看 maxL 和 nextJ 的值，当 maxL 不等于 nextJ 的时候，nextVal 的值就等于 nextJ 的值；当 当 maxL 等于 nextJ 的时候，nextVal 的值就等于查找序号为 nextJ 的 nextVal 值。 a b a a b c a c 数组下标 0 1 2 3 4 5 6 7 序号 1 2 3 4 5 6 7 8 maxL 0 0 1 1 2 0 1 0 nextJ 0 1 1 2 2 3 1 2 nextVal 0 1 0 2 1 3 0 2 整体代码： /** * 通过模式串获取next表 * @param pat 模式串 * @return next表 */ private int[] pre_next(String pat) { int patLen = pat.length(); // 若模式串长度8，使用下标0-7，实际计算使用1-8 int[] next = new int[patLen + 1]; next[0] = -1; int i = 0, j = -1; // 若计算下标为i的next值时，会将其填入下标为i+1的位置上 while (i &lt; patLen - 1) { if (j == -1 || pat.charAt(i) == pat.charAt(j)) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } /** * KMP字符串查询(前缀表) * @param pat 模式串 * @param txt 主串 * @return 匹配成功的初始位置 OR 匹配失败(FALSE) */ int kmp(String pat, String txt) { int[] next = pre_next(pat); int i = 0, j = 0; int patLen = pat.length(); int txtLen = txt.length(); while (i &lt; txtLen &amp;&amp; j &lt; patLen) { if (j == -1 || txt.charAt(i) == pat.charAt(j)) { i++; j++; } else { j = next[j]; } } if (i >= patLen) { return i - patLen; } else { return -1; } } next 表计算流程如下： i j maxL index 0 -1 -1 1 0 0 1 1 -1 2 0 0 2 3 1 1 3 3 0 4 1 1 4 5 2 2 5 5 0 5 -1 6 0 0 6 7 1 1 7 7 0 7 -1 8 0 0 8 DFA 实现 DFA：通过使用确定有限状态自动机(DFA)记录模式匹配状态，状态匹配方法如下：设模式串为 ABABAC，字母表 r 为 ABC。(DFA 根据文本中的字符改变而改变自身的状态，还有一种非确定有限状态自动机 NFA 在抽象方面比 DFA 更强，他可以根据或操作判断模式是否存在，即可以根据不确定的字符判断模式是否存在，常用于正则表达式) 第一步：将输入的A记为1，其它都记为0。(i=0，j=0) A B A B A C A 1 B 0 C 0 第二步：把第一个字符的状态值复制到第二个状态值，然后修改匹配成功的字符的状态值，也就是说本来从上到下是110，因为B是输入的所以是匹配成功的，变成了120，i记得要赋值成修改之前的 B 的值，也就是匹配不成功时 B 的值。(i=0，j=1) A B A B A C A 1 1 B 0 2 C 0 0 第三步：不断重复，例如第三列为300(i=1，j=2)，最后表的样子为 A B A B A C A 1 1 3 1 5 1 B 0 2 0 4 0 4 C 0 0 0 0 0 6 整体代码： /** * @Author 喵粮都输光了 * @Date 2020/3/28 16:57 * @Description KMP 模式匹配算法 */ public class Kmp { /** * 模式串 */ private String pat; /** * 确定有限状态自动机，行表匹配串字符，列表匹配串索引，值为状态 * 状态的意思是例如dfa[r][j]，在已匹配j个字符时，若当前字符串字母为r，已匹配数量会变为多少 */ private int[][] dfa; /** * 构造模式串的DFA * @param pat 模式串 */ public Kmp(String pat) { // 使用模式串构造dfa this.pat = pat; int m = pat.length(); // ASCII 基数 int r = 256; // 一共可能有256个字符，表示输入下标为多少的某个字符其状态为什么 dfa = new int[r][m]; // 将模式串第一个字符的状态值置为 1，第一个字符和自己匹配不管怎么样都是匹配的，也就是已匹配1个 dfa[pat.charAt(0)][0] = 1; // 计算dfa[][j]即模式串第二到最后一个字符的状态值，j是第几个字符 for (int i = 0, j = 1; j &lt; m; j++) { // 遍历所有可能的字符， for (int k = 0; k &lt; r; k++) { dfa[k][j] = dfa[k][i]; } // 一开始全部都是设定成不匹配的，此时要修改匹配成功情况下的值，也就是模式串第j个位置的字符就是输入字符，他匹配数量一定增1，其他情况都是匹配失败 dfa[pat.charAt(j)][j] = j + 1; // i 是记录这个当前第j次循环开始时匹配不成功情况下的值，也就是上面那个循环结束时pat.charAt(j)的值。 i = dfa[pat.charAt(j)][i]; } } /** * 和暴力查找算法的显示回退思路一样，只是回退时使用的是DFA而已 * @param txt 需要查找子串的主串 * @return 查找到的子串下标开始位置 */ public int search(String txt) { int i, n = txt.length(); int j, m = pat.length(); for (i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; i++) { // 匹配不成功时候回退到第j个字符，匹配成功也会有相应状态，所以不需要加判断了 j = dfa[txt.charAt(i)][j]; } if (j == m) { // 若子串指针匹配长度等于子串的长度匹配成功 return i - m; } else { // 未找到匹配，返回主串的长度 return n; } } public static void main(String[] args) { String txt = \"ABCDEFT\"; String pat = \"DEF\"; Kmp kmp = new Kmp(pat); System.out.println(kmp.search(txt)); } } Boyer-Moore 字符串查找算法用一个数组记录字母表中的每个字符在模式串中出现的最右位置，当匹配失败时通过该数组查找与主串匹配失败的字符在模式串中的最右位置来进行重新匹配。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 20:25 * @Description Boyer-Moore 子串查找算法 */ public class BoyerMoore { /** * 记录字母表中的每个字符在模式串中出现的最靠右的位置 * 例如ABBA，则A是3，B是2 */ private int[] right; /** * 模式串 */ private String pat; public BoyerMoore(String pat) { this.pat = pat; int m = pat.length(); int r = 256; right = new int[r]; // 将right的所有值设置成-1 for (int i = 0; i &lt; r; i++) { right[i] = -1; } // 将包含于模式串中的值设置成该字符在模式串中出现的最右边的位置 for (int i = 0; i &lt; m; i++) { right[pat.charAt(i)] = i; } } /** * Boyer-Moore查找 * @param txt 需要查找子串的主串 * @return 查找到的子串下标开始位置 */ public int search(String txt) { int n = txt.length(); int m = pat.length(); // 匹配失败时模式串移动的的幅度 int skip; for (int i = 0; i &lt;= n - m; i += skip) { skip = 0; // right中记录的是最右的位置，因此从right的最右向左遍历 for (int j = m - 1; j >= 0; j--) { // 如果出现了不相等则修改移动幅度skip if (pat.charAt(j) != txt.charAt(i + j)) { /* * 若模式串的j下标字符与主串的i+j下标字符不匹配， * 查找right表主串不匹配字符不在其中直接右挪一位，在其中则j减去该字符在模式串中最右的位置的下标 * 也就是说将与主串那个字符匹配的模式串中最右的该字符移动上去与之匹配 */ skip = j - right[txt.charAt(i + j)]; // 若j减去模式串最右的位置的字符出现了负数，不需要将模式串左右，直接将模式串右移一位即可 if (skip &lt; 1) { skip = 1; } break; } } // 当skip为0时，匹配成功返回主串与模式串匹配的初始位置 if (skip == 0) { return i; } } //匹配失败返回主串长度。 return n; } public static void main(String[] args) { String txt = \"ABCDEFT\"; String pat = \"DEF\"; BoyerMoore boyerMoore = new BoyerMoore(pat); System.out.println(boyerMoore.search(txt)); } } Rabin-Karp 指纹字符串查找算法通过计算模式字符串的散列函数，然后用相同的散列函数计算文本中所有可能的 m 个字符的子字符串散列值并寻找匹配，当寻找到一个散列值与模式字符串相同的子字符串还要继续验证两者是否真的匹配。Rabin-Karp 算法能在常数时间内计算 m 个字符的子字符串散列值，否则直接计算每个字符串的散列值将导致该算法比暴力查询还要慢。 此处使用的 horner 方法即如果在每次算术操作之后都将结果模以 Q 等价于在完成所有算术操作之后将最终的结果模以 Q，可以在常数时间内高效的移动子串。 总结 字符串排序 算法 稳定性 时间复杂度 空间复杂度 优势 低位优先排序 是 O(nw) O(n) 较短的定长字符串 高位优先排序 是 O(n)~O(nw) O(n+wr) 随机字符串 三向快速排序 否 O(n)~O(nw) O(w+logn) 含有较长公共前缀的字符串 字符串查找 暴力查找实现简单且在一般情况下性能良好，但是其所需时间可能和 MN 成正比，JAVA 中的 indexOf() 采用的是暴力查找； KMP 算法能够保证线性级别的性能且不需要再正文中回退，但是需要额外内存空间； Boyer-Moore 算法在一般情况下性能是亚线性级别(可能是线性级别的 M 倍)，但是需要额外内存空间； Rabin-Karp 算法性能是线性级别的，但是其内循环很长。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://blog.kuukokawaii.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法之图","date":"2020-03-26T13:47:14.000Z","path":"posts/d01e83b2/","text":"背包类下面算法会用到背包类： /** * @Author 喵粮都输光了 * @Date 2020/3/27 10:33 * @Description 背包(存取不能删) */ public class Bag&lt;Item> implements Iterable&lt;Item> { /** * 头结点 */ private Node&lt;Item> first; /** * 结点个数 */ private int n; private static class Node&lt;Item> { private Item item; private Node&lt;Item> next; } /** * 初始化背包 */ public Bag() { first = null; n = 0; } /** * 背包是否位空 * @return true or false */ public boolean isEmpty() { return first == null; } /** * 背包存储的数据个数 * @return 背包存储的数据个数 */ public int size() { return n; } /** * 添加 * @param item 元素 */ public void add(Item item) { Node&lt;Item> oldFirst = first; first = new Node&lt;>(); first.item = item; first.next = oldFirst; n++; } @Override public Iterator&lt;Item> iterator() { return new LinkedIterator(first); } /** * 背包迭代器 */ private class LinkedIterator implements Iterator&lt;Item> { /** * 当前结点 */ private Node&lt;Item> current; public LinkedIterator(Node&lt;Item> first) { current = first; } @Override public boolean hasNext() { return current != null; } @Override public void remove() { // 背包无删除方法 throw new UnsupportedOperationException(); } @Override public Item next() { if (!hasNext()) { throw new NoSuchElementException(); } Item item = current.item; current = current.next; return item; } } } 并查集并查集用于解决动态连通性问题，能动态连接两个顶点，并且判断两个顶点是否连通。 Quick Find可以快速的判断两个结点是否相通，因为同一连通分量的所有结点 id 相等，所以通过判断 id 是否相等就可以判断两个结点是否连通。 union 操作代价很高，需要将其中一个连通分量的所有 id 改成另一个连通分量的 id。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 20:48 * @Description quick find */ public class QuickFindUf { /** * 连通分量编号 */ private int[] id; public QuickFindUf(int n) { id = new int[n]; // 初始化，一个结点一个连通分量，刚开始无连接结点 for (int i = 0; i &lt; n; i++) { id[i] = i; } } /** * 查找p所在连通分量的编号 * @param p 结点p * @return 编号 */ public int find(int p) { return id[p]; } /** * 连接结点p和结点q * @param p 结点p * @param q 结点q */ public void union(int p, int q) { int pId = find(p); int qId = find(q); // 若两个结点id相等返回 if (pId == qId) { return; } // 否则把所有id等于p的都改成id等于q for (int i = 0; i &lt; id.length; i++) { if (id[i] == pId) { id[i] = qId; } } } } Quick Union可以快速的进行 union 操作，只需要修改一个结点的id即可，但是 find 操作代价很高，因为同一个连通分量的结点 id 值均不同，一个结点的 id 只是指向另一个结点，查找需要找到最顶层的结点 id。 quick union 会导致树高度可能为结点的数目，查找非常耗时。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 20:54 * @Description quick union */ public class QuickUnionUf { /** * 连通分量编号 */ private int[] id; public QuickUnionUf(int n) { id = new int[n]; // 初始化，一个结点一个连通分量，刚开始无连接结点 for (int i = 0; i &lt; n; i++) { id[i] = i; } } /** * 查找p所在连通分量的编号 * @param p 结点p * @return 编号 */ public int find(int p) { // 若结点p的值不等于结点p的下标，说明结点p的值是另一个结点的下标，将修改p的下标为p的值，继续查找根结点 while (p != id[p]) { p = id[p]; } return p; } /** * 连接结点p和结点q * @param p 结点p * @param q 结点q */ public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); // 将p的根结点下标改成q的根结点下标即可 if (pRoot != qRoot) { id[pRoot] = qRoot; } } } 加权 Quick Union通过将较小的树连接到较大的树上解决了 quick union 树高的问题。加权 quick union 的树高最多不超过 logn。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 21:02 * @Description 加权 quick union */ public class WeightedQuickUnionUf { /** * 连通分量编号 */ private int[] id; /** * 保存结点的数量信息 */ private int[] size; public WeightedQuickUnionUf(int n) { id = new int[n]; // 初始化，一个结点一个连通分量，刚开始无连接结点 for (int i = 0; i &lt; n; i++) { id[i] = i; } size = new int[n]; // 初始化，刚开始每个结点树高都为1 for (int i = 0; i &lt; n; i++) { size[i] = 1; } } /** * 查找p所在连通分量的编号 * @param p 结点p * @return 编号 */ public int find(int p) { // 若结点p的值不等于结点p的下标，说明结点p的值是另一个结点的下标，将修改p的下标为p的值，继续查找根结点 while (p != id[p]) { p = id[p]; } return p; } /** * 连接结点p和结点q * @param p 结点p * @param q 结点q */ public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); // 若结点p和结点q处于同一分量直接返回 if (pRoot == qRoot) { return; } // 如果结点p分量树小于结点q分量树 if (size[pRoot] &lt; size[qRoot]) { // 将结点p分量树挂到结点q分量树上 id[pRoot] = qRoot; // 结点q分量树需要加上结点p分量树的个数 size[qRoot] += size[pRoot]; } else { // 与上面相反 id[qRoot] = pRoot; size[pRoot] += size[qRoot]; } } } 路径压缩的加权 Quick Union将每一个连通分量的指向都指向根结点，修改 find 方法即可。 public int find(int p) { int temp = p; while (p != id[p]) { p = id[p]; } id[temp] = id[p]; return p; } 拓扑排序给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素称为拓扑排序。而且拓扑排序只能在有向无环图中才能进行。 拓扑排序实现只需要稍微修改深度优先搜索的代码即可完成。深度优先搜索时保存路径的数据结构的性质以及在递归调用前保存还是递归调用后保存，拓扑排序能分成三种排列顺序：前序(递归调用前入队)；后序(递归调用后入队)；逆后序(递归调用后压栈)； 实现代码： /** * @Author 喵粮都输光了 * @Date 2020/3/27 10:30 * @Description 有向图数据类型 */ public class Digraph { /** * 顶点数目 */ private int v; /** * 边数目 */ private int e; /** * 邻接表，包数组，每一个包代表一个而顶点的所有邻接顶点 */ private Bag&lt;Integer>[] adj; public Digraph(int v) { this.v = v; this.e = 0; adj = (Bag&lt;Integer>[]) new Bag[v]; for (int i = 0; i &lt; v; i++) { adj[i] = new Bag&lt;>(); } } /** * 顶点个数 * @return 顶点个数 */ public int v() { return v; } /** * 边个数 * @return 边个数 */ public int e() { return e; } /** * 添加边 * @param v 顶点v * @param w 顶点w */ public void addEdge(int v, int w) { adj[v].add(w); e++; } /** * 遍历顶点v的所有邻接顶点 * @param v 顶点v * @return 顶点v的所有邻接顶点 */ public Iterable&lt;Integer> adj(int v) { return adj[v]; } /** * 有向图反转，即入度变出度，出度变入度 * @return 反转的有向图 */ public Digraph reverse() { Digraph digraph = new Digraph(v); for (int i = 0; i &lt; v; i++) { for (int w : adj(v)) { digraph.addEdge(w, v); } } return digraph; } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 13:58 * @Description 基于深度优先搜索的顶点排序 */ public class DepthFirstOrder { /** * 存储顶点是否被遍历过的信息 */ private boolean[] marked; /** * 前序排序 */ private Queue&lt;Integer> pre; /** * 后序排序 */ private Queue&lt;Integer> post; /** * 逆后序排序 */ private Stack&lt;Integer> reversePost; /** * 初始化图，遍历所有顶点 * @param g 图g */ public DepthFirstOrder(Digraph g) { pre = new LinkedList&lt;>(); post = new LinkedList&lt;>(); reversePost = new Stack&lt;>(); marked = new boolean[g.v()]; // 若图非连通，遍历所有非连通子图 for (int i = 0; i &lt; g.v(); i++) { if (!marked[i]) { dfs(g, i); } } } /** * 深度优先搜索 * @param g 图g * @param v 顶点v */ private void dfs(Digraph g, int v) { pre.offer(v); marked[v] = true; for (int w : g.adj(v)) { if (!marked[w]) { dfs(g, w); } } post.offer(v); reversePost.push(v); } /** * 前序遍历顶点 * @return 前序顶点集 */ public Iterable&lt;Integer> pre() { return pre; } /** * 后序遍历顶点 * @return 后序顶点集 */ public Iterable&lt;Integer> post() { return post; } /** * 逆后序遍历顶点 * @return 逆后序顶点集 */ public Iterable&lt;Integer> reversePost() { return reversePost; } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 14:11 * @Description 有向图环检测 */ public class DirectedCycle { /** * 存储顶点是否被遍历过的信息 */ private boolean[] marked; /** * 从起点到一个顶点的已知路径上的最后一个顶点。 */ private int[] edgeTo; /** * 有向环中的所有顶点，若存在环 */ private Stack&lt;Integer> cycle; /** * 一次深度优先搜索中(一张子图中)遍历过的顶点 * true表遍历过，false表没遍历过 * 与marked区别为，marked标记整个图，onStack表一个子图即正在递归中的顶点 */ private boolean[] onStack; /** * 初始化图，深度优先搜索查找环 * @param g 图g */ public DirectedCycle(Digraph g) { onStack = new boolean[g.v()]; edgeTo = new int[g.v()]; marked = new boolean[g.v()]; for (int i = 0; i &lt; g.v(); i++) { if (!marked[i]) { dfs(g, i); } } } /** * 深度优先搜索，若搜索的顶点的邻接顶点在栈中则有环 * @param g 图g * @param i 顶点i */ private void dfs(Digraph g, int i) { // 将该顶点置为true因为遍历过 onStack[i] = true; marked[i] = true; for (int w : g.adj(i)) { if (hasCycle()) { // 有环直接返回 return; } else if (!marked[w]) { // 无环且邻接顶点没有被遍历过，就遍历 edgeTo[w] = i; dfs(g, w); } else if (onStack[w]) { // 如果当前顶点的邻接顶点在子图中遍历过则有环 cycle = new Stack&lt;>(); // cycle记录edgeTo中走过的路径。从当前顶点开始，到产生环的邻接顶点(不包含) for (int j = i; j != w; j = edgeTo[j]) { // 例0-1-2-3-0， i是3，edgeTo回退到0，不将0加入 cycle.push(j); } // 将产生环的邻接顶点加入路径，将0加入 cycle.push(w); // 将当前顶点加入，即变成了 3-2-1-0-3 的循环 cycle.push(i); } } // 递归回退将顶点置为false onStack[i] = false; } /** * 是否有环 * @return true or false */ public boolean hasCycle() { return cycle != null; } /** * 遍历环，若环存在 * @return 环中顶点集 */ public Iterable&lt;Integer> cycle() { return cycle; } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 13:35 * @Description 拓扑排序 */ public class Topological { /** * 顶点的拓扑排序 */ private Iterable&lt;Integer> order; /** * 初始化图，若有向图无环进行拓扑排序 * @param g 图g */ public Topological(Digraph g) { DirectedCycle cycleFinder = new DirectedCycle(g); if (!cycleFinder.hasCycle()) { DepthFirstOrder dfs = new DepthFirstOrder(g); order = dfs.reversePost(); } } /** * 顶点拓扑排序集 * @return 顶点拓扑排序集 */ public Iterable&lt;Integer> order() { return order; } /** * 是不是有向无环图 * @return true or false */ public boolean isDag() { return order != null; } } Kosaraju 算法计算有向图的强连通分量分两步： 在给定的有向图 g 中，使用 DepthFirstOrder 来计算 g 的反向图 ~g，并获得其逆后序排列。 对获得的反向图 ~g 的逆后序排列进行深度优先搜索即可获得强连通分量的数量。 所有在同一个dfs()递归中被访问的顶点都属于同一个强连通分量，通过强连通分量的标识符进行识别。 关键代码： // 已访问过的顶点 boolean[] marked; // 强连通分量的数量 int count = 0; // 强连通分量的标识符，若顶点v是第i个连通分量则id[v]=i int[] id; public KosarajuSCC(Digraph g) { id = new int[g.v()]; DepthFirstOrder order = new DepthFirstOrder(g.reverse()); for (int s : order.reversePost()) { // 可能是非连通图 if (!marked[s]) { dfs(g, s); count++; } } } public void dfs(Digraph g, int v) { marked[v] = true; // 顶点v是第count个连通分量，id[v]=count id[v] = count; for (int w : g.adj(v)) { if (!marked[w]) { dfs(g, w); } } } public boolean stronglyConnected() { // 顶点 v 和顶点 w 是否强连通 return id[v] == id[w]; } 最小生成树给定一副加权无向图，找到它的一颗最小生成树(MST)即一颗树中所有边的权值之和最小的生成树。图的生成树是它的一颗含有其所有顶点的无环连通子图。 最小生成树通用类： /** * @Author 喵粮都输光了 * @Date 2020/3/27 15:37 * @Description 带权重的边基础数据类型 */ public class Edge implements Comparable&lt;Edge> { /** * 顶点v */ private int v; /** * 顶点w */ private int w; /** * 权重 */ private double weight; public Edge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } /** * 获得顶点v * @return 顶点v */ public int either() { return v; } /** * 获取另一个顶点 * @param vertex v或w * @return 返回w或v */ public int other(int vertex) { if (vertex == v) { return w; } else if (vertex == w) { return v; } else { throw new RuntimeException(\"参数有问题\"); } } /** * 该边权重 * @return 返回权重 */ public double weight() { return weight; } @Override public int compareTo(Edge that) { if (this.weight() &lt; that.weight()) { return -1; } else if (this.weight() > that.weight()) { return 1; } else { return 0; } } @Override public String toString() { return String.format(\"%d--%d %.2f\", v, w, weight); } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 15:44 * @Description 加权无向图数据类型 */ public class EdgeWeightedGraph { /** * 顶点数目 */ private int v; /** * 边数目 */ private int e; /** * 邻接表 */ private Bag&lt;Edge>[] adj; public EdgeWeightedGraph(int v) { this.v = v; this.e = 0; adj = (Bag&lt;Edge>[]) new Bag[v]; for (int i = 0; i &lt; v; i++) { adj[i] = new Bag&lt;>(); } } /** * 顶点个数 * @return 顶点个数 */ public int v() { return v; } /** * 边个数 * @return 边个数 */ public int e() { return e; } /** * 添加边 * @param edge 边 */ public void addEdge(Edge edge) { int v = edge.either(); int w = edge.other(v); adj[v].add(edge); adj[w].add(edge); e++; } /** * 遍历顶点v的所有邻接顶点 * @param v 顶点v * @return 顶点v的所有邻接顶点 */ public Iterable&lt;Edge> adj(int v) { return adj[v]; } /** * 返回所有边 * @return 边集 */ public Iterable&lt;Edge> edges() { Bag&lt;Edge> bag = new Bag&lt;>(); for (int i = 0; i &lt; v; i++) { for (Edge e : adj[i]) { // 因为每个顶点会在边中出现两次，所以这里只取一个 if (e.other(i) > i) { bag.add(e); } } } return bag; } } Prim 算法选择一个结点作为树的根结点，将这个根结点的所有边存入优先队列。从优先队列中取出一条权值最小的边并将它添加到树中(如果未失效)，再将这个边的另一个顶点添加到树中。然后将新顶点的所有边加入优先队列，选择一条权值最小的边重复之前的操作，直至队列中无边。 算法实现： /** * @Author 喵粮都输光了 * @Date 2020/3/27 16:15 * @Description 最小生成树的Prim算法 */ public class PrimMst { /** * 顶点集是否被遍历过 */ private boolean[] marked; /** * 最小生成树的边 */ private Queue&lt;Edge> mst; /** * 优先队列存储待选择的边 */ private PriorityQueue&lt;Edge> pq; /** * 初始化生成树，并生成最小生成树 * @param g 图g */ public PrimMst(EdgeWeightedGraph g) { pq = new PriorityQueue&lt;>(); marked = new boolean[g.v()]; mst = new LinkedList&lt;>(); visit(g, 0); while (!pq.isEmpty()) { Edge e = pq.poll(); int v = e.either(); int w = e.other(v); // 如果边的两个顶点都遍历过了跳过 if (marked[v] &amp;&amp; marked[w]) { continue; } mst.offer(e); // 如果顶点v没被遍历过，遍历 if (!marked[v]) { visit(g, v); } // 如果顶点w没被遍历过，遍历 if (!marked[w]) { visit(g, w); } } } /** * 遍历顶点v的所有边，将边的另一头未被标记的顶点加入优先队列 * @param g 图g * @param v 顶点v */ private void visit(EdgeWeightedGraph g, int v) { marked[v] = true; for (Edge e : g.adj(v)) { if (!marked[e.other(v)]) { pq.offer(e); } } } /** * 最小生成树的所有边 * @return 最小生成树所有边 */ public Iterable&lt;Edge> edges() { return mst; } /** * 最小生成树的权值 * @return 树的权值 */ public double weight() { int weight = 0; for (Edge e : mst) { weight += e.weight(); } return weight; } } Kruskal 算法Prim 算法是随便选一个结点然后选择该节点权值最小的边扩展成最小生成树，而 Kruskal 算法是选择权值最小的边，然后选择权值第二小的边(如果加入的边会构成循环则舍弃)，直到构成一颗最小生成树为止。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 17:07 * @Description 最小生成树的Kruskal算法 */ public class Kruskal { /** * 最小生成树的边 */ private Queue&lt;Edge> mst; /** * 初始化生成树，并生成最小生成树 * @param g 图g */ public Kruskal(EdgeWeightedGraph g) { mst = new LinkedList&lt;>(); PriorityQueue&lt;Edge> pq = new PriorityQueue&lt;>(); for (Edge e : g.edges()) { pq.offer(e); } // 并查集 Uf uf = new Uf(g.v()); while (!pq.isEmpty() &amp;&amp; mst.size() &lt; g.v() - 1) { Edge e = pq.poll(); int v = e.either(); int w = e.other(v); if (uf.connected(v, w)) { // 并查集判断顶点v和顶点w是否相连 continue; } // 顶点v和顶点w不相连则将其连接 uf.union(v, w); mst.offer(e); } } /** * 最小生成树的所有边 * @return 最小生成树所有边 */ public Iterable&lt;Edge> edges() { return mst; } /** * 最小生成树的权值 * @return 树的权值 */ public double weight() { int weight = 0; for (Edge e : mst) { weight += e.weight(); } return weight; } } 最短路径单点路径最短：给定一幅加权有向图和一个起点 s，找到顶点 s 到顶点 v 的最短(总权重最小)路径(如果可达)。 最短路径树(Shortest Path Tree，SPT)：给定一副加权有向图和一个起点 s，以 s 为起点的一颗最短路径树包含从 s 起可达的所有顶点。 Dijkstra 算法和 Prim 算法构造方法类似，Dijkstra 算法通过将最小权值的非树顶点放松加入树中，不断重复直至所有顶点都在树中或所有的非树顶点的权值都是无穷大为止。也就是说该算法每次都会为最短路径树添加一条边，该边由一个树中的顶点指向一个非树顶点 w 且它是到 s 最近的顶点。 Dijkstra 算法能够解决边权值非负的加权有向图的单起点最短路径问题。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 17:39 * @Description 加权有向边数据类型 */ public class DirectedEdge { /** * 边的起点 */ private int v; /** * 边的终点 */ private int w; /** * 边的权重 */ private double weight; public DirectedEdge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } /** * 获得起点 * @return 顶点v */ public int from() { return v; } /** * 获取终点 * @return 返回w */ public int to() { return w; } /** * 获取权值 * @return 权值 */ public double weight() { return weight; } @Override public String toString() { return String.format(\"%d->%d %.2f\", v, w, weight); } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 17:45 * @Description 加权无向图数据类型 */ public class EdgeWeightedGraph { /** * 顶点数目 */ private int v; /** * 边数目 */ private int e; /** * 邻接表 */ private Bag&lt;DirectedEdge>[] adj; public EdgeWeightedGraph(int v) { this.v = v; this.e = 0; adj = (Bag&lt;DirectedEdge>[]) new Bag[v]; for (int i = 0; i &lt; v; i++) { adj[i] = new Bag&lt;>(); } } /** * 顶点个数 * @return 顶点个数 */ public int v() { return v; } /** * 边个数 * @return 边个数 */ public int e() { return e; } /** * 添加边 * @param edge 边 */ public void addEdge(DirectedEdge edge) { adj[edge.from()].add(edge); e++; } /** * 遍历顶点v的所有邻接顶点 * @param v 顶点v * @return 顶点v的所有邻接顶点 */ public Iterable&lt;DirectedEdge> adj(int v) { return adj[v]; } /** * 返回所有边 * @return 边集 */ public Iterable&lt;DirectedEdge> edges() { Bag&lt;DirectedEdge> bag = new Bag&lt;>(); for (int i = 0; i &lt; v; i++) { for (DirectedEdge e : adj[i]) { bag.add(e); } } return bag; } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 18:13 * @Description 最短路径Dijkstra算法 */ public class DijkstraSp { /** * 存储顶点是否被遍历过的信息 */ private boolean[] marked; /** * 从起点到一个顶点的已知路径上的最后一个顶点。 */ private DirectedEdge[] edgeTo; /** * 最短路径的长度 */ private double[] distTo; /** * 优先队列存储待选择的边 */ private PriorityQueue&lt;DirectedEdge> pq; public DijkstraSp(EdgeWeightedGraph g, int s) { // 权值不能为负 for (DirectedEdge e : g.edges()) { if (e.weight() &lt; 0) { throw new IllegalArgumentException(\"权值不能为负\"); } } edgeTo = new DirectedEdge[g.v()]; distTo = new double[g.v()]; marked = new boolean[g.v()]; pq = new PriorityQueue&lt;>(g.v(), (e1, e2) -> { // 比较返回路径长度最小的 double dist1 = distTo[e1.from()] + e1.weight(); double dist2 = distTo[e2.from()] + e2.weight(); return Double.compare(dist1, dist2); }); // 将所有顶点的路径权值初始化为达不到 for (int i = 0; i &lt; g.v(); i++) { distTo[i] = Double.POSITIVE_INFINITY; } // 选择一个顶点作为开始顶点 distTo[s] = 0; // 松弛边 relax(g, s); while (!pq.isEmpty()) { DirectedEdge e = pq.poll(); int w = e.to(); if (!marked[w]) { relax(g, w); } } } /** * 松弛边操作：放松边v->w意味着检查v到w的最短路径是否是从s到v，然后由v到w。 * 由v到w的最短路径为distTo[v]+e.weight，如果这个值小于distTo[w]就更新数据，否则忽略。 * @param g 图g * @param v 顶点v */ private void relax(EdgeWeightedGraph g, int v) { marked[v] = true; for (DirectedEdge edge : g.adj(v)) { int w = edge.to(); if (distTo[v] + edge.weight() &lt; distTo[w]) { distTo[w] = distTo[v] + edge.weight(); edgeTo[w] = edge; pq.offer(edge); } } } /** * 顶点v的权值 * @param v 顶点v * @return 顶点v的权值 */ public double distTo(int v) { return distTo[v]; } /** * 起点到顶点v是否有路径 * @param v 顶点v * @return true or false */ public boolean hasPathTo(int v) { return marked[v]; } /** * 返回起点到顶点v的最短路径 * @param v 顶点v * @return 路径 */ public Iterable&lt;DirectedEdge> pathTo(int v) { if (!hasPathTo(v)) { return null; } List&lt;DirectedEdge> path = new ArrayList&lt;>(); for (DirectedEdge edge = edgeTo[v]; edge != null; edge = edgeTo[edge.from()]) { path.add(edge); } Collections.reverse(path); return path; } } 顶点松弛+拓扑排序结合求解按照拓扑结构放松顶点，该方法求情节最短路径能够处理负权重的边，且比 Dijkstra 算法快。 如果要求最长路径可以将 distTo 初始化为 Double.NEGATIVE_INFINITY，并且将 relax 方法中的不等式方法更改即可。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 20:03 * @Description 边松弛+拓扑排序求解最短路径 */ public class AcyclicSp { /** * 从起点到一个顶点的已知路径上的最后一个顶点。 */ private DirectedEdge[] edgeTo; /** * 最短路径的长度 */ private double[] distTo; public AcyclicSp(EdgeWeightedGraph g, int s) { edgeTo = new DirectedEdge[g.v()]; distTo = new double[g.v()]; for (int i = 0; i &lt; g.v(); i++) { distTo[i] = Double.POSITIVE_INFINITY; } distTo[s] = 0; Topological topological = new Topological(g); for (int v : topological.order()){ relax(g, v); } } // 其它方法同 Dijkstra 算法。 } 关键路径如果将一系列任务的长度定义为完成所有任务的最早可能时间，那么最长的任务序列就是问题的关键路径。所以使用顶点松弛+拓扑排序结合求解最长路径即可得到关键路径。 Floyd算法利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法。Dijkstra 算法是单源最短路径算法。 Bellman-Ford 算法在任意含有 v 个顶点的加权有向图中给定起点 s，从 s 无法到达任何负权重环，而通过 Bellman-Ford 算法能解决其中的单点最短路径问题。通过将 distTo[s] 初始化为0，其它 distTo[] 元素初始化为无穷大，并以任意顺序放松有向图的所有边，重复 v 轮。 总结 并查集 算法 find union Quick Find O(n) 1 Quick Union 树高 树高 加权 Quick Union O(logn) O(logn) 路劲压缩加权 Quick Union 接近1 接近1 最小生成树 算法 空间 时间 图类型 Prime 算法 O(E) O(ElogE) 无向图 Kruskal 算法 O(E) O(ElogE) 无向图 最短路径 算法 局限 最坏情况 一般情况 所需空间 优势 Dijkstra 算法 边的权重必须为正 O(ElogV) O(ElogV) V 最坏情况下仍有较好的性能 拓扑排序 只适用于无环加权有向图 O(E+V) O(E+V) V 是无环图中的最优算法 Bellman-Ford 算法 不能存在负权重环 O(E+V) O(VE) V 适用领域广泛 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://blog.kuukokawaii.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法之查找","date":"2020-03-25T13:01:43.000Z","path":"posts/4cc1103c/","text":"符号表模板抽象了符号表所需的基本操作。 无序符号表模板/** * @Author 喵粮都输光了 * @Date 2020/3/25 21:22 * @Description 无序符号表模板 */ public interface UnorderedSt&lt;Key, Value> { /** * 存储的键值对个数 * @return 当前个数 */ int size(); /** * 根据key获得其value * @param key 键 * @return 值 */ Value get(Key key); /** * 根据键值存入键值对 * @param key 键 * @param value 值 */ void put(Key key, Value value); /** * 根据键删除键值对 * @param key 键 */ void delete(Key key); } 有序符号表模板/** * @Author 喵粮都输光了 * @Date 2020/3/25 21:26 * @Description 有序符号表模板 */ public interface OrderedSt&lt;Key extends Comparable&lt;Key>, Value> { /** * 存储的键值对个数 * @return 当前个数 */ int size(); /** * 根据key获得其value * @param key 键 * @return 值 */ Value get(Key key); /** * 根据键值存入键值对 * @param key 键 * @param value 值 */ void put(Key key, Value value); /** * 获得最小的键 * @return 最小的键 */ Key min(); /** * 获得最大的键 * @return 最大的键 */ Key max(); /** * 小于key的键的数量 * @param key 键 * @return 符合要求的键的个数 */ int rank(Key key); /** * 表中[lo...hi]之间的所有键，已排序 * @param lo 起始键 * @param hi 终点键 * @return 返回[lo...hi]之间的所有键的集合 */ List&lt;Key> keys(Key lo, Key hi); } 符号表符号表(Symbol Table)主要用于将一个键与一个值联系起来即存储键值对，它支持高效地插入和查找。符号表分为无序符号表和有序符号表，有序符号表通常通过比较键的大小保持键的有序。 无序符号表实现无序符号表常用链表来实现，方便插入和顺序查找。 时间复杂度：插入和查找的时间复杂度均为O(n)。 /** * @Author 喵粮都输光了 * @Date 2020/3/25 21:39 * @Description 顺序查找(基于无序链表) */ public class SequentialSearchSt&lt;Key, Value> implements UnorderedSt&lt;Key, Value> { private class Node { Key key; Value value; Node next; Node(Key key, Value value, Node next) { this.key = key; this.value = value; this.next = next; } } /** * 根结点 */ private Node first; /** * 符号表大小 */ private int size = 0; @Override public int size() { return size; } @Override public Value get(Key key) { for (Node current = first; current != null; current = current.next) { if (key.equals(current.key)) { return current.value; } } return null; } @Override public void put(Key key, Value value) { for (Node current = first; current != null; current = current.next) { if (key.equals(current.key)) { current.value = value; return; } } first = new Node(key, value, first); size++; } @Override public void delete(Key key) { for (Node current = first, pre = first; current != null; pre = current, current = current.next) { if (key.equals(current.key)) { if (key.equals(first.key)) { first = current.next; } else { pre.next = current.next; } size--; return; } } } public static void main(String[] args) { SequentialSearchSt&lt;String, Integer> st = new SequentialSearchSt&lt;>(); st.put(\"1\", 1); st.put(\"2\", 2); st.put(\"3\", 3); st.put(\"3\", 4); System.out.println(st.size()); st.delete(\"1\"); st.delete(\"2\"); st.delete(\"3\"); System.out.println(st.size()); } } 有序符号表实现有序符号表通常使用一对平行数组实现，两个数组分别存储键和值。该算法保证了键的有序性，并通过二分查找高效的实现查找操作。其实现核心为rank()方法，该方法能够定位需要查找的键的位置或者是需要插入的键的插入位置。 时间复杂度：再n个键的有序数组中二分查找最多需要(lgn+1)次比较，因此查找的时间复杂度为O(lgn)；在最糟糕的情况下，插入的键在数组首位则整个数组需要后移一位，一共有两个数组需要访问数组约2n次，所以插入的时间复杂度为O(n)。 /** * @Author 喵粮都输光了 * @Date 2020/3/25 22:26 * @Description 二分查找(基于有序数组) */ public class BinarySearchSt&lt;Key extends Comparable&lt;Key>, Value> implements OrderedSt&lt;Key, Value> { /** * 键数组 */ private Key[] keys; /** * 值数组 */ private Value[] values; /** * 当前存储的键值对数量 */ private int size = 0; public BinarySearchSt(int capacity) { keys = (Key[]) new Comparable[capacity]; values = (Value[]) new Object[capacity]; } @Override public int size() { return size; } @Override public Key min() { return keys[0]; } @Override public Key max() { return keys[size - 1]; } @Override public int rank(Key key) { // 返回小于key的键的数量 int lo = 0, hi = size - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; int cmp = key.compareTo(keys[mid]); if (cmp &lt; 0) { hi = mid - 1; } else if (cmp > 0) { lo = mid + 1; } else { return mid; } } return lo; } @Override public Value get(Key key) { int index = rank(key); if (index &lt; size &amp;&amp; keys[index].compareTo(key) == 0) { return values[index]; } return null; } @Override public void put(Key key, Value value) { int index = rank(key); // 如果存在更新值 if (index &lt; size &amp;&amp; keys[index].compareTo(key) == 0) { values[index] = value; return; } // 不存在则将插入位置后面的元素依次后移一位 for (int i = size; i > index; i--) { keys[i] = keys[i - 1]; values[i] = values[i - 1]; } keys[index] = key; values[index] = value; size++; } @Override public List&lt;Key> keys(Key lo, Key hi) { List&lt;Key> list = new ArrayList&lt;>(); for (int index = rank(lo); index &lt; size &amp;&amp; keys[index].compareTo(hi) &lt;= 0; index++) { list.add(keys[index]); } return list; } public static void main(String[] args) { BinarySearchSt&lt;String, Integer> st = new BinarySearchSt&lt;>(5); st.put(\"1\", 1); st.put(\"3\", 3); st.put(\"2\", 2); List&lt;String> list = st.keys(\"1\", \"2\"); for (String s : list) { System.out.println(s); } } } 二叉查找树(B 树)为了支持高效插入操作需要使用链式结构，但是二分查找法不适用于链式结构，因此诞生了二叉查找树，同时拥有高效的插入和查找操作。 一颗二叉查找树(BST)是一颗二叉树，其中每个结点都含有一个键且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。BST的中序遍历结果是递增排序。 时间复杂度：二叉查找树拥有顺序查找(无序链表)和二分查找(有序数组)的优点，所以其查找和插入的时间复杂度均为O(n)。 基本数据结构： /** * @Author 喵粮都输光了 * @Date 2020/3/26 10:07 * @Description 二叉查找树 */ public class Bst&lt;Key extends Comparable&lt;Key>, Value> implements OrderedSt&lt;Key, Value> { /** * 二叉树根节点 */ protected Node root; protected class Node { /** * 键 */ Key key; /** * 值 */ Value value; /** * 左结点 */ Node left; /** * 右结点 */ Node right; /** * 以该结点为根的子树结点个数(包括该结点) */ int size; /** * 红黑树判断 */ boolean color; public Node(Key key, Value value, int size) { this.key = key; this.value = value; this.size = size; } } @Override public int size() { return size(root); } /** * 该结点为根的子树结点个数(包括该结点) * @param node 结点 * @return 结点个数 */ private int size(Node node) { if (node == null) { return 0; } return node.size; } /** * 重新计算结点个数 * @param node 以该结点为根的子树结点个数。 */ public void recalculateSize(Node node) { node.size = size(node.left) + size(node.right) + 1; } } get()： @Override public Value get(Key key) { return get(root, key); } /** * 递归查找键，键比根结点键小左子树查找，键比根结点键大右子树查找。 * @param root 二叉查找树根节点 * @param key 需要查找的键 * @return 返回该键的值 */ private Value get(Node root, Key key) { if (root == null) { return null; } int cmp = key.compareTo(root.key); if (cmp &lt; 0) { return get(root.left, key); } else if (cmp > 0) { return get(root.right, key); } else { return root.value; } } put()： @Override public void put(Key key, Value value) { root = put(root, key, value); } /** * 插入结点，找到同样的键覆盖值，没有找到则需新建结点挂入树种。同时更新挂入结点及其所有双亲结点的大小 * @param root 根结点 * @param key 键 * @param value 值 * @return 返回插入结点的引用 */ private Node put(Node root, Key key, Value value) { if (root == null) { return new Node(key, value, 1); } int cmp = key.compareTo(root.key); if (cmp &lt; 0) { root.left = put(root.left, key, value); } else if (cmp > 0) { root.right = put(root.right, key, value); } else { root.value = value; } recalculateSize(root); return root; } floor()： /** * 从根结点起，返回小于等于传入键的的最大键 * @param key 传入键 * @return 返回满足要求的键 */ public Key floor(Key key) { Node node = floor(root, key); if (node == null) { return null; } return node.key; } /** * 从所给结点起，返回小于等于键传入键的的最大键 * @param root 结点 * @param key 传入键 * @return 返回满足要求的键所在结点 */ private Node floor(Node root, Key key) { if (root == null) { return null; } int cmp = key.compareTo(root.key); if (cmp == 0) { // 若相等返回该结点 return root; } else if (cmp &lt; 0) { // 若所给键小于结点的键，则键一定在左子树种 return floor(root.left, key); } else { // 若所给键大于结点的键，则递归该结点的右结点继续判断，若右结点返回空就把当前结点返回 Node temp = floor(root.right, key); return temp == null ? root : temp; } } rank()： @Override public int rank(Key key) { // 小于key的键的数量 return rank(root, key); } /** * 返回小于所给键的键的个数 * @param root 当前结点 * @param key 所给键 * @return 小于所给键的个数 */ private int rank(Node root, Key key) { if (root == null) { return 0; } int cmp = key.compareTo(root.key); if (cmp &lt; 0) { // 若小于，递归左子树的排名 return rank(root.left, key); } else if (cmp > 0) { // 若大于，递归计算右子树的排名再加上左子树的结点数再加一个根结点。 return size(root.left) + 1 + rank(root.right, key); } else { // 若等于，返回该结点左子树的结点数 return size(root.left); } } min()： @Override public Key min() { if (root == null) { return null; } return min(root).key; } /** * 返回最小的键所在结点 * @param root 结点 * @return 最小键所在结点 */ private Node min(Node root) { if (root.left == null) { return root; } return min(root.left); } deleteMin()： /** * 删除最小键所在结点 */ public void deleteMin() { if (root == null) { return; } root = deleteMin(root); } /** * 递归删除最小键所在结点，同时更新删除结点的所有双亲结点的大小 * @param root 当前结点 * @return 第一次返回需要删除结点的右结点，之后都是返回当前结点 */ private Node deleteMin(Node root) { // 找到一个结点左子树为空，返回右子树 if (root.left == null) { return root.right; } // 将该结点的左子树删除，右子树挂载到其左子树 root.left = deleteMin(root.left); // 重新计算结点大小 recalculateSize(root); return root; } delete()： /** * 删除给出键所在结点 * @param key 需要删除的键 */ public void delete(Key key) { root = delete(root, key); } /** * 递归删除所给键所在结点，同时更新删除结点的所有双亲结点的大小 * 删除方法：找到键所在节点的第一个右子树，遍历这个右子树的左子树找到叶子结点，用这个叶子结点替换删除结点， * 需要删除结点的左子树是这个叶子结点的左子树，需要删除节点的右子树是这个叶子结点的右子树， * 当然叶子结点如果有右子树则要变成需要删除结点右子树的左子树。 * @param root 当前结点 * @param key 键 * @return 第一次返回需要删除结点的右结点，之后都是返回当前结点 */ private Node delete(Node root, Key key) { if (root == null) { return null; } int cmp = key.compareTo(root.key); if (cmp &lt; 0) { root.left = delete(root.left, key); } else if (cmp > 0) { root.right = delete(root.right, key); } else { if (root.right == null) { return root.left; } if (root.left == null) { return root.right; } Node temp = root; root = min(temp.right); root.right = deleteMin(temp.right); root.left = temp.left; } recalculateSize(root); return root; } keys()： @Override public List&lt;Key> keys(Key lo, Key hi) { List&lt;Key> list = new ArrayList&lt;>(); keys(root, list, lo, hi); return list; } /** * 表中[lo...hi]之间的所有键，已排序，相当于中序遍历 * @param root 当前结点 * @param list 满足要求的键集合 * @param lo 起始键 * @param hi 终点键 */ private void keys(Node root, List&lt;Key> list, Key lo, Key hi) { if (root == null) { return; } int cmpLo = lo.compareTo(root.key); int cmpHi = hi.compareTo(root.key); // 查找左结点 if (cmpLo &lt; 0) { keys(root.left, list, lo, hi); } // 判断是否在指定范围之内，lo一定小于等于所选键，hi一定大于等于所选键 if (cmpLo &lt;= 0 &amp;&amp; cmpHi >= 0) { list.add(root.key); } // 查找右结点 if (cmpHi > 0) { keys(root.right, list, lo, hi); } } 平衡查找树如果能够保证二叉查找树的树高为lgn的话，也就是二叉查找树是完全二叉树的话，就不会出现二叉查找树的最坏情况出现，此时时间复杂度由O(n)提升至O(lgn)。 2-3 查找树在动态插入时保证树的完美平衡代价非常高昂，因此通过提升树中一个结点保存键的个数减少平衡的代价。2-3查找树引入2-结点(一个键两条链接，左连接的键小于该键，右链接的键大于该键)和3-结点(两个键三条链接，左连接的键小于左键，中间链接的键大于左键小于又见，右链接的键大于右键)来保证平衡。一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。 红黑树红黑二叉查找树通过标准的二叉查找树(2-结点构成)和颜色信息(替换3-结点)来表示2-3查找树。若指向一个结点的颜色信息为红色则表示这个结点和上层结点表示的是一个3-结点，为黑色则表示是一个普通链接。红黑树既是二叉查找树又是2-3查找树，继承了二叉查找树中高效的查找方法和2-3查找树中高效的平衡插入算法。 红黑二叉树也可以表示为是含有红黑链接并满足下列条件的二叉查找树： 红链接均为左链接； 没有任何一个结点同时和两条红链接相连； 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 颜色表示(此处继承二叉查找树代码构建红黑树)： /** * @Author 喵粮都输光了 * @Date 2020/3/26 14:31 * @Description 红黑树 */ public class RedBlackBst&lt;Key extends Comparable&lt;Key>, Value> extends Bst&lt;Key, Value> { /** * 指向结点的链接颜色为红色 */ private static final boolean RED = true; /** * 指向结点的链接颜色为黑色 */ private static final boolean BLACK = false; /** * 指向结点的链接颜色是不是红色 * @param node 结点 * @return true or false */ private boolean isRed(Node node) { // 默认空连接颜色为黑色 if (node == null) { return BLACK; } return node.color == RED; } } 左旋转： /** * 右链接为红色需要进行左旋转操作，红黑树只允许左连接为红色 * 操作：需要变动四处，将根结点的右结点替换根结点，将根结点的右结点的左结点当作根结点的右结点， * 变换颜色，计算结点个数 * @param root 需要旋转的结点 * @return 返回旋转后的根结点 */ private Node rotateLeft(Node root) { // 根结点的右结点 Node right = root.right; // 根结点的右结点变成右结点的左结点 root.right = right.left; // 右结点替换根结点，根结点变成右结点的左结点 right.left = root; // 变色，右结点继承根结点的颜色，根结点变红 right.color = root.color; root.color = RED; // 修改结点的个数，右结点继承根结点的结点个数，根结点重新计算 right.size = root.size; recalculateSize(root); return right; } 右旋转： /** * 当出现两个连续的红链接时，将其中一个红色的左链接进行右旋转操作，操作与左旋转相反 * @param root 需要旋转的结点 * @return 返回旋转后的根结点 */ private Node rotateRight(Node root) { // 根结点的左结点 Node left = root.left; // 根结点的左结点变成左结点的右结点 root.left = left.right; // 左结点替换根结点，根结点变成左结点的右结点 left.right = root; // 变色，左结点继承根结点的颜色，根结点变红 left.color = root.color; root.color = RED; // 修改结点的个数，左结点继承根结点的结点个数，根结点重新计算 left.size = root.size; recalculateSize(root); return left; } 颜色转换： /** * 颜色转换，若一个结点指向左右结点的颜色都是红色的，这就是一个4-结点。 * 需要进行分裂操作，并将指向子结点的颜色变成黑色，指向父节点的颜色从黑色变成红色。 * @param root 需要变换颜色的结点 */ private void flipColors(Node root) { root.color = RED; root.left.color = BLACK; root.right.color = BLACK; } 插入： @Override public void put(Key key, Value value) { root = put(root, key, value); // 根结点永远是黑色的 root.color = BLACK; } /** * 插入结点， * 1.先按二叉查找树的方法插入到正确位置，插入结点颜色是红色 * 2.若指向右结点的颜色为红色，左结点的颜色为黑色，左旋； * 若指向左结点的颜色为红色，左结点的左结点颜色还是红色，右旋； * 若指向左右节点的颜色均为红色，进行颜色转换。 * 3. 最后的最后要将根结点变成黑色。（此处在调用方法中实现了） * @param root 当前结点 * @param key 键 * @param value 值 * @return 返回插入结点的引用 */ private Node put(Node root, Key key, Value value) { // 没找到键的位置，把键插入到应该在的位置，颜色设置为红色。 if (root == null) { Node node = new Node(key, value, 1); node.color = RED; return node; } // 查找键所在结点位置，若找到了覆盖其值。 int cmp = key.compareTo(root.key); if (cmp == 0) { root.value = value; } else if (cmp &lt; 0) { root.left = put(root.left, key, value); } else { root.right = put(root.right, key, value); } // 右红左黑(左旋)，可能会出现左脸红两个，所以放在第一个判断。 if (isRed(root.right) &amp;&amp; !isRed(root.left)) { root = rotateLeft(root); } // 左连红两个(右旋)，之后可能左右都红，所以放在第二个判断。 if (isRed(root.left) &amp;&amp; isRed(root.left.left)) { root = rotateRight(root); } // 左右都红(变色) if (isRed(root.left) &amp;&amp; isRed(root.right)) { flipColors(root); } // 重新计算根结点的结点个数 recalculateSize(root); return root; } 散列表散列表类似于数组，只是用散列函数将被查找的键转化为数组的一个索引，通过转化后的索引访问数组。访问散列表的速度和访问数组元素一样快速，可以在常数时间内实现查找和插入操作。散列表无法实现有序性操作，散列函数无法表示键的大小关系。 散列函数如果有一个大小为 M 的数组，散列函数可以将任意键转换为 [0, M-1] 内的正整数，该正整数即为哈希值。散列函数可能会让不同的键拥有相同的哈希值，也就是哈希值分布不均匀，此时就发生了碰撞，需要特殊的碰撞解决方法进行处理。若散列值计算很耗时，可以将每个键的散列值缓存起来，这种方法称为软缓存。 正整数：常用除留余数法，选择任意正整数 k % M(数组长度)得到的数可以有效的将键散布在 [0, M-1] 之间。M 的选择最好是素数，否则无法利用键中包含的所有信息而导致散布不均匀。例如 M 取10的 k 次方，那么就只能利用键的后k位进行散布。 浮点数：将键表示为二进制数然后使用除留余数法。 字符串：可以通过如下方式散列，r为进制数，通过 r 乘上哈希值再加上字符的ASCII码模数组长度得到字符串的哈希值。如果是多部分组合的类型也可以使用该方法。 int hash = 0; for (char sign : s.toCharArray()) { hash = (r * hash + sign) % M; } hashCode()：该方法是 java 中的一个实现了哈希函数的方法，它默认使用对象的地址值，地址值32位也就是说可以均匀散列至32位整数中。如果需要一个数组索引而不是一个32位的整数，所以可以结合除留余数法进行如下改造。也可以自己覆写对象中的 hashCode() 方法。 private int hash(Key key) { // 将符号位屏蔽即32位整数变成31位非负整数，然后使用除留余数法。0x7fffffff即01111111...31个1 return (key.hashCode() &amp; 0x7fffffff) % M; } 其它的散列函数 数字分析法：提前知道关键字集合，且每个关键字的位数比散列表的地址码位数多，则可以从关键字中提取数字分布比较均匀的若干位作为散列地址。 平方取中法：直接取得数字的平方，然后取其中几位。 折叠法：将关键字分割成相同位数的几部分，然后取这几部分的叠加和(舍去进位)作为散列地址。 碰撞解决拉链法将一个大小为 M 的数组中的每个元素指向一条链表，当元素发生碰撞时，就会将该元素存储在索引指向的链表中。拉链法进行查询时，首先查找 key 所在的链表，然后从链表中顺序查找。 线性探测线性探测法使用空位来解决冲突，当发生冲突时在冲突位置遍历数组寻找到一个空位来存储冲突的键。 /** * @Author 喵粮都输光了 * @Date 2020/3/26 19:24 * @Description 线性探测 */ public class LinearProbingHashSt&lt;Key, Value> implements UnorderedSt&lt;Key, Value> { /** * 当前大小 */ private int size = 0; /** * 最大容量 */ private int maxSize; /** * 键集合 */ private Key[] keys; /** * 值集合 */ private Value[] values; public LinearProbingHashSt(int maxSize) { this.maxSize = maxSize; init(); } public LinearProbingHashSt() { init(); } /** * 初始化 */ private void init() { keys = (Key[]) new Comparable[maxSize]; values = (Value[]) new Object[maxSize]; } /** * 散列函数 * @param key 键 * @return 哈希值 */ private int hash(Key key) { return (key.hashCode() &amp; 0x7fffffff) % maxSize; } @Override public Value get(Key key) { for (int i = hash(key); keys[i] != null; i = (i + 1) % maxSize) { if (keys[i].equals(key)) { return values[i]; } } return null; } @Override public void put(Key key, Value value) { resize(); putElem(key, value); } /** * 插入元素，不包含调整数组 * @param key 键 * @param value 值 */ public void putElem(Key key, Value value) { int i; for (i = hash(key); keys[i] != null; i = (i + 1) % maxSize) { // 找到相同的键，覆盖其值 if (keys[i].equals(key)) { values[i] = value; return; } } keys[i] = key; values[i] = value; size++; } @Override public void delete(Key key) { int i = hash(key); // 寻找需要删除的键 while (keys[i] != null &amp;&amp; !key.equals(keys[i])) { i = (i + 1) % maxSize; } // 若不存在返回 if (keys[i] == null) { return; } // 删除键值对 keys[i] = null; values[i] = null; // 将删除键之后相同哈希值的键值对重新插入 i = (i + 1) % maxSize; while (keys[i] != null) { Key tempKey = keys[i]; Value tempValue = values[i]; keys[i] = null; values[i] = null; size--; putElem(tempKey, tempValue); i = (i + 1) % maxSize; } size--; resize(); } /** * 调整数组大小，使用率α=size/maxSize，当α小于0.5时，探测性能最好，所以最好保证使用率在0.5。 */ private void resize() { if (size >= maxSize / 2) { // 当前大小大于等于容量的1/2，数组扩容一倍 resize(2 * maxSize); } else if (size > 0 &amp;&amp; size &lt;= maxSize / 8) { // 当前大小小于等于容量的1/8，数字缩小一倍 resize(maxSize / 2); } } /** * 根据容量重新调整数组大小 * @param capacity 最大容量 */ private void resize(int capacity) { LinearProbingHashSt&lt;Key, Value> linearProbingHashSt = new LinearProbingHashSt&lt;>(capacity); for (int i = 0; i &lt; maxSize; i++) { if (keys[i] != null) { linearProbingHashSt.putElem(keys[i], values[i]); } } keys = linearProbingHashSt.keys; values = linearProbingHashSt.values; maxSize = linearProbingHashSt.maxSize; } @Override public int size() { return size; } } 查询算法对比 算法 查找 插入 使用 顺序查找(无序链表) O(n) O(n) 操作大型符号表很慢。 二分查找(有序数组) O(lgn) O(n) 查找很快插入很慢，有序操作，空间占用少。 二叉树查找(二叉查找树) O(n) O(n) 性能没有保障，有序操作，链接需要额外空间。 2-3树查找(红黑树) O(2lgn) O(2lgn) 查找插入很快，有序操作，连接需要额外空间。 拉链法(链表数组) 小于O(lgn) 小于O(lgn) 查找插入很快，需要额外计算和大量空间。 线性探测法(并行数组) O(clgn) O(clgn) 查找插入很快，需要额外计算和大量空间。 散列表都是无序的，如果需要优先考虑散列表速度快，如果需要有序性操作则考虑红黑树。考虑存储空间的话散列表占用的存储空间较大，其次红黑树和二叉查找树，再然后顺序查找，最后二分查找。 java 中 java.util.TreeMap 通过红黑树实现；java.util.HashMap 通过拉链法的散列表实现。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://blog.kuukokawaii.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法之排序","date":"2020-03-24T06:59:26.000Z","path":"posts/db4eb545/","text":"排序模板通过 java 的 Comparable 接口的 compareTo() 方法判断两个元素大小关系，使用 less() 和 swap() 来进行比较和交换操作。排序算法的成本模型是比较和交换的次数。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 18:40 * @Description 排序模板 */ public abstract class BaseSort&lt;T extends Comparable&lt;T>> { /** * 排序 * @param nums 排序的数组 */ public abstract void sort(T[] nums); /** * 传入的第一个参数是否比第二个参数小 * @param v 第一个参数 * @param w 第二个参数 * @return true or false */ protected boolean less(T v, T w) { return v.compareTo(w) &lt; 0; } /** * 交换数组中两个元素 * @param nums 需要交换的数组 * @param i 下标i * @param j 下标j */ protected void swap(T[] nums, int i, int j) { T temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } 选择排序从数组中选择一个最小的元素与数组第一个位置的元素交换，再从剩余数组中选择一个最小的元素与数组第二个位置的元素交换，不断重复直至完成排序。 时间复杂度：需要约n(n-1)/2次的比较和n-1次的交换，因此时间复杂度为O(n²)。时间复杂度与数组初始顺序无关。 空间复杂度：交换两个元素只需要一个辅助空间，空间复杂度为O(1)。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 18:10 * @Description 选择排序 */ public class SelectionSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int length = nums.length; for (int i = 0; i &lt; length - 1; i++) { int min = i; for (int j = i + 1; j &lt; length; j++) { if (less(nums[j], nums[min])) { min = j; } } swap(nums, i, min); } } public static void main(String[] args) { SelectionSort&lt;Integer> sort = new SelectionSort&lt;>(); Integer[] nums = {5, 4, 2, 3, 1}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 冒泡排序数组中相邻元素两两比较，遇到右侧元素小于左侧元素则交换，每过一轮循环，就可以让未排序的最大元素上浮至右侧。 时间复杂度：需要约n(n-1)/2次的比较和n(n-1)/2次的交换，因此时间复杂度为O(n²)。若在一轮循环中没有发生元素交换，则说明数组有序。 空间复杂度：交换两个元素只需要一个辅助空间，空间复杂度为O(1)。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 19:08 * @Description 冒泡排序 */ public class BubbleSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int length = nums.length; boolean isSorted = false; for (int i = length - 1; i > 0 &amp;&amp; !isSorted; i--) { isSorted = true; for (int j = 0; j &lt; i; j++) { if (less(nums[j + 1], nums[j])) { isSorted = false; swap(nums, j, j + 1); } } } } public static void main(String[] args) { BubbleSort&lt;Integer> sort = new BubbleSort&lt;>(); Integer[] nums = {2, 6, 3, 4, 9}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 插入排序将当前元素插入到左侧已经排序的数组中，使得插入后的左侧数组仍是井井有条的。 时间复杂度：需要约n(n-1)/2次的比较和n(n-1)/2次的交换，因此时间复杂度为O(n²)。时间复杂度取决于数组的初始顺序，若数组已经部分有序，则逆序较少，需要交换的次数也就较少，时间复杂度较低，最低为O(n)。 空间复杂度：交换两个元素只需要一个辅助空间，空间复杂度为O(1)。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 20:26 * @Description 插入排序 */ public class BubbleSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int length = nums.length; for (int i = 1; i &lt; length; i++) { for (int j = i; j > 0 &amp;&amp; less(nums[j], nums[j - 1]); j--) { swap(nums, j, j - 1); } } } public static void main(String[] args) { BubbleSort&lt;Integer> sort = new BubbleSort&lt;>(); Integer[] nums = {2, 6, 3, 4, 9}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 希尔排序对于大规模数组，插入排序速度就不是很理想，插入排序由于每次只能将逆序数量减1，因此只适合规模不大的数组排序。希尔排序的出现就是为了解决这种问题，希尔排序每次减少的逆序数量大于插入排序，它通过使用插入排序对间隔h的序列进行排序，然后不断的减少h的值直至另h=1时，整个数组就是有序的。 时间复杂度：希尔排序的运行时间小于平方级别(大约为n的1点几次方)。 空间复杂度：交换两个元素只需要一个辅助空间，空间复杂度为O(1)。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 22:27 * @Description 希尔排序 */ public class ShellSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int length = nums.length; int h = 1; while (h &lt; length / 3) { h = 3 * h + 1; } while (h >= 1) { for (int i = h; i &lt; length; i++) { for (int j = i; j >= h &amp;&amp; less(nums[j], nums[j - h]); j -= h) { swap(nums, j, j - h); } } h = h / 3; } } public static void main(String[] args) { ShellSort&lt;Integer> sort = new ShellSort&lt;>(); Integer[] nums = {2, 6, 3, 4, 9}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 归并排序归并排序通过将一个数组分成两部分，分别对其进行排序然后归并起来，其时间复杂度为O(nlogn)。归并排序常用于大规模数组，在小规模数组上可能不如插入排序快。 归并方法将两个已排序数组归并称一个。 /** * 排序用复制数组 */ private T[] temp; /** * 归并 * @param nums 数组 * @param lo 开始下标 * @param mid 中点下标 * @param hi 结束下标 */ private void merge(T[] nums, int lo, int mid, int hi) { int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) { temp[k] = nums[k]; } for (int k = lo; k &lt;= hi; k++) { if (i > mid) { nums[k] = temp[j++]; } else if (j > hi) { nums[k] = temp[i++]; } else if (less(temp[j], temp[i])) { nums[k] = temp[j++]; } else { nums[k] = temp[i++]; } } } 自顶向下归并排序将大数组对半分求解，即不断的对半分将数组分成两两一组然后通过merge方法排序合并。 @Override public void sort(T[] nums) { temp = (T[]) new Comparable[nums.length]; sort(nums, 0, nums.length - 1); } /** * 递归排序各部分数组 * @param nums 数组 * @param lo 开始下标 * @param hi 结束下标 */ private void sort(T[] nums, int lo, int hi) { if (hi &lt;= lo) { return; } int mid = lo + (hi - lo) / 2; sort(nums, lo, mid); sort(nums, mid + 1, hi); merge(nums, lo, mid, hi); } 自底向上归并排序将微型数组进行归并，然后成对归并得到的微型数组。 @Override public void sort(T[] nums) { int length = nums.length; temp = (T[]) new Comparable[length]; for (int size = 1; size &lt; length; size += size) { for (int lo = 0; lo &lt; length - size; lo += 2 * size) { merge(nums, lo, lo + size - 1, Math.min(lo + 2 * size - 1, length - 1)); } } } 快速排序快速排序(Quick Sort)和归并排序有点儿类似，只不过归并排序是对半分求解而快速排序是通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，完成这两个子数组排序就完成了整个数组的排序。 时间复杂度：快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的，其时间复杂度为 O(nlogn)。最坏的情况下切分元素选择的是最小元素，此时时间复杂度为 O(n²)。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。 快速排序算法@Override public void sort(T[] nums) { shuffle(nums); sort(nums, 0, nums.length - 1); } /** * 递归排序各部分数组 * * @param nums 数组 * @param lo 开始下标 * @param hi 结束下标 */ private void sort(T[] nums, int lo, int hi) { if (hi &lt;= lo) { return; } int partition = partition(nums, lo, hi); sort(nums, lo, partition - 1); sort(nums, partition + 1, hi); } /** * 打乱重组数组，消除对输入的依赖 * @param nums 数组洗牌 */ private void shuffle(T[] nums) { List&lt;Comparable&lt;T>> list = Arrays.asList(nums); Collections.shuffle(list); list.toArray(nums); } 切分元素选择 直接取第一位作为切分元素。 /** * 取数组第一个元素作为切分元素 * @param nums 数组 * @param lo 开始下标 * @param hi 结束下表 * @return 切分元素下标 */ private int partition(T[] nums, int lo, int hi) { int i = lo, j = hi + 1; T partition = nums[lo]; while (true) { while (less(nums[++i], partition) &amp;&amp; i != hi) { } while (less(partition, nums[--j]) &amp;&amp; j != lo) { } if (i >= j) { break; } swap(nums, i, j); } swap(nums, lo, j); return j; } 三数取中 切分元素最好的情况就是取数组的中位数，但是计算中位数的代价很高。因此通常随机取3个元素，然后将大小其中的元素作为切分元素。 三向切分 对于有大量重复元素的数组，可以将数组切分为三部分，分别对应于小于、等于和大于切分元素。三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。 /** * 三向切分递归排序各部分数组 * @param nums 数组 * @param lo 开始下标 * @param hi 结束下标 */ private void sort(T[] nums, int lo, int hi) { if (hi &lt;= lo) { return; } int lt = lo, i = lo + 1, gt = hi; T partition = nums[lo]; while (i &lt;= gt) { int cmp = nums[i].compareTo(partition); if (cmp &lt; 0) { swap(nums, lt++, i++); } else if (cmp > 0) { swap(nums, i, gt--); } else { i++; } } sort(nums, lo, lt - 1); sort(nums, gt + 1, hi); } 堆排序堆在堆的完全二叉树中，每个结点的值都小于等于它的父结点的值。因为堆是完全二叉树，所以可以通过数组来表示。位置k的结点的父节点位置为 k/2，其两个子结点位置分别为 2k 和 2k+1。数组索引从1开始，方便描述结点位置关系。 /** * @Author 喵粮都输光了 * @Date 2020/3/25 12:05 * @Description 堆 */ public class Heap&lt;T extends Comparable&lt;T>> { /** * 堆主体 */ private T[] heap; /** * 当前元素个数 */ private int num; public Heap(int maxNum) { heap = (T[]) new Comparable[maxNum + 1]; num = 0; } /** * 是否为空 * @return true or false */ public boolean isEmpty() { return num == 0; } /** * 当前栈所包含的元素个数 * @return 元素个数 */ public int length() { return num; } /** * 传入的第一个元素是否比第二个元素小 * @param i 第一个元素下标 * @param j 第二个元素下标 * @return true or false */ private boolean less(int i, int j) { return heap[i].compareTo(heap[j]) &lt; 0; } /** * 交换数组中两个元素 * @param i 下标i * @param j 下标j */ private void swap(int i, int j) { T temp = heap[i]; heap[i] = heap[j]; heap[j] = temp; } /** * 一个元素插入可能会破坏堆的有序状态，上浮操作将大的元素上浮 * @param k 插入的结点 */ private void swim(int k) { while (k > 1 &amp;&amp; less(k / 2, k)) { swap(k / 2, k); k = k / 2; } } /** * 一个元素插入可能会破坏堆的有序状态，下沉操作将小的元素下沉 * @param k 插入的结点 */ private void sink(int k) { while (2 * k &lt;= num) { int j = 2 * k; if (j &lt; num &amp;&amp; less(j, j + 1)) { j++; } if (!less(k, j)) { break; } swap(k, j); k = j; } } /** * 插入元素 * @param elem 需要插入的元素 */ public void insert(T elem) { heap[++num] = elem; swim(num); } /** * 删除最大元素 * @return 返回删除的元素 */ public T delMax() { T max = heap[1]; swap(1, num--); heap[num + 1] = null; sink(1); return max; } public static void main(String[] args) { Heap&lt;Integer> sort = new Heap&lt;>(5); sort.insert(3); sort.insert(2); sort.insert(4); sort.insert(1); sort.insert(5); for (int i = 0; i &lt; 5; i++) { System.out.println(sort.delMax()); } } } 排序无序数组建立堆最简单的方法就是从左至右遍历数组进行上浮操作。稍微复杂一点但是更高效的方法是从右至左遍历进行下沉操作，叶子节点不需要进行下沉操作，所以只需要遍历一般元素即可，比上浮建立的方法快一倍呢。 /** * @Author 喵粮都输光了 * @Date 2020/3/25 13:25 * @Description 堆排序 */ public class HeapSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int num = nums.length - 1; // 构造堆有序 for (int k = num / 2; k >= 1; k--) { sink(nums, k, num); } // 最大元素与最后一个元素交换之后进行下沉操作重新变成堆有序 while (num > 1) { swap(nums, 1, num--); sink(nums, 1, num); } } /** * 一个元素插入可能会破坏堆的有序状态，下沉操作将小的元素下沉 * @param k 插入的结点 */ private void sink(T[] nums, int k, int num) { while (k * 2 &lt;= num) { int j = k * 2; if (j + 1 &lt;= num &amp;&amp; less(nums[j], nums[j + 1])) { j++; } if (!less(nums[k], nums[j])) { break; } swap(nums, k, j); k = j; } } public static void main(String[] args) { HeapSort&lt;Integer> sort = new HeapSort&lt;>(); Integer[] nums = {0, 2, 6, 3, 4, 9}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 排序算法对比 算法 稳定性 时间复杂度 空间复杂度 备注 选择排序 × O(n²) O(1) 冒泡排序 √ O(n²) O(1) 插入排序 √ O(n)~O(n²) O(1) 时间复杂度与输入元素排列情况有关。 希尔排序 × O(n的一点几次方) O(1) 插入排序改良版，依次减少大于一个逆序组。 归并排序 √ O(nlogn) O(n) 需要额外数组复制原数组元素。 快速排序 × O(nlogn)~O(n²) O(lgn)~O(n) 空间复杂度与递归深度有关。 三向快速排序 × O(n)~O(nlogn) O(lgn) 专门用于处理数组中含大量重复元素的情况。 堆排序 × O(nlogn) O(1) 通常使用快速排序，其时间复杂度 O(cnlogn) 的常数 c 通常比其他排序小；当出现大量重复元素时使用三向快速排序，因为它的时间复杂度可能达到O(n)。 JAVA 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向快速排序，对于引用类型使用归并排序。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://blog.kuukokawaii.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构之图","date":"2020-03-22T04:49:06.000Z","path":"posts/f932ba85/","text":"图$($Graph$)$由顶点$($V, vertex$)$和表示顶点之间关系的边$($E, edge, 弧$)$所组成。$V(G)$和$E(G)$分别表示图G的顶点集和边集，$E(G)$可为空集。 基本术语设n为图中顶点数目，e为表示边的数目。 子图 一个图的顶点集和边集完全包含另一张图的顶点集和边集。 无向完全图和有向完全图 完全图即顶点集中每两个顶点之间都至少有一条边，若有一条边则称为无向完全图，有两条互相指向对方的边则称为有向完全图。有n个顶点的无向完全图，具有$\\frac{n(n-1)}{2}$条边，有向完全图的边数是其两倍，为$n(n-1)$。 稀疏图和稠密图 边数很少$(e\\lt nlog_2n)$的图称为稀疏图，反之称为稠密图。 邻接点 无向图中，若两顶点之间有边则称这两个点相邻接。 度、入度和出度 无向图一个顶点有几条边，其度就是几，记作TD$($v$)$。有向图分为入度和出度，入度即其他顶点指向该顶点的边数，记作ID$($v$)$；出度即该顶点指向其他顶点的边数，记作OD$($v$)$；有向图的度等于入度加出度。 路径和路径长度 路径即一个顶点到另一个顶点经过的顶点的集合。路径长度是一条路径上经过的边的数目。有向图其路径也是有向的。 回路或环 第一个顶点和最后一个顶点相同的路径。 简单路径、简单回路或简单环 简单路径即序列中顶点不重复出现的路径。除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路或简单环。 连通、连通图和连通分量 若顶点v到顶点v’有路径，则称v和v’是连通的。若一张图任意两个顶点之间都是连通的，则该图是连通图。连通分量即无向图中的极大连通子图。 强连通图和强连通分量 在一张有向图中，对于任意两个顶点v和v’，存在v到v’和v’到v都存在路径，则该有向图是强连通图。有向图中的极大强连通子图就是有向图的强连通分量$($有向图不一定要是强连通图$)$。 连通图的生成树 一个包含了图中全部顶点的极小连通子图，且仅拥有足以构成一棵树的n-1条边，该连通子图就称为连通图的生成树。 有向树和生成森林 有向树即有一个顶点入度为0，其余顶点入度为1的有向图。一个有向图的生成树即由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的边。 图的存储结构邻接矩阵 邻接矩阵$($Adjacency Matrix$)$是表示顶点之间相邻关系的矩阵。可以看作是一个矩阵，其行依次代表顶点$v_1, \\dots, v_n$，其列也分别代表顶点$v_1, \\dots, v_n$。因此可以用一个二维数组来存储边相关信息，一个一维数组存储顶点信息。 优点 缺点 邻接矩阵 1.便于计算两个顶点之间是否有边；2.便于计算各个顶点之间的度，例如行和就是该顶点的入度，列和就是该顶点的出度。 1.不利于增删顶点；不便统计边的条数，每次统计需要扫描整个表，时间复杂度为$O(n^2)$；2.空间复杂度为$O(n^2)$；适合表示稠密图。 具体代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/23 10:27 * @Description 有向图邻接矩阵 */ public class AdjacencyMatrix { /** * 邻接矩阵主体 */ private int[][] arcs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 顶点表 */ private List&lt;Object> vexs; /** * 初始化一个空邻接矩阵 * @param vexMaxNum 图总顶点数 */ public AdjacencyMatrix(int vexMaxNum) { this.vexMaxNum = vexMaxNum; arcNum = 0; arcs = new int[vexMaxNum][vexMaxNum]; vexs = new ArrayList&lt;>(vexMaxNum); } /** * 返回顶点在图中所在位置(下标) * @param vex 顶点 * @return 下标，-1为空 */ public int locateVex(Object vex) { if (vexs.contains(vex)) { return vexs.indexOf(vex); } else { return -1; } } /** * 根据下标获取顶点 * * @param index 顶点下标 * @return 顶点 */ public Object getVex(int index) { if (index >= vexs.size()) { throw new ArrayIndexOutOfBoundsException(\"没有该顶点\"); } return vexs.get(index); } /** * 将顶点加入顶点表 * @param vex 顶点 */ public void insertVex(Object vex) { // 满了直接返回 if (vexMaxNum == vexs.size()) { throw new ArrayIndexOutOfBoundsException(\"顶点表满了\"); } vexs.add(vex); } /** * 根据顶点下标删除顶点 * @param index 顶点下标 */ public void deleteVex(int index) { if (vexs.size() == 0) { throw new ArrayIndexOutOfBoundsException(\"顶点为空\"); } vexs.remove(index); // 删除边表中该顶点所在行列 int[][] finalArcs = new int[arcs.length][arcs.length]; for (int i = 0, fi = i; i &lt; arcs.length; i++) { if (i != index) { for (int j = 0, fj = j; j &lt; arcs.length; j++) { if (j != index) { finalArcs[fi][fj] = arcs[i][j]; fj++; } } fi++; } } arcs = finalArcs; } /** * 插入顶点1和顶点2的边 * @param v1Index 顶点1 * @param v2Index 顶点2 */ public void insertArc(int v1Index, int v2Index) { // 无向图边最多为顶点数*(顶点数-1)/2，有向图边数是无向图边数*2 if (arcNum == vexs.size() * (vexs.size() - 1)) { throw new ArrayIndexOutOfBoundsException(\"已达顶点所能拥有的最大边数\"); } arcs[v1Index][v2Index]++; arcNum++; } /** * 删除顶点1和顶点2的边 * @param v1Index 顶点1 * @param v2Index 顶点2 */ public void deleteArc(int v1Index, int v2Index) { if (arcNum == 0) { throw new ArrayIndexOutOfBoundsException(\"图中连一条边都没有\"); } if (arcs[v1Index][v2Index] != 0) { arcs[v1Index][v2Index]--; } arcNum--; } /** * 根据顶点下标返回该顶点的第一个邻接顶点下标 * @param index 顶点下标 * @return 邻接顶点下标，-1为空。 */ public int firstAdjVex(int index) { // 列和表示出度 for (int i = 0; i &lt; vexs.size(); i++) { if (arcs[i][index] != 0) { return i; } } return -1; } /** * 返回顶点v1相对于其邻接顶点v2 * @param v1Index 顶点v1 * @param v2Index 顶点v1的一个邻接顶点v2 * @return 下一个邻接顶点下标 */ public int nextAdjVex(int v1Index, int v2Index) { // 列和表示出度 for (int i = v2Index + 1; i &lt; vexs.size(); i++) { if (arcs[i][v1Index] != 0) { return i; } } return -1; } } 邻接表 邻接表$($Adjacency List$)$由表头结点表和边表组成： 表头结点表使用一维数组存储表头结点，而表头结点包含data$($数据域$)$和firstarc$($指向邻接结点$)$。 边表结点包含adjvex$($邻接点域，与表头结点中顶点邻接的顶点的位置$)$、info$($边相关信息，如权值$)$和nextarc$($与表头结点中顶点邻接的下一个邻接结点$)$。 优点 缺点 邻接表 1. 便于增删顶点；2.便于统计边的数目，按定点表顺序扫描所有边表即可获得数目，其时间复杂度为$O(n+e)$；3.空间效率高，有向图的边表结点为e个，无向图边表结点为2e个，其空间复杂度为$O(n+e)$，适合表示稀疏图。 1.不便于判断顶点之间是否有边。2.不便于计算有向图各个顶点的度。在有向图中遍历某个表头结点的边表是该顶点的出度，如果要获得入度则需要遍历全表，可以为邻接表建立逆邻接表获得入度。（逆邻接表就是边表存储该顶点的入度，但是获取出度困难。） 具体代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:31 * @Description 边 */ public class Edge { /** * 弧尾 */ VexNode start; /** * 弧头 */ VexNode end; public Edge(VexNode start, VexNode end) { this.start = start; this.end = end; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:33 * @Description 表头结点 */ public class VexNode { /** * 顶点包含数据 */ Object data; /** * 与该顶点邻接的第一个边 */ ArcNode firstArc; public VexNode(Object data, ArcNode firstArc) { this.data = data; this.firstArc = firstArc; } public VexNode(Object data) { this.data = data; firstArc = null; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:33 * @Description 边表结点 */ public class ArcNode { /** * 边相关信息，如权值 */ int info; /** * 邻接点域，与表头结点中顶点邻接的顶点的位置 */ VexNode adjVex; /** * 与表头结点中顶点邻接的下一个边结点 */ ArcNode nextArc; public ArcNode(int info, VexNode adjVex, ArcNode nextArc) { this.info = info; this.adjVex = adjVex; this.nextArc = nextArc; } public ArcNode(VexNode adjVex, ArcNode nextArc) { info = 1; this.adjVex = adjVex; this.nextArc = nextArc; } public ArcNode(VexNode adjVex) { info = 1; this.adjVex = adjVex; this.nextArc = null; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 12:02 * @Description 邻接表 */ public class AdjacencyList { /** * 顶点结点表 */ private List&lt;VexNode> vexs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 根据顶点集和边集初始化邻接表 * @param vexs 顶点集 * @param edges 边集 */ public AdjacencyList(List&lt;VexNode> vexs, List&lt;Edge> edges) { if (vexs == null || vexs.size() == 0) { return; } vexMaxNum = vexs.size(); // 将顶点集的顶点存入顶点结点表 this.vexs = vexs; // 将边信息存入边结点，并与其邻接点相连 if (edges != null) { for (Edge edge : edges) { VexNode startNode = edge.start; ArcNode arcNode = new ArcNode(edge.end); arcNode.nextArc = startNode.firstArc; startNode.firstArc = arcNode; arcNum++; } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:46 * @Description 测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(1); VexNode v2 = new VexNode(2); VexNode v3 = new VexNode(3); VexNode v4 = new VexNode(4); List&lt;VexNode> vexs = new ArrayList&lt;>(4); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); List&lt;Edge> edges = new ArrayList&lt;>(4); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v3)); edges.add(new Edge(v4, v2)); edges.add(new Edge(v4, v3)); new AdjacencyList(vexs, edges); } } 十字链表 十字链表$($Orthogonal List$)$相当于有向图的邻接表和逆邻接表结合所得到的一种链表。它由顶点结点和边结点组成： 顶点结点包含data$($数据域$)$、firstin$($指向以该顶点为弧头的顶点，即该顶点的入度表$)$和firstout$($指向以该顶点为弧尾的顶点，即该顶点的出度表$)$。 边结点包含tailvex$($尾域，弧尾指向的结点$)$、headvex$($头域，弧头指向的结点$)$、hlink$($头链域，以头域所指顶点为弧头的下一个结点，即头域所指结点的入度表$)$、tlink$($尾链域，以尾域所指顶点为弧尾的下一个结点，即尾域所指结点的出度表$)$和info$($边相关信息，如权值$)$。 优点：时间复杂度和邻接表一样都是$O(n+e)$，且容易求得顶点的出度和入度。 具体代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:31 * @Description 边 */ public class Edge { /** * 弧尾 */ VexNode start; /** * 弧头 */ VexNode end; public Edge(VexNode start, VexNode end) { this.start = start; this.end = end; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:59 * @Description 表头结点 */ public class VexNode { /** * 顶点包含数据 */ Object data; /** * 指向以该顶点为弧头的边，即该顶点的入度表 */ ArcNode firstIn; /** * 指向以该顶点为弧尾的边，即该顶点的出度表 */ ArcNode firstOut; public VexNode(Object data, ArcNode firstIn, ArcNode firstOut) { this.data = data; this.firstIn = firstIn; this.firstOut = firstOut; } public VexNode(Object data) { this.data = data; this.firstIn = null; this.firstOut = null; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 14:00 * @Description 边表结点 */ public class ArcNode { /** * 边相关信息，如权值 */ int info; /** * 尾域，弧尾指向的结点 */ VexNode tailVex; /** * 头域，弧头指向的结点 */ VexNode headVex; /** * 头链域，以头域所指顶点为弧头的下一个结点，即头域所指结点的入度表 */ ArcNode headLink; /** * 尾链域，以尾域所指顶点为弧尾的下一个结点，即尾域所指结点的出度表 */ ArcNode tailLink; public ArcNode(int info, VexNode tailVex, VexNode headVex, ArcNode headLink, ArcNode tailLink) { this.info = info; this.tailVex = tailVex; this.headVex = headVex; this.headLink = headLink; this.tailLink = tailLink; } public ArcNode(VexNode tailVex, VexNode headVex, ArcNode headLink, ArcNode tailLink) { this.info = 1; this.tailVex = tailVex; this.headVex = headVex; this.headLink = headLink; this.tailLink = tailLink; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 14:05 * @Description 十字链表 */ public class OrthogonalList { /** * 顶点结点表 */ private List&lt;VexNode> vexs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 根据顶点集和边集初始化十字链表 * @param vexs 顶点集 * @param edges 边集 */ public OrthogonalList(List&lt;VexNode> vexs, List&lt;Edge> edges) { if (vexs == null || vexs.size() == 0) { return; } vexMaxNum = vexs.size(); // 将顶点集的顶点存入顶点结点表 this.vexs = vexs; // 将边信息存入边结点，并与其邻接点相连 if (edges != null) { for (Edge edge : edges) { // edge.start是弧尾 VexNode startNode = edge.start; // edge.end是弧头 VexNode endNode = edge.end; // 参数分别为尾域、头域、头链域、尾链域， ArcNode arcNode = new ArcNode(startNode, endNode, endNode.firstIn, startNode.firstOut); // 指向下一个出度结点 startNode.firstOut = arcNode; // 指向下一个入度结点 endNode.firstIn = arcNode; arcNum++; } } } /** * 输出 */ public void print() { System.out.println(\"出\"); for (VexNode vexNode : vexs) { System.out.print(vexNode.data + \" -> \"); ArcNode arcNode = vexNode.firstOut; while (arcNode != null) { System.out.print(arcNode.headVex.data + \" -> \"); arcNode = arcNode.tailLink; } System.out.println(\"\\n\"); } System.out.println(\"入\"); for (VexNode vexNode : vexs) { System.out.print(vexNode.data + \" &lt;- \"); ArcNode arcNode = vexNode.firstIn; while (arcNode != null) { System.out.print(arcNode.tailVex.data + \" &lt;- \"); arcNode = arcNode.headLink; } System.out.println(\"\\n\"); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/19 10:37 * @Description 算法测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(\"v1\"); VexNode v2 = new VexNode(\"v2\"); VexNode v3 = new VexNode(\"v3\"); VexNode v4 = new VexNode(\"v4\"); List&lt;VexNode> vexs = new ArrayList&lt;>(4); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); List&lt;Edge> edges = new ArrayList&lt;>(4); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v3)); edges.add(new Edge(v4, v2)); edges.add(new Edge(v4, v3)); OrthogonalList s = new OrthogonalList(vexs, edges); s.print(); } } 邻接多重表 邻接多重表$($Adjacency Multilist$)$是无向图的另一种链式存储结构。在邻接表中同一条边所对应的两个顶点分别在两个不相同的边表中，当有需求寻找一条边的两个顶点时，采用邻接多重表操作图比较方便。邻接多重表和十字链表一样由顶点结点和边结点组成： 顶点结点包含firstedge$($指向第一条依附该顶点的边$)$和data$($数据域$)$。 边结点包含mark$($标记域，标记该边是否被搜索过$)$、ivex$($该边依附的顶点i$)$、ilink$($指向依附于顶点i的另一条边$)$、jvex$($该边依附的顶点j$)$、jlink$($指向依附于顶点j的另一条边$)$和info$($边相关信息，如权值$)$。 优点：邻接多重表除了每个边结点比邻接表多边结点一个标记域，其所需存储量和邻接表相同。 具体代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:31 * @Description 边 */ public class Edge { /** * 弧尾 */ VexNode start; /** * 弧头 */ VexNode end; public Edge(VexNode start, VexNode end) { this.start = start; this.end = end; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 17:24 * @Description 表头结点 */ public class VexNode { /** * 顶点包含数据 */ Object data; /** * 指向第一条依附该顶点的边 */ ArcNode firstEdge; public VexNode(Object data, ArcNode firstEdge) { this.data = data; this.firstEdge = firstEdge; } public VexNode(Object data) { this.data = data; this.firstEdge = null; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 17:24 * @Description 边表结点 */ public class ArcNode { /** * 边相关信息，如权值 */ int info; /** * 标记域，是否被搜索过 */ boolean isSearched; /** * 该边依附的顶点i */ VexNode iVex; /** * 指向依附于顶点i的另一条边 */ ArcNode iLink; /** * 该边依附的顶点j */ VexNode jVex; /** * 指向依附于顶点j的另一条边 */ ArcNode jLink; public ArcNode(int info, VexNode iVex, ArcNode iLink, VexNode jVex, ArcNode jLink) { this.info = info; this.iVex = iVex; this.iLink = iLink; this.jVex = jVex; this.jLink = jLink; this.isSearched = false; } public ArcNode(VexNode iVex, ArcNode iLink, VexNode jVex, ArcNode jLink) { this.info = 1; this.iVex = iVex; this.iLink = iLink; this.jVex = jVex; this.jLink = jLink; this.isSearched = false; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 17:26 * @Description 邻接多重表 */ public class AdjacencyMultiList { /** * 顶点结点表 */ private List&lt;VexNode> vexs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 根据顶点集和边集初始化邻接多重表 * @param vexs 顶点集 * @param edges 边集 */ public AdjacencyMultiList(List&lt;VexNode> vexs, List&lt;Edge> edges) { if (vexs == null || vexs.size() == 0) { return; } vexMaxNum = vexs.size(); // 将顶点集的顶点存入顶点结点表 this.vexs = vexs; // 将边信息存入边结点，并与其邻接点相连 if (edges != null) { for (Edge edge : edges) { // edge.start是弧尾 VexNode startNode = edge.start; // edge.end是弧头 VexNode endNode = edge.end; // 创建这两个结点的边结点，两个顶点共用一条边 ArcNode arcNode = new ArcNode(startNode, startNode.firstEdge, endNode, endNode.firstEdge); // 弧头的另一个边 startNode.firstEdge = arcNode; // 弧尾的另一个边 endNode.firstEdge = arcNode; arcNum++; } } } /** * 输出 */ public void print() { for (VexNode vex : vexs) { System.out.print(vex.data + \" -> \"); ArcNode arcNode = vex.firstEdge; while (arcNode != null) { System.out.print(\" | \" + arcNode.iVex.data + \"-\" + arcNode.jVex.data + \" | -> \"); // 需要输出某个顶点的所有边，需要判断当前边的iVex还是jVex等于需要输出的结点来决定下一个访问iLink还是JLink。 if (vex == arcNode.iVex) { arcNode = arcNode.iLink; } else { arcNode = arcNode.jLink; } } System.out.println(\"\\n\"); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/19 10:37 * @Description 算法测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(\"v1\"); VexNode v2 = new VexNode(\"v2\"); VexNode v3 = new VexNode(\"v3\"); VexNode v4 = new VexNode(\"v4\"); VexNode v5 = new VexNode(\"v5\"); List&lt;VexNode> vexs = new ArrayList&lt;>(5); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); vexs.add(v5); List&lt;Edge> edges = new ArrayList&lt;>(5); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v4)); edges.add(new Edge(v2, v3)); edges.add(new Edge(v2, v5)); edges.add(new Edge(v3, v5)); edges.add(new Edge(v3, v4)); AdjacencyMultiList adjacencyMultiList = new AdjacencyMultiList(vexs, edges); adjacencyMultiList.print(); } } 图的遍历深度优先搜索 深度优先搜索$($Depth First Search, DFS$)$遍历思路$($类似树的先序遍历$)$：从图中某个顶点开始遍历，将遍历过的顶点标上已遍历的标记，随意选择一个邻接顶点遍历它并选择这个顶点的邻接顶点遍历，不断重复，当遍历到某个顶点发现这个顶点没有未标记的邻接顶点时就往回退返回上一个邻接顶点，从上一个邻接顶点选择其他未标记的邻接顶点遍历，以此类推直到图中所有邻接顶点都标记过了遍历就完成了。通过深度优先搜索遍历路径构成的树称为深度优先生成树。 时间复杂度：当使用邻接矩阵存储时，每个顶点都要遍历n次寻找邻接顶点，其时间复杂度为$O(n^2)$；当用邻接表存储时，每个顶点只需要查找其相连的边即可，即查找邻接顶点时间复杂度为$O(e)$，所以整体遍历时间复杂度为$O(n+e)$。 算法实现：通常使用递归实现，此处实现遍历非连通的邻接表结构的图。 /** * @Author 喵粮都输光了 * @Date 2020/3/23 12:02 * @Description 邻接表 */ public class AdjacencyList { /** * 顶点结点表 */ private List&lt;VexNode> vexs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 存储顶点是否被遍历过的信息 */ private boolean[] state; /** * 根据顶点集和边集初始化邻接表 * @param vexs 顶点集 * @param edges 边集 */ public AdjacencyList(List&lt;VexNode> vexs, List&lt;Edge> edges) { if (vexs == null || vexs.size() == 0) { return; } vexMaxNum = vexs.size(); // 将顶点集的顶点存入顶点结点表 this.vexs = vexs; // 将边信息存入边结点，并与其邻接点相连 if (edges != null) { for (Edge edge : edges) { VexNode startNode = edge.start; ArcNode arcNode = new ArcNode(edge.end); arcNode.nextArc = startNode.firstArc; startNode.firstArc = arcNode; arcNum++; } } } /** * 查找顶点所在位置 * @param vexNode 需要查找的顶点 * @return 顶点下标 */ public int getVexIndex(VexNode vexNode) { return vexs.indexOf(vexNode); } /** * 顶点是否被遍历 * @param vexNode 顶点 * @return true or false */ private boolean isVisited(VexNode vexNode) { return state[getVexIndex(vexNode)]; } /** * 深度优先遍历 */ public void dfsTraverse() { state = new boolean[vexMaxNum]; // 若图非连通，遍历所有子连通图 for (VexNode vexNode : vexs) { if (!isVisited(vexNode)) { dfs(vexNode); } } } /** * 深度优先遍历子图 * @param vexNode 需要遍历的结点 */ private void dfs(VexNode vexNode) { // 将遍历顶点设置称true state[getVexIndex(vexNode)] = true; System.out.println(vexNode.data); // 寻找下一条边的另一个顶点，判断是否遍历过，若未遍历过则递归遍历，遍历过就寻找下一个邻接点 for (ArcNode arcNode = vexNode.firstArc; arcNode != null; arcNode = arcNode.nextArc) { vexNode = arcNode.adjVex; if (!isVisited(vexNode)) { dfs(vexNode); } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/24 10:18 * @Description 测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(\"v1\"); VexNode v2 = new VexNode(\"v2\"); VexNode v3 = new VexNode(\"v3\"); VexNode v4 = new VexNode(\"v4\"); VexNode v5 = new VexNode(\"v5\"); List&lt;VexNode> vexs = new ArrayList&lt;>(4); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); vexs.add(v5); List&lt;Edge> edges = new ArrayList&lt;>(4); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v3)); edges.add(new Edge(v4, v2)); edges.add(new Edge(v4, v3)); AdjacencyList adjacencyList = new AdjacencyList(vexs, edges); System.out.println(\"深度\"); adjacencyList.dfsTraverse(); } } 广度优先搜索 广度优先搜索$($Breadth Firsh Search, BFS$)$遍历思路$($类似树的层序遍历$)$：从图中某个顶点开始遍历，将遍历过的顶点标上已遍历的标记，遍历所有该顶点的邻接顶点，然后分别从刚访问过的邻接顶点出发依次访问它们的邻接顶点，直到图中所有邻接顶点都标记过了遍历就完成了。通过广度优先搜索遍历路径构成的树称为广度优先生成树。 时间复杂度：时间复杂度和深度优先搜索相同，使用邻接矩阵时时间复杂度为$O(n^2)$，使用连接表时时间复杂度为$O(n+e)$。因此两者的区别仅仅是遍历顺序不同而已。 算法实现：通常使用队列实现，此处实现遍历非连通的邻接表结构的图。 /** * 广度优先遍历 */ public void bfsTraverse() { state = new boolean[vexMaxNum]; // 若图非连通，遍历所有子连通图 for (VexNode vexNode : vexs) { if (!isVisited(vexNode)) { bfs(vexNode); } } } /** * 广度优先遍历子图 * @param rootNode 需要遍历的结点 */ private void bfs(VexNode rootNode) { Queue&lt;VexNode> queue = new LinkedList&lt;>(); queue.offer(rootNode); while (!queue.isEmpty()) { rootNode = queue.poll(); state[getVexIndex(rootNode)] = true; System.out.println(rootNode.data); for (ArcNode arcNode = rootNode.firstArc; arcNode != null; arcNode = arcNode.nextArc) { rootNode = arcNode.adjVex; if (!isVisited(rootNode)) { queue.offer(rootNode); } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/24 10:18 * @Description 测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(\"v1\"); VexNode v2 = new VexNode(\"v2\"); VexNode v3 = new VexNode(\"v3\"); VexNode v4 = new VexNode(\"v4\"); VexNode v5 = new VexNode(\"v5\"); List&lt;VexNode> vexs = new ArrayList&lt;>(4); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); vexs.add(v5); List&lt;Edge> edges = new ArrayList&lt;>(4); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v3)); edges.add(new Edge(v4, v2)); edges.add(new Edge(v4, v3)); AdjacencyList adjacencyList = new AdjacencyList(vexs, edges); System.out.println(\"广度\"); adjacencyList.dfsTraverse(); } } 常用图算法 最小生成树：又称为最小代价生成树$($Minimum Cost Spanning Tree$)$，是在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树。其常用算法有 Prim 算法和 Kruskal 算法。 最短路径：从一个顶点到另一个顶点之间各边代价之和最小的那条路径。在带权有向网中，第一个顶点称为源点$($Source$)$，最后一个顶点称为终点$($Destination$)$。其常用算法有 Dijkstra 算法和 Floyd 算法。 拓扑排序： 有向无环图$($Directed Acycline Graph, DAG$)$：一个无环的有向图。 AOV网$($Activity On Vertex Network$)$：用顶点表示活动，用弧表示活动之间的优先关系的有向无环图称为顶点表示活动的网。例如游戏中做某个任务，但是这个任务有多个前置任务，需要先做了前置任务才能进行该任务。 拓扑排序：将AOV网中所有顶点排成一个线性序列，该序列满足：若AOV网中由顶点$V_i$到顶点$V_j$有一条路径，则在该线性序列中的顶点$V_i$必定在顶点$V_j$之前。排序方法为：删除图中一个无前驱的顶点$($包括和该顶点有关的边$)$并输出顶点，重复直至图中无顶点为止。 关键路径： AOE网$($Activity On Edge Network$)$：用顶点表示事件，用弧表示活动，权表示活动持续的事件的带权有向无环图称为以边表示活动的网。 源点和汇点：网中有一个入度为零的点称为源点，也仅有一个出度为零的点称为汇点。 带权路径长度：一条路径各弧上的权值之和。 关键路径$($Critical Path$)$：从源点到汇点的带权路径长度最长的路径。 关键活动：在关键路径上的活动都称为关键活动。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之树","date":"2020-03-21T00:48:15.000Z","path":"posts/6c17d6bd/","text":"树树的定义树是n个结点的有限集，它可以是空树或非空树。对于非空树T： 最多一个根结点。 根结点的每一个孩子都是一颗子树。 基本术语 结点的度 结点拥有的子树个数。 树的度 树中各结点度的最大值。 祖先 从根到该结点所经分支上的所有结点。 子孙 以某节点为根的子树中的任一结点都是该结点的子孙。 层次 结点的高度（从一开始）。 堂兄弟 双亲在同一层的结点互为堂兄弟。 树的深度 树的高度（从一开始）。 有序树和无序树 无序树即忽略节点的信息，只考虑其拓扑结构的树，也就是说兄弟之间没有顺序关系，而有序树与之相法。 森林 树的集合（树的个数可为零）。 树的存储结构 双亲表示法：用一组连续的存储单元存储树的结点，每个结点都拥有数据域和双亲域（指向该结点的双亲）。很容易求得树的根和结点的双亲，但是求结点的孩子时需要遍历整个结构。 孩子表示法： 第一种方法：每个结点由数据域和多个指针域构成，每个指针域指向一颗子树的根结点，指针域的个数就是该树的度，但是树中不是每个结点的度都等于树的度，因此会造成很多指针域的浪费。一颗n个结点度为k的树必有$n(k-1)+1$个空链域。 第二种方法：每个结点由数据域、degree域（存储该结点的度）和多个指针域构成，这样不会造成空间的浪费，但是操作起来不是太方便。 第三种方法：用一组连续的存储单元存储树的结点，每个结点都有数据域和存储该结点孩子的单链表表头，这样很容易获得结点的所有孩子。可以对该结构进行扩展，每个结点都增加一个双亲域，很容易就能获得该结点的孩子和双亲。 孩子兄弟表示法：使用二叉链表做树的存储结构，结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，也就是说结点由数据域、指向第一个孩子结点的指针域和指向下一个兄弟结点的指针域构成。该结构非常容易寻找孩子结点，如果添加双亲域的话寻找双亲也非常便捷。 二叉树二叉树的定义二叉树与树类似，区别主要有如下两点： 二叉树每个结点最多只有两个子树，即结点的度小于等于二。 二叉树的子树有左右之分，其次序不能颠倒。 二叉树的性质 二叉树第i层上最多有$2^{i-1}$个结点。 推导：第一层有1个，第二层有2个，第三层有4个，到第n层有$a_n=a_1*q^(n-1)$（等比数列）。 深度为k的二叉树最多有$2^k-1$个结点。 推导：根据等比数列求和公式$S_n=a_1\\frac{1-q^n}{1-q}$，其中$q=2, a_1=1$，计算得$S_n=2^n-1$。 二叉树叶子结点个数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。 推导：设$n_1$是度为1的结点个数，n为总结点个数，则可得$n=n_0+n_1+n_2$。由于树的总分支条数加一等于树的总结点个数，以及度为1的结点有1条分支，度为2的结点有两条分支，可以得知$n=n_1+2n_2+1$，两式相减可得度1和度2结点个数之间的关系公式。 满二叉树即深度为k且含有$2^k-1$个结点的二叉树。 完全二叉树即深度为k的二叉树，其1至k-1层是满二叉树，而在第k层上，所有叶子结点都连续集中在左侧（也就是说不可以存在只有右结点没有左节点的结点）。 具有n个结点的完全二叉树的深度为$\\lfloor log_2n \\rfloor+1$或$\\lceil log_2(n+1) \\rceil$。 推导：设深度为k的完全二叉树结点有n个，则n肯定大于等于k行结点的个数以及小于等于满二叉树总结点个数，也就是说$2^{k-1}≤n$和$n≤2^k-1$。对左式的两边加$log_2$计算得$k-1≤log_2n$，由于k是整数，$log_2n$可能是小数，因为是小于等于所以$log_2n$取下限得$\\lfloor log_2n \\rfloor+1$；对右式进行同样的方法计算得$log_2(n+1)≤k$，k是整数，k大于等于可能是小数的$log_2n$，所以对其取上限得$\\lceil log_2(n+1) \\rceil$。 按层序给一颗有n个结点的完全二叉树的结点编号，则对任一结点i有： 若$i=1$，则i是二叉树的根节点；若$i&gt;1$，则其双亲结点为$\\lfloor \\frac{i}{2} \\rfloor$。 若$2i&gt;n$，则i是叶子节点，否则其左孩子结点是$2i$。 若$2i+1&gt;n$，则i无右孩子，否则右孩子结点是$2i+1$。 二叉树的存储结构 顺序存储：对于完全二叉树来说即将所有结点按照层次顺序存储到连续的存储单元中；对于一般二叉树来说需要将其每个结点与完全二叉树上的结点一一对应进行存储，比如根结点有右孩子没有左孩子，则存储时数组下标1需要空出，0存储根节点而2存储右孩子。由此看来，顺序存储仅适合完全二叉树，一般二叉树会造成空间的极大浪费。 链式存储：二叉树链式存储分为二叉链表和三叉链表。 二叉链表：结点包含左孩子和右孩子指针域以及数据域。拥有n个结点的二叉链表中有n+1个空链域。 推导：二叉链表中每个叶子结点有两个空链域，度为零的结点有一个空链域，则空链域个数为$2n_0+n_1$，通过公式$n=n_0+n_1+n_2$和$n_0=n_2+1$可以得到$2n_0+n_1=n+1$。 三叉链表：结点比二叉链表的结点多一个双亲指针域。 二叉树的遍历二叉树的遍历即通过遍历得到二叉树中结点访问的线性序列，实现了非线性结构的线性化。根据访问结点的次序不同可得三种遍历：先序遍历、中序遍历、后序遍历，此外还有层序遍历，时间复杂度均为O(n)。先序遍历和中序遍历或后序遍历和中序遍历可以唯一确定一颗二叉树。 先序遍历：1.访问根节点；2.先序遍历左子树；3.先序遍历右子树。也就是中左右的顺序。 先序遍历递归算法： /** * 先序遍历递归实现 * @param root 根节点 */ public void preOrderTraverse(TreeNode root) { if (root != null) { // 访问根节点 System.out.println(root.data); // 先序遍历左子树 preOrderTraverse(root.left); // 先序遍历右子树 preOrderTraverse(root.right); } } 先序遍历非递归算法： /** * 先序遍历非递归实现 * @param root 根节点 */ public void preOrderTraverseStack(TreeNode root) { Stack&lt;TreeNode> stack = new Stack&lt;>(); TreeNode current = root; // 当前结点不为空就处理结点入栈，当前结点为空处理出栈为结点赋值，当前结点和栈都空处理完毕。 while (current != null || !stack.isEmpty()) { if (current != null) { // 先序打印根结点并将根结点入栈，当前节点赋值根结点的左结点。 System.out.println(current.data); stack.push(current); current = current.left; } else { // 左结点处理完毕，弹栈出来的是根节点，因为根节点处理过了此时将根节点的右结点压栈处理。 TreeNode temp = stack.pop(); current = temp.right; } } } 中序遍历：1.中序遍历左子树；2.访问根节点；3.中序遍历右子树。也就是左中右的顺序。 中序遍历递归算法： /** * 中序遍历递归实现 * @param root 根节点 */ public void inOrderTraverse(TreeNode root) { if (root != null) { // 中序遍历左子树 inOrderTraverse(root.left); // 访问根节点 System.out.println(root.data); // 中序遍历右子树 inOrderTraverse(root.right); } } 中序遍历非递归算法： /** * 中序遍历非递归实现 * @param root 根节点 */ public void inOrderTraverseStack(TreeNode root) { Stack&lt;TreeNode> stack = new Stack&lt;>(); TreeNode current = root; while (current != null || !stack.isEmpty()) { if (current != null) { // 压入根节点不打印，当前结点赋值左结点。 stack.push(current); current = current.left; } else { // 弹栈出来的是根结点，打印并给当前结点赋值该根结点的右结点。 TreeNode temp = stack.pop(); System.out.print(temp.data); current = temp.right; } } } 后序遍历：1.后序遍历左子树；2.后序遍历右子树；3.访问根节点。也就是左右中的顺序。 后序遍历递归算法： /** * 后序遍历递归实现 * @param root 根节点 */ public void postOrderTraverse(TreeNode root) { if (root != null) { // 后序遍历左子树 postOrderTraverse(root.left); // 后序遍历右子树 postOrderTraverse(root.right); // 访问根节点 System.out.println(root.data); } } 后序遍历非递归算法： /** * 后序遍历非递归实现 * @param root 根节点 */ public void postOrderTraverseStack(TreeNode root) { Stack&lt;TreeNode> stack = new Stack&lt;>(); TreeNode current, previous = null; stack.push(root); while (!stack.isEmpty()) { current = stack.peek(); /* * 判断两种情况： * 1.当前节点的左右结点是否为空，空就打印该结点并弹栈。 * 2.当前结点的左右结点有一个不为空时，判断上一个结点是否为空并且是不是该结点的孩子，如果是打印并弹栈。 */ if ((current.left == null &amp;&amp; current.right == null) || (previous != null &amp;&amp; (previous == current.left || previous == current.right))) { System.out.println(current.data); stack.pop(); previous = current; } else { // 如果当前结点有孩子结点，先处理左结点再处理右结点。因为栈后入先出，所以先压栈右再压栈左。 if (current.right != null) stack.push(current.right); if (current.left != null) stack.push(current.left); } } } 层序遍历：从上往下，从左往右进行遍历。 层序遍历实现： /** * 层序遍历 * @param root 根节点 */ public void levelOrderTraverse(TreeNode root) { // 排除根节点为空的情况 if (root == null) { return; } // 先进的结点先出，使用队列实现 Queue&lt;TreeNode> queue = new LinkedList&lt;TreeNode>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); System.out.println(node.data); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } 线索二叉树 n个结点的二叉链表就会有n+1个指针域被浪费，线索二叉树为了将浪费的指针域利用起来，将空指针域用来存储其该结点的直接前驱和直接后继（就是遍历的上一个结点和下一个结点），其中指向结点前驱和后继的指针称为线索。 线索二叉树的结点由左孩子（left）、右孩子（right）、数据域、左标记（leftIsThread）和右标记（rightIsThread）组成。以左标记为例，$leftIsThread=\\begin{cases}false&amp;left指向结点的左孩子\\\\true&amp;left指向结点的前驱 \\end{cases}$ 按照不同的遍历顺序进行线索化（即遍历二叉树将其变成线索二叉树的过程）可分为先序线索二叉树、中序线索二叉树和后序线索二叉树。中序线索二叉树具体代码如下： /** * @Author 喵粮都输光了 * @Date 2020/3/21 16:19 * @Description 线索二叉树 */ public class ThreadTree { private static class Node { /** * 左孩子 */ private Node left; /** * 左结点是否线索化，默认不是 */ private boolean leftIsThread; /** * 数据 */ private Object data; /** * 右结点是否线索化，默认不是 */ private boolean rightIsThread; /** * 右孩子 */ private Node right; public Node(Object data) { left = null; leftIsThread = false; this.data = data; rightIsThread = false; right = null; } } /** * 根节点 */ private Node root; /** * 上一个遍历到的结点 */ private Node pre; /** * 总结点数 */ private int length; public ThreadTree() { root = null; pre = null; length = 0; } /** * 初始化线索二叉树 * @param data 需要存储的数据 */ public ThreadTree(Object[] data) { // 此处传入下标1是为了方便二叉树创建时使用递归 root = createTree(data, 1); // 中序线索化 inOrderThread(root); pre = null; length = data.length; } /** * 创建二叉树 * @param data 数据 * @param index 数组开始下标加一 * @return 根结点 */ private Node createTree(Object[] data, int index) { // index 默认多了1，所以此处可以等于数组长度 if (index > data.length) { return null; } Node node = new Node(data[index - 1]); Node left = createTree(data, 2 * index); Node right = createTree(data, 2 * index + 1); node.left = left; node.right = right; return node; } /** * 中序线索二叉树（最左结点前驱是线索，最右结点后继不是线索） * @param root 需要线索化的二叉树根节点 */ private void inOrderThread(Node root) { if (root != null) { // 中序遍历线索化左子树 inOrderThread(root.left); // 左孩子为空设置其前驱。 if (root.left == null) { root.leftIsThread = true; root.left = pre; } // 若上一个结点不为空（特殊处理根结点的上一个结点）并且上一个结点的右孩子为空，设置上一个结点的后继为当前结点。 if (pre != null &amp;&amp; pre.right == null) { pre.rightIsThread = true; pre.right = root; } pre = root; // 中序遍历线索化右子树 inOrderThread(root.right); } } /** * 中序遍历线索二叉树，按照后继方式遍历。（找最左子结点开始） * @param root 需要遍历的二叉树根节点 */ private void inOrderTraversePost(Node root) { // 查找最左子结点，最左结点前驱是线索 while (root != null &amp;&amp; !root.leftIsThread) { root = root.left; } while (root != null) { System.out.println(root.data); if (root.rightIsThread) { // 如果是线索直接找后继 root = root.right; } else { // 如果右指针不是线索，找从右子树开始的最左结点 root = root.right; while (root != null &amp;&amp; !root.leftIsThread) { root = root.left; } } } } /** * 中序后继方式遍历线索化二叉树 */ public void inOrderTraversePost() { inOrderTraversePost(root); } /** * 中序遍历线索二叉树，按照前驱方式遍历。（找到最右结点开始倒序遍历） * @param root 需要遍历的二叉树根节点 */ private void inOrderTraversePre(Node root) { // 查找最右结点，最右结点后继不是线索 while (root.right != null &amp;&amp; !root.rightIsThread) { root = root.right; } while (root != null) { System.out.println(root.data); if (root.leftIsThread) { // 如果是线索直接找前驱 root = root.left; } else { // 如果左指针不是线索，找从左子树开始的最右结点 root = root.left; while (root.right != null &amp;&amp; !root.rightIsThread) { root = root.right; } } } } /** * 中序前驱方式遍历线索化二叉树 */ public void inOrderTraversePre() { inOrderTraversePre(root); } } 森林森林与二叉树的转换森林是树的集合，通过左结点取第一个孩子结点，右结点取第一个兄弟结点可以将森林转化成二叉树。反过来也可以将二叉树转化成森林。 树和森林的遍历 树的遍历：先根遍历树即先访问树的根结点再依次先根遍历根的每颗子树；后根遍历即先依次后跟遍历每颗子树再访问根结点。将树转化成二叉树（和森林转化二叉树方法一样），则对树的先根和后根遍历等同于二叉树的先序和中序遍历。 森林的遍历：先序遍历即从第一颗树开始依次先序遍历所有树；中序遍历即从第一棵树开始依次后跟遍历所有树。森林的先序和中序遍历等同于将该森林转化成的二叉树的先序和中序遍历。 哈夫曼树基本概念哈夫曼（Huffman）树又称为最优二叉树，是一类带权路径长度最短的树。其基本术语如下： 路径：一个结点到另一个结点之间的分支构成这两个结点之间的路径。 路径长度：一个结点到另一个结点之间经过的线（边或分支）的条数就是路径长度。 树的路径长度：从树根到每一个结点的路径长度之和。 权：赋予某个实体一个量，是对实体的某个或某些属性的数值化描述，分为结点权和边权。 结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。 树的带权路径长度：树中所有叶子结点的带权路径长度。 哈夫曼树：由带权叶子节点构造的带权路径长度WPL最小的二叉树。 构造算法 构造过程：用所有带权根节点构成一个森林，从森林中挑选两个权最小的作为新构造的二叉树的两个孩子结点，两个孩子结点的双亲结点为这两个孩子结点权的和。此时从森林中删除这两个孩子结点，并将新构造的二叉树放入森林，重复之前的操作知道森林构成一颗二叉树为止。 算法实现：哈夫曼树中只有度为2和0的结点，因此n个叶子结点的哈夫曼树共有2n-1个结点，可以将其存储在大小为2n-1的一维数组中。数组中每个单元存储一个树结点，树结点由weight（权重）、left（左孩子）和right（右孩子）构成。且为了实现方便，下标零一般不存储数据，并将叶子节点集中存储在下标1至n上。哈夫曼树构造具体代码如下： /** * @Author 喵粮都输光了 * @Date 2020/3/21 22:21 * @Description 哈夫曼树 */ public class HuffmanTree { public static class Node implements Comparable&lt;Node> { /** * 权重 */ private double weight; /** * 左孩子、右孩子 */ private Node left, right; public Node(double weight) { this.weight = weight; } @Override public int compareTo(Node o) { if (this.weight &lt; o.weight) { return -1; } else if (this.weight > o.weight) { return 1; } return 0; } @Override public String toString() { return \"weight:\" + this.weight + \"; \"; } } /** * 哈夫曼树根节点 */ private Node root; public HuffmanTree(List&lt;Node> nodes) { root = createTree(nodes); } /** * 构造哈夫曼树 * @param nodes 带权结点集合 * @return 哈夫曼树根结点 */ private Node createTree(List&lt;Node> nodes) { // 最后留下构成的二叉树根节点 while (nodes.size() > 1) { Collections.sort(nodes); Node left = nodes.get(0); Node right = nodes.get(1); Node parent = new Node(left.weight + right.weight); parent.left = left; parent.right = right; nodes.remove(left); nodes.remove(right); nodes.add(parent); } return nodes.get(0); } } 哈夫曼编码哈夫曼编码是一种可变长编码方式，常用于数据压缩。将字符出现频率作为该字符的权并构造其哈夫曼树，因此出现频率最高的结点离根结点最近，也就是说其编码位数越短，以此达到压缩数据的目的。哈夫曼编码具体代码如下： /** * @Author 喵粮都输光了 * @Date 2020/3/22 0:55 * @Description 哈夫曼编码 */ public class Huffman { private static class Node implements Comparable&lt;Node> { /** * 数据（字符） */ private char ch; /** * 出现频率 */ private int freq; /** * 左右孩子 */ private Node left, right; public Node(char ch, int freq, Node left, Node right) { this.ch = ch; this.freq = freq; this.left = left; this.right = right; } /** * 判断该结点是否是叶子结点 * @return true or false */ private boolean isLeaf() { return (left == null) &amp;&amp; (right == null); } @Override public int compareTo(Node o) { if (this.freq > o.freq) { return 1; } else if (this.freq &lt; o.freq) { return -1; } return 0; } } /** * 哈夫曼树根结点 */ private Node root; /** * 编码表 */ private Map&lt;Character, String> encodeTable = new Hashtable&lt;>(256); public Huffman(String s) { root = createHuffmanTree(s); encodeTable(root, \"\", encodeTable); } /** * 通过给定的字符串构建哈夫曼树 * @param s 给定字符串 * @return 哈夫曼树根结点 */ private Node createHuffmanTree(String s) { // 字符串为空直接返回 if (s == null || \"\".equals(s)) { return null; } // 统计单词出现频率 HashMap&lt;Character, Integer> maps = new HashMap&lt;>(256); for (char letter : s.toCharArray()) { maps.put(letter, maps.getOrDefault(letter, 0) + 1); } // 单词和其出现频率封装在Node中，并用list储存node List&lt;Node> nodes = new ArrayList&lt;>(); for (Map.Entry&lt;Character, Integer> map : maps.entrySet()) { nodes.add(new Node(map.getKey(), map.getValue(), null, null)); } // 构造哈夫曼树 while (nodes.size() > 1) { Collections.sort(nodes); Node left = nodes.get(0); Node right = nodes.get(1); Node parent = new Node('\\0', left.freq + right.freq, left, right); parent.left = left; parent.right = right; nodes.remove(left); nodes.remove(right); nodes.add(parent); } return nodes.get(0); } /** * 哈夫曼解码 * @param encodeString 需要解码的字符串 * @return 解码后的字符串 */ public String decode(String encodeString) { StringBuilder decodeString = new StringBuilder(); // 遍历字符串 for (int i = 0, start = i; i &lt; encodeString.length(); i++) { String nowString = encodeString.substring(start, i + 1); // 在编码表中查找子串是否存在 if (encodeTable.containsValue(nowString)) { for (Map.Entry&lt;Character, String> decode : encodeTable.entrySet()) { if (decode.getValue().equals(nowString)) { decodeString.append(decode.getKey()); } } start = i + 1; } } return decodeString.toString(); } /** * 哈夫曼编码 * @param s 需要编码的字符串 * @return 编码后的字符串 */ public String encode(String s) { StringBuilder encodedString = new StringBuilder(); // 获得编码表 for (char letter : s.toCharArray()) { encodedString.append(encodeTable.get(letter)); } return encodedString.toString(); } /** * 将字符编码存入编码表 * @param root 哈夫曼树根节点 * @param encoding 字符编码 * @param map 编码表 */ private void encodeTable(Node root, String encoding, Map&lt;Character, String> map) { if (root == null) { return; } // 是叶子结点就存储 if (root.isLeaf()) { map.put(root.ch, encoding); return; } // 递归左右结点 encodeTable(root.left, encoding + '0', map); encodeTable(root.right, encoding + '1', map); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之串、数组与广义表","date":"2020-03-20T14:41:27.000Z","path":"posts/2844cbbf/","text":"串 串（string或字符串）是内容受限的线性表，限定了表中的元素为字符。 串的两种基本存储结构为顺序存储和链式存储。通常采用顺序存储结构。 数组 数组是由类型相同的数据元素构成的有序集合，数组中存储的数据可以是带有结构的同一数据类型的数据。数组一般采用顺序存储结构，其存储方式也可分为按行存储和按列存储。 多维数组实质上是 n 个线性表的组合，其每一维都是一个线性表，因此多维数组可以看成是线性表的推广。 特殊矩阵压缩存储，可以将多个值相同的元只分配一个存储空间，对零元不分配空间。常见的有对称矩阵，三角矩阵和对角矩阵： 对称矩阵：一维数组array[k]与矩阵$a_{ij}$之间的对应关系：$$k=\\begin{cases}\\frac{i(i-1)}{2}+j-1&amp;当i≥j，\\\\ \\frac{j(j-1)}{2}+i-1&amp;当i\\lt j。 \\end{cases}$$对称矩阵只需要存储包含对角线及以上或者以下元素，因此存储空间可以从$n^2$减小到$\\frac{n(n+1)}{2}$。假设当作下三角来看，第一行1个元素，第二行2个元素，直到第n行n个元素。可以知道$a_{ij}$就是第1行到第i-1行的元素个数加上第i行的元素个数再减去一（一维数组下标从0开始），即$\\frac{i(i-1)}{2}+j-1$。由于对称矩阵是对称的，将刚得出的公式中的i和j互换即可获得一样的下标。 三角矩阵： 下三角矩阵：矩阵下三角(不含对角线)的元素均为某一常数或零。一维数组array[k]与矩阵$a_{ij}$之间的对应关系：$$k=\\begin{cases}\\frac{i(i-1)}{2}+j-1&amp;当i≥j，\\\\ \\frac{n(n+1)}{2}&amp;当i\\lt j。 \\end{cases}$$矩阵下三角第一行1个元素，第二行2个元素，直到n行n个元素。元素总和为$\\frac{n(n+1)}{2}$。因此当需要计算$a_{ij}$时，首先需要计算1至i-1行有多少个元素在加上第i行的j个元素，还要减一（一维数组下标从0开始）。均为某一常数或零就存储在最后一个位置上。 上三角矩阵：与下三角矩阵相反。一维数组array[k]与矩阵$a_{ij}$之间的对应关系：$$k=\\begin{cases}\\frac{(i-1)(2n-i+2)}{2}+(j-i) &amp;当i≤j，\\\\ \\frac{n(n+1)}{2} &amp;当i\\gt j。 \\end{cases}$$矩阵上三角第一行n个元素，第二行n-1个元素，直到第n行1个元素。由此可知这是一个等差数列，i行的元素个数为$n-i+1$个，再根据公式$S_n=\\frac{n(a_1+a_n)}{2}$可得1至i-1行有$\\frac{(i-1)(n+n-(i-1)+1)}{2}=\\frac{(i-1)(2n-i+2)}{2}$个元素，加上第i行的(j-i+1)个元素（看$a_{11}，j-i为0，还要加上1才能表示有一个元素$），还要减一（一维数组下标从0开始）。均为某一常数或零就存储在最后一个位置上。 对角矩阵：对角矩阵所有的非零元都集中在以主对角线为中心的带状区域中，即除了对角线上和在对角线上、下方若干条对角线上的数据外，其他数据都为零。可以通过以行或列为主，或以对角线顺序将其压缩到一维数组上。 广义表 广义表是另外一种线性表的推广形式，表中的元素可以是称为原子的单个元素，也可以是一个子表，所以线性表可以看成广义表的特例。 广义表的常用操作有取表头和取表尾。 取表头：取出的表头为非空广义表的第一个元素，可以是单原子也可以是子表。 取表尾：取出的表尾为去表头之外其余元素所构成的表，尾表一定是一个广义表。 广义表通常采用链式存储结构：头尾链表的存储结构和扩展线性链表的存储结构。 头尾链表的存储结构：表结点由标志域(1表子表，0表原子)、指示表头的指针域和指示表尾的指针域构成。原子结点由标志域和值域构成。 扩展线性链表的存储结构：无论表结点还是原子结点均由三个域组成，即标志域、指示表头的指针域(表结点或原子结点)和指示表尾的指针域。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之栈与队列","date":"2020-03-20T07:09:59.000Z","path":"posts/2442d660/","text":"栈栈是限定仅在表尾进行插入或删除操作的线性表(表尾为栈顶，表头为栈底)，简单说就是后存入的元素在取的时候反而会先取出，因此也称为后进先出(LIFO)的线性表。栈可分为顺序栈和链栈。 顺序栈顺序栈的基本操作实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/20 16:29 * @Description 顺序栈 */ public class ArrayStack { /** * 栈主体 */ private Object[] stack; /** * 已存储的元素个数 */ private int length; /** * 初始化顺序栈 * @param maxLength 最大长度 */ public ArrayStack(int maxLength) { stack = new Object[maxLength]; length = 0; } /** * 顺序栈是否为空 * @return 为空true，不空false */ public boolean empty() { return length == 0; } /** * 清空顺序栈 */ public void clear() { length = 0; } /** * 顺序栈中数据元素个数。 * @return 元素个数 */ public int length() { return length; } /** * 压栈 * @param elem 需要存储的元素 */ public void push(Object elem) { if (length == stack.length) { throw new ArrayIndexOutOfBoundsException(\"栈满了\"); } stack[length] = elem; length++; } /** * 弹栈 * @return 删除的元素 */ public Object pop() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"栈式空的\"); } Object data = stack[length - 1]; length--; return data; } /** * 获取栈顶元素 * @return 栈顶元素 */ public Object getTop() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"栈空\"); } return stack[length - 1]; } } 链栈链栈的基本操作实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/20 16:29 * @Description 链栈 */ public class LinkedStack&lt;T> { /** * 栈顶 */ private Node top; /** * 已存储的元素个数 */ private int length; private class Node { /** * 数据 */ private T data; /** * 下一个结点 */ private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } } /** * 初始化链栈 */ public LinkedStack() { clear(); } /** * 链栈是否为空 * @return 为空true，不空false */ public boolean empty() { return length == 0; } /** * 清空链栈 */ public void clear() { top = null; length = 0; } /** * 链栈中数据元素个数。 * @return 元素个数 */ public int length() { return length; } /** * 压栈 * @param elem 需要存储的元素 */ public void push(T elem) { top = new Node(elem, top); length++; } /** * 弹栈 * @return 删除的元素 */ public T pop() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"栈空\"); } T data = top.data; top = top.next; length--; return data; } /** * 获取栈顶元素 * @return 栈顶元素 */ public T getTop() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"栈空\"); } return top.data; } } 队列 队列是限定在表尾(队尾)进行插入，在表头(队头)进行删除的线性表，换句话说就是先进先出(FIFO)的线性表。队列可分为顺序队列(常用循环队列)和链式队列。 循环队列循环队列的基本操作实现，需要注意的有四点： 队列入队出队首尾指针：(rear + 1) % maxLength 和 (front + 1) % maxLength。 队长及队列判空判满条件： 方法一：为了区分队满和队空，入队时少用一个队列单元，即当rear的下一个为front时表示队满。 队满：(rear + 1) % maxLength == front。 队空：front == rear。 队长：(rear - front + maxLength) % maxLength。 方法二：通过变量length记录实际在队列中的元素个数。 队满：length == maxLength。 队空：length == 0。 队长：length。 /** * @Author 喵粮都输光了 * @Date 2020/3/20 18:30 * @Description 循环队列(牺牲一个队列单元判空判满) */ public class CircleQueue { /** * 循环队列主体 */ private Object[] queue; /** * 队头 */ private int front; /** * 队尾 */ private int rear; /** * 队列最大长度 */ private int maxLength; /** * 初始化链式队列 */ public CircleQueue(int maxLength) { this.maxLength = maxLength + 1; queue = new Object[maxLength + 1]; front = 0; rear = 0; } /** * 链式队列是否为空 * @return 为空true，不空false */ public boolean empty() { return rear == front; } /** * 清空链栈 */ public void clear() { front = 0; rear = 0; } /** * 链式队列中数据元素个数。 * @return 元素个数 */ public int length() { return (rear + maxLength - front) % maxLength; } /** * 入队 * @param elem 需要存储的元素 */ public void enqueue(Object elem) { if ((rear + 1) % maxLength == front) { throw new ArrayIndexOutOfBoundsException(\"队列满\"); } queue[rear] = elem; rear = (rear + 1) % maxLength; } /** * 出队 * @return 删除的元素 */ public Object dequeue() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"队列空\"); } Object data = queue[front]; front = (front + 1) % maxLength; return data; } /** * 队头元素 * @return 队头元素 */ public Object getHead() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"队列空\"); } return queue[front]; } } 链式队列链式队列的基本操作实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/20 18:30 * @Description 链式队列 */ public class LinkedQueue&lt;T> { /** * 队头 */ private Node&lt;T> front; /** * 队尾 */ private Node&lt;T> rear; /** * 已存储的元素个数 */ private int length; private static class Node&lt;T> { /** * 数据 */ private T data; /** * 下一个结点 */ private Node&lt;T> next; public Node(T data, Node&lt;T> next) { this.data = data; this.next = next; } } /** * 初始化链式队列 */ public LinkedQueue() { clear(); } /** * 链式队列是否为空 * @return 为空true，不空false */ public boolean empty() { return length == 0; } /** * 清空链栈 */ public void clear() { front = null; rear = null; length = 0; } /** * 链式队列中数据元素个数。 * @return 元素个数 */ public int length() { return length; } /** * 入队 * @param elem 需要存储的元素 */ public void enqueue(T elem) { Node&lt;T> oldRear = rear; rear = new Node&lt;>(elem, null); if (empty()) { front = rear; } else { oldRear.next = rear; } length++; } /** * 出队 * @return 删除的元素 */ public T dequeue() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"队列空\"); } T data = front.data; front = front.next; length--; if (empty()) { rear = null; } return data; } /** * 队头元素 * @return 队头元素 */ public T getHead() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"队列空\"); } return front.data; } } 栈和队列的比较 栈 队列 逻辑结构 和线性表相同，元素一一对应。 和线性表相同，元素一一对应。 顺序存储(存储结构) 空间预先分配，容易导致空间溢出或闲置。 常设计为循环队列。空间预先分配，容易导致空间溢出或闲置。 链式存储(存储结构) 动态分配，不会造成空间浪费或溢出。 动态分配，不会造成空间浪费或溢出。 运算规则 后进先出，插入删除在表的一端(栈顶)完成。 先进先出，插入在队尾进行，删除在队头进行。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之线性表","date":"2020-03-19T12:26:13.000Z","path":"posts/91054329/","text":"线性表特点 线性表第一个元素无前驱，最后一个元素无后继，其他每个数据元素都有一个前驱和后继。 对线性表的数据元素可以进行增删改查等操作。 顺序表 顺序表(ArrayList)即线性表的顺序存储表示，通过使用一组地址连续的存储单元依次存储线性表的数据元素。简单说就是逻辑上相邻的数据元素，在物理地址上也是相邻的。 顺序表的基本操作实现(使用数组)： /** * @Author 喵粮都输光了 * @Date 2020/3/19 21:12 * @Description 顺序表，下标从0开始。 */ public class ArrayList { /** * 顺序表主体 */ private Object[] list; /** * 已存储的元素个数 */ private int length; /** * 初始化顺序表 * @param maxLength 最大长度 */ public ArrayList(int maxLength) { list = new Object[maxLength]; length = 0; } /** * 清空顺序表 */ public void clearList() { length = 0; } /** * 顺序表是否为空 * @return 为空true，不空false */ public boolean listEmpty() { return length == 0; } /** * 顺序表中数据元素个数。 * @return 元素个数 */ public int listLength() { return length; } /** * 获取顺序表指定位置元素 * @param index 下标 * @return 指定元素 */ public Object getElem(int index) { // 下标不合法 if (index &lt; 0 || index > length - 1) { return null; } return list[index]; } /** * 返回顺序表中第一个值与object相同的元素位置，没找到返回-1 * @param elem 需要查找的元素 * @return 返回查找到的第一个与之相同的元素位置，否则返回-1 */ public int locateElem(Object elem) { for (int i = 0; i &lt; length; i++) { if (list[i].equals(elem)) { return i; } } return -1; } /** * 在所给index位置之前插入新的元素。index位置之后元素后移 * @param elem 需要插入的元素 * @param index 需要插入的位置 */ public void listInsert(Object elem, int index) { // 下标不合法或数组满了 if (index &lt; 0 || index > list.length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } if (length == list.length) { throw new ArrayIndexOutOfBoundsException(\"数组满了\"); } if (index != length) { for (int i = length; i > index; i--) { list[i] = list[i - 1]; } } list[index] = elem; length++; } /** * 删除所给index位置的元素，index位置之后元素前移 * @param index 需要删除的位置 * @return 返回删除的元素 */ public Object listDelete(int index) { // 下标不合法或数组为空 if (index &lt; 0 || index > length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } Object removeElem = list[index]; if (index != length - 1) { for (int i = index; i &lt; length - 1; i++) { list[index] = list[index + 1]; } } length--; return removeElem; } /** * 遍历顺序表 * @return 返回遍历结果 */ public String traverseList() { if (length == 0) { return \"[]\"; } StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"[\"); for (int i = 0; i &lt; length; i++) { stringBuilder.append(list[i]).append(\", \"); } stringBuilder.delete(stringBuilder.length() - 2, stringBuilder.length()); stringBuilder.append(\"]\"); return String.valueOf(stringBuilder); } } 链表链表(LinkedList)即线性表的链式存储表示，用一组任意的存储单元存储线性表的数据元素，由于物理地址可能非连续，因此需要存储一个指示其直接后继的信息。也就是说逻辑上相邻的数据元素，在物理地址上可能相邻也可能不相邻。(链表示例动画) 单链表 单链表如下图所示只能从头访问至尾。 单链表的基本操作实现： /** * @Author 喵粮都输光了 * @Date 2020/3/19 21:12 * @Description 单链表。 */ public class SinglyLinkedList&lt;T> { /** * 头结点 */ private Node head; /** * 单链表长度 */ private int length; private class Node { /** * 数据 */ private T data; /** * 下一个结点 */ private Node next; /** * 初始化一个结点 * @param data 存储的数据 * @param next 下一个结点 */ public Node(T data, Node next) { this.data = data; this.next = next; } /** * 尾结点，未传入下一个结点，则初始化下一个结点为空 * @param data 存储的数据 */ public Node(T data) { this(data, null); } } /** * 初始化单链表 */ public SinglyLinkedList() { head = null; length = 0; } /** * 在表头插入数据元素 * @param elem 数据元素 */ public void listInsertHead(T elem) { head = new Node(elem, head); length++; } /** * 在表尾插入数据元素 * @param elem 数据元素 */ public void listInsertTail(T elem) { listInsert(elem, length); } /** * 在指定位置插入数据元素 * @param elem 数据元素 * @param index 需要插入的位置 */ public void listInsert(T elem, int index) { // 下标不合法 if (index &lt; 0 || index > length) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listInsertHead(elem); return; } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } preNode.next = new Node(elem, preNode.next); length++; } /** * 删除头结点元素 * @return 返回删除的元素 */ public T listDeleteHead() { if (length == 0) { throw new ArrayIndexOutOfBoundsException(\"数组为空\"); } T removeElem = head.data; head = head.next; length--; return removeElem; } /** * 删除尾结点元素 * @return 返回删除的元素 */ public T listDeleteTail() { return listDelete(length - 1); } /** * 删除指定结点元素 * @param index 需要删除的元素位置 * @return 返回删除的元素 */ public T listDelete(int index) { // 下标不合法或数组为空 if (index &lt; 0 || index > length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listDeleteHead(); } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } T removeElem = preNode.next.data; preNode.next = preNode.next.next; return removeElem; } /** * 返回链表中第一个值与elem相同的元素位置，没找到返回-1 * @param elem 需要查找的元素 * @return 返回查找到的第一个与之相同的元素位置，否则返回-1 */ public int locateElem(T elem) { if (length == 0) { return -1; } Node temp = head; int index = 0; // 必须用equals，类型不同 if (temp.data.equals(elem)) { return index; } while (temp.next != null) { temp = temp.next; index++; if (temp.data.equals(elem)) { return index; } } return -1; } /** * 遍历链表 * @return 返回遍历结果 */ public String traverseList() { if (length == 0) { return \"[]\"; } Node temp = head; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"[\"); stringBuilder.append(temp.data).append(\", \"); while (temp.next != null) { temp = temp.next; stringBuilder.append(temp.data).append(\", \"); } stringBuilder.delete(stringBuilder.length() - 2, stringBuilder.length()); stringBuilder.append(\"]\"); return String.valueOf(stringBuilder); } } 循环链表 循环链表的最后一个结点指向头结点。与单链表基本一致，唯一差别仅在判断当前指针是否指向表尾结点的终止条件不同。循环链表示意图如下。 循环链表的基本操作实现：直接通过如下方式修改单链表。 添加尾结点。 /** * 尾结点 */ private Node tail; 为尾结点初始化。 /** * 初始化循环链表 */ public CircularLinkedList() { head = null; tail = null; length = 0; } 修改插入删除方法。 /** * 在表头插入数据元素 * @param elem 数据元素 */ public void listInsertHead(T elem) { head = new Node(elem, head); if (length == 0) { tail = head; tail.next = head; } length++; } /** * 在指定位置插入数据元素 * @param elem 数据元素 * @param index 需要插入的位置 */ public void listInsert(T elem, int index) { // 下标不合法 if (index &lt; 0 || index > length) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listInsertHead(elem); return; } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } preNode.next = new Node(elem, preNode.next); if (index == length) { tail = preNode.next; tail.next = head; } length++; } /** * 删除头结点元素 * @return 返回删除的元素 */ public T listDeleteHead() { if (length == 0) { throw new ArrayIndexOutOfBoundsException(\"数组为空\"); } T removeElem = head.data; head = head.next; tail.next = head; length--; return removeElem; } /** * 删除指定结点元素 * @param index 需要删除的元素位置 * @return 返回删除的元素 */ public T listDelete(int index) { // 下标不合法或数组为空 if (index &lt; 0 || index > length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listDeleteHead(); } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } T removeElem = preNode.next.data; preNode.next = preNode.next.next; if (index == length - 1) { tail = preNode; tail.next = head; } return removeElem; } 修改locateElem和traverseList方法的判断是否到链尾的方法为如下。 while (temp.next != head) { // 方法 } 双向链表 双向链表的结点比单链表和循环链表的结点多一个指向其直接前驱的信息，双向链表也可以有双向循环链表的实现方式，其示意图如下。 双向循环链表的基本操作实现：直接通过如下方式修改双链表(可以去掉尾结点，留着没有意义)。 删除尾结点并修改class Node增加前驱信息保存。 private class Node { /** * 数据 */ private T data; /** * 下一个结点 */ private Node next; /** * 上一个结点 */ private Node pre; /** * 初始化一个结点 * @param data 存储的数据 * @param next 下一个结点 */ public Node(T data, Node pre, Node next) { this.data = data; this.next = next; this.pre = pre; } } 修改插入删除方法。 /** * 在表头插入数据元素 * @param elem 数据元素 */ public void listInsertHead(T elem) { if (length == 0) { head = new Node(elem, head, head); head.pre = head; head.next = head; } else { head = new Node(elem, head.pre, head); head.pre.next = head; head.next.pre = head; } length++; } /** * 在指定位置插入数据元素 * @param elem 数据元素 * @param index 需要插入的位置 */ public void listInsert(T elem, int index) { // 下标不合法 if (index &lt; 0 || index > length) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listInsertHead(elem); return; } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } preNode.next = new Node(elem, preNode, preNode.next); preNode.next.next.pre = preNode.next; if (index == length) { preNode.next.next = head; } length++; } /** * 删除头结点元素 * @return 返回删除的元素 */ public T listDeleteHead() { if (length == 0) { throw new ArrayIndexOutOfBoundsException(\"数组为空\"); } T removeElem = head.data; head.pre.next = head.next; head.next.pre = head.pre; head = head.next; length--; return removeElem; } /** * 删除指定结点元素 * @param index 需要删除的元素位置 * @return 返回删除的元素 */ public T listDelete(int index) { // 下标不合法或数组为空 if (index &lt; 0 || index > length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listDeleteHead(); } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } T removeElem = preNode.next.data; preNode.next = preNode.next.next; preNode.next.pre = preNode; if (index == length - 1) { preNode.next = head; head.pre = preNode; } return removeElem; } 顺序表与链表的比较存储密度：指的是数据元素本身所占用的存储量和整个结点结构所占用的存储量之比。存储密度越大，存储空间的利用率越高。 顺序表 链表 存储空间(空间) 预先分配，容易导致空间溢出或闲置。 动态分配，不会造成空间浪费或溢出。 存储密度(空间) 不用存储结点间的逻辑关系，存储密度等于1。 需要存储结点间逻辑关系，存储密度小于1。 存取元素(时间) 随机存取，复杂度O(1)。 顺序存取，复杂度O(n)。 插入删除(时间) 平均需移动一半元素，复杂度O(n)。 不需要移动元素，复杂度O(1)。 使用情况 1.表长变化不大，事先能知道大概大小。2.多查少增删。 1.表长变化大。2.多增删少查。 各链表的时间复杂度比较 查找头结点 查找尾结点 查找结点p的前驱 带头结点的单链表 直接获取，复杂度O(1)。 需要遍历表，复杂度为O(n)。 无法获得前驱。 带头结点的循环单链表(无尾指针) O(1) O(n) 需要遍历表，复杂度为O(n)。 带头结点的循环单链表(无头指针) O(1) 通过尾指针直接获取，复杂度为O(1)。 O(n) 带头结点的双向循环链表 O(1) 直接获取头结点的前驱就是尾结点，复杂度为O(1)。 直接通过p结点的前驱获取，复杂度为O(1)。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构简介","date":"2020-03-19T11:14:55.000Z","path":"posts/b8928e0e/","text":"基本概念及术语 数据：能输入到计算机中并能被计算机处理的符号。例如文本字符串、数学实数、图形图像和声音等通过特殊编码后获得的数据。 数据元素：是数据的基本单位，通常作为整体考虑。例如学生记录$($包含姓名、年龄、学号等$)$。 数据项：是组成数据元素的最小单位。例如姓名、年龄、学号等，也就是说数据元素是由数据项构成的。 数据对象：可以看作是一个包含了相同性质的数据元素的集合。例如学生表，包含了相同性质的数据元素学生记录。 数据结构数据结构就是数据元素之间存在关系的集合，数据结构包含逻辑结构和存储结构。 逻辑结构：逻辑上存在关系，与数据存储无关的结构。如果数据元素之间存在一对一关系称为线性结构，否则称为非线性结构$($集合结构、树形结构和图状结构$)$。几种常用的逻辑结构层次图如下： 存储结构：数据在计算机中存储表示的方式，又称为物理结构。顺序存储结构和链式存储结构是两种常用的基本存储结构。 顺序存储结构：所有元素依次存放在一片连续的存储空间中。 链式存储结构：无需占用一整块存储空间，但是作为代价为了表示结点之间的关系，需要让每个结点都拥有指向其他结点的指针字段。也就是说链式存储结构中结点拥有数据和其他结点的存储地址。 算法分析 内循环：执行最频繁的指令决定了程序执行的总时间，把这些指令称为程序的内循环。 成本模型：使用成本模型来评估算法，例如数组的访问次数就是一种成本模型。 常见的增长数量级函数： 描述 函数 常数级别 1 对数级别 logN 线性级别 N 线性对数级别 NlogN 平方级别 $N^2$ 立方级别 $N^3$ 指数级别 $2^N$ 倍率定理：若$T(N)\\sim aN^blgN$，那么$\\frac{T(2N)}{N}\\sim 2^b$。 大常数：在求近似时，如果低级项的常数系数很大，那么近似的结果是错误的。 均摊分析：通过记录所有操作的总成本除以操作总数来将成本均摊。例如由数组实现的栈，当进行压栈操作时操作所访问数组的次数为常数次，但是如果栈满还要压栈时需要对数组扩容，为了将数据后移此时需要访问次数为数组大小次，均摊后访问数组的平均次数为常数$($也就是将写入数组时访问的次数与扩容时访问数组的次数平摊$)$。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"设计模式之复合模式","date":"2020-03-18T02:42:34.000Z","path":"posts/198c6c0a/","text":"复合模式 复合模式在一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题。 下面代码展现了模式之间合作的例子，其UML类图如下： 原型 需求：设计一个鸭子模拟器，具体鸭子实现各自的叫声接口。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:54 * @Description 叫声接口 */ public interface Quackable { /** * 叫声 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:58 * @Description 橡皮鸭 */ public class RubberDuck implements Quackable { @Override public void quack() { System.out.println(\"吱吱叫\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:57 * @Description 红头鸭 */ public class RedheadDuck implements Quackable { @Override public void quack() { System.out.println(\"呱呱叫\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:00 * @Description 鸭子模拟器 */ public class DuckSimulator { public static void main(String[] args) { DuckSimulator duckSimulator = new DuckSimulator(); duckSimulator.simulate(); } /** * 模拟鸭子 */ void simulate() { Quackable redheadDuck = new RedheadDuck(); Quackable rubberDuck = new RubberDuck(); simulate(redheadDuck); simulate(rubberDuck); } /** * 模拟鸭子叫重载 * @param duck 鸭子 */ void simulate(Quackable duck) { duck.quack(); } } 适配器模式 需求：现在需要添加一个鹅类，鹅会咯咯叫，将鹅包装成鸭子类使用同一个接口进行叫声调用。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:03 * @Description 鹅 */ public class Goose { /** * 鹅叫 */ void honk() { System.out.println(\"咯咯叫\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:06 * @Description 鹅叫声适配器，适配器模式 */ public class GooseAdapter implements Quackable { private Goose goose; public GooseAdapter(Goose goose) { this.goose = goose; } @Override public void quack() { goose.honk(); } } 修改DuckSimulator中的simulate()方法如下： /** * 模拟鸭子 */ void simulate() { Quackable redheadDuck = new RedheadDuck(); Quackable rubberDuck = new RubberDuck(); Quackable gooseDuck = new GooseAdapter(new Goose()); simulate(redheadDuck); simulate(rubberDuck); simulate(gooseDuck); } 装饰器模式 需求：现在需要一个叫声计数器，在不改变鸭子的代码的情况下统计鸭子叫声的次数。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:17 * @Description 叫声计数器，装饰器模式 */ public class QuackCounter implements Quackable { private Quackable duck; /** * 叫声次数，要记录所有传入对象的叫声次数，使用静态 */ private static int numberOfQuacks; public QuackCounter(Quackable duck) { this.duck = duck; } @Override public void quack() { duck.quack(); numberOfQuacks++; } /** * 获得叫声次数 * @return 叫声次数 */ public static int getQuacks() { return numberOfQuacks; } } 修改DuckSimulator中的simulate()方法如下： /** * 模拟鸭子 */ void simulate() { Quackable redheadDuck = new QuackCounter(new RedheadDuck()); Quackable rubberDuck = new QuackCounter(new RubberDuck()); simulate(redheadDuck); simulate(rubberDuck); System.out.println(\"叫声次数：\" + QuackCounter.getQuacks()); } 抽象工厂模式 需求：因为所有鸭子的叫声都需要统计，为了防止拥有叫声的鸭子对象创建时没有进行装饰，因此将鸭子对象的创建以及叫声的统计包装起来。通过一个工厂生产装饰过的鸭子，该工厂还要能够生产不同类型的鸭子(不包括鹅，此处相当于是鸭子产品家族，当然也可以创建鹅抽象工厂接口并建立鹅家族)。 代码演示： 鸭子抽象工厂接口。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:42 * @Description 鸭子抽象工厂接口 */ public abstract class BaseDuckFactory { /** * 创建红头鸭 * @return 红头鸭对象 */ abstract Quackable createRedheadDuck(); /** * 创建橡皮鸭 * @return 橡皮鸭对象 */ abstract Quackable createRubberDuck(); } 普通鸭子抽象工厂。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:48 * @Description 未装饰的鸭子抽象工厂 */ public class DuckFactory extends BaseDuckFactory { @Override Quackable createRedheadDuck() { return new RedheadDuck(); } @Override Quackable createRubberDuck() { return new RubberDuck(); } } 装饰叫声统计功能的鸭子抽象工厂。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:49 * @Description 装饰叫声统计功能的鸭子抽象工厂 */ public class CountingDuckFactory extends BaseDuckFactory { @Override Quackable createRedheadDuck() { return new QuackCounter(new RedheadDuck()); } @Override Quackable createRubberDuck() { return new QuackCounter(new RubberDuck()); } } 鸭子模拟器测试类。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:00 * @Description 鸭子模拟器 */ public class DuckSimulator { public static void main(String[] args) { DuckSimulator duckSimulator = new DuckSimulator(); BaseDuckFactory countingDuckFactory = new CountingDuckFactory(); duckSimulator.simulate(countingDuckFactory); } /** * 模拟鸭子 * @param duckFactory 鸭子工厂 */ void simulate(BaseDuckFactory duckFactory) { Quackable redheadDuck = duckFactory.createRedheadDuck(); Quackable rubberDuck = duckFactory.createRubberDuck(); simulate(redheadDuck); simulate(rubberDuck); System.out.println(\"叫声次数：\" + QuackCounter.getQuacks()); } /** * 模拟鸭子叫重载 * @param duck 鸭子 */ void simulate(Quackable duck) { duck.quack(); } } 组合模式和迭代器模式 需求：分别管理不同的鸭子非常的繁琐，因此需要将所有鸭子视为一个集合，通过少数命令让整个集合的鸭子听令行动。 代码演示： 会叫对象管理类。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 12:11 * @Description 所有拥有叫声的对象群(对象集合) */ public class Flock implements Quackable { /** * 会叫对象集合 */ private ArrayList&lt;Quackable> quackers = new ArrayList&lt;>(); /** * 向集合中添加会叫的对象 * @param quacker 会叫的对象 */ public void add(Quackable quacker) { quackers.add(quacker); } @Override public void quack() { // 此处使用了内置的迭代器。超级循环封装使用了集合和数组的迭代器。 for (Quackable quacker : quackers) { quacker.quack(); } } } 修改DuckSimulator中的simulate(BaseDuckFactory duckFactory)方法如下： /** * 模拟鸭子 * @param duckFactory 鸭子工厂 */ void simulate(BaseDuckFactory duckFactory) { Quackable redheadDuck = duckFactory.createRedheadDuck(); Quackable rubberDuck = duckFactory.createRubberDuck(); Quackable gooseDuck = new QuackCounter(new GooseAdapter(new Goose())); Flock flockOfDucks = new Flock(); flockOfDucks.add(redheadDuck); flockOfDucks.add(rubberDuck); flockOfDucks.add(gooseDuck); simulate(flockOfDucks); System.out.println(\"叫声次数：\" + QuackCounter.getQuacks()); } 观察者模式 需求：现在需要追踪个别的鸭子实时的观察其呱呱叫的行为。订阅需要观察的鸭子，当鸭子调用了叫声功能就通知订阅者。 代码演示： 叫声观察主题。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 12:27 * @Description 叫声观察主题 */ public interface QuackObservable { /** * 注册为观察者 * @param observer 需要注册的对象 */ void registerObserver(Observer observer); /** * 通知所有观察者方法 */ void notifyObservers(); } 观察者接口。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 13:28 * @Description 观察者接口 */ public interface Observer { /** * 更新 * @param duck 需要更新的对象 */ void update(QuackObservable duck); } 让叫声接口继承该主题，并对所有实现叫声接口的类实现叫声观察主题的方法，此处所有叫声对象方法都相同，可以通过一个类实现QuackObservable，在叫声对象中调用即可。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:54 * @Description 叫声接口 */ public interface Quackable extends QuackObservable { /** * 叫声 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2020/3/18 13:38 * @Description QuackObservable的一个具体实现 */ public class Observable implements QuackObservable { private ArrayList&lt;Observer> observers = new ArrayList&lt;>(); private QuackObservable duck; public Observable(QuackObservable duck) { this.duck = duck; } @Override public void registerObserver(Observer observer) { observers.add(observer); } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(duck); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:06 * @Description 鹅叫声适配器，适配器模式 */ public class GooseAdapter implements Quackable { private Observable observable; private Goose goose; public GooseAdapter(Goose goose) { observable = new Observable(this); this.goose = goose; } @Override public void quack() { goose.honk(); notifyObservers(); } @Override public void registerObserver(Observer observer) { observable.registerObserver(observer); } @Override public void notifyObservers() { observable.notifyObservers(); } @Override public String toString() { return \"伪装成鸭的鹅\"; } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:57 * @Description 红头鸭 */ public class RedheadDuck implements Quackable { private Observable observable; public RedheadDuck() { observable = new Observable(this); } @Override public void quack() { System.out.println(\"呱呱叫\"); notifyObservers(); } @Override public void registerObserver(Observer observer) { observable.registerObserver(observer); } @Override public void notifyObservers() { observable.notifyObservers(); } @Override public String toString() { return \"红头鸭\"; } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:58 * @Description 橡皮鸭 */ public class RubberDuck implements Quackable { private Observable observable; public RubberDuck() { observable = new Observable(this); } @Override public void quack() { System.out.println(\"吱吱叫\"); notifyObservers(); } @Override public void registerObserver(Observer observer) { observable.registerObserver(observer); } @Override public void notifyObservers() { observable.notifyObservers(); } @Override public String toString() { return \"橡皮鸭\"; } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:17 * @Description 叫声计数器，装饰器模式 */ public class QuackCounter implements Quackable { private Quackable duck; private Observable observable; /** * 叫声次数，要记录所有传入对象的叫声次数，使用静态 */ private static int numberOfQuacks; public QuackCounter(Quackable duck) { observable = new Observable(this); this.duck = duck; } @Override public void quack() { duck.quack(); numberOfQuacks++; notifyObservers(); } /** * 获得叫声次数 * @return 叫声次数 */ public static int getQuacks() { return numberOfQuacks; } @Override public void registerObserver(Observer observer) { observable.registerObserver(observer); } @Override public void notifyObservers() { observable.notifyObservers(); } @Override public String toString() { return duck.toString(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 12:11 * @Description 所有拥有叫声的对象群(对象集合) */ public class Flock implements Quackable { /** * 会叫对象集合 */ private ArrayList&lt;Quackable> quackers = new ArrayList&lt;>(); /** * 向集合中添加会叫的对象 * @param quacker 会叫的对象 */ public void add(Quackable quacker) { quackers.add(quacker); } @Override public void quack() { // 此处使用了内置的迭代器。超级循环封装使用了集合和数组的迭代器。 for (Quackable quacker : quackers) { quacker.quack(); } } @Override public void registerObserver(Observer observer) { for (QuackObservable quacker : quackers) { quacker.registerObserver(observer); } } @Override public void notifyObservers() { for (QuackObservable quacker : quackers) { quacker.notifyObservers(); } } } 观察者具体实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 13:48 * @Description 观察者 */ public class Quackologist implements Observer { @Override public void update(QuackObservable duck) { System.out.println(\"正在呱呱叫的对象：\" + duck); } } 修改DuckSimulator中的simulate(BaseDuckFactory duckFactory)方法如下： /** * 模拟鸭子 * @param duckFactory 鸭子工厂 */ void simulate(BaseDuckFactory duckFactory) { Quackable redheadDuck = duckFactory.createRedheadDuck(); Quackable rubberDuck = duckFactory.createRubberDuck(); Quackable gooseDuck = new QuackCounter(new GooseAdapter(new Goose())); Flock flockOfDucks = new Flock(); flockOfDucks.add(redheadDuck); flockOfDucks.add(rubberDuck); flockOfDucks.add(gooseDuck); Quackologist quackologist = new Quackologist(); flockOfDucks.registerObserver(quackologist); simulate(flockOfDucks); System.out.println(\"叫声次数：\" + QuackCounter.getQuacks()); } MVC MVC即“模型-视图-控制器”(Model-View-Controller)是由数个模式结合起来而形成的新模式，三者关系如下： 视图：用来呈现模型。视图通常直接从模型中取得它需要显示的状态与数据。 控制器：取得用户的输入并解读其对模型的意思。 模型：模型持有所有的数据、状态和程序逻辑。模型没有注意到视图和控制器，虽然它提供了操纵和检索状态的接口，并发送状态改变通知给观察者。 应用到的设计模式：策略模式、观察者模式和组合模式。(此处将视图想象为GUI组件比较容易理解) 策略模式：视图可以视为一个显示信息的窗口，上面有很多模块，每个模块可能对应一个控制器。当按下某一个模块上的某个按钮时，便请求该模块对应的控制器调用相应的方法或模型处理。视图可以组合各种控制器。 观察者模式：模型实现了观察者模式，当模型状态改变时，相关对象将持续更新。也就是说当模型数据更新时，一个模型所使用到的多个视图(或是控制器)都会自动更新。 组合模式：显示包括了窗口、按钮、文本标签等。每个显示组件不是组合节点(窗口)，就是叶节点(按)。当控制器返回用户请求结果信息时，只需通知最顶层窗口即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之代理模式","date":"2020-03-17T01:49:06.000Z","path":"posts/907a70d0/","text":"代理模式 代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。 代理模式UML类图：Proxy持有RealSubject的引用。客户和RealSubject的交互都必须通过Proxy。因为Proxy和RealSubject实现相同的接口，所以任何用到RealSubject的地方都可以用Proxy取代。Proxy也控制了对RealSubject的访问。 远程代理 远程代理控制访问远程对象。 远程代理可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。JAVA中常用RMI进行远程方法调用。RMI生成stub充当代理，其运行流程为客户对象→stub→skeleton→服务对象，然后从服务对象依次返回到客户对象。 代码演示： Subject和RealSubject。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 15:49 * @Description 商店接口 */ public interface Store extends Remote { /** * 列出商店书籍 * * @return 书籍 * @throws RemoteException rmi异常 */ String bookList() throws RemoteException; } /** * @Author 喵粮都输光了 * @Date 2020/3/17 15:50 * @Description 商店实现类(实际工作的类) */ public class StoreImpl extends UnicastRemoteObject implements Store { public StoreImpl() throws RemoteException { // UnicastRemoteObject提供了一些远程功能 // 超类UnicastRemoteObject调用I/O，网络可能产生RemoteException异常，子类需要将其抛出 } @Override public String bookList() { return \"《西游记》、《三国演义》\"; } } 注册服务对象至rmi。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 15:55 * @Description 将StoreImpl服务注册入rmi的registry */ public class ServiceTestDrive { public static void main(String[] args) { try { Store store = new StoreImpl(); // 通过Naming的rebind方法将对象注册入rmi的registry中。 Naming.rebind(\"store\", store); } catch (Exception e) { e.printStackTrace(); } } } 客户对象。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 15:57 * @Description 客户端测试 */ public class Main { public static void main(String[] args) { try { // 通过Naming的lookup方法在rmi的registry中查找注册在其中的对象并返回。 Store store = (Store) Naming.lookup(\"rmi://127.0.0.1/store\"); // 调用该对象的方法，rmi会请求真实的StoreImpl并将结果打包返回。 String books = store.bookList(); System.out.println(books); } catch (Exception e) { e.printStackTrace(); } } } 运行时，需要命令行进入java的class文件生成目录下运行rmiregistry，打开注册服务。否则rebind方法会失败，然后将需要调用的对象注册入registry中，在运行客户端。 保护代理 保护代理基于权限控制对资源的访问。 利用JAVA动态代理创建保护代理。设计一个person，拥有姓名、性别和评分。创建两代理：1.类拥有者能设置自己的姓名、性别等，但不能给自己打分。2.非类拥有者能进行打分，但是不能设置别人的其他属性。 代码演示： 接口类及其具体实现类 /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:05 * @Description 人接口 */ public interface PersonBean { /** * 获得姓名 * @return 姓名 */ String getName(); /** * 获得性别 * @return 性别 */ String getGender(); /** * 获得评分 * @return 评分 */ int getHotOrNotRating(); /** * 设置姓名 * @param name 姓名 */ void setName(String name); /** * 设置性别 * @param gender 性别 */ void setGender(String gender); /** * 设置评分 * @param rating 评分 */ void setHotOrNotRating(int rating); } /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:09 * @Description 人实体实现 */ public class PersonBeanImpl implements PersonBean { /** * 姓名 */ private String name; /** * 性别 */ private String gender; /** * 评分 */ private int rating; /** * 评价人数 */ private int ratingCount = 0; @Override public String getName() { return name; } @Override public String getGender() { return gender; } @Override public int getHotOrNotRating() { if (ratingCount == 0) { return 0; } return rating / ratingCount; } @Override public void setName(String name) { this.name = name; } @Override public void setGender(String gender) { this.gender = gender; } @Override public void setHotOrNotRating(int rating) { this.rating += rating; ratingCount++; } } 代理行为。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:20 * @Description 拥有者代理，自己不能设置自己的评分 */ public class OwnerInvocationHandler implements InvocationHandler { private PersonBean personBean; private final static String SET_RATING = \"setHotOrNotRating\"; public OwnerInvocationHandler(PersonBean personBean) { this.personBean = personBean; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (SET_RATING.equals(method.getName())) { // 如果是自己评价自己不允许 throw new IllegalAccessException(); } else { // 否则都允许 return method.invoke(personBean, args); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:20 * @Description 非拥有者代理，只能打分不能修改其他的 */ public class NonOwnerInvocationHandler implements InvocationHandler { private PersonBean personBean; private final static String SET = \"set\"; private final static String SET_RATING = \"setHotOrNotRating\"; public NonOwnerInvocationHandler(PersonBean personBean) { this.personBean = personBean; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName().startsWith(SET)) { if (SET_RATING.equals(method.getName())) { // 如果是打分允许 return method.invoke(personBean, args); } else { // 其他修改不允许 throw new IllegalAccessException(); } } else { return method.invoke(personBean, args); } } } 测试。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:04 * @Description 测试 */ public class Main { public static void main(String[] args) { PersonBean personBean = new PersonBeanImpl(); PersonBean owner = getOwnerProxy(personBean); PersonBean nonOwner = getNonOwnerProxy(personBean); owner.setHotOrNotRating(1); nonOwner.setGender(\"男\"); } /** * 获取拥有者代理 * @param personBean 代理对象 * @return 拥有者代理 */ public static PersonBean getOwnerProxy(PersonBean personBean) { return (PersonBean) Proxy.newProxyInstance(personBean.getClass().getClassLoader(), personBean.getClass().getInterfaces(), new OwnerInvocationHandler(personBean)); } /** * 获取非拥有者代理 * @param personBean 代理对象 * @return 非拥有者代理 */ public static PersonBean getNonOwnerProxy(PersonBean personBean) { return (PersonBean) Proxy.newProxyInstance(personBean.getClass().getClassLoader(), personBean.getClass().getInterfaces(), new NonOwnerInvocationHandler(personBean)); } } 虚拟代理 虚拟代理控制访问创建开销大的资源。 虚拟代理作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来边沿对象的替身。对象创建后，代理就会将请求直接委托给对象。 使用场景：需求GUI加载图片，图片未被加载时候显示文字图片加载中，图片加载完成时替换文字图片加载中为实际的图片。此时可以设计一个代理类，传入图片加载类，首先为程序显示文字图片加载中，然后创建线程调用图片加载方法(防止程序等待图片加载返回被挂起)，等图片加载方法返回了图片时，将显示的文字图片加载中替换成真正的图片即可。 其他变种代理 防火墙代理(Firewall Proxy)：控制网络资源的访问，保护主题免于“坏客户”的侵害。常用于公司的防火墙系统。 智能引用代理(Smart Reference Proxy)：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。 缓存代理(Caching Proxy)：为开销大的运算结果提供暂时存储，它也允许多个客户共享结果，以减少计算或网络延迟。常用于Web服务器代理，以及内容管理与出版系统。 同步代理(Synchronization Proxy)：在多线程的情况下为主题提供安全的访问。常用于为分散式环境内的潜在对象集合提供同步访问控制，例如JavaSpaces。 复杂隐藏代理(Complexity Hiding Proxy)：用来隐藏一个类的复杂集合的复杂度，并进行访问控制。也被称为外观代理。 写入时复制代理(Copy-On-Write Proxy)：用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。这是虚拟代理的变体。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之状态模式","date":"2020-03-16T01:38:00.000Z","path":"posts/61e067b6/","text":"状态模式 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 状态模式UML类图： 原型 需求：设计一个状态机具有如下功能并测试。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/16 10:24 * @Description 糖果机（状态机） */ public class GumballMachine { /** * 售空状态 */ private final static int SOLD_OUT = 0; /** * 未投入钱状态，有库存 */ private final static int NO_QUARTER = 1; /** * 已投入钱状态 */ private final static int HAS_QUARTER = 2; /** * 出售状态 */ private final static int SOLD = 3; /** * 当前状态，默认售空 */ private int state = SOLD_OUT; /** * 糖果库存 */ private int count; public GumballMachine(int count) { this.count = count; if (count > 0) { // 糖果库存大于0，设置为未投入钱状态 state = NO_QUARTER; } } /** * 投钱。 */ public void insertQuarter() { if (state == HAS_QUARTER) { System.out.println(\"投钱失败，已存在投入的钱。\"); } else if (state == NO_QUARTER) { state = HAS_QUARTER; System.out.println(\"投钱成功。\"); } else if (state == SOLD_OUT) { System.out.println(\"投钱失败，没有库存了。\"); } else if (state == SOLD) { System.out.println(\"投钱失败，正在出售请稍等。\"); } } /** * 退钱。 */ public void ejectQuarter() { if (state == HAS_QUARTER) { state = NO_QUARTER; System.out.println(\"退钱成功。\"); } else if (state == NO_QUARTER) { System.out.println(\"退钱失败，未投入钱。\"); } else if (state == SOLD_OUT) { System.out.println(\"退钱失败，未投入钱。\"); } else if (state == SOLD) { System.out.println(\"退钱失败，正在出售请稍等。\"); } } /** * 转动曲柄购买糖果。 */ public void turnCrank() { if (state == HAS_QUARTER) { state = SOLD; System.out.println(\"转动曲柄成功。\"); dispense(); } else if (state == NO_QUARTER) { System.out.println(\"转动曲柄失败，未投入钱。\"); } else if (state == SOLD_OUT) { System.out.println(\"转动曲柄失败，没有库存了。\"); } else if (state == SOLD) { System.out.println(\"转动曲柄失败，正在出售请稍等。\"); } } /** * 发放糖果。 */ private void dispense() { if (state == SOLD) { System.out.println(\"发放糖果成功。\"); count--; if (count == 0) { state = SOLD_OUT; System.out.println(\"糖果售空了。\"); } else { state = NO_QUARTER; } } else if (state == NO_QUARTER) { System.out.println(\"发放糖果失败，请先投钱。\"); } else if (state == SOLD_OUT) { System.out.println(\"发放糖果失败。\"); } else if (state == HAS_QUARTER) { System.out.println(\"发放糖果失败。\"); } } @Override public String toString() { return \"目前糖果库存\" + count; } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 10:55 * @Description 测试 */ public class Main { public static void main(String[] args) { GumballMachine gumballMachine = new GumballMachine(5); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.ejectQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.ejectQuarter(); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); } } 增加新状态 问题：当需要增加新状态时，上面的程序需要修改所有包含状态的方法并且新增状态，极难维护。 解决：对变化的状态进行封装，使一个状态对应一个类，再使用组合的方法再当前状态中组合所需状态即可。其UML图如下： 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:24 * @Description 状态接口 */ public interface State { /** * 投钱。 */ void insertQuarter(); /** * 退钱。 */ void ejectQuarter(); /** * 转动曲柄购买糖果。 */ void turnCrank(); /** * 发放糖果。 */ void dispense(); } import java.util.Random; /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:27 * @Description 已投入钱状态 */ public class HasQuarterState implements State { private GumballMachine gumballMachine; private Random randomWinner = new Random(System.currentTimeMillis()); public HasQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\"投钱失败，已存在投入的钱。\"); } @Override public void ejectQuarter() { gumballMachine.setState(gumballMachine.getNoQuarterState()); System.out.println(\"退钱成功。\"); } @Override public void turnCrank() { int winner = randomWinner.nextInt(10); if ((winner == 0) &amp;&amp; (gumballMachine.getCount() > 1)) { gumballMachine.setState(gumballMachine.getWinnerState()); } else { gumballMachine.setState(gumballMachine.getSoldState()); } System.out.println(\"转动曲柄成功。\"); } @Override public void dispense() { System.out.println(\"发放糖果失败。\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:27 * @Description 未投入钱状态 */ public class NoQuarterState implements State { private GumballMachine gumballMachine; public NoQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { gumballMachine.setState(gumballMachine.getHasQuarterState()); System.out.println(\"投钱成功。\"); } @Override public void ejectQuarter() { System.out.println(\"退钱失败，未投入钱。\"); } @Override public void turnCrank() { System.out.println(\"转动曲柄失败，未投入钱。\"); } @Override public void dispense() { System.out.println(\"发放糖果失败，请先投钱。\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:27 * @Description 售空状态 */ public class SoldOutState implements State { private GumballMachine gumballMachine; public SoldOutState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\"投钱失败，没有库存了。\"); } @Override public void ejectQuarter() { System.out.println(\"退钱失败，未投入钱。\"); } @Override public void turnCrank() { System.out.println(\"转动曲柄失败，没有库存了。\"); } @Override public void dispense() { System.out.println(\"发放糖果失败。\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:27 * @Description 出售状态 */ public class SoldState implements State { private GumballMachine gumballMachine; public SoldState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\"投钱失败，正在出售请稍等。\"); } @Override public void ejectQuarter() { System.out.println(\"退钱失败，正在出售请稍等。\"); } @Override public void turnCrank() { System.out.println(\"转动曲柄失败，正在出售请稍等。\"); } @Override public void dispense() { gumballMachine.releaseBall(); if (gumballMachine.getCount() > 0) { gumballMachine.setState(gumballMachine.getNoQuarterState()); } else { gumballMachine.setState(gumballMachine.getSoldOutState()); System.out.println(\"糖果售空了。\"); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 13:25 * @Description 中奖状态 */ public class WinnerState implements State { private GumballMachine gumballMachine; public WinnerState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\"投钱失败，正在出售请稍等。\"); } @Override public void ejectQuarter() { System.out.println(\"退钱失败，正在出售请稍等。\"); } @Override public void turnCrank() { System.out.println(\"转动曲柄失败，正在出售请稍等。\"); } @Override public void dispense() { System.out.println(\"恭喜中奖，你将多获得一颗糖。\"); gumballMachine.releaseBall(); if (gumballMachine.getCount() == 0) { gumballMachine.setState(gumballMachine.getSoldOutState()); } else { gumballMachine.releaseBall(); if (gumballMachine.getCount() > 0) { gumballMachine.setState(gumballMachine.getNoQuarterState()); } else { gumballMachine.setState(gumballMachine.getSoldOutState()); System.out.println(\"糖果售空了。\"); } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:48 * @Description 糖果机（状态机） */ public class GumballMachine { /** * 售空状态 */ private State soldOutState; /** * 出售状态 */ private State soldState; /** * 未投入钱状态 */ private State noQuarterState; /** * 已投入钱状态 */ private State hasQuarterState; /** * 中奖状态 */ private State winnerState; /** * 当前状态，默认售空 */ private State state; /** * 糖果库存 */ private int count; public GumballMachine(int count) { soldOutState = new SoldOutState(this); soldState = new SoldState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); winnerState = new WinnerState(this); state = soldOutState; this.count = count; if (count > 0) { state = noQuarterState; } } /** * 投钱。 */ public void insertQuarter() { state.insertQuarter(); } /** * 退钱。 */ public void ejectQuarter() { state.ejectQuarter(); } /** * 转动曲柄购买糖果。 */ public void turnCrank() { state.turnCrank(); state.dispense(); } /** * 发放糖果。 */ void releaseBall() { System.out.println(\"发放糖果成功。\"); if (count != 0) { count--; } } /** * 填充糖果库存。 */ void refill(int count) { this.count = count; state = noQuarterState; } public State getSoldOutState() { return soldOutState; } public State getSoldState() { return soldState; } public State getNoQuarterState() { return noQuarterState; } public State getHasQuarterState() { return hasQuarterState; } public State getWinnerState() { return winnerState; } public int getCount() { return count; } void setState(State state) { this.state = state; } public State getState() { return state; } @Override public String toString() { return \"目前糖果库存\" + count; } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 10:55 * @Description 测试 */ public class Main { public static void main(String[] args) { GumballMachine gumballMachine = new GumballMachine(5); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之迭代器模式与组合模式","date":"2020-03-15T02:16:31.000Z","path":"posts/f8e48b7d/","text":"迭代器模式 迭代器模式提供一种方法顺序访问一个聚合(集合)对象中的各个元素，而又不暴露其内部的表示。 设计原则：一个类应该只有一个引起变化的原因，即单一责任。 迭代器模式UML类图： 迭代器模式原型 当不同类型的集合在遍历时需要使用不同的循环进行遍历，迭代器模式便是抽取遍历的部分进行封装，因此只需一个循环即可多态的处理任何集合项。 案例：两个菜单项，一个返回数组一个返回ArrayList，此时需要两个循环进行遍历，通过iterator进行封装使用一个循环遍历两个不同集合。其UML图如下： 代码演示：此处使用java自带的iterator（也可以自己设计一个iterator接口包含hasNext()和next()方法即可。） 1.菜单项。 /** * @Author 喵粮都输光了 * @Date 2020/3/15 14:45 * @Description 菜单项 */ public class MenuItem { /** * 菜名 */ private String name; /** * 是否是素菜 */ private boolean vegetarian; /** * 菜价 */ private double price; public MenuItem(String name, boolean vegetarian, double price) { this.name = name; this.vegetarian = vegetarian; this.price = price; } public String getName() { return name; } public boolean isVegetarian() { return vegetarian; } public double getPrice() { return price; } } 2.早餐(ArrayList)和晚餐(数组)，因为ArrayList JAVA实现过iterator可以不用管，数组没有实现iterator，需要继承JAVA的iterator接口自己实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:20 * @Description 创建菜单迭代器接口 */ public interface Menu { /** * 创建菜单迭代器 * @return 菜单迭代器 */ Iterator&lt;MenuItem> createIterator(); } /** * @Author 喵粮都输光了 * @Date 2020/3/15 14:48 * @Description 早餐菜单，ArrayList方式 */ public class BreakfastMenu implements Menu { private ArrayList&lt;MenuItem> menuItems; public BreakfastMenu() { menuItems = new ArrayList&lt;>(); addItem(\"鸡蛋\", true, 1); addItem(\"牛奶\", false, 3); addItem(\"皮蛋瘦肉粥\", false, 10); } /** * 增加菜单项 * @param name 菜名 * @param vegetarian 是否素菜 * @param price 价格 */ public void addItem(String name, boolean vegetarian, double price) { MenuItem menuItem = new MenuItem(name, vegetarian, price); menuItems.add(menuItem); } @Override public Iterator&lt;MenuItem> createIterator() { return menuItems.iterator(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 14:49 * @Description 晚餐菜单，数组方式 */ public class DinnerMenu implements Menu { /** * 菜单最大存储菜单项 */ private static final int MAX_ITEMS = 6; /** * 已存储菜单项 */ private int numberOfItems = 0; private MenuItem[] menuItems; public DinnerMenu() { menuItems = new MenuItem[MAX_ITEMS]; addItem(\"小炒肉\", false, 8); addItem(\"大鸡腿\", false, 7); addItem(\"青菜\", true, 3); } /** * 增加菜单项 * @param name 菜名 * @param vegetarian 是否素菜 * @param price 价格 */ public void addItem(String name, boolean vegetarian, double price) { MenuItem menuItem = new MenuItem(name, vegetarian, price); if (numberOfItems >= MAX_ITEMS) { System.err.println(\"菜单满了，不能再添加菜单项了。\"); } else { menuItems[numberOfItems] = menuItem; numberOfItems++; } } @Override public Iterator&lt;MenuItem> createIterator() { return new DinnerMenuIterator(menuItems); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:29 * @Description 晚餐菜单迭代器 */ public class DinnerMenuIterator implements Iterator&lt;MenuItem> { private int position = 0; private MenuItem[] menuItems; public DinnerMenuIterator(MenuItem[] menuItems) { this.menuItems = menuItems; } @Override public boolean hasNext() { return position &lt; menuItems.length &amp;&amp; menuItems[position] != null; } @Override public MenuItem next() { return menuItems[position++]; } @Override public void remove() { throw new UnsupportedOperationException(\"不支持删除操作。\"); } } 3.对两个菜单进行打印。 /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:14 * @Description 女招待，用于打印菜单 */ public class Waitress { private ArrayList&lt;Iterator&lt;MenuItem>> menus; public Waitress(ArrayList&lt;Iterator&lt;MenuItem>> menus) { this.menus = menus; } /** * 打印菜单 */ public void printMenu() { Iterator&lt;Iterator&lt;MenuItem>> menuIterator = menus.iterator(); while (menuIterator.hasNext()) { Iterator&lt;MenuItem> menu = menuIterator.next(); printMenu(menu); } /* 可用将上面的代码替换成如下： * 超级for可用在一个集合或者一个数组中遍历，无需显示创建迭代器。 * for (Iterator&lt;MenuItem> menu : menus) { printMenu(menu); } */ } /** * 根据传入的iterator打印菜单 * @param menuIterator 菜单iterator */ private void printMenu(Iterator&lt;MenuItem> menuIterator) { while (menuIterator.hasNext()) { MenuItem menuItem = menuIterator.next(); System.out.println(menuItem.getName() + \", \" + menuItem.getPrice()); } } } 4.测试。 /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:07 * @Description 测试 */ public class Main { public static void main(String[] args) { BreakfastMenu breakfastMenu = new BreakfastMenu(); DinnerMenu dinnerMenu = new DinnerMenu(); ArrayList&lt;Iterator&lt;MenuItem>> menus = new ArrayList&lt;>(); menus.add(breakfastMenu.createIterator()); menus.add(dinnerMenu.createIterator()); Waitress waitress = new Waitress(menus); waitress.printMenu(); } } 组合模式 组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。说白了组合模式就是对树形结构的一种遍历。 组合模式UML类图： 组合模式原型 需求：此时需要为晚餐菜单增加子菜单甜点，也就是说打印方法还需要打印菜单中的菜单。可用通过组合模式的方法，将菜单和菜单项视作同一个整体进行遍历。其UML图如下： 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/15 16:40 * @Description 菜单组件提供了菜单项和菜单所需的操作。 */ public abstract class BaseMenuComponent { /** * 新增菜单组件 * @param menuComponent 菜单组件 */ public void add(BaseMenuComponent menuComponent) { throw new UnsupportedOperationException(); } /** * 删除菜单组件 * @param menuComponent 菜单组件 */ public void remove(BaseMenuComponent menuComponent) { throw new UnsupportedOperationException(); } /** * 获取菜单组件 * @param i 下标 * @return 菜单组件 */ public BaseMenuComponent getChild(int i) { throw new UnsupportedOperationException(); } /** * 获取菜单或菜名字 * @return 菜名或菜单名 */ public String getName() { throw new UnsupportedOperationException(); } /** * 获取菜单或菜介绍 * @return 菜介绍或者菜单介绍 */ public String getDescription() { throw new UnsupportedOperationException(); } /** * 获取菜价 * @return 菜价 */ public double getPrice() { throw new UnsupportedOperationException(); } /** * 菜是否是素菜 * @return true or false */ public boolean isVegetarian() { throw new UnsupportedOperationException(); } /** * 打印菜单或者菜 */ public void print() { throw new UnsupportedOperationException(); } /** * 创建迭代器 * @return 迭代器 */ public Iterator&lt;BaseMenuComponent> createIterator() { throw new UnsupportedOperationException(); } /** * 返回list * @return list */ public List&lt;BaseMenuComponent> getMenuComponentList() { throw new UnsupportedOperationException(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 17:23 * @Description 菜单迭代器 */ public class CompositeIterator implements Iterator&lt;BaseMenuComponent> { private Stack&lt;Iterator&lt;BaseMenuComponent>> stack = new Stack&lt;>(); public CompositeIterator(Iterator&lt;BaseMenuComponent> iterator) { stack.push(iterator); } @Override public boolean hasNext() { if (stack.empty()) { return false; } else { Iterator&lt;BaseMenuComponent> iterator = stack.peek(); if (!iterator.hasNext()) { stack.pop(); return hasNext(); } else { return true; } } } @Override public BaseMenuComponent next() { if (hasNext()) { Iterator&lt;BaseMenuComponent> iterator = stack.peek(); BaseMenuComponent component = iterator.next(); if (component instanceof Menu) { stack.push(component.getMenuComponentList().iterator()); } return component; } else { return null; } } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 16:56 * @Description 菜单（组合） */ public class Menu extends BaseMenuComponent { private ArrayList&lt;BaseMenuComponent> menuComponents = new ArrayList&lt;>(); private String name; private String description; public Menu(String name, String description) { this.name = name; this.description = description; } @Override public void add(BaseMenuComponent menuComponent) { menuComponents.add(menuComponent); } @Override public void remove(BaseMenuComponent menuComponent) { menuComponents.remove(menuComponent); } @Override public BaseMenuComponent getChild(int i) { return menuComponents.get(i); } @Override public String getName() { return name; } @Override public String getDescription() { return description; } @Override public void print() { System.out.println(\"------------------------\\n\" + getName() + \", \" + getDescription()); // 还需要打印该子菜单中的菜或者是子子菜单。 for (BaseMenuComponent menuComponent : menuComponents) { menuComponent.print(); } } @Override public Iterator&lt;BaseMenuComponent> createIterator() { return new CompositeIterator(menuComponents.iterator()); } @Override public List&lt;BaseMenuComponent> getMenuComponentList() { return menuComponents; } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 14:45 * @Description 菜单项（叶子） */ public class MenuItem extends BaseMenuComponent { /** * 菜名 */ private String name; /** * 是否是素菜 */ private boolean vegetarian; /** * 菜价 */ private double price; /** * 菜介绍 */ private String description; public MenuItem(String name, boolean vegetarian, double price, String description) { this.name = name; this.vegetarian = vegetarian; this.price = price; this.description = description; } @Override public String getDescription() { return description; } @Override public String getName() { return name; } @Override public double getPrice() { return price; } @Override public boolean isVegetarian() { return vegetarian; } @Override public void print() { System.out.println(getName() + \", 是素菜吗？\" + isVegetarian() + \", \" + getPrice()); } @Override public Iterator&lt;BaseMenuComponent> createIterator() { // 菜单项是叶子不需要再遍历了 return new NullIterator(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:54 * @Description 空迭代器 */ public class NullIterator implements Iterator&lt;BaseMenuComponent> { @Override public boolean hasNext() { return false; } @Override public Object next() { return null; } @Override public void remove() { throw new UnsupportedOperationException(\"不支持删除操作。\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:14 * @Description 女招待，用于打印菜单 */ public class Waitress { private BaseMenuComponent allMenus; public Waitress(BaseMenuComponent allMenus) { this.allMenus = allMenus; } /** * 打印所有菜单项 */ public void printMenu() { allMenus.print(); } /** * 输出所有素菜菜单项 */ public void printVegetarianMenu() { Iterator&lt;BaseMenuComponent> iterator = allMenus.createIterator(); while (iterator.hasNext()) { BaseMenuComponent menuComponent = iterator.next(); try { if (menuComponent.isVegetarian()) { menuComponent.print(); } } catch (UnsupportedOperationException ignored) { } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:07 * @Description 测试 */ public class Main { public static void main(String[] args) { BaseMenuComponent allMenus = new Menu(\"总菜单\", \"总菜单介绍\"); BaseMenuComponent breakfastMenu = new Menu(\"早餐\", \"早餐介绍\"); BaseMenuComponent dinnerMenu = new Menu(\"晚餐\", \"晚餐介绍\"); BaseMenuComponent dessertMenu = new Menu(\"晚餐后甜点\", \"晚餐后甜点介绍\"); breakfastMenu.add(new MenuItem(\"鸡蛋\", true, 1, \"鸡蛋早餐\")); breakfastMenu.add(new MenuItem(\"牛奶\", false, 3, \"牛奶早餐\")); dinnerMenu.add(new MenuItem(\"小炒肉\", false, 8, \"小炒肉晚餐\")); dinnerMenu.add(new MenuItem(\"大鸡腿\", false, 7, \"大鸡腿晚餐\")); dessertMenu.add(new MenuItem(\"大西瓜\", true, 20, \"西瓜甜点\")); dinnerMenu.add(dessertMenu); allMenus.add(breakfastMenu); allMenus.add(dinnerMenu); Waitress waitress = new Waitress(allMenus); waitress.printMenu(); waitress.printVegetarianMenu(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之模板方法模式","date":"2020-03-14T05:07:55.000Z","path":"posts/6948162f/","text":"模板方法模式 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 设计原则：别调用我们，我们会调用你，即好莱坞原则。也就是说高层组件控制何时以及如何使用底层组件，底层组件可以参与计算但不能直接调用高层组件（不绝对），防止低层组件依赖高层组件，高层组件又依赖底层组件的情况发生。 模板方法模式UML类图： 原型 需求：设计一个咖啡类，其中有一个方法可以进行咖啡的冲泡（1.煮沸水；2.冲泡咖啡；3.倒入杯子；4.加糖和牛奶）；设计一个茶类，其中有一个方法可以进行茶的冲泡（1.煮沸水；2.浸泡茶叶；3.倒入杯子；4.加柠檬）。这两个类都有相同的步骤1和3，对步骤2和4进行更高层抽象可以笼统为步骤2冲泡和步骤4加调料。再在抽象类中增加对饮料制作步骤的控制方法就是模板方法的原形了。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:11 * @Description 咖啡因饮料 */ public abstract class BaseCaffeineBeverage { /** * 进行饮料冲泡，固定步骤防止被子类覆盖 */ final void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } /** * 煮沸水，固定方法防止被子类覆盖 */ protected final void boilWater() { System.out.println(\"煮沸水\"); } /** * 冲泡 */ protected abstract void brew(); /** * 倒入杯子，固定方法防止被子类覆盖 */ protected final void pourInCup() { System.out.println(\"倒入杯子\"); } /** * 增加佐料 */ protected abstract void addCondiments(); } /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 咖啡类 */ public class Coffee extends BaseCaffeineBeverage { @Override protected void brew() { System.out.println(\"冲泡咖啡\"); } @Override protected void addCondiments() { System.out.println(\"添加糖和牛奶\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 茶叶类 */ public class Tea extends BaseCaffeineBeverage { @Override protected void brew() { System.out.println(\"浸泡茶叶\"); } @Override protected void addCondiments() { System.out.println(\"加柠檬\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 测试 */ public class Main { public static void main(String[] args) { Coffee coffee = new Coffee(); coffee.prepareRecipe(); Tea tea = new Tea(); tea.prepareRecipe(); } } 增加钩子 需求：饮料中的调料需要根据客户的需求选择添加或不添加。 解决：使用钩子，钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩，是否需要挂钩则由子类自行决定。 代码演示： 修改BaseCaffeineBeverage类，因为添加调料方法是可选的，将其更改为钩子。 /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:11 * @Description 咖啡因饮料 */ public abstract class BaseCaffeineBeverage { /** * 进行饮料冲泡，固定步骤防止被子类覆盖 */ final void prepareRecipe() { boilWater(); brew(); pourInCup(); if (customerWantsCondiments()) { addCondiments(); } } /** * 煮沸水，固定方法防止被子类覆盖 */ protected final void boilWater() { System.out.println(\"煮沸水\"); } /** * 冲泡 */ protected abstract void brew(); /** * 倒入杯子，固定方法防止被子类覆盖 */ protected final void pourInCup() { System.out.println(\"倒入杯子\"); } /** * 增加佐料 */ protected abstract void addCondiments(); /** * 客户是否需要添加调料，默认添加 * @return true */ protected boolean customerWantsCondiments() { return true; } } 以咖啡类为例，修改方法。 import java.util.Scanner; /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 咖啡类 */ public class Coffee extends BaseCaffeineBeverage { /** * 用户输入首字母判断是否为y */ private final static String YES = \"y\"; @Override protected void brew() { System.out.println(\"冲泡咖啡\"); } @Override protected void addCondiments() { System.out.println(\"添加糖和牛奶\"); } /** * 根据客户对调料的需求覆写该方法，则可以不覆盖默认客户需要调料。 * @return true or false */ @Override protected boolean customerWantsCondiments() { String answer = getUserInput(); return answer.toLowerCase().startsWith(YES); } /** * 获取用户输入 * @return 用户输入 */ private String getUserInput() { System.out.println(\"是否需要添加牛奶和糖？(y/n)\"); Scanner scanner = new Scanner(System.in); String answer = scanner.next(); scanner.close(); return answer; } } 进行测试。 /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 测试 */ public class Main { public static void main(String[] args) { Coffee coffee = new Coffee(); coffee.prepareRecipe(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之适配器模式与外观模式","date":"2020-03-13T06:12:37.000Z","path":"posts/aa979c82/","text":"适配器模式 适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 使用场景：当需要使用一个现有的类而其接口并不符合你的需求时，就使用适配器。 对象适配器模式 对象适配器模式通过组合的方式实现适配器模式，比类适配器模式更灵活。其UML类图如下： 代码演示： 有一个鸭子类。 /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:55 * @Description 鸭子接口 */ public interface Duck { /** * 鸭子呱呱叫 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:57 * @Description 绿头鸭 */ public class MallardDuck implements Duck { @Override public void quack() { System.out.println(\"呱呱叫\"); } } 有一个火鸡类。 /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:55 * @Description 火鸡接口 */ public interface Turkey { /** * 火鸡咯咯叫 */ void gobble(); } /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:58 * @Description 野生火鸡 */ public class WildTurkey implements Turkey { @Override public void gobble() { System.out.println(\"咯咯叫\"); } } 将火鸡包装成鸭子并测试。 /** * @Author 喵粮都输光了 * @Date 2020/3/13 15:00 * @Description 火鸡适配器，火鸡→鸭子 */ public class TurkeyAdapter implements Duck { private Turkey turkey; TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } @Override public void quack() { turkey.gobble(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:59 * @Description 测试 */ public class Main { public static void main(String[] args) { // 鸭子 Duck duck = new MallardDuck(); duck.quack(); // 火鸡 Turkey turkey = new WildTurkey(); turkey.gobble(); // 将需要转换的火鸡变成鸭子 Duck turkeyAdapter = new TurkeyAdapter(turkey); turkeyAdapter.quack(); } } 类适配器模式 类适配器模式：通过继承的方式实现适配器模式。其UML类图如下： 代码演示（JAVA不支持多继承此处使用python）： class Duck: @staticmethod def quack(): print(\"呱呱叫\") class Turkey: @staticmethod def gobble(): print(\"咯咯叫\") class TurkeyAdapter(Duck, Turkey): def quack(self): self.gobble() if __name__ == '__main__': duck = Duck() duck.quack() turkey = Turkey() turkey.gobble() turkeyAdapter = TurkeyAdapter() turkeyAdapter.quack() 外观模式 外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 使用场景：当需要简化并统一一个很大的接口或者一群复杂的接口时，就使用外观模式。 设计原则：只和你的密友谈话，即最少知识原则。也就是说在对象的方法内调用属于一下范围的方法： 该对象本身。 被当作方法的参数而传递进来的对象。 此方法所创建或实例化的任何对象。 对象的任何组件，也就是构造方法传入的参数或对象。 最好不要使用对象的方法的方法所返回的值。当然不需要完全遵守，因为实现最少知识原则虽然减少了对象之间的依赖方便维护，但是导致系统复杂度和开发时间的增加并降低了运行时的性能。 外观模式可以这么来看。当有一批操作经常需要一起进行时，也就是说我想完成一个操作，而这个操作需要调用类A的a方法，类B的bc方法，类C…等等。这时候可以创建一个外观（类），在构造参数中传入每一个使用到的组件并把它们赋值给相应的实例变量，然后创建方法，在方法中执行之前所需执行的一系列操作。这样就使用上了外观模式，外观模式将客户从复杂的子系统中解耦。 外观模式UML类图： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之命令模式","date":"2020-03-12T05:30:23.000Z","path":"posts/933830c7/","text":"命令模式 命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。常用于队列请求（命令对象排队进行处理）和日志请求（所有操作记录于日志中，系统死机时可以按照日志恢复）。 命令模式UML类图： 原型设计一个遥控器，当按下遥控器上的按钮时，就会执行一个命令，例如打开风扇或关闭电灯。遥控器无需知道如何执行命令，只需要知道按下按钮即可完成命令。其实说白了就是将原来控制器直接调用具体方法变成了控制器调用命令对象，命令对象调用具体方法，有一个特别大的好处，就是控制器调用命令对象可以对一系列的方法进行操控，而不是像原来一个一个去new调用。代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 命令接口 */ public interface Command { /** * 命令执行 */ void execute(); } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:28 * @Description 开关门命令 */ public class DoorCommand implements Command { private Door door; DoorCommand(Door door) { this.door = door; } @Override public void execute() { if (door.getStatus() == 1) { door.off(); } else { door.on(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:22 * @Description 大门实体 */ public class Door { /** * 门关着 */ private static final int OFF = 0; /** * 门开着 */ private static final int ON = 1; /** * 门状态 */ private int status; Door() { status = OFF; } void off() { status = OFF; System.out.println(\"门关上了\"); } void on() { status = ON; System.out.println(\"门打开了\"); } int getStatus() { return status; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:15 * @Description 关灯命令 */ public class LightOffCommand implements Command { private Light light; LightOffCommand(Light light) { this.light = light; } @Override public void execute() { light.off(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启强光灯命令 */ public class LightOnStrongCommand implements Command { private Light light; LightOnStrongCommand(Light light) { this.light = light; } @Override public void execute() { light.strong(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启弱光灯命令 */ public class LightOnWeekCommand implements Command { private Light light; LightOnWeekCommand(Light light) { this.light = light; } @Override public void execute() { light.week(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:16 * @Description 灯实体 */ public class Light { /** * 强光 */ private static final int STRONG = 2; /** * 弱光 */ private static final int WEEK = 1; /** * 关闭 */ private static final int OFF = 0; /** * 灯光亮度 */ private int luminance; Light() { luminance = OFF; } void strong() { luminance = STRONG; System.out.println(\"开启了强光灯\"); } void week() { luminance = WEEK; System.out.println(\"开启了弱光灯\"); } void off() { luminance = OFF; System.out.println(\"灯关了\"); } int getLuminance() { return luminance; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:32 * @Description 控制器实体，相当于invoker */ public class RemoteControl { /** * 控制器按钮多个 */ private Command[] button; RemoteControl() { // 按钮5个 button = new Command[5]; } /** * 将具体按钮与需要执行的命令绑定 * @param location 按钮位置 * @param command 命令 */ void setCommand(int location, Command command) { button[location] = command; } /** * 按下按钮执行命令 */ void buttonWasPressed(int location) { button[location].execute(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 测试 */ public class Main { public static void main(String[] args) { // 控制器 RemoteControl remoteControl = new RemoteControl(); // 需要操控的对象 Door door = new Door(); Light light = new Light(); // 命令需要有执行的对象 Command doorCommand = new DoorCommand(door); Command lightOnWeekCommand = new LightOnWeekCommand(light); Command lightOnStrongCommand = new LightOnStrongCommand(light); Command lightOffCommand = new LightOffCommand(light); // 控制器按钮绑定需要执行的命令 remoteControl.setCommand(0, doorCommand); remoteControl.setCommand(1, lightOnWeekCommand); remoteControl.setCommand(2, lightOnStrongCommand); remoteControl.setCommand(3, lightOffCommand); // 操作控制器 remoteControl.buttonWasPressed(0); remoteControl.buttonWasPressed(0); remoteControl.buttonWasPressed(1); remoteControl.buttonWasPressed(2); remoteControl.buttonWasPressed(3); } } 增加undo方法为命令模式实现撤销方法。代码演示：修改Command和其实现类，对于门只有开关两种状态，检测一下当前状态将其向反方向执行就是撤销了。对于有多种状态的对象例如灯有强光、弱光和关闭，则需要变量先对其进行记录才能进行撤销。 /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 命令接口 */ public interface Command { /** * 命令执行 */ void execute(); /** * 撤销上一条执行的命令 */ void undo(); } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:28 * @Description 开关门命令 */ public class DoorCommand implements Command { private Door door; DoorCommand(Door door) { this.door = door; } @Override public void execute() { if (door.getStatus() == 1) { door.off(); } else { door.on(); } } @Override public void undo() { execute(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 18:52 * @Description 灯光命令 */ public class LightCommand implements Command { private Light light; /** * 记录灯光亮度 */ private int luminance; LightCommand(Light light) { this.light = light; } @Override public void execute() { } @Override public void undo() { if (luminance == Light.OFF) { light.off(); } else if (luminance == Light.WEEK) { light.week(); } else if (luminance == Light.STRONG) { light.strong(); } } public Light getLight() { return light; } public void setLuminance(int luminance) { this.luminance = luminance; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启弱光灯命令 */ public class LightOnWeekCommand extends LightCommand { LightOnWeekCommand(Light light) { super(light); } @Override public void execute() { setLuminance(getLight().getLuminance()); getLight().week(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启强光灯命令 */ public class LightOnStrongCommand extends LightCommand { LightOnStrongCommand(Light light) { super(light); } @Override public void execute() { setLuminance(getLight().getLuminance()); getLight().strong(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:15 * @Description 关灯命令 */ public class LightOffCommand extends LightCommand { LightOffCommand(Light light) { super(light); } @Override public void execute() { setLuminance(getLight().getLuminance()); getLight().off(); } } 修改RemoteControl类，在控制器中新增变量用于记录上一条执行的命令就可以实现撤销功能了。 /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:32 * @Description 控制器实体，相当于invoker */ public class RemoteControl { /** * 控制器按钮多个 */ private Command[] button; /** * 记录上一个执行的命令 */ private Command undoCommand; RemoteControl() { button = new Command[5]; } /** * 将具体按钮与需要执行的命令绑定 * @param location 按钮位置 * @param command 命令 */ void setCommand(int location, Command command) { button[location] = command; } /** * 按下按钮执行命令 */ void buttonWasPressed(int location) { button[location].execute(); undoCommand = button[location]; } /** * 撤销按钮 */ void undoButtonWasPushed() { if (undoCommand != null) { undoCommand.undo(); } } } 修改测试类（带结果）。 // 操作控制器 //门打开了 remoteControl.buttonWasPressed(0); //门关上了 remoteControl.undoButtonWasPushed(); //开启了弱光灯 remoteControl.buttonWasPressed(1); //灯关了 remoteControl.undoButtonWasPushed(); //开启了强光灯 remoteControl.buttonWasPressed(2); //灯关了 remoteControl.buttonWasPressed(3); 使用宏命令同时执行多个命令，例如同时打开灯和门。以及撤销宏命令。 /** * @Author 喵粮都输光了 * @Date 2020/3/12 19:06 * @Description 宏命令 */ public class MacroCommand implements Command { private Command[] commands; MacroCommand(Command[] commands) { this.commands = commands; } @Override public void execute() { for (Command command : commands) { command.execute(); } } @Override public void undo() { for (Command command : commands) { command.undo(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 测试 */ public class Main { public static void main(String[] args) { RemoteControl remoteControl = new RemoteControl(); Door door = new Door(); Light light = new Light(); Command doorCommand = new DoorCommand(door); Command lightOnStrongCommand = new LightOnStrongCommand(light); Command[] commands = {doorCommand, lightOnStrongCommand}; MacroCommand macroCommand = new MacroCommand(commands); remoteControl.setCommand(0, macroCommand); remoteControl.buttonWasPressed(0); remoteControl.undoButtonWasPushed(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之单件模式","date":"2020-03-12T03:30:49.000Z","path":"posts/9b1fa808/","text":"单件模式 单件模式确保一个类只有一个实例，并提供一个全局访问点。 应用场景：有些对象其实只需要一个而不是多个，例如线程池、缓存、注册表、全局设置等。因此当需要确保程序中的某个类只有一个实例时，就可以采用单件模式。 原型该单件模式是延迟实例化模式。代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:27 * @Description 单件模式 */ public class Singleton { /** * getInstance静态方法中使用了该变量因此需要在变量上加static，确保唯一性。 */ private static Singleton uniqueInstance; /** * 禁止new创建 */ private Singleton() { } /** * 当实例未被创建时，uniqueInstance为空，创建一个实例返回，否则返回已创建的实例。 * 此处static是因为无法通过new创建实例则无法调用实例的方法。通过static关键字可以直接使用类名调用方法。 * @return Singleton */ public static Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:29 * @Description 测试 */ public class Main { public static void main(String[] args) { Singleton singleton = Singleton.getInstance(); System.out.println(singleton); } } 处理多线程 问题：原型的单例模式在多线程情况下可能会创建多个不同的实例。 解决1：为getInstance()增加关键字synchronized，但是会造成性能非常低的问题。如果getInstance()的性能对应用程序不是很关键这个方法足够使用了。 代码演示1： 修改原型的getInstance()如下即可。 public static synchronized Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } 解决2：使用急切实例化的方法，而不是使用延迟实例化的做法。如果程序在创建和运行时方面的负担不太繁重，这样会让JVM在加载这个类时马上创建出此唯一的单件实例，就不存在线程安全问题啦。 代码演示2： /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:27 * @Description 急切实例化的单件模式 */ public class Singleton { private static Singleton uniqueInstance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return uniqueInstance; } } 解决3：用“双重检查加锁”，在getInstance()中减少使用同步。这样做会先检查实例是否创建了，未创建才进行同步，这样保证只有第一次调用方法实例化时才会同步。 代码演示3： /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:27 * @Description 双重检查加锁的单件模式 */ public class Singleton { /** * volatile关键词确保当uniqueInstance变量被初始化成Singleton实例时，多个线程能正确地处理uniqueInstance变量。 */ private volatile static Singleton uniqueInstance = new Singleton(); private Singleton() { } /** * 此处判断两次是为了防止当多个线程通过了第一次判断之后，其中一个线程加锁进行了实例化之后解锁， * 另一个线程加锁进来又一次实例化之后解锁，导致实例化对象不同的情况。因此在锁内还需要判断一次。 * @return Singleton */ public static Singleton getInstance() { if (uniqueInstance == null) { synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之工厂模式","date":"2020-03-11T07:23:40.000Z","path":"posts/bf53f1b3/","text":"工厂模式 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。 抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 设计原则：要依赖抽象，不要依赖具体类，即依赖倒置原则。 应用场景： 简单工厂：将实例化具体类的代码进行了封装，实现了解耦操作。缺点也很明显，不利于扩展，需要创建对象数量众多时，工厂会比较臃肿。且每次修改都需要对源代码进行修改，违反了关闭修改的设计原则。 工厂方法：拥有简单工厂的优点，并且便于扩展（新增不同的子类即可），适用于实现具体工厂。在编写新的具体产品类时，还要提供与之相对的具体工厂类，类的个数成对增长，在一定程度上增加了系统的复杂度。其UML类图如下： 抽象工厂：如果需要创建一系列同分类的产品时，使用抽象工厂是一个很好的选择，可以将相关产品都聚合起来。需要注意的是如果要新增一个产品需要对接口进行修改！所以常用于事先规划好且不会进行变更的产品。具体工厂实现经常使用工厂方式进行搭配。其UML类图如下： 原型设计一个比萨商店系统，出售各种类型的比萨（比萨商店类，比萨抽象类，具体比萨子类）。 简单工厂 问题：当通过比萨商店出售比萨时，需要按照所需比萨类型去实例化具体的比萨子类。当比萨商店新增不同的比萨时，需要修改商店的实例化部分代码，也就是说需要不断的修改源代码。 解决：将实例化部分代码提取出来设计成一个简单工厂，专门用该工厂实例化不同类型的比萨。此时，新增比萨则无需变动比萨商店类，只需修改简单工厂即可。 简单工厂UML类图： 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:06 * @Description 比萨抽象类 */ public abstract class BasePizza { /** * 比萨名字 */ private String name; /** * 面团种类 */ private String dough; /** * 准备材料过程 */ void prepare() { System.out.println(\"材料准备\"); } /** * 打包过程 */ void box() { System.out.println(\"打包\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDough() { return dough; } public void setDough(String dough) { this.dough = dough; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 芝士比萨子类 */ public class CheesePizza extends BasePizza { CheesePizza() { setName(\"芝士比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 素食比萨子类 */ public class VeggiePizza extends BasePizza { VeggiePizza() { setName(\"素食比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:21 * @Description 披萨简单工厂 */ public class SimplePizzaFactory { /** * 芝士比萨 */ public final static String CHEESE = \"cheese\"; /** * 素食比萨 */ public final static String VEGGIE = \"veggie\"; /** * 创建具体类型比萨 * @param type 比萨类型 * @return 具体类型比萨 */ BasePizza createPizza(String type) { BasePizza pizza = null; if (type.equals(CHEESE)) { pizza = new CheesePizza(); } else if (type.equals(VEGGIE)) { pizza = new VeggiePizza(); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:18 * @Description 披萨商店 */ public class PizzaStore { private SimplePizzaFactory factory; PizzaStore(SimplePizzaFactory factory) { this.factory = factory; } /** * 比萨订单 * @param type 比萨类型 * @return 具体类型比萨 */ BasePizza orderPizza(String type) { BasePizza pizza; pizza = factory.createPizza(type); pizza.prepare(); pizza.box(); return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:14 * @Description 测试 */ public class Main { public static void main(String[] args) { SimplePizzaFactory simplePizzaFactory = new SimplePizzaFactory(); PizzaStore pizzaStore = new PizzaStore(simplePizzaFactory); BasePizza cheesePizza = pizzaStore.orderPizza(SimplePizzaFactory.CHEESE); System.out.println(cheesePizza.getName() + \"完成\"); BasePizza veggiePizza = pizzaStore.orderPizza(SimplePizzaFactory.VEGGIE); System.out.println(veggiePizza.getName() + \"完成\"); } } 工厂方法模式 问题：此时如果要新增比萨商店，例如中国比萨商店、日本比萨商店，可以通过增加各地区简单工厂来实现。但是通过简单工厂的方式实现无法变更正在创建的产品，也就是说当需要增加新产品时就需要更改工厂类，违反了对修改关闭的原则。 解决：将简单工厂实现为继承PizzaStore的具体子类，PizzaStore中新增create的抽象方法。使用工厂方式模式一定程度可以克服以上问题。 工厂方法模式例子UML类图： 代码演示： 将PizzaStore类改变成BasePizzaStore抽象类。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:18 * @Description 披萨商店 */ public abstract class BasePizzaStore { /** * 芝士比萨 */ public final static String CHEESE = \"cheese\"; /** * 素食比萨 */ public final static String VEGGIE = \"veggie\"; /** * 比萨订单 * @param type 比萨类型 * @return 具体类型比萨 */ BasePizza orderPizza(String type) { BasePizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.box(); return pizza; } /** * 实例化具体的比萨 * @param type 比萨类型 * @return 具体类型比萨 */ abstract BasePizza createPizza(String type); } 新建中国比萨商店和日本比萨商店以及两商店所能产出的比萨。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 中国素食比萨子类 */ public class ChinaVeggiePizza extends BasePizza { ChinaVeggiePizza() { setName(\"中国素食比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 中国芝士比萨子类 */ public class ChinaCheesePizza extends BasePizza { ChinaCheesePizza() { setName(\"中国芝士比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 中国比萨商店子类 */ public class ChinaPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; if (type.equals(CHEESE)) { pizza = new ChinaCheesePizza(); } else if (type.equals(VEGGIE)) { pizza = new ChinaVeggiePizza(); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 日本素食比萨子类 */ public class JapanVeggiePizza extends BasePizza { JapanVeggiePizza() { setName(\"日本素食比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 日本芝士比萨子类 */ public class JapanCheesePizza extends BasePizza { JapanCheesePizza() { setName(\"日本芝士比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 日本比萨商店子类 */ public class JapanPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; if (type.equals(CHEESE)) { pizza = new JapanCheesePizza(); } else if (type.equals(VEGGIE)) { pizza = new JapanVeggiePizza(); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:14 * @Description 测试 */ public class Main { public static void main(String[] args) { BasePizzaStore chinaPizzaStore = new ChinaPizzaStore(); BasePizza chinaPizza = chinaPizzaStore.orderPizza(BasePizzaStore.CHEESE); System.out.println(chinaPizza.getName() + \"完成\"); BasePizzaStore japanPizzaStore = new JapanPizzaStore(); BasePizza japanPizza = japanPizzaStore.orderPizza(BasePizzaStore.VEGGIE); System.out.println(japanPizza.getName() + \"完成\"); } } 抽象工厂模式 问题：每个地区生产的比萨制作方法不同，原料也不尽相同，这时就需要一个原料工厂了。以面团为例，面团假设有厚面团和薄面团，通过使用工厂方式模式就需要建立一个父类面团，子类厚面团和薄面团。原料不可能只有面团，有无数个都需要如此建立父类子类，这是非常劳累的事情，而且他们都属于一个类别，通过工厂方式模式无法将这些原料归类在一起。 解决：使用抽象工厂模式，设计一个原料工厂接口用于创建所有所需原料，然后按地区划分创建原料工厂实现类，直接实例化具体的原料，例如厚面团。这样做的好处是可以聚集所有同类别的代码，相当于分类一样。 抽象工厂模式例子UML类图： 代码演示： 新增原料工厂接口，并实现具体地区的原料工厂。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:25 * @Description 比萨原料工厂接口 */ public interface PizzaIngredientFactory { /** * 生产面团 * @return 面团 */ Dough createDough(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:48 * @Description 中国比萨原料工厂 */ public class ChinaIngredientFactory implements PizzaIngredientFactory { @Override public Dough createDough() { // 使用厚皮 return new ThickCrustDough(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:49 * @Description 日本比萨原料工厂 */ public class JapanIngredientFactory implements PizzaIngredientFactory { @Override public Dough createDough() { // 使用薄皮 return new ThinCrustDough(); } } 新增面团原料接口，并实现具体的面团。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:26 * @Description 面团 */ public interface Dough { /** * 面团类型 * @return 面团类型 */ String doughType(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:46 * @Description 厚皮面粉实现类 */ public class ThickCrustDough implements Dough { @Override public String doughType() { return \"厚皮面粉\"; } @Override public String toString() { return doughType(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:46 * @Description 薄皮面粉实现类 */ public class ThinCrustDough implements Dough { @Override public String doughType() { return \"薄皮面粉\"; } @Override public String toString() { return doughType(); } } 修改pizza抽象类，将原料准备方法设置成抽象方法，修改dough的类型为Dough。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:06 * @Description 比萨抽象类 */ public abstract class BasePizza { /** * 比萨名字 */ private String name; /** * 面团种类 */ private Dough dough; /** * 准备材料过程 */ abstract void prepare(); /** * 打包过程 */ void box() { System.out.println(\"打包\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public Dough getDough() { return dough; } public void setDough(Dough dough) { this.dough = dough; } } 修改每一个具体的pizza实现类。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 中国素食比萨子类 */ public class ChinaVeggiePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; ChinaVeggiePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"中国素食比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 日本素食比萨子类 */ public class JapanVeggiePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; JapanVeggiePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"日本素食比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 中国芝士比萨子类 */ public class ChinaCheesePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; ChinaCheesePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"中国芝士比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 日本芝士比萨子类 */ public class JapanCheesePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; JapanCheesePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"日本芝士比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } 修改每一个商店类，在实例化具体pizza时添加对应地区原料。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 中国比萨商店子类 */ public class ChinaPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; PizzaIngredientFactory ingredientFactory = new ChinaIngredientFactory(); if (type.equals(CHEESE)) { pizza = new ChinaCheesePizza(ingredientFactory); } else if (type.equals(VEGGIE)) { pizza = new ChinaVeggiePizza(ingredientFactory); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 日本比萨商店子类 */ public class JapanPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; JapanIngredientFactory ingredientFactory = new JapanIngredientFactory(); if (type.equals(CHEESE)) { pizza = new JapanCheesePizza(ingredientFactory); } else if (type.equals(VEGGIE)) { pizza = new JapanVeggiePizza(ingredientFactory); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:14 * @Description 测试 */ public class Main { public static void main(String[] args) { BasePizzaStore chinaPizzaStore = new ChinaPizzaStore(); BasePizza chinaPizza = chinaPizzaStore.orderPizza(BasePizzaStore.CHEESE); System.out.println(chinaPizza.getDough() + \"\\n\" + chinaPizza.getName() + \"完成\"); BasePizzaStore japanPizzaStore = new JapanPizzaStore(); BasePizza japanPizza = japanPizzaStore.orderPizza(BasePizzaStore.VEGGIE); System.out.println(japanPizza.getDough() + \"\\n\" + japanPizza.getName() + \"完成\"); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之装饰者模式","date":"2020-03-11T04:12:09.000Z","path":"posts/2ba79d9e/","text":"装饰者模式 装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 设计原则：类应该对扩展开放，对修改关闭。 特性： 1.装饰者和被装饰对象有相同的超类型。 2.可以用一个或多个装饰者包装一个对象。 3.在任何需要被包装的场合，可以用装饰过的对象代替它。 4.装饰者可以在所委托被装饰者的行为前后增加自己的行为达到特定目的。 5.对象可以在任何时候不限量被装饰（比如运行时）。 装饰者模式UML类图： 原型设计一个饮品订单系统，抽象一个饮品类，让所有的饮品都继承该超类。 为饮品增加调料 问题：饮品中大多都会增加调料，例如咖啡加奶加糖等等。按照原型的设计思路需要新设计一个类（类名为饮品+调料）输出饮品增加了调料后的价格及介绍。这将导致类的数量爆炸式增长。 解决：在饮品抽象类中增加所有出现的调料变量（布尔型），并通过hasX和setX的方式获取和设置调料变量的布尔值。在其子类中需要修改cost方法，调用父类cost方法得知调料价格，再加上子类饮品的价格输出。这样做只需要保留所需的饮品子类即可。 以装饰的方式对饮品增加调料 问题：上述解决方法没有封装变化的部分（出现新的调料就需要不断修改抽象类），而且可能会出现一些饮品不能增加的调料（例如茶+奶泡）或是需要双倍份的调料。 解决：以饮品为主体，在运行时以调料来装饰饮品。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/11 12:20 * @Description 饮品抽象类 */ public abstract class BaseBeverage { /** * 饮品描述 */ String description = \"未知饮品\"; /** * 获取饮品描述 * @return 饮品描述 */ public String getDescription() { return description; } /** * 饮品价格 * @return 饮品价格 */ abstract double cost(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:18 * @Description 调料装饰者抽象类 */ public abstract class BaseCondimentDecorator extends BaseBeverage { /** * 重新实现获取描述的方法 * @return 描述 */ @Override public abstract String getDescription(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:00 * @Description 深焙咖啡饮品实现类 */ public class DarkRoast extends BaseBeverage { DarkRoast() { description = \"深焙咖啡\"; } @Override double cost() { return 0.99; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:03 * @Description 蒸馏咖啡饮品实现类 */ public class Espresso extends BaseBeverage { Espresso() { description = \"浓缩咖啡\"; } @Override double cost() { return 1.99; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:23 * @Description 摩卡调料装饰器实现类 */ public class Mocha extends BaseCondimentDecorator { private BaseBeverage beverage; Mocha(BaseBeverage beverage) { this.beverage = beverage; } @Override public String getDescription() { return beverage.getDescription() + \"+摩卡\"; } @Override double cost() { return beverage.cost() + 0.2; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:26 * @Description 奶泡调料装饰器实现类 */ public class Whip extends BaseCondimentDecorator { private BaseBeverage beverage; Whip(BaseBeverage beverage) { this.beverage = beverage; } @Override public String getDescription() { return beverage.getDescription() + \"+奶泡\"; } @Override double cost() { return beverage.cost() + 0.1; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { BaseBeverage beverage1 = new DarkRoast(); beverage1 = new Mocha(beverage1); System.out.println(\"描述：\" + beverage1.getDescription()); System.out.println(\"价格：\" + beverage1.cost()); BaseBeverage beverage2 = new Espresso(); beverage2 = new Mocha(beverage2); beverage2 = new Whip(beverage2); System.out.println(\"描述：\" + beverage2.getDescription()); System.out.println(\"价格：\" + beverage2.cost()); } } 自定义JAVA I/O装饰者 需求：装饰Reader类，将从控制台读入的所有大写字母转换成小写。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/11 15:17 * @Description Reader组件装饰器：大写转小写 */ public class LowerCaseInputStream extends Reader { private final StreamDecoder sd; public LowerCaseInputStream(InputStream in) { super(in); try { sd = StreamDecoder.forInputStreamReader(in, this, (String) null); } catch (UnsupportedEncodingException e) { throw new Error(e); } } @Override public int read() throws IOException { // 针对字节 int result = super.read(); return result == -1 ? result : Character.toLowerCase(result); } @Override public int read(char[] cbuf, int off, int len) throws IOException { // 针对字节数组 int result = sd.read(cbuf, off, len); for (int i = off; i &lt; off + result; i++) { cbuf[i] = Character.toLowerCase(cbuf[i]); } return result; } @Override public void close() throws IOException { sd.close(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(new LowerCaseInputStream(System.in)); String s = scanner.next(); System.out.println(s); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之观察者模式","date":"2020-03-09T10:08:00.000Z","path":"posts/168b5985/","text":"观察者模式 观察者模式定义了对象之间的一(subject)对多(observer)依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。类似关注up主，up主更新视频时就会推送视频给关注该up主的用户。 设计原则：为了交互对象之间的松耦合设计而努力。（松耦合：当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。） 观察者模式UML图： 原型 需求：设计一个气象站发布栏，要求气象站数据更新时，推送最新的数据至订阅了该气象站的用户手中，用户可以自定义数据的显示样式。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:00 * @Description 主题接口 */ public interface Subject { /** * 注册观察者 * @param observer 观察者接口 */ void registerObserver(Observer observer); /** * 删除观察者 * @param observer 观察者接口 */ void removeObserver(Observer observer); /** * 状态更新，通知观察者 */ void notifyObservers(); } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:00 * @Description 观察者接口 */ public interface Observer { /** * 通知观察者状态更新的接口 * @param args 更新数据 */ void update(Object[] args); } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:05 * @Description 信息显示样式接口 */ public interface DisplayElement { /** * 数据展示样式 */ void display(); } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:12 * @Description 主题具体实现类 */ public class WeatherData implements Subject { private ArrayList&lt;Observer> observers; private Object[] args; public WeatherData() { observers = new ArrayList&lt;>(); } @Override public void registerObserver(Observer observer) { int index = observers.indexOf(observer); if (index &lt; 0) { observers.add(observer); } } @Override public void removeObserver(Observer observer) { int index = observers.indexOf(observer); if (index >= 0) { observers.remove(index); } } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(args); } } /** * 通知观察者。 */ public void measurementsChanged() { notifyObservers(); } /** * 设气象数据并通知观察者。 * @param args 更新数据 */ public void setMeasurements(Object[] args) { this.args = args; measurementsChanged(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:21 * @Description 信息显示样式具体实现：目前状况样式 */ public class CurrentConditionsDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private float pressure; @Override public void display() { System.out.println(\"当前状态：\\n温度：\" + temperature + \"\\n湿度：\" + humidity + \"\\n气压：\" + pressure + \"\\n\"); } @Override public void update(Object[] args) { this.temperature = (float) args[0]; this.humidity = (float) args[1]; this.pressure = (float) args[2]; display(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(); weatherData.registerObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{10f, 20f, 30f}); weatherData.setMeasurements(new Float[]{40f, 50f, 60f}); weatherData.removeObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{70f, 80f, 90f}); } } 新增pull功能 问题：上面设计的观察者模式只能通过主题推送数据至观察者，不能由观察者从主题上拉取自己所需数据，当观察者所需数据很小时，这就是个很头疼的问题了，获取了一堆没用的数据。 解决：新增pull功能，当主题更新了数据时通知观察者但不发送数据，观察者从主题处拉取自己所需数据。 代码演示： 修改Observer接口中的update方法。 /** * 通知观察者状态更新的接口 * @param subject 订阅的主题 * @param args 主题参数 */ void update(Subject subject, Object[] args); 修改Subject接口中的notifyObservers方法。 /** * 状态更新，通知观察者 * @param args 参数 */ void notifyObservers(Object[] args); 修改WeatherData类notifyObservers方法和measurementsChanged方法。 @Override public void notifyObservers(Object[] args) { for (Observer observer : observers) { observer.update(this, args); } } /** * 通知观察者。 */ public void measurementsChanged() { // null不推送数据，否则填需要推送的数据。（此处可以提取成动态运行设置是pull还是push） notifyObservers(null); } 弹性更新 问题：当气象站发生很细微的温度变更时就会通知观察者，这并不是我们想要的结果。 解决：将其改成变动半度以上时才更新，可以通过加入tag来标记状态是否进行更新。 代码演示： 新增Subject接口中的方法。 /** * 设置为允许推送 */ void setChanged(); /** * 设置为不允许推送 */ void clearChanged(); /** * 查看是否可推送 */ boolean hasChanged(); 修改WeatherData类的实现。 @Override public void setChanged() { changed = true; } @Override public void clearChanged() { changed = false; } @Override public boolean hasChanged() { return changed; } /** * 通知观察者。 */ public void measurementsChanged() { setChanged(); // null不推送数据，否则填需要推送的数据。（此处可以提取成动态运行设置是pull还是push） notifyObservers(null); } @Override public void removeObserver(Observer observer) { if (changed) { int index = observers.indexOf(observer); if (index >= 0) { observers.remove(index); } clearChanged(); } } 修改CurrentConditionsDisplay类，当没有获取到信息时，手动获取数据。 @Override public void update(Subject subject, Object[] args) { if (subject instanceof WeatherData) { if (args == null) { args = ((WeatherData) subject).getArgs(); } this.temperature = (float) args[0]; this.humidity = (float) args[1]; this.pressure = (float) args[2]; display(); } } JAVA内置观察者模式支持 需求：通过使用JAVA内置的Observable和Observer实现观察者模式。 代码演示： 只留下CurrentConditionsDisplay、Main、WeatherData类和DisplayElement接口。并修改前面三个类。 import java.util.Observable; /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:12 * @Description 主题具体实现类 */ public class WeatherData extends Observable { private Object[] args; /** * 通知观察者。 */ public void measurementsChanged() { setChanged(); // 无参则不推送数据，否则填需要推送的数据。（此处可以提取成动态运行设置是pull还是push） notifyObservers(); } /** * 设气象数据并通知观察者。 * @param args 更新数据 */ public void setMeasurements(Object[] args) { this.args = args; measurementsChanged(); } /** * 数据访问 getter * @return 数据 */ public Object[] getArgs() { return args; } } import java.util.Observable; import java.util.Observer; /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:21 * @Description 信息显示样式具体实现：目前状况样式 */ public class CurrentConditionsDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private float pressure; @Override public void display() { System.out.println(\"当前状态：\\n温度：\" + temperature + \"\\n湿度：\" + humidity + \"\\n气压：\" + pressure + \"\\n\"); } @Override public void update(Observable o, Object arg) { if (o instanceof WeatherData) { if (arg == null) { WeatherData weatherData = (WeatherData) o; this.temperature = (float) weatherData.getArgs()[0]; this.humidity = (float) weatherData.getArgs()[1]; this.pressure = (float) weatherData.getArgs()[2]; } else { Object[] args = (Object[]) arg; this.temperature = (float) args[0]; this.humidity = (float) args[1]; this.pressure = (float) args[2]; } display(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(); weatherData.addObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{10f, 20f, 30f}); weatherData.setMeasurements(new Float[]{40f, 50f, 60f}); weatherData.deleteObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{70f, 80f, 90f}); } } Observable注意：Observable是一个类不是接口，限制了复用潜力（无法多继承），违反了针对接口编程的原则。而且Observable是乱序通知观察者的，每次的次序是不相同的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"概率论与数理统计","date":"2020-03-07T10:50:02.000Z","path":"posts/28d5cef4/","text":"概率论的基本概念随机试验随机试验：$\\begin{cases} 在相同条件下可重复。\\\\结果不止一个。\\\\无法预测。 \\end{cases}$ 样本空间、随机事件 样本空间：所有基本事件的集合。 样本点：样本空间的元素。 $A\\subset B$：事件B包含事件A。 $A\\bigcup B=\\{x|x∈A 或 x∈B\\}$：事件A与事件B的和事件（也可以记为$A+B$），即A，B中至少一个发生，事件$A\\bigcup B$发生。 $A\\bigcap B=\\{x|x∈A 且 x∈B\\}$：事件A与事件B的积事件（也可以记为$AB$），即仅当A，B同时发生时，事件$A\\bigcup B$发生。 $A-B=\\{x|x∈A 且 x∈B\\}$：事件A与事件B的差事件，即当且仅当A发生、B不发生时，事件$A-B$发生。 $A\\bigcap B=\\emptyset$：事件A与B是互不相容的（或互斥的），即事件A与事件B不能同时发生。 $A\\bigcup B=S$且$A\\bigcap B=\\emptyset$，事件A与事件B互为逆事件（或事件A与事件B互为对立事件），即事件A、B中必有一个发生，且仅有一个发生（A的对立事件记为$\\hat{A}$，$\\hat{A}=S-A$，S为总事件）。 频率与概率 频率：描述了事件发生的频繁程度，即大量实验统计。 概率：在一次试验中发生的可能性大小的数。频率的稳定值即统计概率。 公理化：$\\begin{cases} 非负性，概率不为负\\\\规范性，P(S)=1\\\\可列可加性 \\end{cases}$。 概率性质：$\\begin{cases} p(\\emptyset)=0。\\\\P(A_1+A_2+\\dots+A_n)=P(A_1)+P(A_2)+\\dots+P(A_n)。\\\\若A\\subset B，则P(B-A)=P(B)-P(A)，P(B)≥P(A)。\\\\对于任一事件A，P(A)≤1。\\\\对于任一事件A，P(\\hat{A})=1-P(A)。\\\\P(A\\bigcup B)=P(A)+P(B)-P(AB)=P(A)+P(B-AB)。 \\end{cases}$ 古典概型 古典概型：$\\begin{cases} 样本点个数有限。\\\\每个基本事件发生的概率相同。 \\end{cases}$，也可称为等可能概型。 $P(A)=\\frac{有利样本点}{样本总数}$，例如$\\frac{骰子偶数点数3}{总骰子数6}$。 不重复排列：$\\begin{cases}P_n^m=n(n-1)(n-2)\\dots(n-m+1)=\\frac{n!}{(n-m)!}\\\\P_n^n=n(n-1)×\\dots×3×2×1=n! \\end{cases}$。重复排列：$\\begin{cases}C_n^m=\\frac{P_n^m}{m!}=\\frac{n!}{m!(n-m)!}\\\\C_n^m=C_n^{n-m}\\\\C_n^0=C_n^n=1 \\end{cases}$。 几何概型：$p(A)=\\frac{\\mu(G)}{\\mu(S)}$，$\\mu$表几何区域内的一种度量（如线段中即长度），与古典概型性质唯一不同的在于几何概型拥有完全可加性，古典概型是有限可加性。 条件概率 条件概率：S样本空间，A，B两个事件，其中$P(B)&gt;0$，称$P(A|B)=\\frac{P(AB)}{P(B)}$为在事件A发生的条件下事件B发生的条件概率。 乘法公式：$P(ABC)=P(A)P(B|A)P(C|AB)$，即先发生了A，然后在A发生的条件下发生了B，最后在AB发生的条件下发生了C。n项的话依次类推。 全概率公式：$A_1,A_2\\dots A_n$是E的完备事件组（互不相容，并是S），$P(A_i)&gt;0$，$P(B)=\\sum_{i=1}^nP(A_i)P(B|A_i)$。知原因推结果。 贝叶斯公式：$A_1,A_2\\dots A_n$是E的完备事件组，B是任一事件，$P(A_i)&gt;0$，$P(B)&gt;0$，$P(A_k|B)=\\frac{P(A_k)P(B|A_k)}{\\sum_{i=1}{n}P(A_i)P(B|A_i}=\\frac{P(A_kB)}{P(B)}$。知结果推原因。 独立性 若$P(A)&gt;0$，$P(B)&gt;0$，$P(A|B)=P(A)$或$P(AB)=P(A)P(B)$，即A的概率不受B发生与否的影响称为独立性。 若事件A与B相互独立，则A与$\\hat{B}$，$\\hat{A}$与B，$\\hat{A}$与$\\hat{B}$都相互独立。 A，B，C三个事件，若满足等式：$\\begin{cases} P(AB)=P(A)P(B)\\\\P(AC)=P(A)P(C)\\\\P(BC)=P(B)P(C)\\\\P(ABC)=P(A)P(B)P(C) \\end{cases}$，则事件A，B，C相互独立。 随机变量及其分布随机变量 在样本空间$S={e}$中，$X=X(e)$每一个样本都对应一个实值单值函数，则称$X=X(e)$为随机变量。 离散型：有限个或无限可列个。 连续型（非离散型）：取值一个或多个区间。 离散型随机变量及其分布律 离散型随机变量X所有可能取的值为$x_k(k=1,2,\\dots)$，X取各个可能值的概率，即事件$\\{X=x_k\\}$的概率为$P\\{X=x_k\\}=p_k$。且$p_k≥0$，$\\sum_{k=1}^\\infty p_k=1$。 伯努利试验：试验只有A和$\\hat{A}$两种可能。 n重伯努利试验：将伯努利试验重复n次，试验之间彼此独立。 $(0-1)$分布：随机变量X只能取0与1两个值，其分布律为$P\\{X=k\\}=p^k(1-p)^{1-k}, k=0,1（0&lt;p&lt;1）$。 几何分布：设$P(A)=p$，第k次首次发生，即前$k-1$次未发生，则$P\\{X=k\\}=(1-p)^{k-1}p，k=1,2,3,\\dots$，记为$X\\sim G(p)$。 二项分布：即n重伯努利试验，记为$X\\sim B(n, p)$。$P(A)=p$，n次试验发生了k次，则$P\\{X=k\\}=C_n^kp^k(1-p)^{n-k}，k=0,1,\\dots,n$。当$n=1$时，二项分布化为$(0-1)$分布。二项分布最可能值：$\\begin{cases} (n+1)p不为整数，[(n+1)p]达到最大值。\\\\(n+1)p是整数，(n+1)p和(n+1)p-1都是最大值。 \\end{cases}$ 泊松分布：$P\\{X=k\\}=\\frac{\\lambda^ke^{-\\lambda}}{k!}，k=0,1,\\dots$，其中$\\lambda&gt;0$，记为$X\\sim P(\\lambda)$或$X\\sim \\pi(\\lambda)$。 超几何分布：不放回抽样试验，N个元素，$N_1$属于第一类，$N_2$属于第二类，取n个，X：n个中属于第一类的个数，$P\\{X=k\\}=\\frac{C_{N_1}^kC_{N_2}^{n-k}}{C_N^n}$，$k=0,1,\\dots,min{n,N_1}$。 不放回抽样实验，当N很大，n相对于N很小时，可以当作放回抽样试验。$P=\\frac{M}{N}$改变小，即$\\frac{n}{N}$小（N总数，M样本数），则$P=\\{X=k\\}=\\frac{C_M^kC_{N-M}^{n-k}}{C_N^n}\\approx C_n^kP^k(1-p)^{n-k}$。 随机变量的分布函数 $F(x)=P\\{X≤x\\}(-\\infty＜x＜\\infty)$，称为X的分布函数（对于离散型，连续型都成立）。 $F(x)$是一个不减函数（或增或保持不变）；$0≤F(x)≤1$,即$F(-\\infty)=\\lim \\limits_{x \\to -\\infty} F(x)=0$，$F(\\infty)=\\lim \\limits_{x \\to \\infty} F(x)=1$。 $F(x)$对于离散型是右连续的（即$F(x+0)=F(x)$），$F(X)$对于连续型是连续的。 连续型随机变量及其概率密度 非负可积$f(x)$，$f(x)≥0$,$a≤b$，则$P\\{a&lt;x≤b\\}=\\int_a^bf(x){\\rm d}x$，记为$X\\sim f(x)$。连续型随机变量不注重端点值，且$f(x)≥0$，$\\int_{-\\infty}^\\infty f(x){\\rm d}x=1$。 对于任意$x_1≤x_2$，$P\\{x_1&lt;X≤x_2\\}=F(x_2)-F(x_1)=\\int_{x_1}^{x_2}f(x){\\rm d}x$。 若$f(x)$在点x处连续，则$F\\prime(x)=f(x)$。 连续变量取个别值的概率为零。 均匀分布：$f(x)=\\begin{cases} \\frac{1}{b-a}，&amp;a&lt;x&lt;b，\\\\0，&amp;其他，\\end{cases}$，记为$X\\sim U(a, b)$。 指数分布：$f(x)=\\begin{cases} \\lambda e^{-\\lambda x}，&amp;x&gt;0，\\\\0，&amp;x≤0，\\end{cases}$，其中$\\lambda &gt;0$，记为$X\\sim Exp(\\lambda)$。 正态分布（高斯分布）：$f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$，$-\\infty&lt;x&lt;\\infty$，记为$X\\sim N(\\mu, \\sigma^2)$。当$x=\\mu$时取得最大值。曲线关于$x=\\mu$对称，对于任意$h&gt;0$都有$P\\{\\mu-h&lt;X≤\\mu\\}=P\\{\\mu&lt;X≤\\mu+h\\}$。$\\sigma$固定，$\\mu$变化，图像左右移动；$\\mu$固定，$\\sigma$变化，$\\begin{cases} \\sigma变小，最高点上移，图像变陡。\\\\\\sigma变大，最高点下移，图像变缓。 \\end{cases}$ 标准正态分布$\\phi_o(x)$：当$\\mu=0$，$\\sigma=1$时，$\\phi_o(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}$。$\\Phi_o(-x)=1-\\Phi_o(x)$，$\\phi_o(x)=\\phi_o(-x)$。$\\phi(x)=\\frac{1}{\\sigma}\\phi_o(\\frac{x-\\mu}{\\sigma})$。若$X\\sim N(\\mu, \\sigma^2)$，则$Z=\\frac{X-\\mu}{\\sigma}\\sim N(0, 1)$。 随机变量的函数的分布 离散型：X代入函数，p不变。若X代入函数之后有相同值则合并（p相加）。 连续型：设X的$f_X(x)$，$y=g(x)$，$Y=g(X)$，则求解步骤为： 得出$F_Y(x)$，$F_Y(x)=P\\{Y≤x\\}$，将其化成$F_X(x)$，$F_X(x)=P\\{X≤x\\}$。 对$F_Y(x)=F_X(x)$求导得$f_Y(x)=f_X(x)$，根据$f_X(x)$写出$f_Y(x)$的分段函数。 多维随机变量及其分布二维随机变量 联合分布函数：$F(x, y)$=$P\\{(X≤x)\\bigcap(Y≤y)\\}$=$P\\{X≤x, Y≤y\\}$。 $F(x, y)$是不减h函数，y固定时，$x_1＜x_2$，$F(x_1, y)≤F(x_2, y)$。 $0≤F(x, y)≤1$，当y固定时$F(-\\infty, y)=0$，$当x固定时F(x, -\\infty)=0$，$F(-\\infty, -\\infty)=0$，$F(\\infty, \\infty)=1$。 对于任意$(x_1, y_1)$，$(x_2, y_2)$，$x_1&lt;x_2$，$y_1&lt;y_2$，则$F(x_2, y_2)-F(x_2, y_1)+F(x_1, y_1)-F(x_1, y_2)≥0$。 边缘分布 离散型边缘分布：简单说就是确定$x_i$，将$x_i$所在的%y_j%概率相加，即为该$x_i$的边缘分布。 连续型边缘分布：$F(x, y)$=$P\\{X≤x, Y≤y\\}$=$\\int_{-\\infty}^x \\int_{-\\infty}^y f(s, t){\\rm d}s{\\rm d}t$，其中$F(x, y)$是联合分布，$f(x, y)$是联合密度。G是XY平面上的一个区域，$P\\{(X, Y)∈G\\}$=${\\int \\int}_G f(x, y){\\rm d}x{\\rm d}y$。 联合分布可唯一确认边缘分布；边缘分布不能确定联合分布；当X，Y独立时，边缘分布才能确定联合分布。 边缘密度函数：已知$f(x, y)$，求$f_X(x)=\\int_{-\\infty}^{+\\infty} f(x, y){\\rm d}y$，$f_Y(x)=\\int_{-\\infty}^{+\\infty} f(x, y){\\rm d}x$，且$f(x, y)$=$f_X(x)f_Y(y)$。 二维正态分布的边缘分布也是正态。 两边缘分布是正态的，二维并非一定是二维正态的。 条件分布 条件分布：$P\\{X=x_i|Y=y_j\\}$=$\\frac{P\\{X=x_i, Y=y_j\\}}{P\\{Y=y_j\\}}$=$\\frac{P_{ij}}{P_j}$。 离散型的条件分布即$\\frac{某点概率}{边缘分布概率}$。 连续型的条件分布：$(X, Y)$，$f(x, y)$，$f_X(x)$，$f_Y(y)$，若$f_Y(y)&gt;0$，在$Y=y$的条件下，$F(x|y)=\\int_{-\\infty}^x \\frac{f(x, y)}{f_Y(y)}{\\rm d}y$。 相互独立的随机变量 二维离散型的独立性：$P_{ij}=x_iy_j$。 二维连续型的独立性：$f(x, y)=f_X(x)f_Y(y)$。 变量独立，则变量构造的函数也独立。 两个随机变量的函数的分布 二维离散型的函数分布：X和Y代入函数，求XY相乘所有的可能，p不变，若有重复的则合并（p相加）。 二维连续型的函数分布：$(X, Y)$，$f(x, y)$，$Z=g(X, Y)$，$F(\\xi)=P\\{Z≤\\xi\\}=P\\{g(X, Y)≤\\xi\\}={\\int\\int}_{D_\\xi} f(x, y){\\rm d}x{\\rm d}y$，求出$f_Z(\\xi)$。 卷积公式：$f_X*f_Y=f_{X+Y}(z)=\\int_{-\\infty}^{\\infty}f_X(z-y)f_Y(y){\\rm d}y=\\int_{-\\infty}^{\\infty}f_X(x)f_Y(z-x){\\rm d}x$。 $Z=\\frac{Y}{X}$：$f_{\\frac{Y}{X}}(z)=\\int_{-\\infty}^{\\infty}|x|f_X(x)f_Y(xz){\\rm d}x$。 $Z=XY$：$f_{XY}(z)=\\int_{-\\infty}^{\\infty}\\frac{1}{|x|}f_X(x)f_Y(\\frac{z}{x}){\\rm d}x$。 $M=max\\{X, Y\\}$：$F_{max}(z)=F_X(z)F_Y(z)$。 $N=min\\{X, Y\\}$：$F_{min}(z)=1-[1-F_X(z)][1-F_Y(z)]$。 随机变量的数字特征数学期望 离散型的期望：若分布律为$P\\{X=x_k\\}=P_k$，$EX=\\sum_{k=1}^\\infty x_kP_k$（$EX$或$E(X)$数学期望），离散型的期望即值乘以概率值相加。 连续型的期望：若概率密度为$\\int_{-\\infty}^{\\infty} xf(x){\\rm d}x$，$EX=\\int_{-\\infty}^{\\infty} xf(x){\\rm d}x$。 离散型函数的期望：$Y=g(X)$，则$EY=\\sum_{k=1}^\\infty g(x_k)P_k$。 连续型函数的期望：$Y=g(X)$，则$EY=\\int_{-\\infty}^{\\infty} g(x)f(x){\\rm d}x$。 二维离散型函数的期望：$Z=g(X, Y)$，则$EZ=\\sum_i\\sum_j g(x_i, y_j)P_{ij}$。 二维连续型函数的期望：$Z=g(X, Y)$，则$EZ=\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty g(x, y)f(x, y){\\rm d}x{\\rm d}y$。 期望的性质：$\\begin{cases} EC=C\\\\E(X+C)=EX+C\\\\E(CX)=CEX\\\\E(kX+b)=kEX+b\\\\E(X±Y)=EX±EY\\\\若X，Y独立，E(XY)=EX EY \\end{cases}$ 条件期望：一个变量取某值，另一个变量的期望。$\\begin{cases} E(X|Y=y_j)=\\sum x_iP(X=x_i|Y=y_j)&amp;离散型\\\\E(X|Y=y)=\\int_{-\\infty}^\\infty xf(x|y){\\rm d}x&amp;连续型 \\end{cases}$。 方差 方差：即随机变量与期望偏离的程度，记为$DX=E(X-EX)^2=EX^2-(EX)^2$，量纲$\\sqrt{DX}$。 离散型方差：$DX=\\sum_k (x_k-EX)^2P_k$。 连续型方差：$DX=\\int_{-\\infty}^\\infty (x-EX)^2f(x){\\rm d}x$。 方差的性质：$\\begin{cases} DC=0\\\\D(X+C)=DX\\\\D(CX)=C^2DX\\\\D(kX+b)=k^2DX\\\\若X，Y独立，D(X±Y)=DX+DY\\\\DX=0\\Leftrightarrow P(X=EX)=1 \\end{cases}$ 若$X^\\ast=\\frac{X-EX}{\\sqrt{DX}}$，则$EX^\\ast=0$，$DX^\\ast=1$。 $(0-1)$分布的期望与方差：$EX=p$，$DX=p(1-p)$。 二项分布的期望与方差：$EX=np$，$DX=np(1-p)$。 几何分布的期望与方差：$EX=\\frac{1}{p}$，$DX=\\frac{1-p}{p^2}$。 泊松分布的期望与方差：$EX=\\lambda$，$DX=\\lambda$。 均匀分布的期望与方差：$EX=\\frac{a+b}{2}$，$DX=\\frac{(b-a)^2}{12}$。 指数分布的期望与方差：$EX=\\frac{1}{\\lambda}$，$DX=\\frac{1}{\\lambda^2}$。 正态分布的期望与方差：$EX=\\mu$，$DX=\\sigma^2$。 协方差及相关系数 协方差：$Cov(X, Y)=E[(X-EX)(Y-EY)]=E(XY)-EXEY$。 $D(X±Y)=DX+DY±2Cov(X, Y)$。 协方差相关性质：$\\begin{cases} Cov(X, Y)=Cov(Y, X)\\\\Cov(aX, bY)=abCov(X, Y)\\\\Cov(X_1+X_2, Y)=Cov(X_1, Y)+Cov(X_2, Y)\\\\Cov(C, X)=0\\\\若X，Y独立，Cov(X, Y)=0 \\end{cases}$。 标准化：若$X^\\ast=\\frac{X-EX}{\\sqrt{DX}}$，$Y^\\ast=\\frac{Y-EY}{\\sqrt{DY}}$，则$Cov(X^\\ast, Y^\\ast)=\\rho=\\frac{Cov(X, Y)}{\\sqrt{DX}\\sqrt{DY}}$。 相关系数：$\\begin{cases} |\\rho|≤1\\\\ [E(XY)]^2≤EX^2EY^2\\\\|\\rho|=1\\Leftrightarrow P\\{Y=a+bX\\}=1，即XY成线性关系 \\end{cases}$ $\\rho=1$则X，Y完全正相关；$\\rho=-1$则X，Y完全负相关；$|\\rho|$接近0则X，Y线性关系不弱；$\\rho=0$则X，Y不存在线性关系。 X，Y独立则X，Y不相关；X，Y不相关则X，Y不一定独立。独立与不相关是等价的。 矩、协方差矩阵 原点矩：$EX^k$，以原点为中心；中心距：$E(X-EX)^k$，以期望为中心。 离散型原点矩：$\\sum x_i^kP_i$。 离散型中心距：$\\int_{-\\infty}{\\infty}x^kf(x){\\rm d}x$。 连续型原点矩：$\\sum (x_i-EX)^kP_i$。 连续型中心距：$\\int_{-\\infty}{\\infty}(x-EX)^kf(x){\\rm d}x$。 大数定律及中心极限定理大数定律 切比雪夫大数定理：$X_1,\\dots,X_n$不相关的变量，$EX_i$和$DX_i$都存在，方差有界，即$DX_i≤M$，对$\\forall \\epsilon&gt;0$时，有$\\lim \\limits_{n \\to \\infty} P\\{|\\frac{1}{n}\\sum_{i=1}^nX_i-\\frac{1}{n}\\sum_{i=1}^nEX_i|&lt;\\epsilon\\}=1$。 伯努利大数定理：假设n重伯努利试验，事件A发生了m次，P是其发生概率，$\\frac{m_n}{n}$即为其频率，当$n \\to \\infty$时，即$\\lim \\limits_{n \\to \\infty}P\\{|\\frac{m_n}{n}-P|&lt;\\epsilon\\}=1$，其概率依概率收敛于它的概率。也有$\\lim \\limits_{n \\to +\\infty}P\\{|\\frac{m_n}{n}-P|≥\\epsilon\\}=0$。 辛钦大数定理：$X_1,\\dots,X_n$独立同分布，且$EX_i=M$，$DX_i=\\sigma^2$，有$\\forall \\epsilon&gt;0$，则$\\lim \\limits_{n \\to \\infty} P\\{|\\frac{1}{n}\\sum_{i=1}^nX_i-\\mu|&lt;\\epsilon\\}=1$。 中心极限定理 $X_1,\\dots,X_n$独立同分布，$EX_i=\\mu$，$DX_i=\\sigma^2$，$0&lt;\\sigma^2&lt;+\\infty$，$\\lim \\limits_{n \\to \\infty}F_n(x)$=$\\lim \\limits_{n \\to \\infty}P\\{\\frac{\\sum_{k=1}^nX_k-n\\mu}{\\sqrt{n}\\sigma}≤x\\}$=$\\int_{-\\infty}^x\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}{\\rm d}t$=$\\Phi(x)$。当n充分大时，$\\frac{\\sum x_i-n\\mu}{\\sqrt{n}\\sigma}\\sim N(0, 1)$，$\\sum_{i=1}^nX_i\\sim N(n\\mu, n\\sigma^2)$。 $Y_n$，n，p二项分布近似正态分布，$\\Phi_o(x)=\\lim \\limits_{n \\to \\infty}P\\{\\frac{Y_n-np}{\\sqrt{np(1-p)}}≤x\\}$，其中$Y_n=\\sum_{i=1}^nX_i$，$X_i=\\begin{cases} 1&amp;发生\\\\0&amp;未发生 \\end{cases}$，$EX_i=P$，$DX_i=p(1-P)$。 样本及抽样分布随机样本$X:(0-1)分布$：$P(X_1=x_1,\\dots,X_n=x_n)$=$P(X_1=x_1)\\dots P(X_n=x_n)$=$P^{x_1}(1-p)^{1-x_1}\\dots P^{x_n}(1-p)^{1-x_n}$=$P^{x_1+\\dots+x_n}(1-p)^{n-(x_1+\\dots +x_n)}$。 抽样分布 统计量：不含任何未知参数的样本构造的函数。 样本平均值：$\\hat{X}=\\frac{1}{n}\\sum_{i=1}^nX_i$。 未修正样本方差：$S_o^2=\\frac{1}{n}\\sum_{i=1}^n(X_i-\\hat{X})^2$。$S^2=\\frac{n}{n-1}S_o^2$。 样本方差：$S^2=\\frac{1}{n-1}\\sum_{i=1}^n(X_i-\\hat{X})^2$。 样本标准方差：$S=\\sqrt{S^2}$。 样本k阶（原点）矩：$A_k=\\frac{1}{n}\\sum_{i=1}^nX_i^k,(k=1,2,\\dots)$。$A_1=\\hat{X}$。 样本k阶中心距：$B_k=\\frac{1}{n}\\sum_{i=1}^n(X_i-\\hat{X})^k,(k=2,3,\\dots)$。$B_2=S_o^2$。$S^2=\\frac{n}{n-1}B_2$。 协方差：$S_{1,2}=\\frac{1}{n}(X_i-\\hat{X})(Y_i-Y)$。 两样本之间的相关系数：$R=\\frac{S_{1,2}}{S_1S_2}$。 总体X的均值为$EX=\\mu$，方差为$DX=\\sigma^2$，样本（$X_1,X_2,\\dots,X_n$）来自总体X，则$E\\hat{X}=\\mu$，$D\\hat{X}=\\frac{1}{n}\\sigma^2$，$ES^2=\\sigma^2$。 卡方分布： $X_1,\\dots,X_n$独立且是来自$N(0, 1)$的样本，则$\\chi^2=\\sum_{i=1}^nx_i^2\\sim \\chi^2(n)$。 $EX=n$，$DX=2n$。 由中心极限定理得$X\\sim \\chi^2(n)$，$Y\\sim \\chi^2(m)$，X, Y独立，则$X+Y\\sim \\chi^2(m+n)$。 $X_i\\sim \\chi^2(m_i)$，独立，$\\sum_{i=1}^nX_i\\sim \\chi^2(\\sum_{i=1}^nm_i)$。 上$\\alpha$分位数：$P(\\chi^2&gt;\\chi^2_alpha(n))=\\alpha$。$\\chi^2$相当于变量，$\\chi^2_alpha(n)$相当于一个点，$\\alpha$相当于面积。 $\\chi^2(2)$是$\\lambda=\\frac{1}{2}$的指数分布。 $\\chi^2(n)$是单峰曲线，在$n-2$时取得最大值。 当$n=2$时曲线不对称，当n增大图像越接近对称，且在n很大时，可用正态分布近似。 t分布： 若$X\\sim N(0, 1)$，$Y\\sim \\chi^2(n)$，X, Y独立，则$t(n)\\sim\\frac{X}{\\sqrt{\\frac{Y}{n}}}$。 上$\\alpha$分位数：$P(T&gt;t_\\alpha(n))=\\alpha$。 $t_{1-\\alpha}(n)$=$-t_\\alpha(n)$。 n越小，其图像与正态分布差距越大（$n≥30$，与正态分布区别很小）。 F分布： $X\\sim \\chi^2(n_1)$，$Y\\sim \\chi^2(n_2)$，X, Y独立，$F(n_1, n_2)\\sim \\frac{\\frac{X}{n_1}}{\\frac{Y}{n_2}}$。 $\\frac{1}{F}\\sim F(n_2, n_1)$。 上$\\alpha$分位数：$P(F&gt;F_\\alpha(n_1, n_2)=\\alpha$。 $F_{1-\\alpha}(n_1, n_2)=\\frac{1}{F_\\alpha(n_2, n_1)}$。 正态总体下的抽样分布： $X\\sim N(\\mu, \\sigma^2)$，$\\{X_1,\\dots,X_n\\}$样本，则$E\\hat{X}=\\mu$，$D\\hat{X}=\\frac{\\sigma^2}{n}$，$\\frac{\\hat{X}-\\mu}{\\sigma}\\sqrt{n}\\sim N(0, 1)$，即$E(S^2)=\\sigma^2$。 $\\hat{X}\\sim N(\\mu, \\frac{\\sigma^2}{n})$。 $\\frac{(n-1)S^2}{\\sigma^2}\\sim \\chi^2(n-1)$，$\\hat{X}$与$S^2$独立。 $\\frac{1}{\\sigma^2}\\sum_{i=1}^n(X_i-\\mu)^2\\sim \\chi^2(n)$。 $\\frac{\\hat{X}-\\mu}{S}\\sqrt{n}\\sim t(n-1)$。 两个正态总体：$X\\sim N(\\mu_1, \\sigma_1^2)$，$Y\\sim N(\\mu_2, \\sigma_2^2)$，样本$\\{X_1,\\dots,X_{n_1}\\}$，$\\{Y_1,\\dots,Y_{n_2}\\}$，$\\begin{cases} \\frac{(\\hat{X}-\\hat{Y})-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}}\\sim N(0, 1)\\\\\\frac{\\frac{S_1^2}{\\sigma_1^2}}{\\frac{S_2^2}{\\sigma_2^2}}\\sim F(n_1-1, n_2-1)\\\\ \\sigma_1^2=\\sigma_2^2=\\sigma 时，T=\\frac{(\\hat{X}-\\hat{Y})-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}}\\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}}}\\sim t(n_1+n_2-2) \\end{cases}$ 参数估计点估计 点估计：通过一个样本估计总体未知参数。 矩估计法：以样本矩的连续函数作为相应的总体矩的连续函数的估计量。$A_n=\\frac{1}{n}\\sum X_i^2$。 极大似然估计法： 1.写出总体的概率函数或密度函数。 2.写出似然函数$L(\\lambda)=\\prod_{i=1}^2\\frac{\\lambda^{x_i}}{x_i!}e^{-\\lambda}$（此处以泊松分布为例，似然函数即将样本观测值代入1.式并连乘）。 3.需使似然函数取最大值，两边取$ln$。 4.对$\\lambda$求导（此处$\\lambda$根据概率函数或者密度函数改变）。 估计量的评选标准 无偏性： 估计的参数的估计值的期望是其真实的值，即$E\\hat{\\theta}=\\theta$。 总体$X$，$EX=\\mu$，$DX=\\sigma^2$，$(X_1,\\dots,X_n)$，总体与任何分布无关，则$\\begin{cases}\\hat{X}是\\mu的无偏估计，E\\hat{X}=\\mu。\\\\样本方差S^2是\\sigma^2的无偏估计，ES^2=\\sigma^2。\\\\未修正样本方差S_o^2是\\sigma^2的有偏估计。\\\\n \\to \\infty，渐进无偏估计。\\\\ \\hat{\\theta}是\\theta的无偏估计，g(\\hat{\\theta})不一定是g(\\theta)的无偏估计。\\\\DS=\\sigma^2-(ES)^2，ES=\\sqrt{\\sigma^2-DS}≤\\sigma（一般不等于）。 \\end{cases}$ 有效性：$D(\\hat{\\theta}_1)≤D(\\hat{\\theta}_2)$，方差越小越有效。 相合性（一致性）：$\\lim \\limits_{n \\to +\\infty}P(|\\hat{\\theta}-\\theta|&lt;\\epsilon)=1$。 区间估计 置信区间：$[\\hat{\\theta_1},\\hat{\\theta_2}]$能套住$\\theta$的概率，即以区间估计的区域套住$\\theta$的概率。 枢轴变量：即通过先确定两个数来确定未知数。 $I=I(T, \\theta)$，其中$T$已知，$\\theta$未知，枢轴变量I的分布F已知且与$\\theta$无关。 给定$1-\\alpha$，确定F分布的上$$分位数，上$$分位数，即$P\\{V_{1-\\frac{\\alpha}{2}}≤I(T, \\theta)≤V_{\\frac{\\alpha}{2}}\\}=1-\\alpha$。 正态总体均值与方差的区间估计 若给定置信水平$1-\\alpha$，$X_1,\\dots,X_n$为$N(\\mu, \\sigma^2)$的样本，已知$\\hat{X}$，$S^2$。 $\\sigma^2$已知，枢轴变量$\\frac{\\hat{X}-\\mu}{\\frac{\\sigma}{\\sqrt{n}}}$，$1-\\alpha$的置信区间$(\\hat{X}±\\frac{\\sigma}{\\sqrt{n}}z_{\\frac{\\alpha}{2}})$。 $\\sigma^2$未知，枢轴变量$\\frac{\\hat{X}-\\mu}{\\frac{\\sigma}{\\sqrt{n}}}\\sim t(n-1)$，$1-\\alpha$的置信区间$(\\hat{X}±\\frac{S}{\\sqrt{n}}t_{\\frac{\\alpha}{2}}(n-1))$。 单个总体$N(\\mu, \\sigma^2)$情况表 估计表 $\\mu$ $\\sigma^2$已知 $\\frac{\\hat{X}-\\mu}{\\sigma}\\sqrt{n}\\sim N(0, 1)$ $[\\hat{X}-\\frac{\\sigma}{\\sqrt{n}}\\mu_{\\frac{\\alpha}{2}}, \\hat{X}+\\frac{\\sigma}{\\sqrt{n}}\\mu_{\\frac{\\alpha}{2}}]$ $\\mu$ $\\sigma^2$未知 $\\frac{\\hat{X}-\\mu}{S}\\sqrt{n}\\sim t(n-1)$ $[\\hat{X}-\\frac{S}{\\sqrt{n}}t_{\\frac{\\alpha}{2}}(n-1), \\hat{X}+\\frac{S}{\\sqrt{n}}t_{\\frac{\\alpha}{2}}(n-1)]$ $\\sigma^2$ $\\mu$已知 $\\frac{1}{\\sigma^2}\\sum_{i=1}^n(X_i-\\mu)^2\\sim \\chi^2(n)$ $[\\frac{\\sum(X_i-\\mu)^2}{\\chi^2_{\\frac{\\alpha}{2}}(n)}, \\frac{\\sum(X_i-\\mu)^2}{\\chi^2_{1-\\frac{\\alpha}{2}}(n)}]$ $\\sigma^2$ $\\mu$未知 $\\frac{(n-1)S^2}{\\sigma^2}\\sim \\chi^2(n-1)$ $[\\frac{(n-1)S^2}{\\chi^2_{\\frac{\\alpha}{2}}(n-1)}, \\frac{(n-1)S^2}{\\chi^2_{1-\\frac{\\alpha}{2}}(n-1)}]$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"高等数学","date":"2020-03-02T05:00:25.000Z","path":"posts/93e4730e/","text":"函数与极限映射 $D_f$是定义域(domain)，$R_f$是值域(range)。$x∈X$，对应的 y 是唯一的。（$R_f\\subset Y, R_f≠Y$） 满射：$R_f=Y$。 单射：$x_1≠x_2, f(x_1)≠f(x_2)$，即x和f(x)唯一对应。 一一映射：满足单射和满射。 逆映射：设$f:X→Y$且满足单射，每个$y∈R_f$，有唯一的$x∈X, f(x)=y, g:R_f→X$，则$D_{f^{-1}}=R_f, R_{f^{-1}}=X$。 复合映射：$g:X→Y_1, f:Y_2→Z$，且$Y_1 \\subset Y_2, x∈X$，则$f[g(x)]∈Z$。 函数 函数特性：有界性、单调性、奇偶性和周期性。 反函数：若$f:D→f(D)$，且满足单射，则$f^{-1}:f(D)→D$。$f$与$f^{-1}$关于$y=x$对称，所以$f$单调增(减)时，$f^{-1}$也单调增(减)。 复合函数：$y=f(t), t=g(x)$，则$y=f(g(x))$，其中$t=g(x)$的值域必须落在$y=f(t)$的定义域内。 初等函数：由常数和基本初等函数（幂、指数、对数、三角和反三角函数）经过有限次的四则运算和函数复合所构成的函数。 极限 数列极限定义：$\\forall \\epsilon &gt;0$，$\\exists 正整数N$，当$n&gt;N$时，$|x_n-a|&lt;\\epsilon$，其中a就是极限，记作$\\lim \\limits_{n \\to \\infty} x_n=a$或$x_n \\to a(n \\to \\infty)$。也就是说N是数列中的某一项，$n&gt;N$表示该项后面的所有项，$|x_n-a|&lt;\\epsilon$表示该项后面的所有项都落在$\\epsilon$那么大的小区域中。 自变量趋于有限值时函数的极限定义：$\\forall \\epsilon &gt;0$，$\\exists \\delta&gt;0$，当$0&lt;|x-x_0|&lt; \\delta$时，有$|f(x)-A|&lt;\\epsilon$，记作$\\lim \\limits_{x \\to x_0} f(x)=A$或$f(x) \\to A(x \\to x_0)$。也就是说当x趋于$x_0$时，函数f(x)趋于A，f(x)在$x_0$的去心领域内有定义（注在$x_0$处可以没有定义）。 自变量趋于无穷大时函数的极限定义：$\\forall \\epsilon &gt;0$，$\\exists X&gt;0$，当$|x|&gt; X$时，有$|f(x)-A|&lt;\\epsilon$，记作$\\lim \\limits_{x \\to \\infty} f(x)=A$或$f(x) \\to A(x \\to \\infty)$。 单侧极限： 左极限：$\\lim \\limits_{x \\to x_o^-} f(x)=A$，从左边逼近； 右极限：$\\lim \\limits_{x \\to x_o^+} f(x)=A$，从右边逼近； f(x)极限存在。$\\Leftrightarrow$左右极限均存在且相等。 极限性质 类型 性质 数列 1.极限唯一；2.有界性；3.保号性；4.若数列$\\{x_n\\}$收敛于a，那么它的任一子数列也收敛，且极限也是a。 函数 1.极限唯一；2.局部有界性；3.局部保号性；4.海涅定理：若$\\lim \\limits_{x \\to x_o} f(x)=A$，且$\\{x_n\\} \\to x_0$，则$\\lim \\limits_{n \\to \\infty} f(x_n)=\\lim \\limits_{x \\to x_o} f(x)=A$。 无穷小和无穷大 无穷小定义：$x \\to x_0(x \\to \\infty)$，$f(x)$的极限是0。（0是可以作为无穷小的唯一常数。） 无穷大定义：$x \\to x_0(x \\to \\infty)$，$f(x)$的极限是$\\infty$。 $f(x)$是无穷小，则$\\frac{1}{f(x)}$是无穷大；$f(x)$是无穷大，则$\\frac{1}{f(x)}$是无穷小。 极限运算法则 有限个无穷小的和(差)是无穷小。 有界函数与无穷小的乘积是无穷小。 常数与无穷小的乘积是无穷小。 有限个无穷小的乘积是无穷小。 若$\\phi(x)≥\\psi(x)$，则$\\lim \\phi(x)≥\\lim \\psi(x)$。 $\\lim \\limits_{x \\to \\infty} \\frac{a_0x^m+a_1x^{m-1}+\\cdots+a_m}{b_0x^n+b_1x^{n-1}+\\cdots+b_n} = \\begin{cases} 0,&amp;当n&gt;m,\\\\\\frac{a_0}{b_0},&amp;当n=m,\\\\\\infty,&amp;当n&lt;m. \\end{cases}$ 极限存在准则，两个重要极限 夹逼准则：$g(x)≤f(x)≤h(x)$，若$\\lim g(x)=A$,$\\lim h(x)=A$，则$\\lim f(x)=A$。 $\\lim \\limits_{x \\to 0} \\frac{sinx}{x}=A$。 单调有界数列必有极限。 $\\lim \\limits_{x \\to \\infty} (1+\\frac{1}{x})^x=e$或$\\lim \\limits_{x \\to 0} (1+x)^\\frac{1}{x}=e$。即$(1+0)^\\infty$的样子。 柯西极限存在准则：$\\{x_n\\}$收敛$\\Leftrightarrow$$\\forall \\epsilon, \\exists N, m&gt;N, n&gt;N$时，则$|x_n-x_m|&lt;\\epsilon$。即任取某一项N，在该项之后任取两项m和n，他们之间的距离很小。 无穷小的比较无穷小的比较即比较趋向于0的速度快慢。 $\\lim \\frac{\\beta}{\\alpha}=0$，则$\\beta$是比$\\alpha$高阶的无穷小，记作$\\beta=o(\\alpha)$。 $\\lim \\frac{\\beta}{\\alpha}=\\infty$，则$\\beta$是比$\\alpha$低阶的无穷小。 $\\lim \\frac{\\beta}{\\alpha}=c≠0$，则$\\beta$与$\\alpha$是同阶无穷小。 $\\lim \\frac{\\beta}{\\alpha^k}=c≠0$，则$\\beta$是关于$\\alpha$的k阶无穷小 $\\lim \\frac{\\beta}{\\alpha}=1$，则$\\beta$与$\\alpha$是等价无穷小，记作$\\alpha\\sim\\beta$。 $\\beta$与$\\alpha$等价。$\\Leftrightarrow$$\\beta=\\alpha+o(\\alpha)$。 $\\alpha\\sim\\widetilde{\\alpha}$，$\\beta\\sim\\widetilde{\\beta}$，且$\\lim \\frac{\\widetilde{\\beta}}{\\widetilde{\\alpha}}$存在，则$\\lim \\frac{\\beta}{\\alpha}=\\lim \\frac{\\widetilde{\\beta}}{\\widetilde{\\alpha}}$ 当$x \\to 0$时，求两个无穷小比(做乘除运算)的极限时，分子及分母可用等价无穷小来替换。常用等价替换： $sinx\\sim x$ $tanx\\sim x$ $arcsinx\\sim x$ $arctanx\\sim x$ $ln(1+x)\\sim x$ $e^x-1\\sim x$ $a^x\\sim 1+xlna$ $1-cosx\\sim \\frac{1}{2}x^2$ $(1+x)^\\frac{1}{n}-1\\sim \\frac{1}{n}x$ $(1+x)^\\alpha\\sim 1+\\alpha x$ 函数的连续性与间断点 $\\lim \\limits_{\\Delta x \\to 0} \\Delta y=\\lim \\limits_{\\Delta x \\to 0} [f(x_0+\\Delta x)-f(x_0)]=0$。 $\\lim \\limits_{x \\to x_0} f(x)=f(x_0)$。即连续性的条件为$\\begin{cases} 1.在x_0处有极限。\\\\2.在x_0处有定义。\\\\3.极限等于函数值。 \\end{cases}$ 连续。$\\Leftrightarrow$左、右连续。 左连续：$\\lim \\limits_{x \\to x_0^-} f(x)=f(x_0)$。 右连续：$\\lim \\limits_{x \\to x_0^+} f(x)=f(x_0)$。 间断即不满足连续的条件。间断点类型： 第一类间断点(左右极限都存在)：可去间断点、跳跃间断点。 第二类间断点(左右极限至少一个不存在)：无穷间断点、震荡间断点。 连续函数的运算与初等函数的连续性 函数$f(x)$和$g(x)$在点$x_0$连续，则它们的和(差)、积(商)都在点$x_0$处连续。 如果函数$y=f(x)$在区间$I_x$上单调递增(或单调递减)且连续，那么它的反函数$x=f^{-1}(y)$也在对应的区间$I_y$上单调递(或单调递减)增且连续。 $y=f[g(x)]$由$u=g(x)$与$y=f(u)$复合而成，若$\\lim \\limits_{x \\to x_0} g(x)=u_0$，而$y=f(u)$在$u=u_0$连续，则$\\lim \\limits_{x \\to x_0} f[g(x)]=\\lim \\limits_{u \\to u_0} f(u)=f(u_0)$。即$\\lim \\limits_{x \\to x_0} f[g(x)]=f[\\lim \\limits_{x \\to x_0} g(x)]$。 $y=f[g(x)]$由$u=g(x)$与$y=f(u)$复合而成，若$u=g(x)$在$x=x_0$连续，且$g(x_0)=u_0$，而$y=f(u)$在$u=u_0$连续，则$y=f[g(x)]$在$x=x_0$也连续。 基本初等函数在其定义域内都是连续的；一切初等函数在其定义区间内都是连续的。 闭区间上连续函数的性质 在闭区间上连续的函数在该区间上有界且一定能取得它的最大值和最小值。 零点定理：函数$f(x)$在闭区间$[a, b]$上连续，且$f(a)$与$f(b)$异号（即$f(a)*f(b)&lt;0$），则在开区间$(a, b)$内至少有一点$\\xi$，使得$f(\\xi)=0$。 介值定理：函数$f(x)$在闭区间$[a, b]$上连续，且在该区间的端点取不同的函数值$f(a)=A$及$f(b)=B$，则对于A与B之间的任意一个数C，在开区间$(a, b)$内至少有一点$\\xi$，使得$f(\\xi)=C(a&lt;\\xi&lt;b)$。 在闭区间$[a, b]$上连续的函数$f(x)$的值域为闭区间$[m, M]$，其中m与M依次为$f(x)$在$[a, b]$上的最小值与最大值。 导数与微分导数概念 由于自变量x的变化引起函数$y=f(x)$变化的“快慢”问题，即函数的变化率称为导数。 $y=f(x)$在点$x_0$的某个邻域内有定义，当$x$在$x_0$处取得增量$\\Delta x$时，$x_0 \\to x_0+\\Delta x$，$\\Delta y = f(x_0+\\Delta x)-f(x_0)$。若$\\Delta y$与$\\Delta x$之比当$\\Delta x\\to 0$时的极限存在，则称$y=f(x)$在点$x_0$处可导，记为$f^\\prime (x_0)$=$\\lim \\limits_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x}$=$\\lim \\limits_{\\Delta x \\to 0} \\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}$=$\\lim \\limits_{x \\to x_0} \\frac{f(x)-f(x_0)}{x-x_0}$或记为$y^\\prime |_{x=x_0}$=$\\frac{dy}{dx}|_{x=x_0}$=$\\frac{df(x)}{dx}|_{x=x_0}$。其中$\\frac{dy}{dx}$表示y对x求导。 单侧导数： 左导数：$f^\\prime_-$=$\\lim \\limits_{h \\to 0^-} \\frac{f(x_0+h)-f(x_0)}{h}$=$\\lim \\limits_{x \\to x_0^-} \\frac{f(x)-f(x_0)}{x-x_0}$，从左边逼近； 右导数：$f^\\prime_+$=$\\lim \\limits_{h \\to 0^+} \\frac{f(x_0+h)-f(x_0)}{h}$=$\\lim \\limits_{x \\to x_0^+} \\frac{f(x)-f(x_0)}{x-x_0}$，从右边逼近； 可导。$\\Leftrightarrow$左右导数均存在且相等。 导数的几何意义： 在某一点的导数即该点的切线的斜率，$k_切=f^\\prime(x_0)=tan\\alpha$，$k_法=-\\frac{1}{f^\\prime(x_0)}$。 若$y=f(x)$，$f^\\prime(x_0)=\\infty$，表切线垂直于x轴。 可导必连续，连续不一定可导。（$\\lim \\limits_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x}$存在即可导，$\\lim \\limits_{\\Delta x \\to 0} \\Delta y=0$即连续。） 函数的求导法则 常数和基本初等函数的导数公式： $(C)^\\prime=0$ $(x^\\mu)^\\prime=\\mu x^{\\mu-1}$ $(a^x)^\\prime=a^xlna(a&gt;0, a≠1)$ $(e^x)^\\prime=e^x$ $(lnx)^\\prime=\\frac{1}{x}$ $(log_ax)^\\prime=\\frac{1}{xlna}(a&gt;0, a≠1)$ $(sinx)^\\prime=cosx$ $(cosx)^\\prime=-sinx$ $(tanx)^\\prime=sec^2x$ $(cotx)^\\prime=-csc^2x$ $(sec)^\\prime=secxtanx$ $(cscx)^\\prime=-cscxcotx$ $(arcsinx)^\\prime=\\frac{1}{\\sqrt{1-x^2}}$ $(arccosx)^\\prime=-\\frac{1}{\\sqrt{1-x^2}}$ $(arctanx)^\\prime=\\frac{1}{1+x^2}$ $(arccotx)^\\prime=-\\frac{1}{1+x^2}$ $(shx)^\\prime=chx$ $(chx)^\\prime=shx$ $(thx)^\\prime=\\frac{1}{ch^2x}$ $(arshx)^\\prime=\\frac{1}{\\sqrt{1+x^2}}$ $(archx)^\\prime=\\frac{1}{\\sqrt{x^2-1}}$ $(arthx)^\\prime=\\frac{1}{1-x^2}$ 函数的和、差、积、商的求导法则： $(u±v)^\\prime=u^\\prime±v^\\prime$ $(Cu)^\\prime=Cu^\\prime(C是常数)$ $(uv)^\\prime=u^\\prime v+uv^\\prime$ $(\\frac{u}{v})^\\prime=\\frac{u^\\prime v-uv^\\prime}{v^2}$ 反函数求导：$x=f(y)$在$I_y$内单调、可导且$f^\\prime(y)≠0$，则其反函数$y=f^\\prime(x)$在对应区间内也可导，$[f^\\prime(x)]^\\prime=\\frac{1}{f^\\prime(y)}$或$\\frac{dy}{dx}=\\frac{1}{\\frac{dx}{dy}}$。即反函数的导数等于直接函数导数的倒数。 复合函数求导：若$u=g(x)$在点x可导，而$y=f(u)$在点$u=g(x)$可导，则$y=f[g(x)]$在点x可导，$\\frac{dy}{dx}=f^\\prime(u)·g^\\prime(x)$或$\\frac{dy}{dx}=\\frac{dy}{du}·\\frac{du}{dx}$。 高阶导数 对函数做n次求导叫做n阶导数，记作$\\frac{d^ny}{dx^n}$或$y^{(n)}(x)$。 常用高阶导数： $(a^x)^{(n)}=a^x(lna)^n$ $(sinx)^{(n)}=sin(x+\\frac{n\\pi}{2})$ $(cosx)^{(n)}=cos(x+\\frac{n\\pi}{2})$ $(x^n)^{(n)}=n!$ $(x^n)^{(n+k)}=0(k=1, 2, \\dots)$ $(uv)^{(n)}=\\sum_{k=0}^n C_n^ku^{(n-k)}v^{(k)}$ $[ln(1+x)]^{(n)}=(-1)^{(n-1)}\\frac{(n-1)!}{(1+x)^n}$ 隐函数及参数方程求导 $y=sinx$类型是显函数，$x+y^3-1=0$类型是隐函数。此处隐函数同时两边对x求导得到$y^\\prime=\\dots$的型式即可。 参数方程$\\begin{cases} x=\\phi(t)\\\\y=\\Phi(t) \\end{cases}$，$\\frac{dy}{dx}=\\frac{\\frac{dy}{dt}}{\\frac{dx}{dt}}=\\frac{\\Phi^\\prime}{\\phi^\\prime}$。 函数的微分 由于自变量x的微小改变（增量$|\\Delta x|$很小时）引起$y=f(x)$的改变量$\\Delta y$的近似值问题，即微分问题。 $y=f(x)$在某区间内有定义，若$x_0 \\to x_0+\\Delta x$，则$\\Delta y=f(x_0+\\Delta x)-f(x_0)$（精确值）可表示成$\\Delta y=A\\Delta x+o(\\Delta x)$（近似值，$o(\\Delta x)$可忽略不计），A是不依赖$\\Delta x$的常数，称$y=f(x)$可微。其中$A\\Delta x$叫做$y=f(x)$在点$x_0$相应于$\\Delta X$的微分，记作$dy=A\\Delta x$。 可微。$\\Leftrightarrow$可导，$dy=f^\\prime(x)dx$（$\\Delta x=dx$，$A=f^\\prime(x)$）。 函数的微分运算法则微分公式与法则都和导数差不多。 微分的几何意义通过$\\Delta y=f(x_0+\\Delta x)-f(x_0)$与$dy=f^\\prime(x_0)\\Delta x$作图即可得知。（曲线，切线，$x_0$，$x_0+\\Delta x$，$\\Delta y$和$dy$） 微分中值定理与导数的应用微分中值定理 费马引理：$f(x)$在点$x_0$的某邻域$U(x_0)$内有定义，且在$x_0$处可导，若$f(x)≤f(x_0)$（$f(x)≥f(x_0)$），$\\forall x∈U(x_0)$，则$f^\\prime(x_0)=0$。 罗尔定理：$f(x)$满足$\\begin{cases} 1.在[a, b]上连续。\\\\2.在(a, b)内可导。\\\\3.f(a)=f(b)。 \\end{cases}$，则至少有一点$\\xi∈(a, b)$，使得$f^\\prime(\\xi)=0$。 拉格朗日中值定理：$f(x)$满足$\\begin{cases} 1.在[a, b]上连续。\\\\2.在(a, b)内可导。 \\end{cases}$，则至少有一点$\\xi∈(a, b)$，使得$f(b)-f(a)=f^\\prime(\\xi)(b-a)$。即$f^\\prime(\\xi)=\\frac{f(b)-f(a)}{b-a}$，相当于求斜率。 柯西中值定理：$f(x)$及$F(x)$满足$\\begin{cases} 1.在[a, b]上连续。\\\\2.在(a, b)内可导。\\\\3.\\forall x∈(a, b)，F^\\prime(x)≠0。 \\end{cases}$，则至少有一点$\\xi∈(a, b)$，使得$\\frac{f(b)-f(a)}{F(b)-F(a)}=\\frac{f^\\prime(\\xi)}{F^\\prime(\\xi)}$。 $f(x)$在区间I上连续，在I内可导且导数恒为零，则$f(x)=C$（C为常数）。 洛必达法则若$\\begin{cases} 1.当x \\to a时，f(x)和F(x) \\to 0。\\\\2.在点a的某去心邻域内，f^\\prime(x)及F^\\prime(x)都存在且F^\\prime≠0。\\\\3.\\lim \\limits_{x \\to a} \\frac{f^\\prime(x)}{F^\\prime(x)}存在或为无穷大。\\\\ \\end{cases}$，则$\\lim \\limits_{x \\to a} \\frac{f(x)}{F(x)}=\\lim \\limits_{x \\to a} \\frac{f^\\prime(x)}{F^\\prime(x)}$。（将条件$x \\to a$改为$x \\to \\infty$同样适用。） 泰勒公式 泰勒中值定理1：$f(x)$在$x_0$处有n阶导数，$\\exists x_0$的一个邻域，对于该邻域内的任一x，有$f(x)=f(x_0)+f^\\prime(x_0)(x-x_0)+\\frac{f^{\\prime\\prime}(x_0)}{2!}(x-x_0)^2+\\dots+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)$，其中$R_n(x)=o((x-x_0)^n)$。 泰勒中值定理2：$f(x)$在$x_0$的某个邻域$U(x_0)$内具有(n+1)阶导数，$\\forall x∈U(x_0)$，有泰勒中值定理1的公式，其中$R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{n+1}$($\\xi$是$x_0$与$x$之间的某个值)。 当泰勒中值定理2的公式中$n=0$时，就变成了拉格朗日中值公式。 当泰勒中值定理1的公式中$x_0=0$时，就变成了带有佩亚诺余项的麦克劳林公式，$f(x)=f(0)+f^\\prime(0)x+\\frac{f^{\\prime\\prime}(0)}{2!}x^2+\\dots+\\frac{f^{(n)}(0)}{n!}x^n+o(x^n)$。 当泰勒中值定理2的公式中$x_0=0$时，就变成了带有拉格朗日余项的麦克劳林公式，$f(x)=f(0)+f^\\prime(0)x+\\frac{f^{\\prime\\prime}(0)}{2!}x^2+\\dots+\\frac{f^{(n)}(0)}{n!}x^n+\\frac{f^{(n+1)}(\\theta x)}{(n+1)!}x^{n+1}(0&lt;\\theta&lt;1)$。 函数的单调性与曲线的凹凸性 $y=f(x)$在$[a, b]$上连续，在$(a, b)$内可导。则在$(a, b)$内$f^\\prime(x)≥0$($f^\\prime(x)≤0$)，且等号仅在有限多个点处成立，则$y=f(x)$在$[a, b]$上单调增加(减少)。 $y=f(x)$在$[a, b]$上连续，在$(a, b)$内具有一阶和二阶导数。则在$(a, b)$内$f^{\\prime\\prime}(x)&gt;0$($f^{\\prime\\prime}(x)&lt;0$)，$y=f(x)$在$[a, b]$上的图形是凹(凸)的。 导数为零的点称为驻点或临界点；在$f^{\\prime\\prime}(x)=0$或二阶导数不存在的点左右异号则该点就是拐点。 函数的极值与最大值最小值 $f(x)$在$x_0$处可导，且在$x_0$处取得极值，则$f^\\prime(x_0)=0$。 $f(x)$在$x_0$处连续，且在$x_0$的某去心邻域可导。 若$x∈(x_0-\\delta, x_0)$时，$f^\\prime(x)&gt;0$，而$x∈(x_0, x_0+\\delta)$，$f^\\prime(x)&lt;0$，则$f(x)$在$x_0$处取得极大值。 若$x∈(x_0-\\delta, x_0)$时，$f^\\prime(x)&lt;0$，而$x∈(x_0, x_0+\\delta)$，$f^\\prime(x)&gt;0$，则$f(x)$在$x_0$处取得极小值。 若$x∈(x_0-\\delta, x_0)\\bigcup(x_0, x_0+\\delta)$时，$f^\\prime(x)$的符号保持不变，则$f(x)$在$x_0$处没有极值。 $f(x)$在$x_0$处具有二阶导数且$f^\\prime(x_0)=0$，$f^{\\prime\\prime}≠0$，则当$f^{\\prime\\prime}&lt;0$($f^{\\prime\\prime}&gt;0$)时，$f(x)$在$x_0$处取得极大值(极小值)。 将驻点及不可导点带入函数取区间上的最大值和最小值就是函数的最大值和最小值。 函数图形的描绘描绘步骤为： 确定定义域和间断点，判断函数的奇偶性和周期性。 求$f^\\prime(x)$和$f^{\\prime\\prime}$，根据$f^\\prime(x)=0$、$f^{\\prime\\prime}=0$以及间断点分开区间。 确定$y=f(x)$的单调增、减区间，求出极值。 确定$y=f(x)$的凹凸区间和拐点。 取间断点求渐近线方程，共三种： 斜率渐近线：$k=\\lim \\limits{x \\to +\\infty} \\frac{f(x)}{x}$，$b=\\lim \\limits{x \\to +\\infty}[f(x)-kx]$。 垂直渐近线：$x \\to x_0$时，$f(x) \\to \\infty$，则$x=x_0$就是渐近线。 水平渐近线：$k=0$时的渐近线。 作表作图。 不定积分不定积分的概念与性质 $F^\\prime(x)=f(x)$，$F(x)+C$($C$是常数)是原函数，$f(x)$称为导函数。原函数存在的条件为连续函数一定有原函数。 在区间I上，$f(x)$带有任意常数项的原函数称为$f(x)$（或$f(x)dx$）在区间I上的不定积分，记作$\\int f(x){\\rm d}x$，即$\\int f(x){\\rm d}x=F(x)+C$（$C$是常数）。 不定积分的几何含义：即一组平行的曲线簇。 不定积分的性质： $\\int [f(x)+g(x)]{\\rm d}x=\\int f(x){\\rm d}x+\\int g(x){\\rm d}x$ $\\int kf(x){\\rm d}x=k\\int f(x){\\rm d}x$ 基本积分表： $\\int k{\\rm d}x=kx+C$（$k是常数$） $\\int x^\\mu{\\rm d}x=\\frac{x^{\\mu+1}}{\\mu+1}+C$ $\\int \\frac{1}{x}{\\rm d}x=ln|x|+C$ $\\int \\frac{1}{1+x^2}{\\rm d}x=arctanx+C$ $\\int \\frac{1}{\\sqrt{1-x^2}}{\\rm d}x=arcsinx+C$ $\\int cosx{\\rm d}x=sinx+C$ $\\int sinx{\\rm d}x=-cosx+C$ $\\int sec^2x{\\rm d}x=tanx+C$ $\\int csc^2x{\\rm d}x=-cotx+C$ $\\int secxtanx{\\rm d}x=secx+C$ $\\int cscxcotx{\\rm d}x=-cscx+C$ $\\int e^x{\\rm d}x=e^x+C$ $\\int a^x{\\rm d}x=\\frac{a^x}{lna}+C$ $\\int shx{\\rm d}x=chx+C$ $\\int chx{\\rm d}x=shx+C$ $\\int tanx{\\rm d}x=-ln|cosx|+C$ $\\int cotx{\\rm d}x=ln|sinx|+C$ $\\int secx{\\rm d}x=ln|secx+tanx|+C$ $\\int cscx{\\rm d}x=ln|cscx-cotx|+C$ $\\int \\frac{1}{a^2+x^2}{\\rm d}x=\\frac{1}{a}arctan\\frac{x}{a}+C$ $\\int \\frac{1}{x^2-a^2}{\\rm d}x=\\frac{1}{2a}ln|\\frac{x-a}{x+a}|+C$ $\\int \\frac{1}{\\sqrt{a^2-x^2}}{\\rm d}x=arcsin\\frac{x}{a}+C$ $\\int \\frac{1}{\\sqrt{x^2+a^2}}{\\rm d}x=ln(x+\\sqrt{x^2+a^2})+C$ $\\int \\frac{1}{\\sqrt{x^2-a^2}}{\\rm d}x=ln|x+\\sqrt{x^2-a^2}|+C$ $\\int \\sqrt{x^2+a^2}{\\rm d}x=\\frac{a^2}{2}ln(\\sqrt{a^2+x^2}+x)+\\frac{x}{2}\\sqrt{a^2+x^2}+C$ $\\int \\sqrt{x^2-a^2}{\\rm d}x=\\frac{a^2}{2}ln(\\sqrt{x^2-a^2}+x)+\\frac{x}{2}\\sqrt{x^2-a^2}+C$ 换元积分法 第一类换元法：$\\int f(\\phi(x))\\phi^\\prime(x){\\rm d}x=\\int f(\\phi(x)){\\rm d}\\phi(x)=F(\\phi(x))+C$。 第二类换元法：$\\int f(x)dx=\\int f(\\phi(t))\\phi^\\prime(t)dt=g(t)+C$，其中$t=\\phi^{-1}(x)$，因此$g(t)+C$=$g(\\phi^{-1}(x))+C$。做题步骤： 1.设$x=\\phi(t)$，并求积。 2.将t换回x。（此处可画直角三角形辅助，例$sinx=\\frac{x}{a}$，则斜边a、对边x、临边$\\sqrt{a^2-x^2}$，$cosx$就等于$\\frac{\\sqrt{a^2-x^2}}{a}$） 分部积分法 $\\int u {\\rm d}v=uv-\\int v {\\rm d}u$。 选择$\\int u {\\rm d}v$中u的优先级顺序：对数函数、反三角函数、幂函数、三角函数和指数函数（对反幂三指，其中对反可以互换，三指也可以互换）。 有理函数的积分 $R(x)=\\frac{P_m(x)}{Q_n(x)}\\begin{cases} m≥n，&amp;有理假分式。\\\\m&lt;n，&amp;有理真分式。 \\end{cases}$，其中$P(x)$和$Q(x)$是两个多项式，m和n是多项式的最高次幂。有理假分式需要通过长除法变成有理真分式进行求解。 $\\frac{A}{(x-a)^n}$型式化成$\\frac{A_1}{(x-a)^n}+\\frac{A_2}{(x-a)^{n-1}}+\\dots+\\frac{A_n}{x-a}$； $\\frac{Bx+C}{(x^2+px+q)^n}$型式化成$\\frac{B_1x+C_1}{(x^2+px+q)^n}+\\frac{B_2x+C_2}{(x^2+px+q)^{n-1}}+\\dots+\\frac{B_nx+C_n}{x^2+px+q}$。 $\\int \\frac{1}{ax^2+bx+c}{\\rm d}x$ $\\int \\frac{dx+e}{ax^2+bx+c}{\\rm d}x$ b^2-4ac=0 $a(x-x_1)^2$。 $a(x-x_1)^2$，将d凑成和分母类似。 b^2-4ac&gt;0 $a(x-x_1)(x-x_2)$，化成$\\frac{A_1}{x-x_1}+\\frac{A_2}{x-x_2}$型式。 与左边相同。 b^2-4ac&lt;0 先配方，然后将d凑成和分母类似。 与左边相同。 $\\int R(sinx, cosx){\\rm d}x$ 另$t=tan\\frac{x}{2}$。 $\\int R(tanx){\\rm d}x$$\\int R(sin^2x, cos^2 x){\\rm d}x$$\\int R(sin2x, cos2x){\\rm d}x$ 另$t=tanx$。 $\\int R(x, \\sqrt[n]{\\frac{ax+b}{cx+h}}){\\rm d}x$ 另$t=\\sqrt[n]{\\frac{ax+b}{cx+h}}$。 $\\int R(x, \\sqrt{ax^2+bx+c}){\\rm d}x$ 先配方，然后对根式选择适当的三角变换去掉根式，化为三角函数有理式的积分。 定积分定积分的概念与性质 $f(x)$在$[a, b]$上有界，在$[a, b]$上任意插入若干个分点将其分成n个小区间$\\Delta x_1,\\Delta x_2,\\dots,\\Delta x_n$，在每个小区间上任取一点$\\xi_i$，$I=\\lim \\limits_{\\lambda \\to 0} \\sum_{i=1}^n f(\\xi_i)\\Delta x_i$($\\lambda=max\\{\\Delta x_1,\\Delta x_2,\\dots,\\Delta x_n\\}$)，称这个极限I为$f(x)$在$[a, b]$上的定积分，记作$\\int_a^b f(x){\\rm d}x$。就是说若要取一个曲边梯形的面积，则可以用若干个小长方形的面积相加近似的获取其面积。 $f(x)$在$[a, b]$上连续，则$f(x)$在$[a, b]$上可积。 $f(x)$在$[a, b]$上有界，且只有有限个间断点，则$f(x)$在$[a, b]$上可积。 当$b=a$时，则$\\int_a^a f(x){\\rm d}x=0$。 $\\int_a^b f(x){\\rm d}x$=$-\\int_b^a f(x){\\rm d}x$。 $\\int_a^b [\\alpha f(x)+\\beta g(x)]{\\rm d}x$=$\\alpha\\int_a^b f(x){\\rm d}x$+$\\beta\\int_a^b g(x){\\rm d}x$。 当$a&lt;c&lt;b$时，$\\int_a^b f(x){\\rm d}x$=$\\int_a^c f(x){\\rm d}x$+$\\int_c^b f(x){\\rm d}x$。 在$[a, b]$上$f(x)\\equiv 1$，则$\\int_a^b 1{\\rm d}x$=$\\int_a^b {\\rm d}x$=$b-a$。 在$[a, b]$上$f(x)≥0$（$f(x)≤0$），则$\\int_a^b f(x){\\rm d}x≥0$（$\\int_a^b f(x){\\rm d}x≤0$），其中$a&lt;b$。 在$[a, b]$上$f(x)≤g(x)$，则$\\int_a^b f(x){\\rm d}x≤\\int_a^b g(x){\\rm d}x$，其中$a&lt;b$。 $|\\int_a^b f(x){\\rm d}x|≤\\int_a^b |f(x)|{\\rm d}x$，其中$a&lt;b$。 若M及m分别是$f(x)$在$[a, b]$上的最大值和最小值，则$m(b-a)≤\\int_a^b f(x){\\rm d}x≤M(b-a)$，其中$a&lt;b$。 定积分中值定理：若$f(x)$在$[a, b]$上连续，$\\exists \\xi∈[a, b]$，使得$\\int_a^b f(x){\\rm d}x=f(\\xi)(b-a)$。 微积分基本共识 $f(x)$在$[a, b]$上连续，则积分上限的函数在$[a, b]$上可导，其导数为$\\Phi^\\prime(x)=\\frac{d}{dx}\\int_a^xf(t){\\rm d}t=f(x)$，其中($a≤x≤b$)。 $\\int_{\\psi(x)}^{\\phi(x)}[f(t){\\rm d}t]^\\prime=f(\\phi(x))\\phi^\\prime(x)-f(\\psi(x))\\psi^\\prime(x)$。 牛顿-莱布尼茨公式：$F(x)$是连续函数$f(x)$在$[a, b]$上的一个原函数，则$\\int_a^bf(x){\\rm d}x=F(b)-F(a)$。 定积分的换元法和分部积分法 $x=\\phi(t)$，若$\\phi(\\alpha)=a$，$\\phi(\\beta)=b$，则$\\int_a^bf(x){\\rm d}x=\\int_{\\alpha}^{\\beta}f[\\phi(t)]\\phi^\\prime(t){\\rm d}t$。（一定要注意上下限也要替换。） $f(x)$在$[-a, a]$上连续且为偶函数，则$\\int_{-a}^af(x){\\rm d}x=2\\int_0^af(x){\\rm d}x$；$f(x)$在$[-a, a]$上连续且为奇函数，则$\\int_{-a}^af(x){\\rm d}x=0$。 $f(x)$在$[0, 1]$上连续，则$\\int_0^{\\frac{\\pi}{2}}f(sinx){\\rm d}x=\\int_0^{\\frac{\\pi}{2}}f(cosx){\\rm d}x$，$\\int_0^{\\pi}xf(sinx){\\rm d}x=\\frac{\\pi}{2}\\int_0^{\\pi}f(sinx){\\rm d}x$。 $f(x)$是连续的周期函数，则$\\int_a^{a+T}f(x){\\rm d}x=\\int_0^Tf(x){\\rm d}x$，$\\int_a^{a+nT}f(x){\\rm d}x=n\\int_0^Tf(x){\\rm d}x$（$n∈N$）。 $\\int_a^b u {\\rm d}v=[uv]_a^b-\\int_a^b v {\\rm d}u$。 反常积分（广义积分） 无穷限的反常积分： $\\int_a^{+\\infty}f(x)dx=\\lim \\limits_{t \\to +\\infty}\\int_a^tf(x){\\rm d}x$，若极限存在则收敛，否则发散。 $\\int_{-\\infty}^{a}f(x)dx=\\lim \\limits_{t \\to -\\infty}\\int_t^af(x){\\rm d}x$，若极限存在则收敛，否则发散。 $\\int_{-\\infty}^{+\\infty}f(x)dx=\\int_{-\\infty}^{0}f(x)dx+\\int_{0}^{+\\infty}f(x)dx$，若右式均收敛则左式收敛，否则发散。 无界函数的反常积分：（注意函数无定义点。） 若$f(x)$在$(a, b]$上连续，则a就是$f(x)$的瑕点。任取$t&gt;a$，则$\\int_a^bf(x){\\rm d}x=\\lim \\limits_{t \\to a^+}\\int_t^bf(x){\\rm d}x$。 若$f(x)$在$[a, b)$上连续，则b就是$f(x)$的瑕点。任取$t&lt;b$，则$\\int_a^bf(x){\\rm d}x=\\lim \\limits_{t \\to b^-}\\int_a^tf(x){\\rm d}x$。 若$f(x)$在$[a, c)$及$(c, b]$上连续，则c就是$f(x)$的瑕点。$\\int_a^bf(x){\\rm d}x=\\int_a^cf(x){\\rm d}x+\\int_c^bf(x){\\rm d}x$。 $\\Gamma$函数 $\\Gamma(s)$=$\\int_0^{+\\infty}e^{-x}x^{s-1}{\\rm d}x$，其中$s&gt;0$。 $\\Gamma(s+1)$=$s\\Gamma(s)$，其中$s&gt;0$。 $\\Gamma(n+1)=n!$。 定积分的应用定积分在几何学上的应用 平面图形的面积：$A=\\int_a^bf(x){\\rm d}x$。 X型区域：若在x轴的$[a, b]$上$g(x)≤f(x)$，则$S=\\int_a^b[f(x)-g(x)]{\\rm d}x$。 Y型区域：若在y轴的$[c, e]$上$g(y)≤f(y)$，则$S=\\int_c^e[f(y)-g(y)]{\\rm d}y$。 椭圆的面积：$S=\\frac{ab\\pi}{4}$。 根据$sin^2t+cos^2t=1$与$(\\frac{x}{a})^2+(\\frac{y}{b})^2=1$推出$\\begin{cases} x=acost\\\\y=bsint \\end{cases}$，其中$0≤t≤\\frac{\\pi}{2}$。 $S=4\\int_0^ay{\\rm d}x=\\int_0^{\\frac{\\pi}{2}}absin^2t{\\rm d}t=\\frac{\\pi ab}{4}$ 极坐标情形：$A=\\int_\\alpha^\\beta\\frac{1}{2}[p(\\theta)]^2{\\rm d}\\theta$。 旋转体的体积： X型区域：若在x轴的$[a, b]$上，$\\int_a^b\\pi f^2(x){\\rm d}x$=$\\int_a^bA(x){\\rm d}x$。 Y型区域：若在y轴的$[c, e]$上，$\\int_c^e\\pi \\phi^2(y){\\rm d}y$=$\\int_c^eA(y){\\rm d}y$。 旋转体的侧面积：曲线$y=f(x)≥0$，$a≤x≤b$，绕X轴旋转，得到的旋转体侧面积为$S=\\int_a^b2\\pi f(x)\\sqrt{1+f^{\\prime 2}(x)}{\\rm d}x$。 光滑曲线弧是可求长的，求弧长公式为： $\\begin{cases} x=\\phi(t)\\\\y=\\psi(t) \\end{cases}$，其中$\\alpha≤t≤\\beta$，则$s=\\int_\\alpha^\\beta\\sqrt{\\phi^{\\prime 2}(t)+\\psi^{\\prime 2}(t)}{\\rm d}t$。 $\\begin{cases} x=x\\\\y=f(x) \\end{cases}$，其中$a≤x≤b$，则$s=\\int_a^b\\sqrt{1+y^{\\prime 2}}{\\rm d}x$。 $\\rho=\\rho(\\theta)$，($\\alpha≤\\theta≤\\beta$)，$\\begin{cases} x=x(\\theta)=\\rho(\\theta)cos\\theta\\\\y=y(\\theta)=\\rho(\\theta)sin\\theta \\end{cases}$，$s=\\int_\\alpha^\\beta\\sqrt{\\rho^2(\\theta)+\\rho^{\\prime 2}(\\theta)}{\\rm d}\\theta$。 微分方程微分方程的基本概念 通俗说含导数的即微分方程。 任意常数的个数与微分方程的阶数相同，这样的解叫做微分方程的通解。 可分离变量的微分方程$y^\\prime=f(x, y)$化为$g(y){\\rm d}y=f(x){\\rm d}x$，两边同时作积。 齐次方程 齐次方程：$\\frac{dy}{dx}=\\phi(\\frac{y}{x})$，例如：$\\frac{dy}{dx}=\\frac{1+(\\frac{y}{x})^2}{1-2(\\frac{y}{x})^2}$，即$\\frac{y}{x}$是整体出现的。求解步骤： $u=\\frac{y}{x}$。 $y=xu$。 $\\frac{dy}{dx}=u+x\\frac{du}{dx}$。 分离变量。 可化为齐次方程：$\\frac{dy}{dx}=\\frac{ax+by+c}{a_1x+b_1y+c_1}$，当$c=c_1$时是其次的，否则是非齐次的。将非齐次化作齐次方程令$x=X+h$，$y=Y+k$，所以$\\frac{dY}{dX}=\\frac{aX+bY+ah+bk+c}{a_1X+b_1Y+a_1h+b_1k+c_1}$，若方程组$\\begin{cases} ah+bk+c=0,\\\\a_1h+b_1k+c_1=0\\end{cases}$中： 若$\\frac{a_1}{a}≠\\frac{b_1}{b}$，则$\\frac{dY}{dX}=\\frac{aX+bY}{a_1X+b_1Y}$。 若$\\frac{a_1}{a}=\\frac{b_1}{b}$，则令$\\frac{a_1}{a}=\\frac{b_1}{b}=\\lambda$，$\\frac{dy}{dx}=\\frac{ax+by+c}{\\lambda(ax+by)+c_1}$，引入变量$v=ax+by$，则$\\frac{dv}{dx}=a+b\\frac{dy}{dx}$或$\\frac{dy}{dx}=\\frac{1}{b}(\\frac{dv}{dx}-a)$，于是最终方程为$\\frac{1}{b}(\\frac{dv}{dx}-a)=\\frac{v+c}{\\lambda v+c_1}$。 一阶线性微分方程$\\frac{dy}{dx}+P(x)y=Q(x)$称为一阶线性微分方程： 若$Q(x)\\equiv 0$则称为齐次线性微分方程，其通解为$y=Ce^{-\\int P(x){\\rm d}x}$，其中$C=±e^{C_1}$。 若$Q(x)≠0$则称为非齐次线性微分方程，另$y=ue^{-\\int P(x){\\rm d}x}$代入原方程可得到其特解$y=e^{-\\int P(x){\\rm d}x}(\\int Q(x)e^{\\int P(x){\\rm d}x}{\\rm d}x+C)$，其解为通解加上特解为$y=Ce^{-\\int P(x){\\rm d}x}+e^{-\\int P(x){\\rm d}x}\\int Q(x)e^{\\int P(x){\\rm d}x}{\\rm d}x$。 可降阶的高阶微分方程 $y^{(n)}=f(x)$：几阶导就求几次积分。 $y^{\\prime\\prime}=f(x, y^\\prime)$：设$y^\\prime=p$，则$y^{\\prime\\prime}=p^\\prime$，$p^\\prime=f(x, p)$，分离变量求积。 $y^{\\prime\\prime}=f(y, y^\\prime)$：设$y^\\prime=p$，则$y^{\\prime\\prime}=p^\\prime=\\frac{dp}{dx}=\\frac{dp}{dy}\\frac{dy}{dx}=p\\frac{dp}{dy}$，分离变量求积。 高阶线性微分方程 二阶齐次线性方程：$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=0$，其解为$y=C_1y_1(x)+C_2y_2(x)$。 二阶非齐次线性方程：$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=f(x)$，设$y^(x)$是特解，$Y(x)$是通解，则其解为$y=Y(x)+y^(x)$。 常系数齐次线性微分方程将$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=0$写为$y^{\\prime\\prime}+py^\\prime+qy=0$，求解： $r^2+pr+q=0$ $y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=0$ $p^2-4q&gt;0$，$r=\\frac{-p±\\sqrt{p^2-4q}}{2}$ $y=C_1e^{r_1x}+C_2e^{r_2x}$ $p^2-4q=0$，$r=-\\frac{p}{2}$ $y=(C_1+C_2x)e^{r_1x}$ $p^2-4q&lt;0$，$r=\\alpha ±\\beta i$，$\\alpha=-\\frac{p}{2}, \\beta=\\frac{\\sqrt{4q-p^2}}{2}$ $e^{\\alpha x}(C_1cos\\beta x+C_2sin\\beta x)$ 常系数非齐次线性微分方程 $f(x)=e^{\\lambda x}P_m(x)$，其特解为：$y*=e^{\\lambda x}Q_m(x)$， $\\lambda=\\begin{cases} 0,&amp;\\lambda与特征方程两个特征根均不相等\\\\1&amp;\\lambda与特征方程其中一个特征根相等\\\\2&amp;\\lambda与特征方程两个特征根均相等 \\end{cases}$。 $Q_m(x)$与$P_m(x)$是同次的多项式，例如$P_m(x)=x^2+3$，则$Q_m(x)=ax^2+bx+c$。 $f(x)=e^{\\lambda x}[P_l(x)cos\\psi x+Q_n(x)sin \\psi x]$，其特解为：$y^*=x^ke^{\\lambda x}[R_m^{(1)}(x)cos\\psi x+R_m^{(2)}(x)sin\\psi x]$， $\\lambda=\\begin{cases} 0,&amp;\\lambda±i\\psi不是特征方程的根 \\\\1,&amp;\\lambda±i\\psi是特征方程的根 \\end{cases}$。 $P_l(x)$和$Q_n(x)$是两个多项式，$R_m(x)$中的$m=Max\\{l, n\\}$。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数","date":"2020-01-18T06:41:20.000Z","path":"posts/c23efd5b/","text":"行列式行列式定义 $\\begin{vmatrix} a&amp;b\\\\ c&amp;d \\end{vmatrix}=ad-bc$ 三阶行列式：展开式共六项，其中三个正项，三个负项。（n 阶行列式展开式共 n! 项。） n 阶行列式：行取自然排列（例123），列取排列所有可能（例123、132、$\\dots$），不同行不同列取 n 个元素相乘，符号由列标排列逆序数的奇偶决定。 下三角、上三角和对角形的行列式为主对角线元素相乘。 山寨下三角、山寨上三角和山寨对角形的行列式为 $(-1)^{\\frac{n(n-1)}{2}}$ 与次对角线元素相乘。 行列式性质 转置：$D^T=D$ 交换两行（列），行列式变号。 两行（列）元素相等，D=0。 某一行（列）有公因子 k，k 外提一次。所有行（列）都有公因子 k，k 外提 n 次。 两行（列）元素成比例，D=0。 某一行（列）元素全为0，D=0。 某一行（列）元素全是两数之和，拆成两个行列式。（只拆该行或列，其余行或列保持不变。） 某一行（列）乘以一个数加到另一行（列），D 不变。 行列式展开 D = 某一行（列）元素与其代数余子式乘积之和。（将$(i, j)$所在的行列划去留下的就是余子式，代数余子式是带符号的余子式，其符号为$(-1)^{i+j}$。） 异乘变零：某行（列）元素与其他行（列）的代数余子式乘积之和为0。 拉普拉斯定理：任取 k 行（列），由这 k 行（列）元素组成的所有 k 阶子式与其代数余子式乘积之和为 D。（常用于解某一块都是0的行列式。） 克拉默法则：n 个方程 n 个未知数的方程组，系数行列式若不等于0则有唯一解：$x_i=\\frac{D_i}{D}$，其中 $D_i$ 为用常数项替代 i 列，而其他列不变的行列式的值。n 个方程 n 个未知数的齐次方程组，系数行列式若不等于0则有零解；若等于0则有非零解。 范德蒙德行列式： $$\\begin{vmatrix} 1&amp;1&amp;\\cdots&amp;1\\\\ x_1&amp;x_2&amp;\\cdots&amp;x_n\\\\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots\\\\ {x_{1}}^{n-1}&amp;{x_{2}}^{n-1}&amp;\\cdots&amp;{x_{n}}^{n-1} \\end{vmatrix}=\\prod_{1≤j&lt;i≤n}(x_i-x_j)$$ 对称行列式主对角线无要求，上下位置对应相等；反对称行列式主对角线全为零，上下位置对应成相反数。 矩阵及其运算矩阵的运算 负矩阵：A，-A；n阶方阵：行数=列数，$A_{n×n}=A_n$；单位阵：方阵对角线都是1，其余为0，记作E。 矩阵加（减）法：同型矩阵，对应元素相加（减）。 矩阵数乘：kA，用 k 乘以 A 的每个元素。 矩阵提公因子：每个元素都有公因子则向外提一次。 AB 相乘条件：A 的列数=B 的行数。 C=AB，结果矩阵形状：C 的行数=A 的行数；C 的列数=B 的列数。 矩阵乘法不满足： AB 一般不等于 BA。 AB=AC，且 A≠0，推不出 B=C。 AB=0，推不出 A=0，或 B=0。 与零矩阵相乘：$A_{4×3}O_{3×2}=O_{4×2}$； 与E相乘：$AE=A$，$EB=B$； 运算规则：$\\begin{cases}(AB)C=A(BC)\\\\(A+B)C=AC+BC\\\\k(A+B)=(kA)B=A(kB)\\end{cases}$。 次幂：$A^k=AA\\cdots A$（k 个 A 相乘）。 $A^m×A^n=A^{m+n}$$(A^m)^n=A^{mn}$$(P^{-1}AP)^n=P^{-1}A^nP$ $(A^T)^T=A$$(kA)^T=kA^T$$(A+B)^T=A^T+B^T$$(AB)^T=B^TA^T$ $diag(1, 2, 3)=\\begin{bmatrix}1&amp;0&amp;0\\\\0&amp;2&amp;0\\\\0&amp;0&amp;3\\end{bmatrix}$。 对称矩阵：$A^T=A$反对称矩阵：$A^T=-A$ $|A^T|=|A|$$|kA|=k^n|A|$$|AB|=|A||B|$ 分块矩阵求转置分两步： 将分块矩阵的块看作普通元素求转置。 对每一个块求转置。 $\\begin{bmatrix} A_1&amp;0&amp;0&amp;0\\\\0&amp;A_2&amp;0&amp;0\\\\0&amp;0&amp;A_3&amp;0\\\\0&amp;0&amp;0&amp;A_4 \\end{bmatrix}$=$\\begin{bmatrix} A_1^{-1}&amp;0&amp;0&amp;0\\\\0&amp;A_2^{-1}&amp;0&amp;0\\\\0&amp;0&amp;A_3^{-1}&amp;0\\\\0&amp;0&amp;0&amp;A_4^{-1} \\end{bmatrix}$；$H=\\begin{bmatrix} A&amp;C\\\\0&amp;B \\end{bmatrix}$，$H^{-1}=\\begin{bmatrix} A^{-1}&amp;A^{-1}CB^{-1}\\\\0&amp;B^{-1} \\end{bmatrix}$。 标准形： 对角线全0或全1。 对角线从上到下是连续的1和连续的0。 可以不是方阵。 逆矩阵 逆矩阵：$AB=BA=E$，逆矩阵一定是方阵。推论：$AB=E$，A, B 均可逆，所以 $A^{-1}=B$, $B^{-1}=A$ 求 $A^{-1}$： 伴随矩阵法：$A^{-1}=\\frac{1}{|A|}A^*$ 初等变换法：$(\\begin{array}{c:c}A&amp;E\\end{array}) \\longrightarrow (\\begin{array}{c:c}E&amp;A^{-1}\\end{array})$ $(A^{-1})^{-1}=A$$(AB)^{-1}=B^{-1}A^{-1}$ $(A^T)^{-1}=(A^{-1})^T$$(kA)^{-1}=\\frac{1}{k}A^{-1}$ $|A^{-1}|=\\frac{1}{|A|}$$(A^{-1})^{\\ast}=(A^*)^{-1}=\\frac{1}{|A|}A$ A 可逆则 $|A|≠0$。 伴随矩阵 按行求代数余子式，按列放，伴随矩阵一定是方阵。 $AA^{\\ast}=A^{\\ast}A=|A|E$ $|A^{\\ast}|=|A|^{n-1}$ $A^{-1}=\\frac{1}{|A|}A^{\\ast} \\longrightarrow A^{\\ast}=|A|A^{-1}$ $R(A^{\\ast})=\\begin{cases} n,&amp;若 R(A)=n\\\\ 1,&amp;若 R(A)=n-1\\\\ 0,&amp;若 R(A)&lt;n-1 \\end{cases}$ 矩阵的初等变换初等矩阵初等变换 三种初等行变换，三种初等列变换： 交换两行（列）。 用一个非0数乘某一行（列）。 某一行（列）的 k 倍加到另一行（列）上去。 等价：AB 是同型矩阵，A 经初等变换得到 B（同型矩阵行列相等）。 等价：AB 是同型矩阵，存在可逆 P, Q，使得 $PAQ=B$。 初等矩阵即对E做y一次初等变换得到的矩阵。 初等矩阵均可逆，其逆矩阵也是初等矩阵，转置矩阵也是初等矩阵。 初等矩阵左乘 A，相当于对 A 做初等行变换。初等矩阵右乘 A，相当于对 A 做初等列变换。 初等矩阵 $E(i, j)$ 表示交换 i, j 行。其中 $|E(i, j)|=-1$，$E^{-1}(i, j)=E(i, j)$。初等矩阵 $E(i(k))$ 表示用 k 乘第 i 行。其中 $|E(i(k))|=k$，$E^{-1}(i(k))=E(i(\\frac{1}{k}))$。初等矩阵 $E(i, j(k))$ 表示用第 j 行的 k 倍加到第 i 行上。其中 $|E(i, j(k))|=1$，$E^{-1}(i, j(k))=E(i, j(-k))$。 矩阵的秩 R(A)：非零子式的最高阶数。 零矩阵的秩为0。 $0≤R(A)≤min\\{行数, 列数\\}$，若$R(A)=min\\{行数, 列数\\}$则称为满秩，若$R(A)＜min\\{行数, 列数\\}$则称为降秩。 若A是方阵且满秩即|A|≠0，则A可逆。 $R(A)=r \\Longleftrightarrow $有一个 r 阶非零子式，所有 r+1 阶子式均为0。 初等变换（行, 列）不改变矩阵的秩。 求 R(A)，将 A 化为阶梯型（初等行列变换均可），数非零行的行数。阶梯型画线横线可跨多个数，竖线只能跨一个数。行简化阶梯型：在阶梯型的基础上，非零行的首非零元是1；首非零元所在列其余元素是0。 $R(A)=R(A^T)$ P, Q 可逆，$R(A)=R(PA)=R(AQ)=R(PAQ)$。 $max\\{R(A), R(B)\\}≤R(A, B)≤R(A)+R(B)$ $R(A+B)≤R(A)+R(B)$ $R(AB)≤min\\{R(A), R(B)\\}$ $A_{m×n}·B_{n×l}=0$，则 $R(A)+R(B)≤n$。 $A·B=0$，若 A 为列满秩矩阵，则 $B=0$。（列满秩矩阵即矩阵的秩等于矩阵的列数。） 向量组的线性相关性向量的线性组合 $kα=0 \\Longleftrightarrow k=0 或 α=0$ 零向量可由任意向量组表示。 向量组中的一个向量可由该向量组表示。 任意向量可由单位向量组表示。 向量组等价：两向量组可相互表示。 线性相关 &amp;&amp; 线性无关 线性相关：存在不全是0的 $k_1, \\cdots, k_n$，使 $kα_1+ \\cdots +kα_n=0$。 线性无关：$kα_1+ \\cdots +kα_n=0$ 成立，$k_1, \\cdots, k_n$ 全取0。 线性相关、无关的性质 向量组中两个向量分量成比例，向量组线性相关。 一个零向量线性相关，一个非零向量线性无关。 含零向量的向量组必线性相关。 部分组线性相关，则整体组线性相关。整体组线性无关，则部分组线性无关。 向量组线性无关，则接长组线性无关。向量组线性相关，则截短组线性相关。 n 个 n 维向量线性无关 $\\Longleftrightarrow D≠0$n 个 n 维向量线性相关 $\\Longleftrightarrow D=0$ 线性相关、无关的定理 向量线性相关 $\\Longleftrightarrow$ 至少一个向量是其余向量的线性组合。 $α_1, \\cdots, α_s$ 线性无关，$α_1, \\cdots, α_s, β$ 线性相关，则 β 可由 $α_1, \\cdots, α_s$ 唯一线性表示。 $α_1, \\cdots, α_s$ 线性无关，可由 $β_1, \\cdots, β_t$ 线性表示，则 $s≤t$。 $α_1, \\cdots, α_s$ 可由 $β_1, \\cdots, β_t$ 线性表示，且 $s&gt;t$，则 $α_1, \\cdots, α_s$ 线性相关。 向量个数 &gt; 向量维数，向量组线性相关。 n+1 个 n 维向量必线性相关。 等价的线性无关的向量组，含相同个数的向量。 极大线性无关组 线性无关组的定义：$α_1, α_2, \\cdots, α_r$ 的部分组如 $α_1, α_2$ 无关且每个向量均可由 $α_1, α_2$ 表示。 线性无关向量组的极大无关组是本身。 向量组与其极大无关组等价。 向量组的不同极大无关组含向量个数相同。 向量组的秩：极大无关组含向量的个数。 $0≤R(α_1, \\cdots, α_s)≤min\\{向量个数, 向量维数\\}$ A 的行秩=A 的列秩= R(A) $R(AB)≤min\\{R(A), R(B)\\}$ 求极大线性无关组： 不管向量是行或列，均按行构成矩阵。 只做初等行变化，化成行最简形矩阵。 首非零元所在列做极大无关组。 其余向量表示系数直接写出即可。 线性方程组AX=B 有解判定 $R(A)=R(Ā)=n$，有唯一解。（$R(Ā)$是带上等式右边的矩阵的秩。） $R(A)=R(Ā)&lt;n$，有无穷解。 $R(A)≠R(Ā)$，无解。 一般解计算方法： 写出Ā。 通过初等行变化转换成阶梯型。 判断解的个数。 化为行简化阶梯型，非零行的首非零元留在等式左边，其余变量留在等式右边得一般解。 AX=0 齐次方程组 齐次方程组一定有解，至少有零解。 齐次方程组仅有零解 $\\Longleftrightarrow R(A)=n$。 齐次方程组有非零解 $\\Longleftrightarrow R(A)&lt;n$。 齐次方程组中，方程个数&lt;未知数个数，有非零解。 齐次方程组中，方程个数=未知数个数，有非零解 $\\Longleftrightarrow$ 系数行列式等于零；仅有零解 $\\Longleftrightarrow$ 系数行列式不等于零。 AX=0 解的结构 $AX=0$ 的两个解相加仍然是解。 η 是 $AX=0$ 的解，则 cη 也是解。 $AX=0$ 的解的线性组合仍然是解。 基础解系：$η_1, \\cdots, η_s$ 是解，满足： $η_1, \\cdots, η_s$ 线性无关。 任意解可有 $η_1, \\cdots, η_s$ 表示。 $AB=0$，则 $R(A)+R(B)≤n$。 AX=B 解的结构 $AX=B \\longrightarrow AX=0$（导出组） $AX=B$ 的两个解相减是 $AX=0$ 的解。 $AX=B$ 的一个解和 $AX=0$ 的一个解相加是 $AX=B$ 的另一个解。 $AX=B$ 的通解：特解 + 基础解系的线性组合。 $AX=B$ 的一个特解。 $AX=0$ 的基础解系。 相似矩阵及其二次型特征值 &amp;&amp; 特征向量 $Aα=λα$，其中$λ$是特征值，$α$是对应于$λ$的特征向量。特征值可以是零，特征向量是非零向量。 $|λE-A|=0$，用于求特征值。$(λE-A)X=0$ 的非零解，用于求特征向量。解法： 1.写出$|λE-A|$。 2.把某行尽可能转化为零后再按行展开。 3.提关于$λ$的公因子。 4.将$λ$代入$|λE-A|$，做初等行变化转换成行简化阶梯型，计算其基础解系。 A 和 $A^T$ 有相同的特征值。 $\\sum λ_i=\\sum a_{ii}$$λ_1, \\cdots, λ_n=|A|$ 矩阵的迹 $tr(A)=\\sum a_{ii}$ 不同特征值对应的特征向量线性无关。（实对称矩阵，不同特征值对应的特征向量一定正交。） k 重特征值的线性无关的特征向量个数小于等于 k 个。 kλ 是 kA 的特征值。 $λ^k$ 是 $A^k$ 的特征值。 求 A 的多项式的特征值：A 替换成 λ，E 替换成 1。 $λ^{-1}$ 是 $A^{-1}$ 的特征值。 $\\frac{1}{λ}|A|$ 是 $A^*$ 的特征值 相似矩阵 A, B 是同阶方阵，存在可逆 P，$P^{-1}AP=B$。 相似矩阵具有反身性，对称性和传递性。 $A\\sim B\\begin{cases} A, B 有相同的特征值。\\\\ |A|=|B|\\\\ tr(A)=tr(B)\\\\ |A|和|B| 同时为零或同时不为零，因此 A, B 同时不可逆或同时可逆。\\\\ A, B 若可逆则 A^{-1}\\sim B^{-1}。\\\\ A^m\\sim B^m \\end{cases}$ 对角化 A 相似于对角行 $\\Longleftrightarrow$ A 有 n 个线性无关的特征向量。 A 有 n 个互异特征值，可对角化。 不管单根，若每个 k 重特征根，都有 k 个特征向量，则可对角化。 特征向量做列构成 P， 特征值做主对角线构成 A，特征值和特征向量位置对应。 内积 $[α, β]=α^Tβ$，若 α, β 是列向量。 内积是一个数。 $[α, α]≥0$, $[α, α]=0$ $\\Longleftrightarrow$ $α=0$ $[α, β]=[β, α]$$[kα, β]=k[β, α]=k[α, β]$$[α+β, γ]=[α, γ]+[β, γ]$ 长度 $||α||=\\sqrt{[α, α]}$$||α||^2=[α, α]$$[α, α]=||α||^2$ $||α||≥0$, $||α||=0$ $\\Longleftrightarrow$ $α=0$ $||kα||=|k|·||α||$$|[α, β]|≤||α||·||β||$ $||α+β||≤||α||+||β||$ $[α, β]=0$，即正交，$α \\bot β$。 正交向量组：不含零向量，两两正交。 标准正交向量组：正交向量组，每个向量都是单位向量。 施密特正交化：$α_1, α_2, α_3$ | $β_1, β_2, β_3$$β_1=α_1$$β_2=α_2-\\frac{[α_2, β_1]}{[β_1, β_1]}β_1$$β_3=α_3-\\frac{[α_3, β_1]}{[β_1, β_1]}β_1-\\frac{[α_3, β_2]}{[β_2, β_2]}β_2$$\\cdots$ 正交 A 是方阵，$A^TA=E$，A 为正交矩阵。 A 正交，$|A|=1 或 -1$，$|A^{-1}|=A^T$。 A 正交，$A^{-1}$ 和 $A^T$ 也正交。A, B 正交，$AB$ 也正交。 A 正交，$[Aα, Aβ]=[α, β]$。 A 正交 $\\Longleftrightarrow$ 列（行）向量组是标准正交向量组。 正交相似 实对称矩阵 A 的不同特征值的特征向量必正交。 正交相似：A, B 是同阶方阵，存在正交 P，$P^{-1}AP=B$。 A 是实对称矩阵，存在正交 Q，$Q^{-1}AQ=\\bigwedge$。 Q：正交单位化后的特征向量做列。$\\bigwedge$：特征值作为主对角线元素。 二次型 二次型 $\\longrightarrow$ 矩阵： 平方项系数做主对角线。 交叉项系数除以二放两对称位置。 矩阵 $\\longrightarrow$ 二次型： 主对角线做平方项系数。 主对角线右上角元素乘以二做交叉项系数。（如矩阵不对称则先将矩阵化为对称矩阵） 二次型的矩阵对称。 $X=CY$，线性替换。 合同 A, B 是 n 阶方阵，存在可逆 C，$C^TAC=B$。 合同矩阵具有反身性，对称性和传递性。 $A\\simeq B\\begin{cases} R(A)=R(B)\\\\ A 对称 \\Longleftrightarrow B 对称\\\\ A, B 可逆，A^{-1}\\simeq B^{-1}\\\\ A^T\\simeq B^T \\end{cases}$ 标准形 标准形：只有平方项，没有交叉项。 标准形不唯一。 化标准形三种方法： 配方法：先处理 $x_1$，使后边的项中不再出现 $x_1$，再依次对 $x_2, x_3, \\cdots, x_n$ 进行配方法处理。 初等变换法：$(\\begin{array}{c:c}A\\\\E\\end{array}) \\longrightarrow (\\begin{array}{c:c}\\bigwedge\\\\C\\end{array})$（对 A, E 做列变换，只对 A 做相应的行变换，$\\bigwedge$是对角矩阵即除了对角线以外都是零。） 正交替换法：正交 Q，$Q^TAQ=\\bigwedge$。， 规范形 规范形：只有平方项，系数只能为1, -1, 0，且变量的下标是连着的。（1, -1, 0 系数不可变换位置） 规范形是唯一的。 正惯性指数：规范形的正项个数。负惯性指数：规范形的负项个数。符号差：正惯性指数-负惯性指数。 $A\\simeq B$ $\\Longleftrightarrow$ 有相同的秩和正惯性指数。 正定 二次型 $X^TAX$，任意 $X≠0$： $X^TAX&gt;0$，正定。 $X^TAX&lt;0$，负定。 $X^TAX≥0$，半正定。 $X^TAX≤0$，半负定。 正定二次型经过非退化替换仍化为正定二次型。 二次型正定 $\\Longleftrightarrow$ 标准形每个变量的系数都大于零。 二次型正定 $\\Longleftrightarrow$ 正惯性指数为 n。 A 正定，$|A|&gt;0$。 A 正定 $\\Longleftrightarrow$ A 的特征值都大于零。 A 正定 $\\Longleftrightarrow$ A 各阶顺序主子式大于零。 A 正定 $\\longrightarrow$ ①$A^{-1}正定$②${A^*正定}$③$A^k正定$④A 主对角线元素都大于零。 A 正定，B（半）正定 $\\longrightarrow$ A+B 正定。 总结外提 k 行列式一行（列）有公因子 k，向外提一次。 矩阵所有元素都有公因子 k，向外提一次。 向量所有分量都有公因子 k，向外提一次。 $|kA|=k^n|A|$ $(kA)^{-1}=\\frac{1}{k}A^{-1}$ $(kA)^=k^{n-1}A^$ $(kA)^T=kA^T$ $[kα, β]=k[α, β]$ $||kα||=|k|·||α||$ 方阵 A 可逆充要条件 $|A|≠0$ A 满秩。（R(A)=行，R(A)=列。） A 的标准形是 E。 $A=E_1E_2 \\cdots E_s$，$E_i$是初等矩阵。 A 的所有特征值不为0。 $R(A)=n$ A 的行秩=A 的列秩=R(A)=n A 的行（列）向量组无关。 A 的非零子式最高阶数为 n。 AX=0 只有零解。AX=B 有唯一解。 等价、相似、正交相似、合同 $\\cong$ 等价：A, B 同型，存在可逆 P, Q，$PAQ=B$。 $\\sim$ 相似：A, B 方阵，存在可逆 P，$P^{-1}AP=B$。 $\\sim$ 正交相似：A, B 方阵，存在正交 P，$P^{-1}AP=B$。 $\\simeq$ 合同：A, B 方阵，存在可逆 P，$P^TAP=B$。 正交相似肯定相似，且一定合同（$P^{-1}=P^T$）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Django（二）：ORM","date":"2019-12-21T13:15:33.000Z","path":"posts/b179370b/","text":"ORMDjango ORM 默认使用 SQLite 数据库，它是一款轻型的数据库，是遵守ACID的关系型数据库管理系统，它包含在一个相对小的 C 库中。也可以使用其他数据库，例如 MySQL，修改 Django 的默认连接为 MySQL 方式之后，即可通过 Django 的 ORM 操作 MySQL 数据库。 默认数据库连接修改默认数据库连接可以通过修改主目录文件夹下的 settings.py 文件中的 DATABASES 参数。此处以 MySQL 为例，代码如下： DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': '数据库名', 'HOST': '127.0.0.1', 'PORT': '3306', 'USER': '', 'PASSWORD': '', } } 如果是低版本的 pymysql 连接数据库则还需要再主目录文件夹下的 __init__.py 文件夹中输入如下代码： import pymysql pymysql.install_as_MySQLdb() 数据表操作Django 支持在应用的 models.py 中进行数据表的增删改操作，示例代码如下： # models.py from django.db import models # 此处User在数据库中的表名为user.user，因为该models在user应用下，其中类名会自动小写。 class User(models.Model): username = models.CharField(max_length=45, unique=True) password = models.CharField(max_length=45) # 此处department在数据库中的字段名为department_id，Django会自动增加_id为尾缀 department = models.ForeignKey(\"Department\") class Department(models.Model): name = models.CharField(max_length=32) 字段参考 字段名 作用 models.AutoField int 类型=int(11)。如果类中没有 models.AutoField，则默认会创建一个字段名为 id 的自增列，且默认标注为主键。 models.CharField 字符串类型=varchar。必须有 max_length 参数。 models.BooleanField boolean 类型=tinyint(1)。不能为空，Blank=True。 models.ComaSeparatedIntegerField 用逗号分割的数字=varchar。继承CharField，所以必须 max_length 参数。 models.DateField 日期类型=date。对于参数，auto_now=True 则每次更新都会更新这个时间；auto_now_add=True 则只是第一次创建时添加，之后的更新不再改变。 models.DateTimeField 日期类型=datetime。同 DateField 的参数。 models.Decimal 十进制小数类型=decimal。必须指定整数位 max_digits 和小数位 decimal_places。 models.EmailField 字符串类型（正则表达式邮箱）=varchar。对字符串进行邮箱正则表达式验证。 models.FloatField 浮点类型=double。 models.IntegerField 整型=int。 models.BigIntegerField 长整型=bigint。 models.IPAddressField 字符串类型（ip4 正则表达式） models.GenericIPAddressField 字符串类型（ip4 或 ip6 正则表达式）。参数 protocol 可以是：both、ipv4 或 ipv6 models.NullBooleanField 允许为空的布尔类型。 models.PositiveIntegerFile 正 integer。 models.PositiveSmallIntegerField 正 smallInteger。 models.SlugField 减号、下划线、字母和数字。 models.SmallIntegerField 整型，对应数据库中的 tinyint、smallint、int、bigint。 models.TextField 字符串类型=longtext。 models.TimeField 时间。HH:MM[:ss[.uuuuuu]]。 models.URLField 字符串类型（正则表达式地址）。 models.BinaryField 二进制=binary。 models.ImageField 图片。存储图片名，常与 upload_to 参数连用，设置图片路径。 models.FilePathField 文件。存储文件名常与 upload_to 参数连用，设置文件路径。 models.ForeignKey(其他表类名) 多对一，参数 on_delete 必须。例如动物和狗，则在狗中添加 ForeignKey。 models.OneToOneField(其他表类名) 一对一，参数 on_delete 必须。例如主表和从表，则在从表中添加 OneToOneField。 models.ManyToManyField(其他表类名) 多对多。 参数参考 参数（默认值） 作用 null=True 数据库中字段是否可以为空，True 可以。 blank=True django 的 admin 中添加数据时是否可允许空值，True 可以。 primary_key=False 主键，对 AutoField 设置主键后会代替原来的自增 id 列 ，True 作为主键列。 auto_now 自动创建，无论添加或修改都是会修改成当前操作的时间。 auto_now_add 自动创建，时间永远是创建时的时间。 choices 常用于下拉菜单。例如使用M可以获得Male：class Person(models.Model): GENDER_CHOICES = ( (‘M’, ‘Male’), (‘F’, ‘Female’), ) models.CharField(max_length=2, choices=GENDER_CHOICES)Person(gender=”M”) max_length 最大长度。 default 该字段默认值。 verbose_name admin 中字段的显示名称。 name db_column unique=True 是否允许重复，True 不允许。 db_index=True 是否允许数据库索引，True 允许。 editable=True 在 admin 里是否可编辑。 error_messages=None 错误信息提示，True 允许。 auto_created=False 自动创建，True 允许。 help_text 在 admin 中提示帮助信息。 upload_to 常用于设置文件、图片的上传路径。 on_delete 有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值。CASCADE：级联删除，常用。PROTECT：报完整性错误。SET_NULL：把外键设置为 null，前提是允许为 null。SET_DEFAULT：为外键设置默认值。SET()：此调用其他值，可以是一个函数。 数据行操作进行数据库行操作时，首先需要导入该模块的 models。例如导入 user 模块的 models，代码如下： from user import models 增加 自动提交（传对应参数） models.User.objects.create(username='root', password='123456') 自动提交（传字典，字典中 key 与数据库字段名一一对应） user_info = {\"username\": \"root\", \"password\": \"123456\"} models.User.objects.create(**user_info) 手动提交 obj = models.objects(username='root', password='123456') obj.save() 删除models.User.objects.filter(username='root').delete() 修改 自动提交 models.User.objects.filter(username='root').update(password='654321') 手动提交 obj = models.User.objects.get(username='root') obj.password = '654321' obj.save() 查询 根据条件查找单个 # 查找 username 为 root 的用户 models.User.objects.get(username=\"root\") 查找所有 models.User.objects.all() 查找所有，但只取 values 参数中选定的列 # 只取 username 列 models.User.objects.all().values('username') 查找所有，但只取 values_list 参数中选定的列，并返回一个 list（默认 tuple）。 models.User.objects.all().values_list('username', 'password') 获取所查表行数。 # 查 user 表一共有多少条数据 models.User.objects.count() 根据条件查找。 # 查找 id = 1 的 models.User.objects.filter(id=1) # 查找 id > 1 的 models.User.objects.filter(id__gt=1) # 查找 id &lt; 1 的 models.User.objects.filter(id__lt=1) 自定义 SQL 语句操作获取 django.db.connection 后，直接通过 pymysql 进行操作。 from django.db import connection cursor = connection.cursor() # 增加(插入一条数据成功返回主键，失败返回0) def create_one(): sql = \"insert语句\" result = 0 try: cursor.execute(sql) # 获取插入的数据 id result = connection.insert_id() connection.commit() except Exception as ex: print(\"插入异常：\", ex) connection.rollback() return result # 增加(插入多条数据成功返回更新条数，失败返回0) def create_many(): sql = \"insert语句\" info_list = [(\"root\", \"123\"), (\"admin\", \"321\")] result = 0 try: result = cursor.executemany(createmany_sql, info_list) connection.commit() except Exception as ex: print(\"插入异常：\", ex) connection.rollback() return result # 更新一条数据，返回影响条数 def update(): sql = \"update|delete语句\" result = 0 try: cursor.execute(sql) result = cursor.rowcount connection.commit() except Exception as ex: print(\"更新异常：\", ex) connection.rollback() return result # 查询数据，返回查询的数据，失败返回None def get(): sql = \"selete语句\" result = None try: cursor.execute(sql) # 查询单条用fetchone，查询多条用fetchall result = cursor.fetchone() except Exception as ex: print(\"查找异常：\", ex) return result 事务from django.db import transaction with transaction.atomic(): 数据库操作语句 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"django","slug":"django","permalink":"https://blog.kuukokawaii.com/tags/django/"}]},{"title":"Django（一）：简介","date":"2019-12-21T08:43:22.000Z","path":"posts/1e026f1b/","text":"MTV 框架模式Django 是一个遵循 MVC 设计模式的框架，采用了 MTV 的框架模式（T 即 Template），其中控制器接受用户输入的部分由框架自行处理，因此 Django 更关注模板部分。 项目搭建Django 所需命令可以通过django-admin help查看所拥有的命令，使用django-admin help 命令名字可以查看该命令如何使用。 Django 目录结构 templates：存放视图文件。 static：存放静态文件。 django_temp：存放项目相关文件。 settings.py：项目相关配置。 urls.py：路由配置。 user：存放应用模块相关文件。 admin.py：后台管理相关配置。 dao.py：数据库操作相关。 models.py：自定义类，并根据类创建数据库表。 tests.py：单元测试。 views.py：业务处理。 配置静态文件夹在 settings 中配置静态文件夹，代码如下： STATIC_URL = '/static/' STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'), ] 配置模板文件夹在 settings 中配置模板文件夹，修改DIRS中的templates即可修改模板文件夹位置。代码如下： TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 创建一个应用首先通过命令python manage.py startapp 名字创建应用。其次在 settings 中添加新增的应用即可。例如新创建的应用名为user，代码如下： INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'user', ] 配置路由 在 urls.py 中的urlpatterns新增路由即可。path 中第一个参数为 URI 映射位置，后一个参数为需要映射到的服务位置（方法），代码如下： urlpatterns = [ path('admin/', admin.site.urls), path('login/', user_controller.login), path('register/', user_controller.register), ] URL 也可以动态匹配，常用于 Restful 设计风格。函数只需多加变量，即可获得该匹配的 URI 地址，代码如下： urlpatterns = [ # 匹配0和任意整数 path('user/&lt;int:uid>/', user_controller.update), # 匹配除了'/'以外的非空字符串 path('user/&lt;str:username>/', user_controller.update), # 匹配任意由 ASCII 字母或数字以及连字符和下划线组成的短标签 path('user/&lt;slug:username>/', user_controller.update), ] def update(uid): return HttpResponse(uid) 项目主文件夹的 urls.py 还可以通过 include() 函数包含其他子文件夹的路由映射。例如在主文件中包含 user 文件夹下的 urls.py，此时所有 user 文件夹下的路径都会加上user/的前缀： # main.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('user/', include(\"user.urls\")), ] # user文件夹下的 urls.py from django.urls import path from user.views import login, register, index, temp urlpatterns = [ path('login/', login), path('register/', register), path('index/', index), path('temp/&lt;str:slug>/', temp), ] path 可以取别名，此时在前端页面可以通过花括号内% url 名字 [参数] %的形式调用。当目录过深时，会使用别名取代长路径，代码如下： urlpatterns = [ path('temp/&lt;str:slug>/', temp), ] &lt;form action=\"{% url 名字 参数%}\" method=\"POST\"> 花括号内输入% csrf_token % &lt;/form>411 初始化 Django 数据库 Django 拥有自带的数据库，但此处使用 Mysql 数据库为例（需要安装 mysqlclient），在应用的models.py中通过表创建数据库。此处建立一个 User 表，代码如下： from django.db import models class User(models.Model): username = models.CharField(max_length=45, unique=True) password = models.CharField(max_length=45) 通过命令行输入python manage.py makemigrations保存修改在本地。 输入python manage.py migrate提交本地修改至数据库，即可完成建表操作。 注意事项Django CSRF 提交问题Django 中设置防跨站请求伪造功能，当用 POST 提交数据的时候，Django 会去检查是否有一个 CSRF 的随机字符串，如果没有则会报错（Forbidden 403）。 在表单中通过 POST 方法提交出现问题，则需要再表单中输入花括号内包含% csrf_token %即可完成完成操作。代码如下： &lt;form action=\"\" method=\"POST\"> 花括号内输入% csrf_token % &lt;/form> 通过 AJAX 提交 POST 请求，需要在 data 中添加csrfmiddlewaretoken数据即可完成提交。代码如下： $.ajax({ url: \"/\", type: \"POST\", data: { csrfmiddlewaretoken: \"{{ csrf_token }}\" }, success: function (data) { }, error: function (error) { } }); 支持 PUT 和 DELETE支持 PUT 和 DELETE 请求，修改 ajaxSetup 函数即可。代码如下： function csrfSafeMethod(method) { return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method)); } $.ajaxSetup({ beforeSend: function (xhr, settings) { if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) { xhr.setRequestHeader(\"X-CSRFToken\", \"{{ csrf_token }}\"); } } }); 后台获取 DELETE 和 PUT 请求携带的参数代码如下： from django.http import QueryDict QueryDict(request.body).get(\"参数名\") session 存储对象session 存储对象需要对对象进行序列化。Django 中用 session 序列化对象需要在 settings.py 中添加如下代码： SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer' document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"django","slug":"django","permalink":"https://blog.kuukokawaii.com/tags/django/"}]},{"title":"Python：邮件发布","date":"2019-12-17T00:55:21.000Z","path":"posts/1530706b/","text":"发送模板import smtplib from email.mime.text import MIMEText smtp_obj = None # QQ邮箱host host = \"smtp.qq.com\" # QQ邮箱port port = 465 password = \"\" # 邮件内容 content = \"内容\" # MIMIE邮件体 message = MIMEText(content) # 邮件标题 message[\"Subject\"] = \"标题\" message[\"From\"] = \"1398524980@qq.com\" message[\"To\"] = \"1134177664@qq.com\" try: # 基于SSL安全协议和发送邮件 smtp_obj = smtplib.SMTP_SSL(host, port) # 邮件发送人验证 smtp_obj.login(message[\"From\"], password) smtp_obj.sendmail(message[\"From\"], message[\"To\"], message.as_string()) except Exception as e: print(\"发送失败\", e) finally: smtp_obj.close() print(\"发送成功\") document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"python","slug":"python","permalink":"https://blog.kuukokawaii.com/tags/python/"}]},{"title":"SpringBoot（十四）：监控管理","date":"2019-12-06T07:30:31.000Z","path":"posts/81ac1c26/","text":"监控管理SpringBoot 通过引入 actuator 依赖，可以获得应用监控和管理功能。可以通过 HTTP、JMX 和 SSH 协议来进行操作，自动得到审计、健康及指标信息等。监控和管理端点信息如下： 端点名 描述 autoconfig 所有自动配置信息 auditevents 审计事件 beans 所有 Bean 的信息 configprops 所有配置属性(application.yml中的配置) dump 线程状态信息 env 当前环境信息（服务器设置，系统环境变量等） health 应用健康信息 info 当前应用信息（内存大小，剩余用量等） metrics 应用的各项指标 mappings 应用@RequestMapping映射路径 shutdown 关闭当前应用（默认关闭） trace 追踪信息（获取最新的 HTTP 请求） SpringBoot 整合监控管理 引入 actuator 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId> &lt;/dependency> 通过 HTTP 方式访问监控端点，如http://localhost:8080/actuator/获取可访问地址列表。 定制端点信息 定制端点一般通过 endpoints + 原端点名 + 属性名来设置。 修改端点 ID，如endpoints.beans.id=myBean。 开启远程应用关闭功能，如endpoints.shutdown.enabled=true。 关闭端点，如endpoints.beans.enabled=false。 关闭所有端点访问：endpoints.enabled=false。 开启所需端点：endpoints.beans.enabled=true。（如关闭所有端点访问，该开启端点可以进行访问。） 定制端点访问路径，如management.context-path=/manage。 关闭 HTTP 端点，如management.port=-1；也可以修改端口，如management.port=8181。 自定义 healthIndicator实现 healthIndicator 接口，指示器名必须为xxxHealthIndicator。代码如下： /** * @Author 喵粮都输光了 * @Date 2019/12/6 16:31 * @Description 自定义状态监测 */ @Component public class CustomHealthIndicator implements HealthIndicator { @Override public Health health() { /* * 自定义检查方法： * Health.up().build() 表健康。 * Health.down().withDetail(\"message\", \"服务异常\").build() 表关闭，附带关闭信息。 */ return Health.down().withDetail(\"message\", \"服务异常\").build(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十三）：热部署","date":"2019-12-06T06:19:11.000Z","path":"posts/64a44bcd/","text":"热部署在开发中修改一个 Java 文件后想要看到效果不得不重启应用，这将导致花费大量的时间，因此希望在不重启应用的情况下，程序可以自动部署（热部署）。 热部署方式模板引擎 在 Spring Boot 中开发情况下禁用模板引擎的 cache。 页面模板改变时重新编译当前页面生效。 Spring LoadedSpring 官方提供的热部署程序，实现修改类文件的热部署。 下载 Spring Loaded。 添加运行时参数：-javaagent:[热部署程序jar包所在位置] -noverify。 JRebelJRebel 是收费的一个热部署软件，在idea 或 eclipse 安装相应插件即可使用。 Spring Boot Devtools 引入依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;optional>true&lt;/optional> &lt;/dependency> 修改编辑器的运行应用程序更新策略（此处以 IDEA 为例）。 update resources：更新资源（如果引入了依赖则为热部署更新）。 update classes and resources：更新类文件和资源（如果引入了依赖则为热部署更新）。 hot swap classes and uodate trigger file if failed：热部署更新类和目标文件，当热部署更新失败时重启应用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十二）：分布式","date":"2019-12-04T14:29:05.000Z","path":"posts/e0109747/","text":"应用架构单一应用架构当网站流量很小时，只需一个应用将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架（ORM）是关键。 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web 框架（MVC）是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。在分布式系统中，国内常用 Dubbo + Zookeeper 组合，而 SpringBoot 推荐使用全栈的 Spring、SpringBoot + SpringCloud。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等现象逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键。 Zookeeper 和 DubboZookeeperZookeeper 是一个分布式的，开放源码的分布式应用程序协调服务（即注册中心）。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步和组服务等。 DubboDubbo 是 Alibaba 开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象处服务提供方（Provider）和服务消费方（Consumer）两个角色。 Container 在启动时负责加载运行 Provider。 Provider 在运行时将所拥有的服务信息注册至 Registry。 Consumer 在启动时会从 Registry 订阅所需服务，Registry 将 Consumer 所需服务的地址列表返回给 Registry。当 Provider 的服务信息有变更时，Registry 会基于长连接的方式将更新推送给 Consumer。 Consumer 需要调用服务时，可以根据负载均衡机制找到服务提供者位置并调用服务，如调用失败则可从服务地址列表中查找该服务的其他提供者调用服务直至调用成功为止。 Monitor 用于监控调用信息。 SpringBoot 整合 Dubbo、Zookeeper 父类 MAVEN 项目 springboot_dubbo，仅用于控制模块的依赖版本。pom 文件如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>springboot_dubbo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;artifactId>provider-ticket&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>provider-ticket&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-dependencies-zookeeper&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 项目模块 provider-ticket，用于继承父类依赖实现出票功能。 pom 文件继承父类 Dubbo 和 zookeeper 依赖版本。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>springboot_dubbo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;artifactId>provider-ticket&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>provider-ticket&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-dependencies-zookeeper&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置注册中心相关信息以及服务提供者所在位置，并通过@Service注解暴露服务。 application.yml配置包扫描+@Service配置方式（注意此处导入的一定要是import org.apache.dubbo.config.annotation.Service）。 dubbo: application: name: provider-ticket registry: address: zookeeper://localhost:21810 scan: base-packages: com.kuukokawaii.ticket.service import org.apache.dubbo.config.annotation.Service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 10:42 * @Description 出票 service 实现 */ @Service public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"取到票了！！\"; } } @DubboComponentScan或@EnableDubbo注解+@Service的配置方式。@DubboComponentScan和@EnableDubbo注解二选一标注于主程序类上，接口实现类仍需@Service注解（注意导入 dubbo 的注解），而application.yml中则无需配置包扫描。 /** * @Author 喵粮都输光了 * @Date 2019/12/6 10:47 * @Description 主程序 */ @SpringBootApplication //@DubboComponentScan(\"com.kuukokawaii.ticket.service\") @EnableDubbo(scanBasePackages = \"com.kuukokawaii.ticket.service\") public class ProviderTicketApplication { public static void main(String[] args) { SpringApplication.run(ProviderTicketApplication.class, args); } } import org.apache.dubbo.config.annotation.Service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 10:42 * @Description 出票 service 实现 */ @Service public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"取到票了！！\"; } } 项目模块 consumer-user，用于继承父类依赖调用 provider-ticket 模块的出票功能。 pom 文件继承父类 Dubbo 和 zookeeper 依赖版本。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>springboot_dubbo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;artifactId>consumer-user&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>consumer-user&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-dependencies-zookeeper&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置注册中心地址（与 provider-ticket 模块同）。 dubbo: application: name: consumer-user registry: address: zookeeper://localhost:21810 consumer-user 模块通过@Reference注解远程引用 provider-ticket 模块的服务则需要先编写服务接口，必须是与 provider-ticket 模块服务接口相同的全限定名。例如此处的com.kuukokawaii.ticket.service.TicketService;（不需要实现类）。 package com.kuukokawaii.ticket.service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 11:21 * @Description 远程调用出票服务 */ public interface TicketService { /** * 出票服务 * * @return 出票String */ String getTicket(); } 通过 dubbo 的@Reference注解远程引用服务，注意此处导入的@Service注解为org.springframework.stereotype.Service。 import org.apache.dubbo.config.annotation.Reference; import org.springframework.stereotype.Service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 11:22 * @Description 用户 service */ @Service public class UserService { @Reference private TicketService ticketService; public void hello() { System.out.println(ticketService.getTicket()); } } Spring Cloud Spring Cloud 是一个分布式的整体解决方案。Spring Cloud 为开发者提供了在分布式系统中快速构建的工具，使用 Spring Cloud 的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 Spring Cloud 分布式开发五大常用组件： Netflix Eureka：服务发现。 Netflix Ribbon：客户端负载均衡。 Netflix Hystrix：断路器。 Netflix Zuul：服务网关。 Spring Cloud Config：分布式配置。 Spring Cloud 对配置管理、服务发现、熔断、路由、微代理、控制总线、一次性 token、全局锁、leader 选举、分布式 session 和集群管理等问题都提供了相应的解决方案。 Spring Cloud 注册中心Spring Cloud 使用 eureka server 作为注册中心。 引入 Spring Cloud eureka server 依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>eureka-server&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>eureka-server&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.RELEASE&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置 eureka server 信息 server: port: 8761 eureka: instance: hostname: eureka-server client: # 是否注册到 eureka 服务器，此处没必要自己注册自己到服务器 register-with-eureka: false # 不从 eureka 上获取服务的注册信息 fetch-registry: false # 设置注册中心地址 service-url: defaultZone: http://localhost:${server.port}/eureka/ 通过@EnableEurekaServer注解标注主程序启用 eureka server。 /** * @Author 喵粮都输光了 * @Date 2019/12/6 12:39 * @Description 注册中心主程序 */ @EnableEurekaServer @SpringBootApplication public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } provider 服务提供者 引入 Spring Cloud Eureka Discovery Client 依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>provider-ticket&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>provider-ticket&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.RELEASE&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置 eureka client provider 信息 server: port: 8001 spring: application: name: provider-ticket eureka: instance: # 注册服务时使用服务的IP地址作为前缀 prefer-ip-address: true client: service-url: # 必须要和 eureka server 相同 defaultZone: http://localhost:8761/eureka/ eureka 提供服务 /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:12 * @Description 出票 service */ public interface TicketService { /** * 出票功能 * @return 出票String */ String getTicket(); } /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:08 * @Description 出票 service 实现 */ @Service public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"出票了！！\"; } } /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:10 * @Description 出票 controller */ @RestController public class TicketController { @Resource private TicketServiceImpl ticketService; @GetMapping(\"/ticket\") public String getTicket() { return ticketService.getTicket(); } } consumer 服务使用者 引入 Spring Cloud Eureka Discovery Client 依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>consumer-user&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>consumer-user&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.RELEASE&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置 eureka client consumer 信息 server: port: 8002 spring: application: name: consumer-user eureka: instance: # 注册服务时使用服务的IP地址作为前缀 prefer-ip-address: true client: service-url: # 必须要和 eureka server 相同 defaultZone: http://localhost:8761/eureka/ 通过@EnableDiscoveryClient注解开启发现服务功能 /** * @Author 喵粮都输光了 * @Date 2019/12/6 12:43 * @Description consumer 主程序 */ @EnableDiscoveryClient @SpringBootApplication public class ConsumerUserApplication { public static void main(String[] args) { SpringApplication.run(ConsumerUserApplication.class, args); } /** * \"@LoadBalanced\"启用负载均衡机制。 * \"RestTemplate\"是Spring提供的用于访问Rest服务的客户端，提供了多种便捷访问远程Http服务的方法。 * 此处用于远程引用provider的服务。 * @return Rest服务客户端对象 */ @LoadBalanced @Bean public RestTemplate restTemplate() { return new RestTemplate(); } } consumer 调用 provider 服务 /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:53 * @Description 用户 controller */ @RestController public class UserController { @Resource private RestTemplate restTemplate; @GetMapping(\"/buy\") public String buyTicket() { // getForObject根据URL获取服务（此处填写需要获取的provider名和服务名），第二个参数为返回类型。 return restTemplate.getForObject(\"http://PROVIDER-TICKET/ticket\", String.class); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十一）：安全","date":"2019-12-04T09:54:41.000Z","path":"posts/f4c26338/","text":"安全机制安全机制主要包含认证（注册主体）和授权（访问权限控制）两个区域的控制。 认证：是建立一个声明主体的过程（主体通常指用户、设备或一些可以在应用程序中执行动作的其他系统）。 授权：确定一个主体是否允许在应用程序中执行一个动作的过程(授权前主体的身份必须通过了认证过程的建立)。 Spring SecuritySpring Security 是针对 Spring 项目的安全框架，也是 Spring Boot 底层安全模块默认的技术选型。对于安全控制，只需引入 Security 模块并进行少量的配置即可实现安全管理。Spring Security 通过WebSecurityConfigurerAdapter和AuthenticationManagerBuilder两个类提供自定义 Security 策略和认证策略功能。 引入 Security 依赖。 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-security&lt;/artifactId> &lt;/dependency> 编写 SpringSecurity 配置类，需要通过@EnableWebSecurity注解开启 SpringSecurity 支持。 /** * @Author 喵粮都输光了 * @Date 2019/12/4 19:22 * @Description Security 配置类 */ @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Resource private DataSource dataSource; @Override protected void configure(HttpSecurity http) throws Exception { /* * 自定义授权规则： * 1.放行静态资源。 * 2.管理员页面需要管理员身份。 * 3.来宾页面需要来宾身份。 * 4.开启自动配置的登陆功能，如未登陆将自动跳转`/login`登陆界面，登陆失败将跳转至`/login?error`页面; * `successForwardUrl`自定义登陆成功跳转页面，`failureForwardUrl`自定义登陆失败跳转页面； * 默认'POST'请求'/login'表示进行登陆验证，'GET'请求'/login'表示跳转登陆页面； * `loginPage`自定义登陆界面，此时该页面的`GET`和`POST`分别成为了登陆验证和跳转登陆页面功能， * 可以通过`loginProcessingUrl`设置成默认的登陆验证； * `usernameParameter`可以自定义账号参数名，`passwordParameter`可以自定义密码参数名。 * 5.开启自动配置的注销功能，访问`/logout`表示用户注销，清空session，如果注销成功跳转至`/login?logout`页面； * `logoutSuccessUrl`设置注销成功跳转页面。 * 6.开启记住我功能，即自动帮忙登陆（该功能会保存cookie，注销会删除该cookie）， * 通过`rememberMeParameter()`可以自定义HTML中`checkbox`表单的`name`实现该功能。 */ http.authorizeRequests() .antMatchers(\"/css/**\", \"/\").permitAll() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"guest/**\").hasRole(\"GUEST\") .and() .formLogin() .and() .logout().logoutSuccessUrl(\"/\") .and() .rememberMe(); } /* @Bean @Override protected UserDetailsService userDetailsService() { // 使用默认的加密方式 bcrypt，PasswordEncoderFactories.createDelegatingPasswordEncoder()中实现了 10 种加密方式。 PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder(); UserDetails root = User.withUsername(\"root\") .password(passwordEncoder.encode(\"root\")).roles(\"GUEST\", \"ADMIN\").build(); UserDetails guest = User.withUsername(\"guest\") .password(passwordEncoder.encode(\"guest\")).roles(\"GUEST\").build(); // 用户信息存储于内存中 return new InMemoryUserDetailsManager(root, guest); }*/ @Bean @Override protected UserDetailsService userDetailsService() { // 使用自定义的加密方式 Map&lt;String, PasswordEncoder> encoders = new HashMap&lt;>(); encoders.put(\"MD5\", new org.springframework.security.crypto.password.MessageDigestPasswordEncoder(\"MD5\")); PasswordEncoder passwordEncoder = new DelegatingPasswordEncoder(\"MD5\", encoders); // 项目启动时默认创建两个用户 UserDetails root = User.withUsername(\"root\") .password(passwordEncoder.encode(\"root\")).roles(\"GUEST\", \"ADMIN\").build(); UserDetails guest = User.withUsername(\"guest\") .password(passwordEncoder.encode(\"guest\")).roles(\"GUEST\").build(); JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager(dataSource); jdbcUserDetailsManager.createUser(root); jdbcUserDetailsManager.createUser(guest); // 用户信息持久化 return jdbcUserDetailsManager; } } 在 HTML 界面显示授权信息，需要先整合 thymeleaf 和 security，即引入相关依赖即可。 &lt;!-- spring security 和 thymeleaf 整合--> &lt;dependency> &lt;groupId>org.thymeleaf.extras&lt;/groupId> &lt;artifactId>thymeleaf-extras-springsecurity5&lt;/artifactId> &lt;/dependency> &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/extras/spring-security\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>首页&lt;/title> &lt;link rel=\"stylesheet\" th:href=\"@{/css/bootstrap.min.css}\"> &lt;/head> &lt;body> &lt;!-- 是否认证，如果认证成功了则不显示登陆超链接 --> &lt;div sec:authorize=\"!isAuthenticated()\"> &lt;a href=\"/login\">登陆页面&lt;/a> &lt;/div> &lt;!-- 是否认证，如果认证成功了则显示注销超链接和认证信息 --> &lt;div sec:authorize=\"isAuthenticated()\"> &lt;h2>账号：&lt;span sec:authentication=\"name\">&lt;/span>&lt;/h2> &lt;h2>所有身份信息：&lt;span sec:authentication=\"principal.authorities\">&lt;/span>&lt;/h2> &lt;a href=\"/logout\">注销&lt;/a> &lt;/div> &lt;!-- 是否拥有管理员权限，有则显示管理员信息超链接 --> &lt;div sec:authorize=\"hasRole('ADMIN')\"> &lt;a href=\"/admin/info\">管理员信息&lt;/a> &lt;/div> &lt;!-- 是否拥有来宾权限，有则显示来宾信息超链接 --> &lt;div sec:authorize=\"hasRole('GUEST')\"> &lt;a href=\"/guest/info\">来宾信息&lt;/a> &lt;/div> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十）：任务","date":"2019-12-04T06:16:25.000Z","path":"posts/454051ae/","text":"异步任务spring 提供了异步任务的功能。 在主程序类上开启异步注解支持@EnableAsync。 @EnableAsync @SpringBootApplication public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } 在方法上使用异步注解@Async。 /** * @Author 喵粮都输光了 * @Date 2019/12/4 14:20 * @Description 异步任务 service */ @Service public class AsyncService { @Async public void hello() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"处理数据中...\"); } } 定时任务Spring 通过TaskExecutor和TaskScheduler接口提供了异步执行任务调度的方式。 在主程序类上开启定时任务注解支持@EnableScheduling。 @EnableScheduling @SpringBootApplication public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } 在方法上使用异步注解@Scheduled。 /** * @Author 喵粮都输光了 * @Date 2019/12/4 14:52 * @Description 定时任务 service */ public class ScheduledService { @Scheduled(cron = \"0 * * * * MON-FRI\") public void hello() { System.out.println(\"hello\"); } } cron 表达式cron表达式一共有六个字段，分别为秒，分，时，日，月和周几，每个字段之间通过空格来间隔。 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 时 0-23 , - * / 日 1-31 , - * ? / L W C 月 1-12 , - * / 星期 0-7 或 SUN-SAT(0和7都是周日) , - * ? / L C # 特殊字符 含义 , 枚举，例如0,1,2代表这几个值都会被匹配。 - 区间，例如0-2代表0,1,2这几个值都会被匹配。 * 任意，所有允许值都会被匹配。 / 步长，例如0-2，在秒字段代表从0开始每2秒就会被匹配。 ? 日和星期冲突时，在日或者星期上标?表示按照另一个未标?的时间来匹配。 L 最后，具体看标识字段。例如0 0 2 ? * 6L表每个月最后一个周六，0 0 2 LW * ?表每个月最后一个工作日。 W 工作日，匹配工作日，只能标识在日上。 C 和 calendar 联系后计算过的值 # 第几个星期，如4#2表示第二个星期四，只能标识在星期上。 邮件任务SpringBoot 使用了jakarta-mail作为默认的邮件模块，通过引入相应的 starter 并配置些许配置即可使用邮件功能。 引入 mail 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-mail&lt;/artifactId> &lt;/dependency> application.yml中配置 mail 相关配置 spring: mail: username: 账号 password: 授权码 host: smtp.qq.com # 如果不加 port 则无需配置 properties。（此处为使用 SSL 加密方式发送邮件） port: 465 properties: mail: smtp: ssl: enable: true 简单邮件发送 @Resource private JavaMailSender javaMailSender; @Test public void send() { SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setSubject(\"邮件标题\"); simpleMailMessage.setText(\"邮件内容\"); simpleMailMessage.setTo(\"目标邮箱\"); simpleMailMessage.setFrom(\"发送邮箱\"); javaMailSender.send(simpleMailMessage); } 复杂邮件发送 @Resource private JavaMailSender javaMailSender; @Test public void send() throws MessagingException { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); // 第二个参数为是否要上传文件编码。 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); mimeMessageHelper.setSubject(\"邮件标题\"); // 第二个参数为是否开启 html 支持。 mimeMessageHelper.setText(\"&lt;b style='color: red'>邮件内容&lt;/b>\", true); mimeMessageHelper.setTo(\"目标邮箱\"); mimeMessageHelper.setFrom(\"发送邮箱\"); // 上传附件 mimeMessageHelper.addAttachment(\"1.jpg\", new File(\"附件地址\")); mimeMessageHelper.addAttachment(\"2.jpg\", new File(\"附件地址\")); javaMailSender.send(mimeMessage); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（九）：检索","date":"2019-12-02T15:02:04.000Z","path":"posts/8146c289/","text":"ElasticSearch ElasticSearch 是一个开源的分布式搜索服务，且提供 Restful API，底层基于 Lucene，采用多 shard（分片）的方式保证数据安全，并且提供自动 Resharding 的功能。SpringBoot 通过整合 Spring Data ElasticSearch 提供了便捷的检索功能支持。 ElasticSearch 概念 它是面向文档的，意味着它存储整个对象或文档，并索引每个文档的内容使之可以被检索。 将 JSON 作为文档的序列化格式。 将存储数据至 ElasticSearch 的行为称之为索引。一个 ElasticSearch 集群可以包含多个索引，每个索引可以包含多个类型，每个类型可以包含多个文档，而每个文档又可以有多个属性（例如雇员文档，一个文档代表一个雇员）。索引文档前需要确定文档存储位置。 在 ElasticSearch 中通过PUT、DELETE、PUT和HEAD请求来对文档进行增删改查（增加修改都用PUT）。 ElasticSearch 采用 Restful 风格请求处理数据（例如GET /index/type/id）。 ElasticSearch 相关文档查看ElasticSearch 官方权威指南。 SpringBoot 整合 ElasticSearchSpringBoot 默认支持两种技术来和 ElasticSearch 交互：Jest（需要引入依赖） 和 SpringData Elasticsearch（默认使用）。 Jest 引入 Jest 依赖 &lt;dependency> &lt;groupId>io.searchbox&lt;/groupId> &lt;artifactId>jest&lt;/artifactId> &lt;/dependency> 存储和查询数据 /** * @Author 喵粮都输光了 * @Date 2019/12/4 12:49 * @Description 文章 entity（JestId标识主键） */ @Data public class Article { @JestId private Integer id; private String title; private String author; private String content; } @Resource private JestClient jestClient; @Test void index() { Article article = new Article(); article.setId(1); article.setTitle(\"新闻标题\"); article.setAuthor(\"张三\"); article.setContent(\"新闻内容！！！！\"); // 构建一个索引功能。索引构建器，索引位置，类型，[.id()文档id]，构建 Index index = new Index.Builder(article).index(\"article\").type(\"news\").build(); try { // 执行存储操作（出现读取时间超时，在application.yml中设置读取时间） jestClient.execute(index); } catch (IOException e) { e.printStackTrace(); } } @Test void search() { String json = \"{\\n\" + \" \\\"query\\\": {\\n\" + \" \\\"match\\\": {\\n\" + \" \\\"content\\\": \\\"内容\\\"\\n\" + \" }\\n\" + \" }\\n\" + \"}\"; // 构建一个检索功能。检索构建器，索引位置，类型，[.id()文档id]，构建 Search search = new Search.Builder(json).addIndex(\"article\").addType(\"news\").build(); try { SearchResult searchResult = jestClient.execute(search); System.out.println(searchResult.getJsonString()); } catch (IOException e) { e.printStackTrace(); } } SpringData Elasticsearch 引入 SpringData Elasticsearch 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-elasticsearch&lt;/artifactId> &lt;/dependency> 通过 ElasticsearchRepository 调用 Elasticsearch /** * @Author 喵粮都输光了 * @Date 2019/12/4 12:32 * @Description 书本 entity */ @Data @Document(indexName = \"kuukokawaii\", type = \"book\") public class Book { private Integer id; private String bookName; private String author; } @Resource private BookRepository bookRepository; @Test void index() { Book book = new Book(); book.setId(1); book.setBookName(\"书本名\"); book.setAuthor(\"书本作者\"); bookRepository.index(book); } @Test void search() { for (Book book : bookRepository.findBooksByBookNameLike(\"书\")) { System.out.println(book); } } 通过 ElasticsearchTemplate 调用 Elasticsearch /** * @Author 喵粮都输光了 * @Date 2019/12/4 12:32 * @Description 书本 entity */ @Data @Document(indexName = \"kuukokawaii\", type = \"book\") public class Book { private Integer id; private String bookName; private String author; } @Resource private ElasticsearchRestTemplate elasticsearchRestTemplate; @Test void index() { Book book = new Book(); book.setId(1); book.setBookName(\"书本名\"); book.setAuthor(\"书本作者\"); // 构建索引构建器 IndexQuery indexQuery = new IndexQueryBuilder().withObject(book).build(); // 存储数据 elasticsearchRestTemplate.index(indexQuery); } @Test void search() { // 查询语句 MatchQueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(\"bookName\", \"书本\"); // 根据查询语句构建查询构建器 SearchQuery searchQuery = new NativeSearchQueryBuilder().withQuery(matchQueryBuilder).build(); // 进行查询，查询构建器，查询的类 for (Book book : elasticsearchRestTemplate.queryForList(searchQuery, Book.class)) { System.out.println(book); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://blog.kuukokawaii.com/tags/elasticsearch/"}]},{"title":"SpringBoot（八）：消息队列","date":"2019-12-01T02:51:55.000Z","path":"posts/2b1dfb69/","text":"消息队列大多应用中可通过消息服务中间件来提升系统异步通信、扩展解耦能力。在消息服务中有消息代理和目的地两个重要的概念，即当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。在消息队列中主要拥有两种形式的目的地，分别为队列和主题，前者用于点对点消息通信，后者用于发布/订阅消息通信。 JMS 和 AMQP 比对 JMS AMQP 定义 Java api 网络线级协议 跨语言 否 是 跨平台 否 是 Model 提供两种消息模型：1.Peer-2-Peer2.Pub/Sub 提供五种消息模型：1.direct exchange2.fanout exchange3.topic exchange4.headers exchange5.system exchange本质来讲，后四种和 JMS 的 Pub/Sub 模型没有太大差别，仅是在路由机制上做了更详细的划分。 支持消息类型 多种消息类型：1.TextMessage2.MapMessage3.BytesMessage4.StreamMessage5.ObjectMessage6.Message（只有消息头和属性） byte[]当实际应用时，有复杂的消息，可以将消息序列化后发送。 综合评价 JMS 定义了 JAVA API 层面的标准。在 JAVA 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。 AMQP 定义了 wire-level 层的协议标准，天然具有跨平台、跨语言特性。 SpringBoot 中的消息队列 spring-jms 提供了对 JMS 的支持。 spring-rabbit 提供了对 AMQP 的支持。 需要ConnectionFactory的实现来连接消息代理。 提供JmsTemplate和RabbitTemplate来发送消息。 将@JmsListener（JMS）和@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息。 @EnableJms和@EnableRabbit开启注解支持。 RabbitMQ 简介RabbitMQ 是一个由 erlang 开发的 AMQP（Advanced Message Queue Protocol） 的开源实现。 核心概念 组件 作用 Message 消息由消息头和消息体组成。其中消息体是不透明的，消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键，决定消息目的地）、priority（相对于其他消息的优先权）和delivery-mode（标明该消息是否需要持久性存储）等。 Publisher 消息的生产者，用于向交换器发布消息，即向消息代理发送消息。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列（根据路由键选择队列）。 Queue 消息队列，用来保存消息直到发送给消费者，一个消息可投入一个或多个队列。 Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列l连接起来的又有规则，Exchange 和 Queue 的绑定可以是多对多的关系。 Connection 网络连接，比如一个 TCP 连接。 Channel 信道是建立在真实的 TCP 连接内的虚拟连接，AMQP 的命令都是通过信道发送出去。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。（类似线程与进程） Consumer 消息的消费者，用于从消息队列中获取消息。 Virtual Host 虚拟主机（简称 vhost），是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个缩小版的 RabbitMQ 服务器，消息代理中可以有多个 vhost 。在连接时，必须指定具体的 vhost，RabbitMQ 默认的 vhost 是 / Broker 消息代理，表示消息队列服务器的实体 Exchange 类型 direct：当消息中的路由键和 Binding 中的 binding key 一致时，交换器就将消息发到对应的队列中。 fanout：交换器会将消息发送到所有与自己绑定的队列上，速度是交换器中最快的（类似广播）。 topic：交换器通过模式匹配分配消息的路由键属性，将路由器和某一个模式进行匹配，此时队列需要绑定到一个模式上。通过识别两个通配符#和*对路由键和绑定键的字符串进行切分，其中前者匹配0个或多个单词，后者匹配一个单词。 header：header 匹配 AMQP 消息的 header 而不是路由键，与 direct 交换器类似但性能差许多，通常不用。 整合 RabbitMQ 引入 RabbitMQ 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-amqp&lt;/artifactId> &lt;/dependency> application.yml中配置 RabbitMQ 相关配置 spring: rabbitmq: username: 账号 password: 密码 virtual-host: \"/\" RabbitTemplate 用于发送和接收消息 @Resource private RabbitTemplate rabbitTemplate; @Test void sendMessage() { // 自动序列化发送消息（使用send方法不会自动序列化） rabbitTemplate.convertAndSend(\"study.direct\", \"study.news\", \"消息体可以是对象\"); } @Test void receiveMessage() { // 自动反序列化转化接收的消息 Object message = rabbitTemplate.receiveAndConvert(\"study.news\"); System.out.println(message); } 配置消息转换器序列化方式 /** * @Author 喵粮都输光了 * @Date 2019/12/2 22:04 * @Description AMQP 配置 */ @Configuration public class AmqpConfig { @Bean public MessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); } } @EnableRabbit+@RabbitListener注解用于监听消息队列 /** * @Author 喵粮都输光了 * @Date 2019/11/21 22:07 * @Description SpringBoot应用主程序 */ @EnableRabbit @SpringBootApplication public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } /** * @Author 喵粮都输光了 * @Date 2019/12/2 22:14 * @Description 书 service */ @Service public class BookService { @RabbitListener(queues = \"study.news\") public void receive(Book book) { System.out.println(\"收到的消息：\" + book); } @RabbitListener(queues = \"study\") public void receive1(Message message) { // 获取消息体 System.out.println(Arrays.toString(message.getBody())); // 获取消息头 System.out.println(message.getMessageProperties()); } } AmqpAdmin 系统管理功能组件，用于创建删除 exchange，queue 和 binding。 @Resource private AmqpAdmin amqpAdmin; @Test void createExchange() { // 创建 exchange amqpAdmin.declareExchange(new DirectExchange(\"study.direct\")); // 创建 queue，是否开启持久化 amqpAdmin.declareQueue(new Queue(\"study.queue\", true)); // 创建 binding （绑定目的地名[此处队列名]，绑定目的地类型[此处队列]，交换名，路由键，参数） amqpAdmin.declareBinding(new Binding(\"study.queue\", Binding.DestinationType.QUEUE, \"study.direct\", \"study\", null)); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（七）：缓存","date":"2019-11-30T04:06:19.000Z","path":"posts/676006d6/","text":"JSR-107Java Caching 定义了5个核心接口，分别为： CachingProvider：定义了创建、配置、获取、管理和控制多个 CacheManager。一个应用可以在运行期间访问多个 CachingProvider。 CacheManager：定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cache 存在于 CacheManager 的上下文中。且一个 CacheManager 仅被一个 CachingProvider 所拥有。 Cache：类似 Map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 所拥有。 Entry： 存储在 Cache 中的 Key-Value 对。 Expiry： 每一个存储在 Cache 中的条目有一个定义的有效期。一旦超过这个时间，Entry 就变为了过期状态。一旦过期，Entry 将不可访问、更新和删除。缓存有效期可以通过 ExpiryPolicy设置。 JSR-107 只需引入如下依赖即可使用： &lt;dependency> &lt;groupId>javax.cache&lt;/groupId> &lt;artifactId>cache-api&lt;/artifactId> &lt;/dependency> Spring 缓存抽象为了简化开发，Spring 定义了 Cache 和 CacheManager 接口来统一不同的缓存技术，同时 Spring 也支持使用 JCache（JSR-107）注解简化开发。 Spring 缓存注解 注解及参数 作用 参数 @Cacheable 根据方法的请求参数对其结果进行缓存，常用于创建。 1.cacheNames/value：指定缓存组件名（可以多个）。2.key：缓存数据使用的 Key（默认使用方法参数的值，可以使用 SpEL 表达式）。3.keyGenerator：Key 的生成器，可以指定 Key 生成器的组件 id（与key二选一）。4.cacheManager：指定缓存管理器。5.cacheResolver：指定获取解析器（与cacheManager二选一）。6.condition：指定符合条件的情况下才缓存。unless：指定符合条件的情况下不进行缓存，并且可以获取缓存结果进行判断。7.sync：是否使用异步模式，此时不支持unless参数。 @CachePut 保证方法一定会被调用且结果会被缓存，常用于更新，如果指定 key 被更新则需要同时更新 key。 @CacheEvict 清空缓存，常用于删除，需要指定删除的 key。 1.key：如未指定则会使用默认策略生成的 key。2.allEntries：是否删除指定 cache 中的所有数据。3.beforeInvocation：缓存的清除是否在方法之前执行（默认 false）。 @EnableCaching 开启基于注解的缓存。 @Caching 是@Cacheable、@CachePut和@CacheEvict的组合注解。 @CacheConfig 抽取缓存的公共配置，标注于类上，类中的缓存注解会默认使用公共配置的参数。 keyGenerator 缓存数据时 Key 的生成策略。 serialize 缓存数据时 Value 序列化策略。 @Cacheable可用 SpEL 表达式 名字 位置 作用 示例 methodName root object 当前被调用的方法名。 #root.methodName method root object 当前被调用的方法。 #root.method.name target root object 当前被调用的目标对象。 #root.target targetClass root object 当前被调用的目标对象类。 #root.targetClass args root object 当前被调用的方法的参数列表。 #root.args[0] caches root object 当前方法调用的缓存列表（如@Cacheable(cacheNames={\"cache1\",\"cache2\"})）。 #root.caches[0].name argument name evaluation context 方法参数的名字，可以直接#参数名，也可以使用#p0或#a0的形式，其中0代表参数的的索引。 #iban、#a0、#p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效）。 #result 缓存使用注意事项 缓存注解不能定义在接口上。 加缓存注解的方法必须为公有（public）的。 @Cahcheable必须指定至少一个cacheNames。 注解使用示例 @Cacheable @Override @Cacheable(cacheNames = \"employee\") public Employee getEmployee(Integer id) { return employeeMapper.getEmployeeById(id); } @CachePut @Override @CachePut(cacheNames = \"employee\", key = \"#result.id\") public Employee updateEmployee(@RequestBody Employee employee) { return employeeMapper.updateEmployee(employee); } @CacheEvict @Override @CacheEvict(cacheNames = \"employee\", key = \"#id\") public int removeEmployee(Integer id) { return employeeMapper.removeEmployeeById(id); } @Caching @Override @Caching( cacheable = { @Cacheable(cacheNames = \"employee\", key = \"#lastName\") }, put = { @CachePut(cacheNames = \"employee\", key = \"#result.id\"), @CachePut(cacheNames = \"employee\", key = \"#result.email\") } ) public Employee getEmployee(String lastName) { return employeeMapper.getEmployeeByLastName(lastName); } @CacheConfig @Service @CacheConfig(cacheNames = \"employee\") public class EmployeeServiceImpl implements EmployeeService { @Resource private EmployeeMapper employeeMapper; @Override @Cacheable public Employee getEmployee(Integer id) { return employeeMapper.getEmployeeById(id); } } 整合 RedisRedis 是一个开源的，内存中的数据结构存储系统，可以用作数据库、缓存和消息中间件。 引入 Redis 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId> &lt;/dependency> application.yml中配置 Redis 相关配置 spring: redis: host: xxx.xxx.xxx.xxx 使用RedisTemplate或StringRedisTemplate操作 Redis RedisTemplate用于操作 K-V 都是字符串的数据。 StringRedisTemplate用于操作 K-V 都是对象的数据。 Redis 常见的五大数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）和ZSet（有序集合）。分别通过五类方法操作：opsForValue()、opsForList()、opsForSet()、opsForHash()和opsForZSet()。 Redis 命令查询 配置RedisCacheManager，并修改 Key 和 Value 的保存格式。之后便可使用 Spring 缓存抽象操作 Redis。 @Configuration public class RedisConfig { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { // Key 使用 StringRedisSerializer 的方式保存 RedisSerializer&lt;String> redisSerializer = new StringRedisSerializer(); // Value 使用 Jackson2JsonRedisSerializer 的方式保存 Jackson2JsonRedisSerializer&lt;Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;>(Object.class); // 解决查询缓存反序列化出错问题 ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); // entryTtl(Duration.ofHours(1))设置生存周期 RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofHours(1)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)).disableCachingNullValues(); return RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(redisCacheConfiguration).build(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（六）：数据访问","date":"2019-11-27T05:15:47.000Z","path":"posts/fd098bd4/","text":"SpringDataSpringData 主要用于简化数据库的访问，开发者只需声明持久层接口即可。SpringData 支持 NoSQL 和关系数据库存储。 JDBC 引入 JDBC 依赖。 &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> application.yml 配置数据源。 spring: datasource: username: 账号 password: 密码 url: jdbc:mysql://localhost:3306/表名?serverTimezone=UTC driver-class-name: 数据库驱动 # 表初始化，默认加载schema.sql（冒号后无空格，不使用请注释） schema: - classpath:sql/department.sql # 数据初始化，默认加载data.sql（冒号后无空格，不使用请注释） data: - classpath:sql/department_data.sql # 初始化模式（不使用请注释） initialization-mode: always # department.sql DROP TABLE IF EXISTS department; CREATE TABLE department( id INT PRIMARY KEY NOT NULL, departmentName varchar(45) NOT NULL ); # department_data.sql INSERT INTO department (id, departmentName) SELECT '1', 'AA' FROM dual WHERE NOT EXISTS(SELECT id from department WHERE id = '1'); 使用 JdbcTemplate 进行查询。 /** * @Author 喵粮都输光了 * @Date 2019/11/27 14:50 * @Description 查询 controller */ @Controller public class QueryController { private final JdbcTemplate jdbcTemplate; @Autowired public QueryController(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @GetMapping(\"/query\") @ResponseBody public Map&lt;String, Object> map() { List&lt;Map&lt;String, Object>> list = jdbcTemplate.queryForList(\"SELECT id, departmentName FROM department\"); return list.get(0); } } 配置 druid 连接池。（在spring.datasource下配置） druid: # 初始化大小，最小，最大 initial-size: 5 min-idle: 10 max-active: 20 # 配置获取连接等待超时的时间 max-wait: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 min-evictable-idle-time-millis: 300000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 time-between-eviction-runs-millis: 600000 validation-query: SELECT 1 test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙。（stat,wall,log4j） filters: stat,wall # 通过connection-properties属性来打开mergeSql功能；慢SQL记录 connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 use-global-data-source-stat: true # 配置DruidStatFilter web-stat-filter: enabled: true url-pattern: \"/*\" exclusions: \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\" # 配置DruidStatViewServlet stat-view-servlet: enabled: true url-pattern: \"/druid/*\" # IP白名单(没有配置或者为空，则允许所有访问) allow: 127.0.0.1 # IP黑名单 (存在共同时，deny优先于allow) deny: # 禁用HTML页面上的“Reset All”功能 reset-enable: false # 登录名 login-username: root # 登录密码 login-password: root MyBatis 引入 Mybatis 依赖。 &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>2.1.0&lt;/version> &lt;/dependency> 注解的方式进行 dao 操作。（可以去掉@Mapper注解，应用入口程序处添加@MapperScan注解批量扫描包。） /** * @Author 喵粮都输光了 * @Date 2019/11/27 19:00 * @Description 部门 dao */ @Mapper public interface DepartmentDao { /** * 根据部门id查询部门对象 * * @param id 部门id * @return 部门对象 */ @Select(\"SELECT id, departmentName FROM department WHERE id = #{id}\") Department getDepartmentById(Integer id); /** * 根据部门id删除部门 * * @param id 部门id * @return 更新条数 */ @Delete(\"DELETE FROM department WHERE id = #{id}\") int removeDepartmentById(Integer id); /** * 根据部门对象增加部门。（useGeneratedKeys 注解让自增的主键会重新封装入 Department 对象中。） * * @param department 部门对象 * @return 更新条数 */ @Insert(\"INSERT INTO department (departmentName) value (#{departmentName})\") @Options(useGeneratedKeys = true, keyProperty = \"id\", keyColumn = \"id\") int createDepartment(Department department); /** * 根据id更新部门信息 * * @param department 部门对象 * @return 更新条数 */ @Update(\"UPDATE department set departmentName = #{department} WHERE id = #{id}\") int updateDepartment(Department department); } 配置文件的方式进行 dao 操作。再配置注解扫描的基础上配置 xml 文件所在位置，即通过在application.yml中配置 xml 文件的位置，例如mybatis.mapper-locations: com/kuukokawaii/springbootstudy/**/dao/**.xml，即可实现配置文件的方式进行 dao 操作。 mybatis: # 下划线转驼峰命名 configuration: map-underscore-to-camel-case: true # xml 配置文件路径 mapper-locations: com/kuukokawaii/springbootstudy/**/dao/**.xml /** * @Author 喵粮都输光了 * @Date 2019/11/29 14:34 * @Description 员工 dao */ @Mapper public interface EmployeeMapper { /** * 根据 id 查找对应的员工信息。 * @param id 员工id * @return 员工对象 */ Employee getEmployeeById(int id); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.kuukokawaii.springbootstudy.employee.dao.EmployeeMapper\"> &lt;resultMap id=\"BaseResultMap\" type=\"com.kuukokawaii.springbootstudy.employee.entity.Employee\"> &lt;!--@mbg.generated--> &lt;!--@Table employee--> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"last_name\" jdbcType=\"VARCHAR\" property=\"lastName\"/> &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\"/> &lt;result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\"/> &lt;result column=\"d_id\" jdbcType=\"INTEGER\" property=\"dId\"/> &lt;/resultMap> &lt;sql id=\"Base_Column_List\"> &lt;!--@mbg.generated--> id, last_name, email, gender, d_id &lt;/sql> &lt;select id=\"getEmployeeById\" resultMap=\"BaseResultMap\"> select &lt;include refid=\"Base_Column_List\"/> from employee where id = #{id,jdbcType=INTEGER} &lt;/select> &lt;/mapper> Spring Data JPA 基本功能 JpaRepository 基本功能。 Spring Data JPA 具有统一的 Repository 接口，通过继承该接口可以实现 CRUD 和分页等操作。 定义符合规范的方法命名。 在接口中只需要声明符合规范的方法，即拥有对应的功能。 通过@Query自定义查询，定制查询 SQL。 支持动态查询（Specifications 查询）。 引入 JPA 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId> &lt;/dependency> 使用 JPA 根据 entity 自动建表，在application.yml中加入如下配置。 spring: jpa: hibernate: # 根据 entity 更新或者创建数据表结构 ddl-auto: update # 控制台显示 SQL show-sql: true 新建 entity。 @Entity用于标注该类是实体类。 @Table可以标明该表的表名和所属 schema。 @Id用于标注该属性是主键。 @GeneratedValue包含strategy和generator两个参数。前者包含AUTO、IDENTITY、SEQUENCE和Table四个属性，其作用分别为主键由程序控制（默认值）、主键由数据库生成采用数据库的自增形式（Oracle 不支持）、主键通过数据库的序列生成（Mysql 不支持）和提供特定的数据库产生主键方式（利于数据库移植）；后者用于声明主键生成器的名称。 @Column用于标注数据库列名及该列属性。 /** * @Author 喵粮都输光了 * @Date 2019/11/29 15:53 * @Description 用户 entity */ @Entity @Data @Table(name = \"user\", schema = \"springboot_study\") @JsonIgnoreProperties(value = { \"hibernateLazyInitializer\"}) public class User { /** * 用户id */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; /** * 用户名 */ @Column(name = \"last_name\", length = 45, nullable = false) private String lastName; /** * 用户邮箱 */ @Column(name = \"email\", length = 45, nullable = false) private String email; } 编写接口继承JpaRepository接口。接口上泛型分别写对应的实体类和该实体类的主键。 /** * @Author 喵粮都输光了 * @Date 2019/11/29 16:09 * @Description 用户 repository */ public interface UserRepository extends JpaRepository&lt;User, Integer> {} JpaRepository接口的使用。如果 get 方法出现com.fasterxml.jackson.databind.exc.InvalidDefinitionException:错误，则需要在实体类上加@JsonIgnoreProperties(value={\"hibernateLazyInitializer\"})的注解，防止jsonplugin操作hibernateLazyInitializer属性。 /** * @Author 喵粮都输光了 * @Date 2019/11/29 16:38 * @Description 用户 controller */ @RestController public class UserController { private final UserRepository userRepository; @Autowired public UserController(UserRepository userRepository) { this.userRepository = userRepository; } @GetMapping(\"/user/{id}\") public User getUser(@PathVariable(\"id\") int id) { return userRepository.getOne(id); } @PostMapping(\"/user\") public User createUser(@RequestBody User user) { return userRepository.save(user); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（五）：Docker","date":"2019-11-27T01:45:29.000Z","path":"posts/3096723d/","text":"什么是 DockerDocker 是基于 Go 语言并遵从 Apache 协议开源的一个开源的应用容器引擎，支持将软件编译成一个镜像并设置镜像中各软件的配置，获得镜像的其他使用者可以直接使用镜像。Docker 容器是完全使用沙箱机制的，相互之间不会有任何接口，更重要的是容器性能开销极低。 Docker 核心概念Docker 主机从仓库下载所需镜像并通过 daemon 运行镜像产生容器之后，Docker 客户端就可以连接主机进行操作。 Docker 镜像（Images）：Docker 镜像是用于创建 Docker 容器的模板。 Docker 容器（Container）：容器是独立运行的一个或一组应用。 Docker 客户端（Client）：客户端通过命令行或者其他工具使用 Docker。 Docker 主机（Host）：一个物理或虚拟的机器用于执行 Docker 守护进程和容器。 Docker 仓库（Registry）：Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub提供了庞大的镜像集合供使用。 Docker 常用操作镜像操作| 操作 | 命令 | 说明 | | --- | ---- | ---- | | 检索 | docker search 关键字 | 常用于检索镜像的详细信息，或镜像版本。 | | 拉取 | docker pull 镜像名:tag | `:tag`是可选的，tag 表示标签，多为软件的版本，默认是 latest。 | | 列表 | docker images | 查看所有本地镜像。 | | 删除 | docker rmi image-id | 删除指定的本地镜像。 |容器操作| 操作 | 命令 | 说明 | | --- | ---- | ---- | | 运行 | docker run --name container-name &lt;br&gt; -d image-name | `--name`：自定义容器名; &lt;br&gt;`-d`：后台运行; &lt;br&gt;`image-name`：指定镜像模板（推荐加上版本号）。 | | 列表 | docker ps | 查看运行中容器，加上`-a`可以查看所有容器。 | | 停止 | docker stop container-name/container-id | 停止指定的运行中容器。 | | 启动 | docker start container-name/container-id | 启动指定的容器。 | | 删除 | docker rm container-id | 删除指定容器。 | | 端口映射 | 输入运行容器命令时添加`-p`命令 &lt;br&gt;例：docker run -d -p 6379:6379 镜像名 | `-p`主机端口映射至容器内部的端口。 | | 容器日志 | docker logs container-name/container-id | 查看容器日志。 | document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"docker","slug":"docker","permalink":"https://blog.kuukokawaii.com/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（四）：WEB 开发","date":"2019-11-24T06:27:09.000Z","path":"posts/4fa653eb/","text":"静态资源映射规则SpringBoot 的静态资源与 SSM 框架整合的静态资源所在位置不同，SSM 框架静态资源存储于 webapp 的 static 中，而 SpringBoot 的静态资源存储于 resources 中。SpringBoot 默认有两种静态资源映射模式： webjars 模式 应用使用 MAVEN 导入 webjars 的静态资源依赖，则所有通过该方法导入的静态资源都存储于classpath:/META-INF/resources/webjars/中。需要访问时，只需要通过类似http://localhost:8080/webjars/所需资源名的方式即可完成调用。 自定义模式 通过查看 SpringBoot 源码中的WebMvcAutoConfiguration和ResourceProperties类的SERVLET_LOCATIONS和CLASSPATH_RESOURCE_LOCATIONS常量，可以得出静态资源的默认存储位置为classpath:/META-INF/resources/、classpath:/resources/、classpath:/static/、classpath:/public/和/。调用方式与 webjars 模式类似，例如静态文件存储于classpath:/static/，则调用方式如http://localhost:8080/所需资源名即可。 欢迎页静态资源文件夹下的所有index.html页面都会被映射为/，也就是说当你输入http://localhost:8080/时，就会自动跳转至index.html页面。 修改静态资源位置可以在application.yml中通过spring.resources.static-locations设置默认的静态资源位置，使用该条命令会使 SpringBoot 本身的默认静态资源位置失效，因此不推荐修改。 Thymeleaf 模板引擎 模板引擎用于将视图和数据进行整合解析，而不同的模板引擎之间的区别仅在于模板引擎获取数据的语法不同。 SpringBoot 推荐使用 Thymeleaf 模板引擎，因为其语法更简洁，功能共强大。通过 MAVEN 引入 Thymeleaf 模板引擎的依赖。（如需修改 thymeleaf 版本则需注意thymeleaf-layout-dialect.version） &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> Thymeleaf 将classpath:/templates/作为默认的视图存储位置，只需将 HTML 页面放入该文件夹中，Thymeleaf 就能自动渲染。 Thymeleaf 的使用&amp;语法： 导入 Thymeleaf 的命名空间。(不导入不会出错，但是 HTML 页面不会有 Thymeleaf 语法提示。) &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> 后端通过Model、ModelMap、ModelAndView或Map向前端传输数据。 @RequestMapping(\"/helloPage\") public String hello(ModelMap modelMap) { modelMap.addAttribute(\"hello\", \"helloValue\"); return \"hello\"; } 在对应的 HTML 中使用 Thymeleaf 语法。 &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;p th:text=\"${hello}\">&lt;/p> &lt;/body> &lt;/html> WebMvc 扩展与全面接管SpringBoot 在自动配置组件时，会先扫描容器中是否有用户自定义的配置，如果有则使用用户自定义的配置文件或将用户自定义的配置文件与默认的自动配置文件组合起来，没有则执行 SpringBoot 的自动配置。例如&lt;mvc:view-controller path=\"/hello\" view-name=\"hello\"/&gt;映射/hello至hello.html页面。而在 SpringBoot 中可以通过@Configuration注解 + 实现WebMvcConfigurer接口中addViewControllers方法的形式实现该功能，SpringBoot 不仅保留了所有的自动配置，而且还加载了自定义的扩展功能。 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/hello\").setViewName(\"hello\"); } } 当需要对 WebMvc 进行全面接管时（即使得 SpringBoot 不进行自动配置，而是按照自定义的配置加载），通过使用@EnableWebMvc注解即可实现该效果，此时 SpringBoot 自动配置将失效且仅保留 SpringMVC 最进本的效果。 错误处理机制SpringBoot 错误的默认处理机制是通过ErrorMvcAutoConfiguration为容器添加了DefaultErrorAttributes、BasicErrorController、ErrorPageCustomizer和DefaultErrorViewResolver组件。一旦应用出现错误，ErrorPageCustomizer就会向/error/控制器发起请求（类似web.xml注册错误页面的规则），此时会进入BasicErrorController控制器。该控制器根据请求头向用户发送错误 HTML 页面或 JSON 数据，最终通过DefaultErrorAttributes中的错误状态码响应至特定的页面。 定制错误 HTML 页面 在拥有模板引擎的情况下，将错误状态码.html放置在模板引擎文件夹下的 error 文件夹中，SpringBoot 就会自动进行错误页面的配置。也可以将错误页面命名为4xx.html或5xx.html等，表示匹配所有 4 开头或者 5 开头的错误状态码，当项目下同时拥有类似4xx.html和404.html时，则会按精确优先的方式响应至404.html的错误页面。 在没有模板引擎的情况下，SpringBoot 将会在静态资源文件夹下的 error 文件夹中寻找错误页面。 如上述两处都没有发现错误页面，将跳转至 SpringBoot 默认的错误提示页面。 使用模板引擎的错误页面可以通过语法获取页面的错误信息，如timestamp：时间戳、status：状态码、error：错误提示、exception：异常对象、message：异常消息和errors：JSR303 数据校验错误。（如获取不到exception，则需要在application.yml中将server.error.include-exception开启） 定制错误 JSON 数据 自定义异常处理数据，浏览器和客户端返回的都是 JSON 数据。 /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:42 * @Description 异常处理器 */ @ControllerAdvice public class CustomExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String, Object> handleException(Exception e) { Map&lt;String, Object> map = new HashMap&lt;>(2); map.put(\"code\", \"userNotExist\"); map.put(\"message\", e.getMessage()); return map; } } 将异常请求转发至/error页面，通过 SpringBoot 自行产生自适应 /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:42 * @Description 异常处理器 */ @ControllerAdvice public class CustomExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public String handleException(HttpServletRequest request, Exception e) { // 设置错误状态码 request.setAttribute(\"javax.servlet.error.status_code\", 500); return \"/error\"; } } 拥有自适应效果且能携带定制数据 /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:36 * @Description 自定义 ErrorAttributes */ @Component public class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map&lt;String, Object> errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace); errorAttributes.put(\"customError\", webRequest.getAttribute(\"customError\", 0)); return errorAttributes; } } /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:42 * @Description 异常处理器 */ @ControllerAdvice public class CustomExceptionHandler { @ExceptionHandler(UserNotExistException.class) public String handleException(HttpServletRequest request, Exception e) { // 设置错误状态码 request.setAttribute(\"javax.servlet.error.status_code\", 500); Map&lt;String, Object> map = new HashMap&lt;>(2); map.put(\"code\", \"userNotExist\"); map.put(\"message\", e.getMessage()); request.setAttribute(\"customError\", map); return \"/error\"; } } SpringBoot 嵌入式 Servlet 容器 SpringBoot 默认使用 Tomcat 作为嵌入式的 Servlet 容器，需要对 Servlet 容器进行修改可以通过如下两种方式： 在application.yml中通过server.xxxx修改，如需修改 Tomcat 配置则通过server.tomcat.xxx进行修改。 编写一个嵌入式的 Servlet 容器定制器WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;来修改 Servlet 容器的配置。（优先级高于配置文件） @Bean public WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory> webServerFactoryCustomizer() { return new WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory>() { @Override public void customize(ConfigurableServletWebServerFactory factory) { factory.setPort(8081); } }; } SpringBoot 默认时以 Jar 包的方式启动嵌入式的 Servlet 容器来启动 Web 应用，没有 web.xml 文件，因此提供ServletRegistrationBean、FilterRegistrationBean和ServletListenerRegistrationBean三大组件用于注册 Servlet、Filter 和Listener。 ServletRegistrationBean /** * @Author 喵粮都输光了 * @Date 2019/11/26 17:17 * @Description 自定义 servlet */ public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().write(\"Hello Servlet！！！\"); } } @Bean public ServletRegistrationBean&lt;MyServlet> servletRegistrationBean() { return new ServletRegistrationBean&lt;>(new MyServlet(), \"/myServlet\"); } FilterRegistrationBean /** * @Author 喵粮都输光了 * @Date 2019/11/26 17:31 * @Description 自定义 filter */ public class MyFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"MyFilter process...\"); chain.doFilter(request, response); } } @Bean public FilterRegistrationBean&lt;MyFilter> filterFilterRegistrationBean() { FilterRegistrationBean&lt;MyFilter> filterFilterRegistrationBean = new FilterRegistrationBean&lt;>(); filterFilterRegistrationBean.setFilter(new MyFilter()); // 设置要拦截的请求 filterFilterRegistrationBean.setUrlPatterns(Arrays.asList(\"/hello\", \"/\")); return filterFilterRegistrationBean; } ServletListenerRegistrationBean /** * @Author 喵粮都输光了 * @Date 2019/11/26 17:40 * @Description 自定义 listener */ public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"web 应用启动\"); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\"web 应用销毁\"); } } @Bean public ServletListenerRegistrationBean&lt;MyListener> servletListenerRegistrationBean() { return new ServletListenerRegistrationBean&lt;>(new MyListener()); } 其他内嵌式的 Servlet 容器 Jetty 适用于长连接应用。 Undertow 高性能非阻塞，并发性能非常强，但不支持 JSP。 内嵌式的 Servlet 容器切换方法：只需将默认的 Tomcat 依赖排除，然后引入其他内嵌式 Servlet 容器依赖即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（三）：日志","date":"2019-11-23T02:39:48.000Z","path":"posts/1d79677f/","text":"日志框架市场上存在多种日志框架，日志接口有 JCL、SLF4j 和 jboss-logging，日志具体实现有 Log4j、Logback、JUL 和 Log4j2。其中 JUL 是 JAVA 官方日志；JCL 和 Log4j2 是 apache 开发的日志接口；SLF4j、Log4j 和 Logback 是由同一作者开发完成，所以适配性较好，当中的 Log4j 存在性能问题，其升级版为 Logback。 SLF4j SLF4j 是针对日志框架开发的一个统一接口层，因此只需实现 SLF4j 即可使用日志功能，这样分层的好处是更改日志接口的实现框架依赖便可完成日志框架的升级。 SpringBoot 的底层是 Spring 框架，而 Spring 框架默认是用 JCL 日志接口，但是 SpringBoot 默认排除了 JCL 依赖，使用 SLF4j 和 Logback 作为自己的日志框架。 SLF4j 针对按自己接口实现的日志框架只需导入日志实现框架依赖即可，而针对不是按自己接口的日志实现框架则需要额外导入一个适配依赖，才能完成日志功能。适配依赖的原理即实现 SLF4j 接口，实现方式就是包装对应的日志实现框架方法。 每个日志实现框架都有自己的配置文件，即使使用了 SLF4j，配置文件还是使用日志实现框架的配置文件。 统一日志框架SpringBoot 整合了许多框架，而每一个框架使用的可能都不是同一个日志框架，因此需要对这些框架的日志框架进行统一。将日志框架统一成 SLF4j 的步骤如下： 先排除系统中其他日志实现框架的依赖。 用中间包来替换排除的日志实现框架依赖，否则会报错。中间包的原理即覆写排除了的日志实现框架，将其所有方法的原有调用都转为调用 SLF4j 的方法，这样即可防止报错并实现功能。 之后导入 SLF4j 和日志实现框架依赖。（根据日志实现框架选择是否需要添加适配依赖） 日志默认配置全局常规设置SpringBoot 自配配置了默认的日志配置，可以在application.yml中修改部分配置。 修改日志输出文件位置在application.yml中可以通过logging.file和logging.path指定配置文件位置。（只能二选一，两个都写默认生效logging.file） logging.file在不指定路径时则在当前项目下生成 springboot.log 日志文件，指定路径时则按指定的完整路径存放日志文件。例如：logging.file: G:/springboot.log。 logging.path在指定路径下创建文件夹并使用 spring.log 作为默认日志文件。例如：logging.path: /spring/log则表示在项目所在磁盘的根目录下创建 spring 文件夹和其中的 log 文件夹并生成一个 spring.log 的日志文件。 自定义日志配置文件当要使用自定义日志配置文件而非 SpringBoot 的默认日志配置时，可以通过在类路径下放上相应的日志实现框架的配置文件即可。| 日志系统 | 自定义配置文件 || ——- | ————————————– || Logback | logback-spring.xml 或 logback.xml || Log4j2 | log4j2-spring.xml 或 log4j2.xml || JUL | logging.properties | 其中没有加spring尾缀的配置会跳过 SpringBoot 直接被日志实现框架识别；增加了尾缀的日志实现框架不直接加载日志配置，而是由 SpringBoot 解析日志配置，因此可以在日志的配置文件中使用 SpringBoot 的高级 Profile 功能。 &lt;springProfile name=\"dev\"> &lt;!-- 可以指定该日志配置只在 dev 应该环境下才被加载。修改 dev 可以修改为其它应用环境。 --> &lt;/springProfile> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（二）：配置文件","date":"2019-11-22T01:43:31.000Z","path":"posts/2250b4d3/","text":"YAMLSpringBoot 可以使用 YAML 进行全局配置。YAML 是以数据为中心的标记语言，比 JSON、XML 等更适合做配置文件。YAML 通过缩进表示层级关系，且支持三种数据结构：对象（键值对集合）、数组和字面量（单个、不可再分的值）。 字面量即数字、字符串和布尔值。通过k: v的方式书写，字符串默认不用加上引号。也可以使用单引号或双引号，其中单引号会转义特殊字符。字符串也可以写成多行，但从第二行开始必须有一个空格缩进，换行符会被转义为空格。 对象假设有一对象为 student，其中有 lastName 和 age 的属性，其 YAML 写法如下： student: lastName: xx age: 12 也可以采用行内写法：student: {lastName: xx, age: 12} 数组用连线词-来表示数组中的一个元素，一组-开头的行构成一个数组，其写法如下: pets: - cat - dog - pig 也可以采用行内写法：pets: [cat, dog, pig] 复合结构即字面量、对象和数组的复合使用。 将配置文件中的属性值映射至 bean/** * @Author 喵粮都输光了 * @Date 2019/11/22 10:50 * @Description dog entity */ @Data public class Dog { private String name; private Integer age; } person: lastName: LaoZhang age: 11 boss: false birth: 2019/5/5 map: key1: value1 key2: value2 list: - LaoWang - LaoLi dog: name: 小狗 age: 2 可以在 resources 下新建 META-INF 文件夹，并新建 additional-spring-configuration-metadata.json 输入如下代码为 yaml 添加 person。 { \"properties\": [ { \"name\": \"person.dog.name\", \"type\": \"java.lang.String\", \"description\": \"Description for person.dog.name.\" }, { \"name\": \"person.dog.age\", \"type\": \"java.lang.Integer\", \"description\": \"Description for person.dog.age.\" } ] } 使用@ConfigurationProperties注解，需要添加依赖spring-boot-configuration-processor。 /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component @ConfigurationProperties(\"person\") public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object> map; private List&lt;Object> list; private Dog dog; } 使用@Value()注解获取值，其中可以用SpEL表达式获取值，不支持复杂类型封装。 /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component public class Person { @Value(\"${person.lastName}\") private String lastName; @Value(\"#{11*2}\") private Integer age; @Value(\"false\") private Boolean boss; private Date birth; private Map&lt;String, Object> map; private List&lt;Object> list; private Dog dog; } @ConfigurationProperties支持 JSR303 数据校验。在类上添加注解@validated用于支持 JSR303，在需要接收的数据上加上需要校验格式的注解，例如@Email。 /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component @ConfigurationProperties(\"person\") @validated public class Person { @Email private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object> map; private List&lt;Object> list; private Dog dog; } 自定义配置文件加载@PropertySource通过组合@PropertySource和@ConfigurationProperties可以读取指定 properties 文件中的属性值并映射至 bean。 person.lastName=LaoZhang person.age=11 person.boss=false person.birth=2019/5/5 person.map.key1=value1 person.map.key2=value2 person.list=LaoWang, LaoLi person.dog.name=小狗 person.dog.age=2 /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component @PropertySource(\"classpath:person.properties\") @ConfigurationProperties(\"person\") public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object> map; private List&lt;Object> list; private Dog dog; } @ImportResource该注解用于导入自定义的 Spring 的配置文件，将注解添加至 SpringBoot 应用主程序类上即可，可添加多个 Spring 配置文件。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"helloService\" class=\"com.kuukokawaii.springbootstudy.service.HelloService\"/> &lt;/beans> @SpringBootApplication @ImportResource(locations = {\"classpath:beans.xml\"}) public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } @ConfigurationSpringBoot 推荐使用全注解的方式添加组件代替配置文件，只需要在类上加@Configuration的注解即可指明该类是配置类。 /** * @Author 喵粮都输光了 * @Date 2019/11/22 12:42 * @Description 应用注解配置 */ @Configuration public class MyApplicationConfig { /** * 将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名。相当于&lt;bean id=\"helloService\", clas==\"\">&lt;/bean> * @return 返回 HelloService 对象。 */ @Bean public HelloService helloService() { System.out.println(1); return new HelloService(); } } 配置文件占位符配置文件中可以使用随机数和占位符，且占位符可设置默认值。例如：person.dog.name引用了person.lastName的值，而person.dog.age引用了hello.age的值，因没有定义hello.age的值，会使用默认值10，最终person.dog.age的值为10。 person: lastName: LaoZhang${random.uuid} age: ${random.int} boss: false birth: 2019/5/5 map: key1: value1 key2: value2 list: - ${random.value} - LaoLi dog: name: ${person.lastName}的小狗 age: ${hello.age:10} 环境配置选择多文件形式SpringBoot 可以在application.yml/properties中通过spring.profiles.active = {profile}来选择应用环境，其中其他配置文件名应为application-{profile}.yml/properties的形式。例如此处应用的主配置应用端口号为 8080，dev 配置文件中应用端口号为 8081，在主配制中激活 dev 配置，则应用端口号变为 8081。 #application-dev.yml server: port: 8081 #application.yml server: port: 8080 spring: profiles: active: dev 多文档块形式（仅 YAML 支持）在application.yml中可以通过三横杠---的方式划分文档块，每一个文档块相当于一个自定义的配置文件，可以通过spring.profiles = {profile}定义文档块的名字，并使用spring.profiles.active = {profile}的形式激活选定的文档块。 server: port: 8080 spring: profiles: active: dev --- server: port: 8081 spring: profiles: dev --- server: port: 8082 spring: profiles: prod 激活 profile 通过配置文件指定，如上。 通过命令行参数指定，如在Program arguments中输入--spring.profiles.active=dev或java -jar xxx.jar --spring.profiles.active=dev 通过虚拟机参数指定，如在VM options中输入-Dspring.profiles.active=dev。 配置文件加载位置SpringBoot 会自定扫描如下位置的application.properties/yml文件作为默认配置文件。配置加载优先级高低从上至下，其中高优先级的配置会覆盖低优先级的内容。所有位置的文件都会被加载，当配置项相同时会按优先级进行覆盖，而配置项不同时则会全部加载，也就是所谓的配置互补。 file:./config/即项目根目录下的config文件夹。 file:./即项目根目录。 classpath:/config/即resources文件夹下的config文件夹。 classpath:/即resources文件夹。 SpringBoot 允许通过spring.config.location来改变默认的配置文件位置。如java -jar xxx.jar --spring.config.location=G:/application.yml。（只能在命令行运行 Jar 包时通过该参数改变默认的配置文件位置，会遵循优先级和互补原则） 外部配置文件加载顺序SpringBoot 也可以从以下位置加载配置（优先级从高到低），会遵循优先级和互补原则。 命令行参数。 来自java:comp/env的JNDI属性。 JAVA 系统属性。 操作系统环境变量。 RandomValuePropertySource 配置的random.*属性值。 JAR 包外部的application-{profile}.properties或application.yml（带Spring.profile）配置文件。 JAR 包内部的application-{profile}.properties或application.yml（带Spring.profile）配置文件。 JAR 包外部的application.properties或application.yml（带Spring.profile）配置文件。 JAR 包内部的application.properties或application.yml（带Spring.profile）配置文件。 @Configuration注解类上的@PropertySource。 通过 SpringApplication.setDefaultProperties 指定的默认属性。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（一）：简介","date":"2019-11-21T04:31:51.000Z","path":"posts/1bc2c8b5/","text":"服务架构 传统 WEB 应用服务架构是单体应用模式，即一个 WAR 包包含了项目所有功能，其所带来的优势是使得项目的开发，测试和部署极其方便。但是所带来的缺陷也是极其明显的，当某一功能进行修改时，项目需要重新进行部署。 微服务架构即一个应用便是一组小型服务的集合，并且各个服务之间可以通过 HTTP 协议进行互通。当使用微服务架构时，每一个功能元素最终都是一个可独立替换或独立升级的软件单元，而 SpringBoot 可以快速的开发每一个软件单元，之后可通过 SpringCloud 将所开发软件单元联系起来。 SpringBoot 优点 无需手动管理依赖 JAR 包的版本 无须配置XML，自动配置，简化开发且可修改默认值 使用嵌入式的 Servlet 容器，应用无需达成 WAR 包 外部化配置SpringBoot 可以使用 properties 文件，YAML文件，环境变量，命令行参数等来外部化配置。 无缝集成 Spring 技术栈SpringBoot 通过stater pom来导入这些依赖，且自动进行配置。 devtools提供的开发时特性SpringBoot 的 devtools 模块可以为应用增加开发时特性，例如开发环境属性默认值。 Actuator提供的生产特性Actuator 提供准生产环境的运行时应用监控。 天然集成云计算 SpringBoot 环境搭建 搭建完成的目录层级。 通过 IDEA 创建 MAVEN 项目。 配置 pom.xml 文件（可参考 SpringBoot 构建 RESTful 项目）。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>spring-boot&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;properties> &lt;!-- jdk版本 --> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;!-- 用于管理SpringBoot应用中所有的依赖版本 --> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;/parent> &lt;dependencies> &lt;!-- 导入WEB模块正常运行所依赖的组件 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;!-- 导入测试模块正常运行所依赖的组件 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- 导入JSON模块正常运行所依赖的组件 --> &lt;dependency> &lt;groupId>com.jayway.jsonpath&lt;/groupId> &lt;artifactId>json-path&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;!-- 将程序打包成可执行的JAR包 --> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 编写 SpringBoot 应用运行主程序。 /** * @Author 喵粮都输光了 * @Date 2019/11/21 20:32 * @Description SpringBoot主程序 */ @SpringBootApplication public class Main { public static void main(String[] args) { // 运行SpringBoot应用(SpringBootApplication会自动扫描该类所在包及其下所有子包内的组件添加入Spring容器) SpringApplication.run(Main.class, args); } } 编写简单 Controller 类向页面返回数据。 /** * @Author 喵粮都输光了 * @Date 2019/11/21 20:34 * @Description HelloController */ @Controller public class HelloController { @RequestMapping(\"/hello\") @ResponseBody public String hello() { return \"Hello world!\"; } } SpringBoot 应用快速构建此处以 IDEA 为例通过 Spring Initializr 快速构建 SpringBoot 项目。 通过 New -&gt; Project -&gt; Spring Initializr 单击下一步。 填写项目配置之后单击下一步。 勾选项目所需服务之后单击下一步后，IDEA 自动从 Spring 官网下载快速构建的项目。 SpringBoot 配置原理SpringBoot 将所有的功能场景抽取成为一个个 Starter，只需要在项目中引入这些 Starters，其相关环境的所有依赖都会导入进来。 @SpringBootApplication该注解应用于某一个 JAVA 类上是指该类是 SpringBoot 的主配置类，SpringBoot 将会运行该类的 main 方法来启动 SpringBoot 应用。 @SpringBootConfiguration该注解是@SpringBootApplication所包含的注解之一，标注在某一个 JAVA 类上是指该类是 SpringBoot 的配置类。该注解中包含 @Configuration 用于表明该类是一个配置类（即配置文件），通过@Component注解表明配置类是一个组件并能被 Spring 容器扫描到。 @EnableAutoConfiguration该注解是@SpringBootApplication所包含的注解之一，用于扫描组件并进行自动配置。该注解通过@AutoConfigurationPackage中的@Import(\"AutoConfigurationPackages.Registrar.class\")将@SpringBootApplication标注的类所在包及其下所有子包内的所有组件扫描入 Spring 容器中，最后通过@Import(EnableAutoConfigurationImportSelector.class)获取需要导入组件的选择器全限定类名添加入 Spring 容器中，并通过自动配置类（xxxAutoConfiguration）为组件自动配置。自动配置类文件包含在 spring-boot-autoconfiguration.jar 包下。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SSM整合","date":"2019-11-20T02:54:59.000Z","path":"posts/12cc57d7/","text":"目录层级 web.xml 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!-- spring容器监听器 --> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:applicationContext.xml&lt;/param-value> &lt;/context-param> &lt;!-- 前端控制器 --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 加载springMVC配置文件 --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springMVC.xml&lt;/param-value> &lt;/init-param> &lt;!-- 服务器启动时初始化该servlet --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;!-- 编码过滤器 --> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;/web-app> spring 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 注解扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii\"> &lt;!-- 不扫描controller --> &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &lt;!-- aop --> &lt;aop:aspectj-autoproxy/> &lt;!-- 事务管理 --> &lt;tx:annotation-driven/> &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- mybatis start --> &lt;!-- 加载jdbc.properties --> &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/> &lt;!-- alibaba druid --> &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"> &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> &lt;property name=\"url\" value=\"${jdbc.url}\"/> &lt;property name=\"username\" value=\"${jdbc.username}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;!-- 配置初始化大小、最小、最大 --> &lt;property name=\"initialSize\" value=\"1\"/> &lt;property name=\"minIdle\" value=\"1\"/> &lt;property name=\"maxActive\" value=\"20\"/> &lt;!-- 配置获取连接等待超时的时间 --> &lt;property name=\"maxWait\" value=\"10000\"/> &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --> &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/> &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --> &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/> &lt;!-- 这里建议配置为TRUE，防止取到的连接不可用 --> &lt;property name=\"testWhileIdle\" value=\"true\"/> &lt;property name=\"testOnBorrow\" value=\"true\"/> &lt;property name=\"testOnReturn\" value=\"false\"/> &lt;!-- 这里配置提交方式，默认就是TRUE，可以不用配置 --> &lt;property name=\"defaultAutoCommit\" value=\"true\"/> &lt;!-- 验证连接有效与否的SQL，不同的数据配置不同 --> &lt;property name=\"validationQuery\" value=\"${validationQuery}\"/> &lt;property name=\"filters\" value=\"stat\"/> &lt;!-- 打开removeAbandoned功能 --> &lt;property name=\"removeAbandoned\" value=\"true\"/> &lt;!-- 1800s --> &lt;property name=\"removeAbandonedTimeout\" value=\"1800\"/> &lt;!-- 关闭abandoned链接时输出错误日志 --> &lt;property name=\"logAbandoned\" value=\"true\"/> &lt;/bean> &lt;!-- sqlSessionFactory --> &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;property name=\"mapperLocations\" value=\"classpath:com/kuukokawaii/**/**.xml\"/> &lt;/bean> &lt;!-- dao接口所在包 --> &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"> &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/> &lt;property name=\"basePackage\" value=\"com.kuukokawaii.**.dao\"/> &lt;/bean> &lt;!-- mybatis end --> &lt;/beans> jdbc.driverClassName=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC jdbc.username=账号 jdbc.password=密码 validationQuery=SELECT 1 springMVC 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 注解扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii\"> &lt;!-- 只扫描controller --> &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &lt;!-- 视图解析器 thymeleaf start --> &lt;bean id=\"templateResolver\" class=\"org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"/> &lt;property name=\"suffix\" value=\".html\"/> &lt;property name=\"templateMode\" value=\"HTML\"/> &lt;property name=\"characterEncoding\" value=\"UTF-8\"/> &lt;property name=\"cacheable\" value=\"false\"/> &lt;/bean> &lt;bean id=\"templateEngine\" class=\"org.thymeleaf.spring5.SpringTemplateEngine\"> &lt;property name=\"templateResolver\" ref=\"templateResolver\"/> &lt;/bean> &lt;bean class=\"org.thymeleaf.spring5.view.ThymeleafViewResolver\"> &lt;property name=\"templateEngine\" ref=\"templateEngine\"/> &lt;property name=\"characterEncoding\" value=\"UTF-8\"/> &lt;/bean> &lt;!-- 视图解析器 thymeleaf end --> &lt;!-- 过滤静态资源 --> &lt;mvc:resources mapping=\"/static/css/\" location=\"/static/css/**\"/> &lt;mvc:resources mapping=\"/static/js/\" location=\"/static/js/**\"/> &lt;mvc:resources mapping=\"/static/images/\" location=\"/static/images/**\"/> &lt;!-- FAST_JSON解析 --> &lt;mvc:annotation-driven> &lt;mvc:message-converters> &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"/> &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\"> &lt;property name=\"supportedMediaTypes\"> &lt;list> &lt;value>text/html;charset=UTF-8&lt;/value> &lt;value>application/json;charset=UTF-8&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;/mvc:message-converters> &lt;/mvc:annotation-driven> &lt;!-- 注解支持 --> &lt;mvc:annotation-driven/> &lt;/beans> log4j 配置文件###################################### # log4j配置相关说明 ###################################### #%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL #%r 输出自应用启动到输出该log信息耗费的毫秒数 #%c 输出所属的类目，通常就是所在类的全名 #%t 输出产生该日志事件的线程名 #%m 输出代码中指定的信息 #%n 输出一个回车换行符，Windows平台为“\\r\\n”，Unix平台为“\\n” #%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MM dd HH:mm:ss,SSS}，输出类似： 2002年10月18日 22：10：28，921 #%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) #log4j提供4种布局: #org.apache.log4j.HTMLLayout（以HTML表格形式布局） #org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， #org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， #org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息 #log4j中有五级logger 输出级别: #FATAL 0 #ERROR 3 #WARN 4 #INFO 6 #DEBUG 7 ###################################### # log4j相关配置 ###################################### #日志输出级别 log4j.rootLogger=INFO,stdout,other #设置stdout的日志输出控制台 log4j.appender.stdout=org.apache.log4j.ConsoleAppender #输出日志到控制台的方式，默认为System.out log4j.appender.stdout.Target=System.out #设置使用灵活布局 log4j.appender.stdout.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.stdout.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %m %n #设置other的日志输出控制台(RollingFileAppender)/每天生产一个日志文件(DailyRollingFileAppender) log4j.appender.other=org.apache.log4j.DailyRollingFileAppender #设置other的输出日志 log4j.appender.other.File=src/main/webapp/WEB-INF/logs/ssm.log #设置other的日志最大限制 log4j.appender.other.MaxFileSize=1024KB #最多只保存20个备份文件 log4j.appender.other.MaxBackupIndex=1000 #输出INFO级别以上的日志 log4j.appender.other.Threshold=INFO #设置使用灵活布局 log4j.appender.other.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.other.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %t %m %n ###显示SQL语句部分 log4j.logger.com.mybatis=DEBUG log4j.logger.com.mybatis.common.jdbc.SimpleDataSource=DEBUG log4j.logger.com.mybatis.common.jdbc.ScriptRunner=DEBUG log4j.logger.com.mybatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG JAVA 类controller/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:28 * @Description 账户Controller */ @Controller(\"accountController\") @RequestMapping(\"/account\") public class AccountController { private final AccountService accountService; @Autowired public AccountController(AccountService accountService) { this.accountService = accountService; } @RequestMapping(\"/findAll\") public String findAll(ModelMap modelMap) { modelMap.put(\"list\", accountService.findAllAccount()); return \"list\"; } } dao/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:21 * @Description 账户dao */ @Repository public interface AccountMapper { /** * 查找所有账户 * @return 账户集合 */ List&lt;Account> findAllAccount(); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.kuukokawaii.account.dao.AccountMapper\"> &lt;resultMap id=\"accountResultMap\" type=\"com.kuukokawaii.account.entity.Account\"> &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/> &lt;result column=\"name\" property=\"name\" jdbcType=\"VARCHAR\"/> &lt;result column=\"money\" property=\"money\" jdbcType=\"DOUBLE\"/> &lt;/resultMap> &lt;sql id=\"account_column_List\"> &lt;!--@sql SELECT --> account.id, account.name, account.money &lt;!--@sql FROM account --> &lt;/sql> &lt;select id=\"findAllAccount\" resultMap=\"accountResultMap\"> SELECT &lt;include refid=\"account_column_List\"/> FROM account &lt;/select> &lt;/mapper> entity/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:19 * @Description 账户实体 */ @Data public class Account implements Serializable { private int id; private String name; private double money; } service/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:25 * @Description 账号Service */ public interface AccountService { /** * 查找所有账户 * @return 账户集合 */ List&lt;Account> findAllAccount(); } /** * @Author 喵粮都输光了 * @Date 2019/11/20 13:27 * @Description 账号Service实现 */ @Service(\"accountService\") public class AccountServiceImpl implements AccountService { private final AccountMapper accountMapper; @Autowired public AccountServiceImpl(AccountMapper accountMapper) { this.accountMapper = accountMapper; } @Override public List&lt;Account> findAllAccount() { return accountMapper.findAllAccount(); } } HTML 页面&lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>list&lt;/title> &lt;/head> &lt;body> &lt;!--/*@thymesVar id=\"list\" type=\"java.util.List\"*/--> &lt;div th:each=\"account : ${list}\"> &lt;p th:text=\"${account.id}\">&lt;/p> &lt;p th:text=\"${account.name}\">&lt;/p> &lt;p th:text=\"${account.money}\">&lt;/p> &lt;/div> &lt;/body> &lt;/html> pom.xml 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>ssm&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;packaging>war&lt;/packaging> &lt;name>ssm Maven Webapp&lt;/name> &lt;url>http://www.example.com&lt;/url> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;spring.version>5.1.9.RELEASE&lt;/spring.version> &lt;/properties> &lt;dependencies> &lt;!-- Spring --> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-beans&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-core&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.aspectj&lt;/groupId> &lt;artifactId>aspectjweaver&lt;/artifactId> &lt;version>1.9.4&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-aop&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-tx&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-test&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-jdbc&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;!-- SpringMVC --> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-web&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-webmvc&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;!-- Mybatis --> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis-spring&lt;/artifactId> &lt;version>2.0.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.17&lt;/version> &lt;/dependency> &lt;!-- thymeleaf --> &lt;dependency> &lt;groupId>org.thymeleaf&lt;/groupId> &lt;artifactId>thymeleaf&lt;/artifactId> &lt;version>3.0.11.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.thymeleaf&lt;/groupId> &lt;artifactId>thymeleaf-spring5&lt;/artifactId> &lt;version>3.0.11.RELEASE&lt;/version> &lt;/dependency> &lt;!-- alibaba --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.1.20&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>fastjson&lt;/artifactId> &lt;version>1.2.61&lt;/version> &lt;/dependency> &lt;!-- junit --> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.13-beta-3&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- lombok --> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;version>1.18.10&lt;/version> &lt;/dependency> &lt;!-- servlet --> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>javax.servlet-api&lt;/artifactId> &lt;version>4.0.1&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> &lt;!-- log --> &lt;dependency> &lt;groupId>log4j&lt;/groupId> &lt;artifactId>log4j&lt;/artifactId> &lt;version>1.2.17&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.slf4j&lt;/groupId> &lt;artifactId>slf4j-api&lt;/artifactId> &lt;version>2.0.0-alpha0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.slf4j&lt;/groupId> &lt;artifactId>slf4j-log4j12&lt;/artifactId> &lt;version>2.0.0-alpha0&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;finalName>ssm&lt;/finalName> &lt;!-- 编译java目录下的mapper文件 --> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>true&lt;/filtering> &lt;/resource> &lt;/resources> &lt;pluginManagement> &lt;plugins> &lt;plugin> &lt;artifactId>maven-clean-plugin&lt;/artifactId> &lt;version>3.1.0&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-resources-plugin&lt;/artifactId> &lt;version>3.0.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.8.0&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-surefire-plugin&lt;/artifactId> &lt;version>2.22.1&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-war-plugin&lt;/artifactId> &lt;version>3.2.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-install-plugin&lt;/artifactId> &lt;version>2.5.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-deploy-plugin&lt;/artifactId> &lt;version>2.8.2&lt;/version> &lt;/plugin> &lt;/plugins> &lt;/pluginManagement> &lt;/build> &lt;/project> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"},{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"Mybatis（六）：注解开发","date":"2019-10-14T05:26:13.000Z","path":"posts/13944/","text":"CRUD 注解写法在 Mybatis 中如果使用注解，那么在该 DAO 下就不能使用 XML 的方式进行开发。 select 的注解写法/** * 查询指定的user * * @param id 需要查询的user id * @return 返回查找到的user */ @Select(\"select * from user where id = #{id};\") User getUser(Integer id); /** * 查找所有User * * @return 返回User集合 */ @Select(\"select * from user\") List&lt;User> findUsers(); insert 的注解写法/** * 插入一个User * * @param user 需要插入的user * @return 返回插入结果 */ @Insert(\"insert into user (id, name, birthday, sex, address) values (#{id}, #{name}, #{birthday}, #{sex}, #{address});\") int createUser(User user); update 的注解写法 /** * 更新已给user * @param user 需要更新的user * @return 返回更新结果 */ @Update(\"update user set id = #{id}, name = #{name}, birthday = #{birthday}, sex = #{sex}, address = #{address} where id = #{id};\") int updateUser(User user); delete 的注解写法/** * 删除指定用户 * * @param id 需要删除用户的id * @return 返回删除结果 */ @Delete(\"delete from user where id = #{id};\") int deleteUser(Integer id); resultMap 注解写法Mybatis 提供了 @Results、@Result 和 @ResultMap 三个注解用于调用和实现 XML 配置中的 ResultMap 标签。其中 @Results 相当于 XML 配置中的 ResultMap 标签；@Result 相当于 XML 配置中 ResultMap 的子标签 result；而 @ResultMap 相当于 XML 配置中 CRUD 标签中的 resultMap 属性，通过填入 ResultMap 的 id 与之对应。 /** * 查找所有User * * @return 返回User集合 */ @Select(\"select * from user\") @Results(id = \"UserResultMap\", value = { @Result(id = true, column = \"id\", jdbcType = JdbcType.INTEGER, property = \"id\"), @Result(column = \"name\", jdbcType = JdbcType.VARCHAR, property = \"name\"), @Result(column = \"birthday\", jdbcType = JdbcType.DATE, property = \"birthday\"), @Result(column = \"sex\", jdbcType = JdbcType.VARCHAR, property = \"sex\"), @Result(column = \"address\", jdbcType = JdbcType.VARCHAR, property = \"address\") }) List&lt;User> findUsers(); /** * 查询指定的user * * @param id 需要查询的user id * @return 返回查找到的user */ @Select(\"select * from user where id = #{id};\") @ResultMap(\"UserResultMap\") User getUser(Integer id); 多表查询与延迟加载注解写法Mybatis 提供了 @One 和 @Many 两个注解用于实现 XML 配置中的 association 标签 和 collection 标签。其中 fetchType 属性可以选择快速加载或延迟加载。 一对一查询/** * 查找所有Account（立即加载） * * @return 返回Account集合 */ @Select(\"select * from account\") @Results(id = \"AccountResultMap\", value = { @Result(id = true, column = \"id\", jdbcType = JdbcType.INTEGER, property = \"id\"), @Result(column = \"username\", jdbcType = JdbcType.VARCHAR, property = \"username\"), @Result(column = \"password\", jdbcType = JdbcType.DATE, property = \"password\"), @Result(column = \"id\", jdbcType = JdbcType.INTEGER, property = \"user\", one = @One( select = \"com.kuukokawaii.user.dao.UserDao.getUser\", fetchType = FetchType.EAGER )) }) List&lt;Account> findAccounts(); 一对多查询/** * 查找所有User（延迟加载） * * @return 返回User集合 */ @Select(\"select * from user\") @Results(id = \"UserResultMap\", value = { @Result(id = true, column = \"id\", jdbcType = JdbcType.INTEGER, property = \"id\"), @Result(column = \"name\", jdbcType = JdbcType.VARCHAR, property = \"name\"), @Result(column = \"birthday\", jdbcType = JdbcType.DATE, property = \"birthday\"), @Result(column = \"sex\", jdbcType = JdbcType.VARCHAR, property = \"sex\"), @Result(column = \"address\", jdbcType = JdbcType.VARCHAR, property = \"address\"), @Result(column = \"id\", property = \"accounts\", many = @Many( select = \"com.kuukokawaii.user.dao.AccountDao.getAccount\", fetchType = FetchType.LAZY )) }) List&lt;User> findUsers(); 二级缓存注解写法Mybatis 提供了 @CacheNamespace 用于实现 XML 配置中 cache 标签的功能，需要注意的是该注解使用于 Dao 类上而非方法上。二级缓存可以在 SqlMapConfig.xml 中进行开启（默认开启）。 注解说明： readWrite：读写模式，True：必须实现序列化接口； flushInterval：刷新时间，单位：毫秒；这里的刷新是指缓存数据的有效期； implementation：缓存实现自定义对象； eviction：缓存策略的算法； size：是引用的缓存结果，这里是指1024次查询的结果，是序列化之后的结果； blocking：防止缓存击穿，对应的实现类：BlockingCache.putObject； 代码演示： &lt;settings> &lt;!-- 开启二级缓存支持。（可以不进行配置，默认 true。） --> &lt;setting name=\"cacheEnabled\" value=\"true\"/> &lt;/settings> @CacheNamespace(blocking = true) public interface UserDao { // 内容省略 } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（五）：缓存","date":"2019-10-13T09:42:50.000Z","path":"posts/2305/","text":"缓存适用性 经常查询且不经常改变的数据适用于缓存。 数据的正确与否对最终结果影响不大适用于缓存。相反，商品的库存、银行的汇率和股市的牌价等皆不适用于缓存。 一级缓存Mybatis 的一级缓存指的是 SqlSession 对象的缓存。当执行查询之后，查询的结果会同时存入到 SqlSession 中的一块 Map 结构的存储区域中。当我们再次执行查询同样的数据时，Mybatis 会先去 SqlSession 中查询是否拥有该数据，有则直接从缓存中获取。需要注意的是当调用 SqlSession 对象的修改、添加、删除、commit()、close()等方法时，Mybatis 的一级缓存将会被清空。 二级缓存Mybatis 的二级缓存指的是 SqlSessionFactory 对象的缓存。由同一个 SqlSessionFactory 对象创建的 SqlSession 对象将共享该缓存。不同于一级缓存，二级缓存需要手动配置。 二级缓存配置方法 让 Mybatis 框架支持二级缓存（在 SqlMapConfig.xml 中配置）。 让当前的映射文件支持二级缓存（在 UserMapper.xml 中配置）。 让当前的操作支持二级缓存（在 select 标签中配置）。 代码演示： SqlMapConfig.xml &lt;settings> &lt;!-- 开启二级缓存支持。（可以不进行配置，默认 true。） --> &lt;setting name=\"cacheEnabled\" value=\"true\"/> &lt;/settings> UserMapper.xml &lt;!-- 在 mapper 标签下开启二级缓存支持 --> &lt;cache/> select 标签 &lt;!-- 通过 userCache 属性开启二级缓存 --> &lt;select id=\"findUsers\" resultMap=\"UserResultMap\" useCache=\"true\"> select &lt;include refid=\"User_Column_List\"/> from user &lt;/select> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（四）：延迟加载","date":"2019-10-11T11:56:30.000Z","path":"posts/4576/","text":"立即加载和延迟加载 疑问在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候，要不要查询关联的账户。 在查询账户的时候，是否需要查询关联的用户。 解决 在查询用户的时候，是否查询关联的账户是按需查询。因此此处采用延迟加载（按需加载、懒加载），即数据只在需要的时候进行加载。 在查询账户的时候，关联的用户信息会随着账户查询一并查询显示。因此此处采用立即加载，即无论数据是否需要，再发起查询的时候都立即加载。 总结 一对多，多对多：通常情况下都是采用延迟加载。 一对一（多对一）：通常情况下都是采用立即加载。 代码演示/** * @Author 喵粮都输光了 * @Date 2019/9/30 14:53 * @Description 账户实体 */ public class Account implements Serializable { // 此处省略 get 和 set private Integer id; private String username; private String password; private User user; @Override public String toString() { return \"Account{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 此处省略 get 和 set private Integer id; private String name; private Date birthday; private String sex; private String address; private List&lt;Account> accounts; @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '}'; } } /** * @Author 喵粮都输光了 * @Date 2019/9/23 17:12 * @Description 用户持久层接口 */ public interface UserDao { /** * 查找指定的User * @param id 通过id查找User * @return 返回找到的User对象 */ User getUser(String id); /** * 查找所有User * @return 返回User集合 */ List&lt;User> findUsers(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 15:37 * @Description 账号持久层接口 */ public interface AccountDao { /** * 查找指定的Account * @param id 通过id查找Account * @return 返回找到的Account对象 */ Account getAccount(String id); /** * 查找所有Account * @return 返回Account集合 */ List&lt;Account> findAccounts(); } 在 SqlMapConfig.xml 中开启延迟加载 &lt;settings> &lt;!-- 开启延迟加载开关 --> &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/> &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/> &lt;/settings> 一对多延迟加载：一个 User 拥有多个 Account，通过 UserMapper 中的 collection 标签的 select 调用 Account 中的 getAccount 方法进行延迟加载。 &lt;sql id=\"Account_Column_List\"> &lt;!--@sql select --> account.id, username, password &lt;!--@sql from account --> &lt;/sql> &lt;select id=\"getAccount\" parameterType=\"string\" resultType=\"com.kuukokawaii.user.entity.Account\"> select &lt;include refid=\"Account_Column_List\"/> from account where account.id = #{id}; &lt;/select> &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;!-- 延迟加载一对多。 select：表示调用其他查询（可以是其他mapper中的查询），此处为查询用户的唯一标识。 column：用户根据 id 查询时，所需要的参数的值。即为 select 中查询提供所需的 id 进行查询。 --> &lt;collection column=\"id\" property=\"accounts\" select=\"com.kuukokawaii.user.dao.AccountDao.getAccount\"/> &lt;/resultMap> &lt;sql id=\"User_Column_List\"> &lt;!--@sql select --> user.id, name, birthday, sex, address &lt;!--@sql from user --> &lt;/sql> &lt;select id=\"findUsers\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/> from user &lt;/select> 一对一（多对一）延迟加载：多个 Account 对应一个 User，通过 AccountMapper 中的 association 标签的 select 调用 User 中的 getUser 方法进行延迟加载。 &lt;sql id=\"User_Column_List\"> &lt;!--@sql select --> user.id, name, birthday, sex, address &lt;!--@sql from user --> &lt;/sql> &lt;select id=\"getUser\" parameterType=\"string\" resultType=\"com.kuukokawaii.user.entity.User\"> select &lt;include refid=\"User_Column_List\"/> from user where user.id = #{id}; &lt;/select> &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;!-- 延迟加载一对一（多对一）。 select：表示调用其他查询（可以是其他mapper中的查询），此处为查询用户的唯一标识。 column：用户根据 id 查询时，所需要的参数的值。即为 select 中查询提供所需的 id 进行查询。 --> &lt;association column=\"id\" property=\"user\" select=\"com.kuukokawaii.user.dao.UserDao.getUser\"/> &lt;/resultMap> &lt;sql id=\"Account_Column_List\"> &lt;!--@sql select --> account.id, username, password &lt;!--@sql from account --> &lt;/sql> &lt;select id=\"findAccounts\" resultMap=\"AccountResultMap\"> select &lt;include refid=\"Account_Column_List\"/> from account &lt;/select> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"设计模式之策略模式","date":"2019-10-09T09:19:54.000Z","path":"posts/36970/","text":"策略模式 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。即将各个功能拆分封装成模块，最终通过组合的方式实现效果。 设计原则： 1.找出应用中可能需要变化之处，把它们独立出来，不要和哪些不需要变化的代码混在一起。 2.针对接口编程，而不是针对实现编程。 3.多用组合，少用继承。 原型根据 OO 标准，设计一个鸭子超类，并让各类鸭子继承此超类。 新增飞行功能 问题：在超类上新增功能飞行，导致子类不能飞行的鸭子也能够飞行。 解决：覆盖不能飞行的鸭子的飞行方法，让不能飞行的鸭子不再拥有飞行功能。如此修改代码的话会导致以后每增加一个继承鸭子超类的子类都需要检查并可能覆盖飞行方法，这是非常痛苦的一件事情！因此将飞行方法抽取出来，让需要该功能的鸭子实现接口即可。 实现飞行接口 问题：当抽取了飞行功能时，发现每次新增子类时都需要实现一次飞行接口，这造成了大量代码的重复！ 解决：这里可以对飞行接口进行实现，让能飞、不能飞的鸭子在初始化实例变量时调用所需接口即可。 UML图： 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/10/9 17:46 * @Description 鸭子超类 */ abstract class AbstractDuck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; /** * 执行飞行功能 */ void performFly() { flyBehavior.fly(); } /** * 执行叫声功能 */ void performQuack() { quackBehavior.quack(); } /** * 游泳功能 */ void swim() { System.out.println(\"会游泳。\"); } /** * 外观 */ abstract void display(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:35 * @Description 飞行接口 */ public interface FlyBehavior { /** * 飞行功能。 */ void fly(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:58 * @Description 飞行接口实现类：不能飞 */ public class FlyNowayImpl implements FlyBehavior { @Override public void fly() { System.out.println(\"不能飞。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:59 * @Description 飞行接口实现类：能飞 */ public class FlyWithWingsImpl implements FlyBehavior{ @Override public void fly() { System.out.println(\"能飞。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:35 * @Description 叫声接口 */ public interface QuackBehavior { /** * 叫声功能。 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 19:01 * @Description 叫声接口实现类：呱呱叫 */ public class QuackImpl implements QuackBehavior{ @Override public void quack() { System.out.println(\"呱呱叫。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 19:01 * @Description 叫声接口实现类：吱吱叫 */ public class SqueakImpl implements QuackBehavior { @Override public void quack() { System.out.println(\"吱吱叫。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 17:48 * @Description 红头鸭 */ public class RedheadDuck extends AbstractDuck { public RedheadDuck() { quackBehavior = new QuackImpl(); flyBehavior = new FlyWithWingsImpl(); } @Override void display() { System.out.println(\"外观是红头鸭。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:20 * @Description 橡皮鸭 */ public class RubberDuck extends AbstractDuck { public RubberDuck() { quackBehavior = new SqueakImpl(); flyBehavior = new FlyNowayImpl(); } @Override void display() { System.out.println(\"外观是橡皮鸭。\"); } } 遗留的小问题 问题：实现飞行功能的解决方法在构造器中制造了一个具体的实现类实例，该行为违反了不对具体实现编程的设计原则。 解决：可以通过其他设计模式解决。 动态设定行为 需求：实现飞行接口的方案可以动态的设定行为，即在运行时修改鸭子的功能，而不是通过构造器实例化。 代码演示（主要代码）： 在 Duck 类新增 setFlyBehavior 和 setQuackBehavior 方法。 /** * @Author 喵粮都输光了 * @Date 2019/10/9 17:46 * @Description 鸭子超类 */ abstract class AbstractDuck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; /** * 执行飞行功能 */ void performFly() { flyBehavior.fly(); } /** * 执行叫声功能 */ void performQuack() { quackBehavior.quack(); } /** * 设置具体飞行功能。 * * @param flyBehavior 具体飞行功能 */ void setFlyBehavior(FlyBehavior flyBehavior) { this.flyBehavior = flyBehavior; } /** * 设置具体叫声功能。 * * @param quackBehavior 具体叫声功能 */ void setQuackBehavior(QuackBehavior quackBehavior) { this.quackBehavior = quackBehavior; } /** * 游泳功能 */ void swim() { System.out.println(\"会游泳。\"); } /** * 外观 */ abstract void display(); } 在运行中修改橡皮鸭的叫声为呱呱叫。 /** * @Author 喵粮都输光了 * @Date 2019/10/9 19:18 * @Description 主函数 */ public class Main { public static void main(String[] args) { AbstractDuck rubberDuck = new RubberDuck(); rubberDuck.swim(); rubberDuck.display(); rubberDuck.performFly(); rubberDuck.performQuack(); System.out.println(\"--------改变了橡皮鸭的叫声为呱呱叫--------\"); rubberDuck.setQuackBehavior(new QuackImpl()); rubberDuck.performQuack(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Mybatis（三）：多表操作","date":"2019-10-09T04:58:18.000Z","path":"posts/44025/","text":"一对多、一对一 案例说明：用户和账户 一个用户可以有多个账户，使用 collection。 一个账户只能属于一个用户，使用 association。（多个账户也可以属于同一个用户） 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 此处省略 get 和 set private Integer id; private String name; private Date birthday; private String sex; private String address; private List&lt;Account> accounts; } /** * @Author 喵粮都输光了 * @Date 2019/9/30 14:53 * @Description 账户实体 */ public class Account implements Serializable { // 此处省略 get 和 set private Integer id; private String username; private String password; private User user; } UserMapper（一对多） &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;collection property=\"accounts\" resultMap=\"AccountResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;/resultMap> AccountMapper（一对一） &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;association property=\"user\" resultMap=\"AccountResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;/resultMap> 多对多 案例说明：用户和角色 一个用户可以有多个角色。 一个角色可以赋予多个用户。 数据库中需要一个中间表来记录角色和用户之间的对应关系。（需要中间表） 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 此处省略 get 和 set private Integer id; private String name; private Date birthday; private String sex; private String address; private List&lt;Role> roles; } /** * @Author 喵粮都输光了 * @Date 2019/10/9 16:50 * @Description 角色实体 */ public class Role implements Serializable { // 此处省略 get 和 set private Integer id; private String roleName; private String roleDesc; private List&lt;User> users; } UserMapper（一对多） &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;collection property=\"roles\" resultMap=\"RoleResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"RoleResultMap\" type=\"com.kuukokawaii.user.entity.Role\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/> &lt;result column=\"role_desc\" jdbcType=\"VARCHAR\" property=\"roleDesc\"/> &lt;/resultMap> AccountMapper（一对多） &lt;resultMap id=\"RoleResultMap\" type=\"com.kuukokawaii.user.entity.Role\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/> &lt;result column=\"role_desc\" jdbcType=\"VARCHAR\" property=\"roleDesc\"/> &lt;collection property=\"users\" resultMap=\"UserResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;/resultMap> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（二）：mapper.xml 文件语法","date":"2019-09-29T10:24:31.000Z","path":"posts/30243/","text":"resultMap resultMap 可以实现将查询结果映射为复杂类型的pojo。 id：用于定义 resultMap 的 id。 type：复杂类型的实体全限定名。 result：对数据库字段和 java 变量进行映射。 column：数据库字段。 jdbcType：数据库字段类型。 property：java 变量。 collection：一个复杂类型的关联，可以关联另一个 resultMap。 案例说明： 创建一个 Account 类，包含 username 和 password。 创建一个 User 类，包含 id、name、birthday、sex 和 address。 定义 User 类的 resultMap。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/30 14:53 * @Description 账户实体 */ public class Account { // 此处省略了 set 和 get。 private String username; private String password; private Integer id; } /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ @Data public class User implements Serializable { // 此处省略了 set 和 get。 private Integer id; private String name; private Date birthday; private String sex; private String address; private Account account; } &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;association property=\"account\" resultMap=\"AccountResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;/resultMap> sql sql 被用来定义可重用的 sql 代码段，可以通过&lt;include&gt;标签进行调用。 案例说明：用 sql 定义 user 和 account 表的字段集。 代码演示： &lt;sql id=\"User_Column_List\"> &lt;!--@sql select --> user.id, name, birthday, sex, address &lt;!--@sql from user --> &lt;/sql> &lt;sql id=\"Account_Column_List\"> &lt;!--@sql select --> account.id, username, password &lt;!--@sql from account --> &lt;/sql> if if 提供了一种可选的查找文本功能，符合条件即执行。 案例说明：当 sex 非 null 时语句查询指定的 name 和 sex 条件，否则只查询 name。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id where name = #{name} &lt;if test=\"sex != null\"> and sex = #{sex} &lt;/if> &lt;/select> choose, when, otherwise choose 从多个条件中挑选一个，类似于 switch 语句。 案例说明：当 sex 非空时根据 name 和 sex 查询，当 birthday 非空时根据 name 和 birthday 查询，当 address 非空时根据 name 和 address 查询，否则仅根据 name 查询。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id where name = #{name} &lt;choose> &lt;when test=\"sex != null\"> and sex = #{sex} &lt;/when> &lt;when test=\"birthday != null\"> and birthday = #{birthday} &lt;/when> &lt;otherwise> and address = #{address} &lt;/otherwise> &lt;/choose> &lt;/select> trim, where, set 当使用 if 进行条件匹配时，如果一个条件都不匹配则语句末尾可能以 where 结尾导致 sql 报错。若匹配的条件非第一项而是其他项则会导致 where and xxx 的语句情况同样会报错。因此 mybatis 的 where 标签会自动处理该情况。set 同理。当 where 和 set 标签没有发挥作用时可以通过 trim 自定义格式执行。 案例说明： 当条件非空时查询指定条件否则查询所有。 当条件非空时更新非空条件。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id &lt;where> &lt;if test=\"name != null\"> name = #{name} &lt;/if> &lt;if test=\"sex != null\"> and sex = #{sex} &lt;/if> &lt;/where> &lt;/select> &lt;!-- where 等价于 trim 的如下情形 --> &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"> &lt;!-- 内容 --> &lt;/trim> &lt;update id=\"updateUser\" parameterType=\"com.kuukokawaii.user.entity.User\"> update user, account &lt;set> &lt;if test=\"id != null\"> user.id = #{id}, &lt;/if> &lt;if test=\"name != null\"> name = #{name}, &lt;/if> &lt;if test=\"birthday != null\"> birthday = #{birthday}, &lt;/if> &lt;if test=\"sex != null\"> sex = #{sex}, &lt;/if> &lt;if test=\"address != null\"> address = #{address}, &lt;/if> &lt;if test=\"account.id != null\"> account.id = #{account.id}, &lt;/if> &lt;if test=\"account.username != null\"> account.username = #{account.username}, &lt;/if> &lt;if test=\"account.password != null\"> account.password = #{account.password}, &lt;/if> &lt;/set> where user.id = account.id and user.id = #{id} &lt;/update> &lt;!-- set 等价于 trim 的如下情形 --> &lt;trim prefix=\"SET\" prefixOverrides=\",\"> &lt;!-- 内容 --> &lt;/trim> foreach 通常是在构建 IN 条件语句的时候使用，对一个集合进行遍历操作。 案例说明：搜索 id 在列表中的 user。 代码演示： &lt;select id=\"selectUserIn\" resultMap=\"UserResultMap\"> select * from user where user.id in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"> #{item} &lt;/foreach> &lt;/select> bind bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。 案例说明：搜索符合条件的 user。 代码演示： &lt;select id=\"selectUsersLike\" resultMap=\"UserResultMap\"> &lt;bind name=\"pattern\" value=\"'%' + _parameter.getTitle() + '%'\" /> select * from user where name like #{pattern} &lt;/select> select select 是 mybatis 的查询语句。 id：用于定义 select 的 id，需要与 DAO 中的方法名对应。方法名为 get 表获取单个元素，find 表获取元素集。 parameterType：表传入的参数类型。 resultType：表示返回类型（与 resultMap 二选一），如果返回的是集合则填写集合所包含的类型。 resultMap：表示返回类型（与 resultType 二选一），返回定义的 resultMap。 案例说明： 查找一个指定名称的 User 对象。 查找所有 User 对象。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id where name = #{name}; &lt;/select> &lt;select id=\"findUser\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id &lt;/select> delete delete 是 mybatis 的删除语句。 案例说明：删除一个指定 id 的 User 和 Account 对象。 代码演示： &lt;delete id=\"deleteUser\" parameterType=\"int\"> delete from user, account using user, account where user.id = account.id and user.id = #{id}; &lt;/delete> update update 是 mybatis 的更新语句。 useGeneratedKeys：更新后返回主键（默认 false）。 keyProperty：指定在 Java 实体中对应的主键变量名。 keyColumn：当主键列不是表中的第一列的时候需要设置，用于指定数据库的主键（默认数据库第一列为主键）。 案例说明：更新指定User对象。 代码演示： &lt;update id=\"updateUser\" parameterType=\"com.kuukokawaii.user.entity.User\"> update user, account &lt;set> &lt;if test=\"id != null\"> user.id = #{id}, &lt;/if> &lt;if test=\"name != null\"> name = #{name}, &lt;/if> &lt;if test=\"birthday != null\"> birthday = #{birthday}, &lt;/if> &lt;if test=\"sex != null\"> sex = #{sex}, &lt;/if> &lt;if test=\"address != null\"> address = #{address}, &lt;/if> &lt;if test=\"account.id != null\"> account.id = #{account.id}, &lt;/if> &lt;if test=\"account.username != null\"> account.username = #{account.username}, &lt;/if> &lt;if test=\"account.password != null\"> account.password = #{account.password}, &lt;/if> &lt;/set> where user.id = account.id and user.id = #{id} &lt;/update> insert insert 是 mybatis 的插入语句。 案例说明：插入一个User对象。(如果在插入一个 User 对象的同时插入 Account 对象，需要在 Service 中开启事务并调用 User 插入和 Account 插入语句。) 代码演示： &lt;insert id=\"createUser\" parameterType=\"com.kuukokawaii.user.entity.User\" useGeneratedKeys=\"true\" keyProperty=\"id\"> insert into user &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\"> &lt;if test=\"name != null\"> name, &lt;/if> &lt;if test=\"birthday != null\"> birthday, &lt;/if> &lt;if test=\"sex != null\"> sex, &lt;/if> &lt;if test=\"address != null\"> address, &lt;/if> &lt;/trim> &lt;trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\"> &lt;if test=\"name != null\"> #{name}, &lt;/if> &lt;if test=\"birthday != null\"> #{birthday}, &lt;/if> &lt;if test=\"sex != null\"> #{sex}, &lt;/if> &lt;if test=\"address != null\"> #{address}, &lt;/if> &lt;/trim> &lt;/insert> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（一）：简介","date":"2019-09-22T04:12:57.000Z","path":"posts/13712/","text":"Mybatis 概述 Mybatis 封装了 jdbc，让开发无需花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 Mybatis 通过 XML 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象 和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 Mybatis 框架执行 sql 并将结果映射为 java 对象并返回。 Mybatis 采用 ORM 思想解决了实体和数据库映射的问题，因此不需要直接操作 JDBC API 便可以完成对数据库的持久化操作。 案例说明 在 mysql 数据库中建立 user 表。 创建 User 实体和 dao 接口。 创建映射配置文件（UserMapper.xml），注意 mybatis 的映射位置文件位置必须和 dao 接口的包结构相同。 配置 mybatis 配置文件（SqlMapConfig.xml）。 Demo 目录层级如下： 使用到的 Jar 包 mybatis.jar log4j.jar junit.jar mysql-connector-java.jar 代码演示use mybatis; create table user( id int(11) not null primary key auto_increment, username varchar(30) not null comment '用户名称', birthday datetime default null comment '生日', sex char(1) default null comment '性别', address varchar(256) default null comment '地址' ) engine=innodb default charset=utf8mb4; insert into user (username, birthday, sex, address) values('update user clear cache', '2018-02-10', '男', '北京xx1'); insert into user (username, birthday, sex, address) values('123', '2018-03-10', '女', '北京xx81'); insert into user (username, birthday, sex, address) values('13535', '2018-05-10', '女', '北京xx71'); insert into user (username, birthday, sex, address) values('456436', '2018-07-10', '男', '北京xx19'); insert into user (username, birthday, sex, address) values('asda', '2018-02-15', '女', '北京xx1'); insert into user (username, birthday, sex, address) values('啊沙发沙发', '2018-08-20', '男', '北京xx12'); insert into user (username, birthday, sex, address) values('让他人', '2018-09-10', '女', '北京xx17'); insert into user (username, birthday, sex, address) values('啊实打实的', '2018-10-01', '男', '北京xx21'); /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 省略了 get 和 set。 private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() { return \"User{id=\" + id + \", username='\" + username + \", birthday=\" + birthday + \", sex='\" + sex + \", address\" + \"='\" + address + \"}\"; } } ###################################### # log4j配置相关说明 ###################################### #%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL #%r 输出自应用启动到输出该log信息耗费的毫秒数 #%c 输出所属的类目，通常就是所在类的全名 #%t 输出产生该日志事件的线程名 #%m 输出代码中指定的信息 #%n 输出一个回车换行符，Windows平台为“\\r\\n”，Unix平台为“\\n” #%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MM dd HH:mm:ss,SSS}，输出类似： 2002年10月18日 22：10：28，921 #%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) #log4j提供4种布局: #org.apache.log4j.HTMLLayout（以HTML表格形式布局） #org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， #org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， #org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息 #log4j中有五级logger 输出级别: #FATAL 0 #ERROR 3 #WARN 4 #INFO 6 #DEBUG 7 ###################################### # log4j相关配置 ###################################### #日志输出级别 log4j.rootLogger=INFO,stdout,other #设置stdout的日志输出控制台 log4j.appender.stdout=org.apache.log4j.ConsoleAppender #输出日志到控制台的方式，默认为System.out log4j.appender.stdout.Target=System.out #设置使用灵活布局 log4j.appender.stdout.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.stdout.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %m %n #设置other的日志输出控制台(RollingFileAppender)。/每天生产一个日志文件(DailyRollingFileAppender),没有MaxFileSize和MaxBackupIndex属性。 #log4j.appender.other=org.apache.log4j.DailyRollingFileAppender log4j.appender.other=org.apache.log4j.RollingFileAppender #设置other的输出日志 log4j.appender.other.File=设置输出位置，例如 D:\\\\JetBrains。 #设置other的日志最大限制 log4j.appender.other.MaxFileSize=1024KB #最多只保存20个备份文件 log4j.appender.other.MaxBackupIndex=1000 #输出INFO级别以上的日志 log4j.appender.other.Threshold=INFO #设置使用灵活布局 log4j.appender.other.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.other.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %t %m %n ###显示SQL语句部分 log4j.logger.com.mybatis=DEBUG log4j.logger.com.mybatis.common.jdbc.SimpleDataSource=DEBUG log4j.logger.com.mybatis.common.jdbc.ScriptRunner=DEBUG log4j.logger.com.mybatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG /** * @Author 喵粮都输光了 * @Date 2019/9/25 14:33 * @Description mybatis demo 测试 */ public class UserDaoTest { public static void main(String[] args) throws IOException { // 读取配置文件。 InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建 sqlSessionFactory 工厂 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); // 使用工厂生产 sqlSession 对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 使用 sqlSession 创建 Dao 接口的代理对象 UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User> userList = userDao.findAllUser(); for (User user : userList) { System.out.println(user); } // 释放资源 sqlSession.close(); inputStream.close(); } } XML 配置方式/** * @Author 喵粮都输光了 * @Date 2019/9/23 17:12 * @Description 用户持久层接口 */ public interface UserDao { /** * 查询所有用户 * @return 返回用户 list */ List&lt;User> findAllUser(); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.kuukokawaii.user.dao.UserDao\"> &lt;!-- 配置查询所有用户 --> &lt;select id=\"findAllUser\" resultType=\"com.kuukokawaii.user.entity.User\"> select * from user &lt;/select> &lt;/mapper> &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 配置环境 --> &lt;environments default=\"mysql\"> &lt;!-- 配置 mysql 的环境 --> &lt;environment id=\"mysql\"> &lt;!-- 配置事务的类型 --> &lt;transactionManager type=\"JDBC\"/> &lt;!-- 配置数据源（连接池） --> &lt;dataSource type=\"POOLED\"> &lt;!-- 配置连接数据库的基本信息 --> &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC\"/> &lt;property name=\"username\" value=\"账号\"/> &lt;property name=\"password\" value=\"密码\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个 dao 独立的配置文件 --> &lt;mappers> &lt;mapper resource=\"com/kuukokawaii/user/dao/UserMapper.xml\"/> &lt;/mappers> &lt;/configuration> 注解方式/** * @Author 喵粮都输光了 * @Date 2019/9/23 17:12 * @Description 用户持久层接口 */ public interface UserDao { /** * 查询所有用户 * * @return 返回用户 list */ @Select(\"select * from user\") List&lt;User> findAllUser(); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 配置环境 --> &lt;environments default=\"mysql\"> &lt;!-- 配置 mysql 的环境 --> &lt;environment id=\"mysql\"> &lt;!-- 配置事务的类型 --> &lt;transactionManager type=\"JDBC\"/> &lt;!-- 配置数据源（连接池） --> &lt;dataSource type=\"POOLED\"> &lt;!-- 配置连接数据库的基本信息 --> &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC\"/> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"qwe123\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个 dao 独立的配置文件。如果使用注解方式来配置则此处应该使用 class 属性指定被注解的 dao 全限定类名 --> &lt;mappers> &lt;mapper class=\"com.kuukokawaii.user.dao.UserDao\"/> &lt;/mappers> &lt;/configuration> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"SpringMVC（八）：拦截器","date":"2019-09-21T11:18:43.000Z","path":"posts/27588/","text":"Filter 与 Interceptor 的区别FilterFilter 依赖于 Servlet 容器，它的实现基于函数回调，几乎可以对所有的请求进行过滤，通常于容器初始化时调用。 InterceptorInterceptor 依赖于 SpringMVC 框架，它的实现基于 Java 的反射机制，属于 AOP 的一种运用。通常对处理器方法进行预处理和后处理。 案例说明 编写两个拦截器类，实现 HandlerInterceptor 接口。其中预处理方法中返回值为布尔型，作用分别如下： true：表放行，执行下一个拦截器，没有则执行 controller 中的方法。 false：表不放行，会执行 preHandle() 和 afterCompletion() 方法，但不对 controller 中的方法和 postHandle() 进行执行。 两个拦截器分别为拦截器1和拦截器2，执行顺序为：1pre()→2pre()→controller方法→2post()→1post()→2after()→1after() SpringMVC 配置文件中配置拦截器。 代码演示/** * @Author 喵粮都输光了 * @Date 2019/9/21 19:44 * @Description 自定义拦截器类1 */ public class MyInterceptor1 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"1拦截器预处理，controller 方法执行前运行\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"1拦截器后处理，controller 方法执行后运行\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"1在视图渲染之后运行，还要再拦截器后处理方法运行之后。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/21 19:44 * @Description 自定义拦截器类2 */ public class MyInterceptor2 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"2拦截器预处理，controller 方法执行前运行\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"2拦截器后处理，controller 方法执行后运行\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"2在视图渲染之后运行，还要再拦截器后处理方法运行之后。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 拦截器 */ @Controller @RequestMapping(\"/user\") public class UserController { @RequestMapping(\"/testInterceptor\") String testInterceptor() { System.out.println(\"controller 方法\"); return \"success\"; } } &lt;!-- 配置拦截器 --> &lt;mvc:interceptors> &lt;mvc:interceptor> &lt;!-- 配置需要拦截的方法。&lt;mvc:mapping>表需要拦截的方法，&lt;mvc:exclude-mapping>表不需要拦截的方法。path 填写需要拦截的 URI --> &lt;mvc:mapping path=\"/user/*\"/> &lt;!-- 配置拦截器对象 --> &lt;bean id=\"myInterceptor1\" class=\"com.kuukokawaii.springmvc.interceptor.MyInterceptor1\"/> &lt;/mvc:interceptor> &lt;mvc:interceptor> &lt;mvc:mapping path=\"/**\"/> &lt;bean id=\"myInterceptor2\" class=\"com.kuukokawaii.springmvc.interceptor.MyInterceptor2\"/> &lt;/mvc:interceptor> &lt;/mvc:interceptors> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>拦截器&lt;/h3> &lt;a href=\"/user/testInterceptor\">拦截器&lt;/a> &lt;/body> &lt;/html> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %> &lt;html> &lt;head> &lt;title>success 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>执行成功&lt;/h3> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（七）：异常处理","date":"2019-09-21T08:28:18.000Z","path":"posts/47299/","text":"异常处理方式SpringMVC 常用的异常处理方式有两种： 使用 SpringMVC 提供的 HandlerExceptionResolver 接口自定义异常处理器。 使用 @ControllerAdvice + @ExceptionHandler 注解实现异常处理。 接口方式 案例说明： 编写自定义异常种类。 编写异常处理器。 配置异常处理器并编写异常跳转页面。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/21 17:06 * @Description 自定义异常 */ public class CustomException extends Exception { /** * 存储提示信息（此处省略了 get 和 set） */ private String message; public CustomException(String message) { this.message = message; } } /** * @Author 喵粮都输光了 * @Date 2019/9/21 17:14 * @Description 自定义异常处理器 */ public class CustomExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { // 获取异常对象 CustomException customException; if (ex instanceof CustomException) { customException = (CustomException) ex; } else { customException = new CustomException(\"系统维护中。\"); } // 创建 ModelAndView 存储异常信息并设置返回页面。 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"errorMsg\", customException.getMessage()); modelAndView.setViewName(\"error\"); return modelAndView; } } /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 异常处理 */ @Controller @RequestMapping(\"/user\") public class UserController{ @RequestMapping(\"/testException\") String testException() throws CustomException { try { // 模拟异常 int i = 1 / 0; } catch (Exception e) { // 打印异常信息 e.printStackTrace(); // 抛出自定义异常信息 throw new CustomException(\"除数不能为0。\"); } return \"success\"; } } &lt;!-- 配置异常处理器 --> &lt;bean id=\"customExceptionResolver\" class=\"com.kuukokawaii.springmvc.exception.CustomExceptionResolver\"/> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %> &lt;html> &lt;head> &lt;title>异常处理界面&lt;/title> &lt;/head> &lt;body> ${errorMsg} &lt;/body> &lt;/html> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>异常处理&lt;/h3> &lt;a href=\"/user/testException\">异常处理&lt;/a> &lt;/body> &lt;/html> 注解方式 案例说明： 编写自定义异常种类。(CustomException、Controller 类同上) 使用 @ControllerAdvice + @ExceptionHandler(xx.class) 注解编写全局异常处理器。其中有 @ControllerAdvice 这个注解的类中的方法的某些注解会应用到所有的 Controller 里，例如 @ExceptionHandler。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/21 17:37 * @Description 基于 @ExceptionHandler 处理异常。 */ @ControllerAdvice public class CustomExceptionHandler { /** * 基于 @ExceptionHandler 的异常处理。 * @param exception 异常信息 * @return 返回视图模型 */ @ExceptionHandler(Exception.class) ModelAndView exceptionHandler(Exception exception) { // 获取异常对象 CustomException customException; if (exception instanceof CustomException) { customException = (CustomException) exception; } else { customException = new CustomException(\"系统维护中。\"); } // 创建 ModelAndView 存储异常信息并设置返回页面。 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"errorMsg\", customException.getMessage()); modelAndView.setViewName(\"error\"); return modelAndView; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（六）：文件上传","date":"2019-09-20T06:31:37.000Z","path":"posts/2009/","text":"前提 form 表单的 enctype 取值必须是 multipart/form-data。（enctype 默认值为 application/x-www-form-urlencoded） enctype：表单请求正文的类型。 method 取值必须是 Post。 提供文件选择域&lt;input type=\"file\" name=\"\"&gt;，该标签 name 属性必须有，否者会导致 fileItem 获取不到值。 原理 当 form 表单的 enctype 取值不是默认值后，request.getParameter()将失效。 当enctype=\"application/x-www-form-urlencoded\"时，form 表单的正文内容是：key=value&amp;key=value。 当enctype=\"multipart/form-data\"时， form 表单的正文内容就变成每一部分都是 MIME 类型描述的正文。 后端解析请求体获取 MIME 类型描述的正文（即上传的文件），并将上传文件写回磁盘存储。 传统方式 案例说明： 通过 commons-fileupload.jar 原生 API 解析请求体。 代码演示： &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>文件上传&lt;/h3> &lt;form action=\"/user/testOldFileUpload\" method=\"post\" enctype=\"multipart/form-data\"> 选择文件：&lt;input type=\"file\" name=\"upload\">&lt;br> &lt;label> &lt;input type=\"submit\" value=\"上传\"> &lt;/label> &lt;/form> &lt;/body> &lt;/html> /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 文件上传 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 利用 fileupload 解析请求体。 * @param request 请求 * @return 返回到 success 页面。 * @throws Exception 异常 */ @RequestMapping(\"/testOldFileUpload\") String testOldFileUpload(HttpServletRequest request) throws Exception { // 1.上传位置创建文件夹。 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); File file = new File(path); if (!file.exists()) { file.mkdirs(); } // 2.创建 DiskFileItemFactory 存储大于 10kb 的临时文件。 DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory(); // 3.创建 ServletFileUpload 负责处理上传的文件数据。 ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory); List&lt;FileItem> fileItems = servletFileUpload.parseRequest(request); for (FileItem fileItem : fileItems) { // 判断当前 fileItem 对象是否是上传文件项,true 不是，false 是。 if (!fileItem.isFormField()) { // 设置文件名称为唯一值 uuid。 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 获取上传文件的名称，并与 uuid 组合。 String fileName = uuid + \"_\" + fileItem.getName(); // 上传文件 fileItem.write(new File(path, fileName)); // 删除临时 fileItem 文件。 fileItem.delete(); } } return \"success\"; } } SpringMVC 方式 案例说明： 在 SpringMVC 的配置文件中配置文件解析器，要求 id 名称必须为 multipartResolver。 SpringMVC 框架提供了 MultipartFile 对象表示上传的对象，该对象要求变量名称和表单 file 标签的 name 属性名称相同。 代码演示： &lt;form action=\"/user/testSpringMvcFileUpload\" method=\"post\" enctype=\"multipart/form-data\"> 选择文件：&lt;input type=\"file\" name=\"upload\">&lt;br> &lt;label> &lt;input type=\"submit\" value=\"上传\"> &lt;/label> &lt;/form> &lt;!-- 文件解析器，要求 id 名称必须为 multipartResolver --> &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"> &lt;property name=\"maxUploadSize\" value=\"10485760\"/> &lt;/bean> /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 文件上传 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 使用 MultipartFile 对象上传文件。 * @param upload 参数名称必须与文件上传 input 标签的 name 相同。 * @return 返回到 success 页面。 * @throws IOException io 异常 */ @RequestMapping(\"/testSpringMvcFileUpload\") String testSpringMvcFileUpload(MultipartFile upload) throws IOException { // 1.上传位置创建文件夹。 String path = \"D:\\\\JetBrains\\\\IdeaProjects\\\\springmvc\\\\target\\\\springmvc\\\\uploads\\\\\"; File file = new File(path); if (!file.exists()) { file.mkdirs(); } // 设置文件名称为唯一值 uuid。 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 获取上传文件的名称，并与 uuid 组合。 String fileName = uuid + \"_\" + upload.getOriginalFilename(); // 上传文件 upload.transferTo(new File(path, fileName)); return \"success\"; } } 跨服务器上传文件 案例说明： 新建一个 maven 的 webapp 项目，在 webapp 目录下新建 uploads 目录，启动该项目的 Tomcat（注意端口不要重复）。 在客户端项目下导入 com.sun.jersey 下的 jersey-core.jar 和 jersey-client.jar 包，编写服务程序并启动 Tomcat。 如果报错的话，需要注意第一个项目的 Tomcat 中的 webapp 中以及 target 或 out 目录下适当位置是否有创建 uploads 目录。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 文件上传 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 跨服务器上传文件。 * @param upload 参数名称必须与文件上传 input 标签的 name 相同。 * @return 返回到 success 页面。 * @throws IOException io 异常 */ @RequestMapping(\"/testCrossServerFileUpload\") String testCrossServerFileUpload(MultipartFile upload) throws IOException { // 1.定义上传文件服务器路径。 String path = \"http://127.0.0.1:8081/uploads/\"; // 设置文件名称为唯一值 uuid。 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 获取上传文件的名称，并与 uuid 组合。 String fileName = uuid + \"_\" + upload.getOriginalFilename(); // 创建客户端对象 Client client = Client.create(); // 和图片服务器进行连接（文件名可能中文转码） WebResource webResource = client.resource(path + URLEncoder.encode(fileName, \"UTF-8\")); // 上传文件 webResource.put(upload.getBytes()); return \"success\"; } } &lt;form action=\"/user/testCrossServerFileUpload\" method=\"post\" enctype=\"multipart/form-data\"> 选择文件：&lt;input type=\"file\" name=\"upload\">&lt;br> &lt;label> &lt;input type=\"submit\" value=\"上传\"> &lt;/label> &lt;/form> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（五）：响应数据和结果视图","date":"2019-09-19T05:32:01.000Z","path":"posts/46928/","text":"响应数据返回值类型 String 案例说明： 创建一个拥有姓名、密码和年龄的 User 类。 通过在 JSP 页面发起请求，控制器类中返回一个封装好了数据的 User 类。 在跳转成功的界面获取 User 类中封装的数据。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:43 * @Description 用户类 */ public class User implements Serializable { // 此处省略了 get 和 set private String username; private String password; private Integer age; } /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 测试返回字符串 * @param model 模型 * @return 返回 */ @RequestMapping(\"/testString\") String testString(Model model) { // 模拟从数据库中查询出 User 对象 User user = new User(); user.setUsername(\"12\"); user.setPassword(\"123\"); user.setAge(11); model.addAttribute(\"user\", user); return \"success\"; } } &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>响应数据和结果视图&lt;/h3> &lt;a href=\"/user/testString\">testString&lt;/a>&lt;br> &lt;/body> &lt;/html> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %> &lt;html> &lt;head> &lt;title>success 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>跳转成功&lt;/h3> 账户：${user.username}&lt;br> 密码：${user.password}&lt;br> 年龄：${user.age}&lt;br> &lt;/body> &lt;/html> 返回值类型 void 案例说明： 创建一个拥有姓名、密码和年龄的 User 类。 通过在 JSP 页面发起请求，控制器类中分别进行转发、重定向和直接响应的方法响应视图页面。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 测试无返回值类型。1、转发 2、重定向 3、直接响应 * @param request Servlet 原生API request * @param response Servlet 原生API response */ @RequestMapping(\"/testVoid\") void testVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1、转发（不会使用视图解析器） request.getRequestDispatcher(\"/WEB-INF/pages/success2.jsp\").forward(request, response); /*2、重定向（无法跳转至 WEB-INF 下，且不会使用视图解析器） response.sendRedirect(\"/success2.jsp\");*/ /*3、直接响应 // 设置中文编码，防止中文乱码。 response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=UTF-8\"); response.getWriter().print(\"你好\");*/ } } &lt;title>index 界面&lt;/title> &lt;a href=\"/user/testVoid\">testVoid&lt;/a>&lt;br> &lt;title>success 界面&lt;/title> &lt;h3>跳转成功&lt;/h3> &lt;title>success2 界面&lt;/title> &lt;h3>跳转成功&lt;/h3> 返回值类型 ModelAndView 案例说明： 创建一个拥有姓名、密码和年龄的 User 类。 通过在 JSP 页面发起请求，控制器类中返回一个封装好了数据的 User 类。 在跳转成功的界面获取 User 类中封装的数据。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 测试 ModelAndView * @param modelAndView 模型与视图 * @return 返回 modelAndView 对象 */ @RequestMapping(\"/testModelAndView\") ModelAndView testModelAndView(ModelAndView modelAndView) { User user = new User(); user.setUsername(\"12\"); user.setPassword(\"123\"); user.setAge(11); modelAndView.addObject(\"user\", user); modelAndView.setViewName(\"success\"); return modelAndView; } } &lt;title>index 界面&lt;/title> &lt;a href=\"/user/testModelAndView\">testModelAndView&lt;/a>&lt;br> &lt;title>success 界面&lt;/title> &lt;h3>跳转成功&lt;/h3> 账号：${user.username}&lt;br> 密码：${user.password}&lt;br> 年龄：${user.age}&lt;br> &lt;/body> &lt;/html> 使用 forward 和 redirect 关键字 案例说明： 通过在 JSP 页面发起请求，控制器类中分别使用 SpringMVC 的关键字进行转发和重定向的方法响应视图页面。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 使用关键字的方式进行转发或重定向（不会使用视图解析器）。 * @return 转发或重定向的目标位置 */ @RequestMapping(\"/testForwardOrRedirect\") String testForwardOrRedirect() { /*1、转发（不会使用视图解析器） return \"forward:/WEB-INF/pages/success.jsp\";*/ // 2、重定向（无法跳转至 WEB-INF 下，且不会使用视图解析器） return \"redirect:success2.jsp\"; } } &lt;title>index 界面&lt;/title> &lt;a href=\"/user/testForwardOrRedirect\">testForwardOrRedirect&lt;/a>&lt;br> &lt;title>success 界面&lt;/title> &lt;h3>跳转成功&lt;/h3> &lt;title>success2 界面&lt;/title> &lt;h3>跳转成功&lt;/h3> JSON 数据处理过滤静态资源 案例说明： 由于 dispatcherServlet 会拦截所有的资源，导致在请求静态资源时也会被拦截。为此需要通过 SpringMVC 的配置文件配置对静态资源不进行拦截。 代码演示： &lt;!-- 设置不拦截的资源（静态资源），静态资源在 WEB-INF 的 static 文件夹下。 --> &lt;mvc:resources mapping=\"/static/**\" location=\"/static/\"/> &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;script src=\"js/jquery-3.4.1.min.js\">&lt;/script> &lt;script> $(function () { $(\"#testAjax\").click(function () { alert(\"hello\"); }); }); &lt;/script> &lt;/head> &lt;body> &lt;h3>JSON 数据处理&lt;/h3> &lt;button id=\"testAjax\">发送 AJAX&lt;/button> &lt;/body> &lt;/html> 发送 AJAX 请求 案例说明： 通过 AJAX 携带 JSON 格式的数据发送 POST 请求给后端。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 模拟异步请求响应。 * @param user 获得封装好的 User 类数据。 */ @RequestMapping(\"/testAjax\") void testAjax(@RequestBody String user) { System.out.println(user); } } &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;script src=\"static/js/jquery-3.4.1.min.js\">&lt;/script> &lt;script> $(function () { $(\"#testAjax\").click(function () { $.ajax({ url: \"/user/testAjax\", contentType: \"application/json;charset=UTF-8\", data: '{\"username\": \"你\",\"password\": 123,\"age\": 11}', dataType: \"json\", type: \"POST\", success: function (data) { //此处 data 是服务器端响应的 json 格式的数据。 } }); }); }); &lt;/script> &lt;/head> &lt;body> &lt;h3>JSON 数据处理&lt;/h3> &lt;button id=\"testAjax\">发送 AJAX&lt;/button> &lt;/body> &lt;/html> 响应 JSON 格式数据 案例说明： 使用 @RequestBody 将接收到的前端 JSON 格式的数据转换成 User 对象进行操作。SpringMVC 默认使用 MappingJacksonHttpMessageConverter 对 JSON 格式的数据进行转换，其中需要加入三个 jackson 的包。 jackson-annotation.jar jackson-databind.jar jackson-core.jar 使用 @ResponseBody 将 User 对象转换成 JSON 格式的数据响应给前端。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 模拟异步请求响应。 * @param user 获得封装好的 User 类数据。 */ @RequestMapping(\"/testAjax\") @ResponseBody User testAjax(@RequestBody User user) { // 客户端发送 AJAX 请求传送的是 JSON 格式的数据，后端把 JSON 格式的数据封装到对应的对象中（此处为 User）。 System.out.println(user); // 将获得的对象修改其中姓名属性并返回。 user.setUsername(\"我\"); return user; } } &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;script src=\"static/js/jquery-3.4.1.min.js\">&lt;/script> &lt;script> $(function () { $(\"#testAjax\").click(function () { $.ajax({ url: \"/user/testAjax\", contentType: \"application/json;charset=UTF-8\", data: '{\"username\": \"你\",\"password\": 123,\"age\": 11}', dataType: \"json\", type: \"POST\", success: function (data) { //此处 data 是服务器端响应的 json 格式的数据。 console.log(\"username:\" + data.username); console.log(\"password\" + data.password); console.log(\"age\" + data.age); } }); }); }); &lt;/script> &lt;/head> &lt;body> &lt;h3>JSON 数据处理&lt;/h3> &lt;button id=\"testAjax\">发送 AJAX&lt;/button> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（四）：常用注解","date":"2019-09-19T05:19:32.000Z","path":"posts/54418/","text":"RequestParam 作用：把请求中指定名称的参数赋值给控制器中的形参。 属性： value：请求参数中的名称。 required：请求参数中是否必须提供此参数。（默认 true） 关键代码演示： &lt;a href=\"/annotation/testRequestParam?username=1&amp;pw=2\">@requestParam&lt;/a> /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试 */ @Controller @RequestMapping(\"/annotation\") public class AnnotationController { /** * 测试 @RequestParam * @param username 账户名 * @param password 密码 * @return 返回到 success 页面 */ @RequestMapping(\"/testRequestParam\") String testRequestParam(@RequestParam String username, @RequestParam(\"pw\") String password) { // 此处前端必须提供 username 和 pw 的值，此处将前端 username 的值传给 username，而 pw 的值传给 password。 System.out.println(\"username=\" + username + \";password=\" + password); return \"success\"; } } RequestBody 作用：用于获取请求体内容，得到 key = value 格式的数据，不适用于 get 请求。 属性： required：请求参数中是否必须提供此参数（默认 true）。为 true 时，get 请求方式报错；为 false 时，get 请求得到 null 值。 关键代码演示： &lt;form action=\"/annotation/testRequestBody\" method=\"POST\"> &lt;label> 账号：&lt;input type=\"text\" name=\"username\"/> &lt;/label>&lt;br> &lt;label> 密码：&lt;input type=\"password\" name=\"password\"/> &lt;/label>&lt;br> &lt;input type=\"submit\" value=\"提交\"/>&lt;br> &lt;/form> /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试 */ @Controller @RequestMapping(\"/annotation\") public class AnnotationController { /** * 测试 @RequestBody * @param requestBody 请求参数体 * @return 返回到 success 页面 */ @RequestMapping(\"/testRequestBody\") String testRequestBody(@RequestBody String requestBody) { System.out.println(requestBody); return \"success\"; } } PathVariable 作用：用于绑定 URL 中的占位符，常用于 REST 风格URL。例如：/delete/{id}，其中{id}就是 URL 占位符。 属性： value：用于指定 URL 中占位符名称。 required：是否必须提供占位符。 关键代码演示： &lt;a href=\"/annotation/testPathVariable/账号\">@PathVariable&lt;/a> /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试 */ @Controller @RequestMapping(\"/annotation\") public class AnnotationController { /** * 测试 @PathVariable * @param username REST 风格 URL 参数 * @return 返回到 success 页面 */ @RequestMapping(\"/testPathVariable/{username}\") String testPathVariable(@PathVariable String username) { System.out.println(username); return \"success\"; } } 衍生问题：form 只支持 GET 与 POST 请求，因此可以使用 HiddenHttpMethodFilter 过滤器更改指定的请求。如果 controller 方法上不添加 @ResponseBody 会报 jsp 不支持该方法，这是因为在tomcat8以上版本是不支持 delete 和 post 请求，此时可以通过 @ResponseBody 注解解决问题，但后端无法直接跳转页面。 解决方法： &lt;!-- 支持更多的表单提交方式，出现 web-app 报错需要升级 xml 的头部信息 --> &lt;filter> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;form action=\"/annotation/testPathVariable/账号\" method=\"POST\"> &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\"/> &lt;label> 账号：&lt;input type=\"text\" name=\"username\"/> &lt;/label>&lt;br> &lt;input type=\"submit\" value=\"提交\"/>&lt;br> &lt;/form> /** * 测试 @PathVariable。 * * @param username REST 风格 URL 参数 * @return 返回到 success 页面 */ @RequestMapping(value = \"/testPathVariable/{username}\", method = RequestMethod.DELETE) @ResponseBody String testPathVariable(@PathVariable String username) { System.out.println(\"删除：\" + username); return \"success\"; } RequestHeader 作用：用于获取请求消息头。 属性： 提供消息头名称。 是否必须有此消息头。 关键代码演示： &lt;a href=\"/annotation/testRequestHeader\">@RequestHeader&lt;/a> /** * 测试 @RequestHeader * @param header 获取某个具体头属性的值。 * @return 返回到 success 页面。 */ @RequestMapping(\"testRequestHeader\") String testRequestHeader(@RequestHeader(\"Accept\") String header) { System.out.println(header); return \"success\"; } CookieValue 作用：用于把指定 cookie 名称的值传入控制器方法参数。 属性： value：指定 cookie 的名称。 required：是否必须有此 cookie。 关键代码演示： &lt;a href=\"/annotation/testCookieValue\">@CookieValue&lt;/a> /** * 测试 @CookieValue * @param cookieValue 获取某个具体 cookie 的值。 * @return 返回到 success 页面。 */ @RequestMapping(\"testCookieValue\") String testCookieValue(@CookieValue(\"JSESSIONID\") String cookieValue) { System.out.println(cookieValue); return \"success\"; } ModelAttribute 作用：可以作用于参数和方法上。作用于参数上时，获取指定的数据给参数赋值；作用于方法上时，表示当前方法会在控制器的其它方法执行前执行。 属性： value：用于获取数据的 key。key 可以是 POJO的属性名称，也可以是 map 结构的 key。 应用场景：当表单提交的数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原有的数据。例如用户类拥有账号和密码两个字段，而对数据库用户进行更新时规定账号不能进行修改，只能对密码进行修改，因此一旦进行更新时账号字段就会变为 null，此时就可以使用此注解解决该问题。 案例说明：提交的 User 类是没有被填充 Date 属性的，在 controller 方法中将 Date 属性进行填充。 关键代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/16 22:03 * @Description 用户实体 */ public class User implements Serializable { // 省略了 get 和 set private String userName; private Integer age; private Date date; @Override public String toString() { return \"User{userName=\" + userName + \", age=\" + age + \", date=\" + date + \"}\"; } } &lt;form action=\"/annotation/testModelAttribute\" method=\"POST\"> &lt;label> 姓名：&lt;input type=\"text\" name=\"userName\"/> &lt;/label>&lt;br> &lt;label> 年龄：&lt;input type=\"text\" name=\"age\"/> &lt;/label>&lt;br> &lt;input type=\"submit\" value=\"提交\"/>&lt;br> &lt;/form> ModelAttribute 修饰方法带返回值constUserName() 会先获得一个拥有 Date 属性的 User 类，然后将 testModelAttribute() 获得的 User 类其他属性填充入之前的 User 类。 /** * 测试 @ModelAttribute * @param user 获取用户设置好名字和年龄的 User 类属性，并将该 User 类的属性填充入之前 constUserName 的 User 类中，最终获得的是在 constUserName * 返回的类上填充了名字和年龄的 User 类。 * @return 返回到 success 页面。 */ @RequestMapping(\"testModelAttribute\") String testModelAttribute(User user) { System.out.println(user); return \"success\"; } /** * 提前获取到 User 类，并为 User 类填充 Date 属性。 * @param user 不带 Date 的 User 封装类。 * @return 将设置了 Date 的 User 封装类返回。 */ @ModelAttribute User constUserName(User user) { user.setDate(new Date()); return user; } ModelAttribute 修饰方法不带返回值 /** * 测试 @ModelAttribute * @param user 从 map 获取 User 类，并将从请求中获得的 User 类属性封装入该 User 类中。 * @return 返回到 success 页面。 */ @RequestMapping(\"testModelAttribute\") String testModelAttribute(@ModelAttribute(\"user\") User user) { System.out.println(user); return \"success\"; } /** * 提前获取到 User 类，并为 User 类填充 Date 属性，将封装好的 User 装入 map 中。 * @param user 不带 Date 的 User 封装类。 * @param map 用于存储封装好的 User 类。 */ @ModelAttribute void constUserName(User user, Map&lt;String, User> map) { user.setDate(new Date()); map.put(\"user\", user); } SessionAttributes 作用：用于多次执行控制器方法间的参数共享，作用于类上。（SessionAttribute 作用于参数前，为形参赋值。） 属性： value：用于指定存入的属性名称。 type：用于指定存入的数据类型。 关键代码演示： &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>SpringMVC 常用注解&lt;/h3> &lt;a href=\"/annotation/testSessionAttributes\">@SessionAttribute&lt;/a>&lt;br> &lt;a href=\"/annotation/testGetSessionAttributes\">Get @SessionAttribute&lt;/a> &lt;a href=\"/annotation/testDeleteSessionAttributes\">Delete @SessionAttribute&lt;/a> &lt;/body> &lt;/html> /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试。 @SessionAttributes(\"test\") 表示将request 域中的 key 为 test 的值存一份在 session 域中。 */ @Controller @RequestMapping(\"/annotation\") @SessionAttributes(\"test\") public class AnnotationController { /** * 测试 @SessionAttribute * @param model 可以将值存入 request 域，map 格式。 * @return 返回到 success 页面。 */ @RequestMapping(\"testSessionAttributes\") String testSessionAttributes(Model model) { // 此处将值存入 request 域。 model.addAttribute(\"test\", \"测试用数据。\"); return \"success\"; } /** * 测试获取 session 域中的值。 * @param modelMap 可以从 session 域获取值，map 格式。 * @return 返回到 success 页面。 */ @RequestMapping(\"testGetSessionAttributes\") String testGetSessionAttributes(ModelMap modelMap) { String test = (String) modelMap.get(\"test\"); System.out.println(test); return \"success\"; } /** * 清空 session 域。 * @param sessionStatus 获得 session 域的状态。 * @return 返回到 success 页面。 */ @RequestMapping(\"testDeleteSessionAttributes\") String testDeleteSessionAttributes(SessionStatus sessionStatus) { sessionStatus.setComplete(); return \"success\"; } } &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %> &lt;html> &lt;head> &lt;title>success 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>跳转成功&lt;/h3> &lt;!-- 获得 request 域中的值 --> request:${requestScope.get(\"test\")}&lt;br> &lt;!-- 获得 session 域中的值 --> session:${sessionScope.get(\"test\")} &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（三）：请求参数绑定","date":"2019-09-16T13:02:47.000Z","path":"posts/25820/","text":"请求参数绑定机制 请求的数据都是 key = value 格式的。 SpringMVC 的参数绑定过程是把请求的参数绑定至控制器中方法的参数上。 提交数据的 key 和参数的名称必须相同。 支持的数据类型有三种： 基本数据类型和字符串类型。 实体类型。 集合数据类型。 GET 请求参数绑定 案例说明：通过 JSP 页面&lt;a&gt;标签向 controller 发起 GET 请求（携带 username 和 password 两参数）。 代码演示：基本数据类型和字符串类型。 /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * GET 请求基本类型参数绑定测试 * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/testGetParam\") String testGetParam(String username, String password) { System.out.println(\"执行成功。username = \" + username + \";password = \" + password); return \"success\"; } } &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>SpringMVC 请求参数绑定&lt;/h3> &lt;a href=\"/param/testGetParam?username=1&amp;password=2\">请求参数绑定测试&lt;/a> &lt;/body> &lt;/html> POST 请求参数绑定 案例说明： Account 实体类中包含 User 实体类。 JSP 页面通过表单向 controller 发起 POST 请求（携带 Account 实体）。 使用 POST 提交数据中如果有中文会导致 controller 获得的数据是乱码。此处可以通过在 web.xml 中配置 filter 解决乱码问题(filter 标签必须在 servlet 标签之前）。 代码演示1：实体类型。 &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" > &lt;web-app> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!-- 中文乱码解决过滤器，filter 需要放置在 servlet 前，否则&lt;/web-app>标签会报错。 --> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;!-- 该类存在 servlet-api.jar 中，用于直接配置 servlet 拦截请求（前端控制器） --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 配置 springmvc 启动 --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring-mvc.xml&lt;/param-value> &lt;/init-param> &lt;!-- 启动服务器就创建了 servlet 对象。（不配置时，只有请求过来时才会进行创建。） --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> /** * @Author 喵粮都输光了 * @Date 2019/9/16 22:03 * @Description 用户实体 */ public class User implements Serializable { // 省略了 get 和 set private String userName; private Integer age; @Override public String toString() { return \"User{userName=\" + userName + \", age=\" + age + \"}\"; } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:42 * @Description 账户实体类 */ public class Account implements Serializable { // 省略了 get 和 set private String username; private String password; private Double money; private User user; @Override public String toString() { return \"Account{username=\" + username + \", password=\" + password + \", money=\" + money + \", \" + user + \"}\"; } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * POST 请求实体参数绑定测试 * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/testPOSTParam\") String testPOSTParam(Account account) { System.out.println(account); return \"success\"; } } &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>SpringMVC 请求参数绑定&lt;/h3> &lt;form action=\"/param/testPOSTParam\" method=\"POST\"> &lt;label> 账号：&lt;input type=\"text\" name=\"username\"/> &lt;/label>&lt;br> &lt;label> 密码：&lt;input type=\"password\" name=\"password\"/> &lt;/label>&lt;br> &lt;label> 金额：&lt;input type=\"text\" name=\"money\"/> &lt;/label>&lt;br> &lt;label>&lt;!-- 此处 User 类的属性可以用 Account 类中对 User 类定义的名称然后加点的形式绑定。 --> 姓名：&lt;input type=\"text\" name=\"user.userName\"/> &lt;/label>&lt;br> &lt;label> 年龄：&lt;input type=\"number\" name=\"user.age\"/> &lt;/label>&lt;br> &lt;input type=\"submit\" value=\"提交\"/>&lt;br> &lt;/form> &lt;/body> &lt;/html> 代码演示2：集合类型。（与上区别仅在 Account、ParamController 类和 index.jsp 页面。且在开发中，前端使用这样的方法进行传值会遭成高耦合性，因此都是通过 json 的格式来传递参数。） /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:42 * @Description 账户实体类 */ public class Account implements Serializable { private String username; private String password; private Double money; private List&lt;User> list; private Map&lt;String, User> map; // 省略了 get 和 set @Override public String toString() { return \"Account{username=\" + username + \", password=\" + password + \", money=\" + money + \", list=\" + list + \", map=\" + map + \"}\"; } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * POST 请求集合类型参数绑定测试 * * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/testPostCollectionsParam\") String testPostCollectionsParam(Account account) { System.out.println(account); return \"success\"; } } &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>SpringMVC 请求参数绑定&lt;/h3> &lt;form action=\"/param/testPostCollectionsParam\" method=\"POST\"> &lt;label> 账号：&lt;input type=\"text\" name=\"username\"/> &lt;/label>&lt;br> &lt;label> 密码：&lt;input type=\"password\" name=\"password\"/> &lt;/label>&lt;br> &lt;label> 金额：&lt;input type=\"text\" name=\"money\"/> &lt;/label>&lt;br> &lt;label> 姓名（list）：&lt;input type=\"text\" name=\"list[0].userName\"/> &lt;/label>&lt;br> &lt;label> 年龄（list）：&lt;input type=\"number\" name=\"list[0].age\"/> &lt;/label>&lt;br> &lt;label> 姓名（map）：&lt;input type=\"text\" name=\"map['map1'].userName\"/> &lt;/label>&lt;br> &lt;label> 年龄（map）：&lt;input type=\"number\" name=\"map['map1'].age\"/> &lt;/label>&lt;br> &lt;input type=\"submit\" value=\"提交\"/>&lt;br> &lt;/form> &lt;/body> &lt;/html> 自定义类型转换器 案例说明： User 实体类包含姓名、年龄和生日日期。 JSP 页面通过表单向 controller 发起 POST 请求（携带 User 实体）。 使用 POST 提交数据如果日期的格式不是yyyy/MM/dd会发生格式转换错误，此时新建自定义类型转换器类实现 Converter 并在 spring-mvc.xml 中配置转换器解决该问题。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/18 12:00 * @Description 字符串转换日期的自定义类型转换器。（String 表示传入进来的值，Date 是需要将String 转换成的目标类型。） */ public class StringToDateConverter implements Converter&lt;String, Date> { @Override public Date convert(String source) { if (source != null) { // 自定义需要转换成的格式。 DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); // 进行转换。 try { return dateFormat.parse(source); } catch (ParseException e) { throw new RuntimeException(\"数据类型转换出现异常。\"); } } else { throw new RuntimeException(\"请您传入数据。\"); } } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * POST 请求自定义类型转换器测试 * * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/customTypeConverter\") String customTypeConverter(User user) { System.out.println(user); return \"success\"; } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.springmvc\"/> &lt;!-- 视图解析器对象 --> &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> &lt;!-- 配置自定义类型转换器（需要在 SpringMVC 框架注解支持上填入配置的 ConversionServiceFactoryBean 的 id。 --> &lt;bean id=\"conversionServiceFactoryBean\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"> &lt;property name=\"converters\"> &lt;set> &lt;bean class=\"com.kuukokawaii.utils.StringToDateConverter\"/> &lt;/set> &lt;/property> &lt;/bean> &lt;!-- 开启 SpringMVC 框架注解的支持 --> &lt;mvc:annotation-driven conversion-service=\"conversionServiceFactoryBean\"/> &lt;/beans> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>SpringMVC 请求参数绑定&lt;/h3> &lt;form action=\"/param/customTypeConverter\" method=\"POST\"> &lt;label> 姓名：&lt;input type=\"text\" name=\"userName\"/> &lt;/label>&lt;br> &lt;label> 年龄：&lt;input type=\"number\" name=\"age\"/> &lt;/label>&lt;br> &lt;label> 生日：&lt;input type=\"text\" name=\"date\"/> &lt;/label>&lt;br> &lt;input type=\"submit\" value=\"提交\"/>&lt;br> &lt;/form> &lt;/body> &lt;/html> Servlet 原生 API 案例说明：在 controller 中使用 servlet 的原生 API。 关键代码演示： &lt;a href=\"/param/testServlet\">Servlet 原生 API 测试&lt;/a> /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * 测试 servlet 原生 API * @param request servlet 请求 * @param response servlet 响应 * @return 返回到 success 页面 */ @RequestMapping(\"/testServlet\") String testServlet(HttpServletRequest request, HttpServletResponse response) { HttpSession session = request.getSession(); System.out.println(request); System.out.println(session); System.out.println(response); return \"success\"; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（二）：环境搭建","date":"2019-09-14T02:42:03.000Z","path":"posts/39549/","text":"案例说明 启动服务器时加载一些配置文件。 DispatcherServlet 对象创建。 SpringMVC 配置文件加载。 HelloController 对象创建。 发送请求，通过 HelloController 处理请求并跳转至 success.jsp 页面。 使用到的 Jar 包 spring-context.jar spring-web.jar（Spring Web 整合） spring-webmvc.jar（SpringMVC 核心） servlet-api.jar(用于提供 DispatcherServlet 类) jsp-api.jar（servlet-api 的依赖） 注解作用@RequestMapping(path\\value = \"\", method = {RequestMethod.POST}, params = {\"\"}, headers = {\"\"\"})：用于建立请求 URL 和处理请求方法之间的对应关系。 可作用于方法和类上。作用于类上便相当于请求 URL 的第一级访问目录，需要以/开头；而作用于方法就相当于请求 URL 的第二级访问目录。 path 和 value 作用是相同的，都是请求路径的映射（如果只有 value 单个属性则可省略）。 method：用于指定请求的方法（GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE）。 params：用于指定限制请求参数的条件。要求请求的参数的 key 和 value 必须和配置的一模一样。 headers：用于指定限制请求消息头的条件，即发送的请求中必须包含的请求头。 代码演示&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.springmvc\"/> &lt;!-- 视图解析器对象 --> &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> &lt;!-- 开启 SpringMVC 框架注解的支持 --> &lt;mvc:annotation-driven/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/13 13:36 * @Description a 标签跳转 controller 类 */ @Controller public class HelloController { /** * 输出测跳转 * @return 返回到 success.jpg 页面 */ @RequestMapping(path = \"/hello\") String sayHello() { System.out.println(\"Hello SpringMVC\"); return \"success\"; } } &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" > &lt;web-app> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!-- 该类存在 servlet-api.jar 中，用于直接配置 servlet 拦截请求（前端控制器） --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 配置 springmvc 启动 --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring-mvc.xml&lt;/param-value> &lt;/init-param> &lt;!-- 启动服务器就创建了 servlet 对象。（不配置时，只有请求过来时才会进行创建。） --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>index 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>SpringMVC 测试&lt;/h3> &lt;a href=\"/hello\">跳转小程序&lt;/a> &lt;/body> &lt;/html> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>success 界面&lt;/title> &lt;/head> &lt;body> &lt;h3>跳转成功&lt;/h3> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"Maven：No Archetype Found","date":"2019-09-12T13:53:17.000Z","path":"posts/6576/","text":"问题在创建 maven 项目时，选择 org.apache.maven.archetypes:maven-archetype-webapp 的 archetype 时，出现项目初始化失败的情况。报错情况如下： 解决方法在创建项目时，配置 archetypeCatalog 的属性为 internal 即可解决问题。 分析给 maven 配置了阿里源导致了如上问题，可能是阿里源的 archetype-catalog.xml 文件出现了问题。其中 archetype-catalog.xml 能提供 Archetype 的信息，常用的属性有 internal、local 和 remote 三个属性。 internal：maven-archetype-plugin 内置的 Archetype Catalog。 local：指向本地的 Archetype Catalog ，其位置为~/.m2/archetype-catalog.xml。需要注意的是，该文件默认是不存在的。 remote：指向了Maven中央仓库的Archetype Catalog。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"problem","slug":"problem","permalink":"https://blog.kuukokawaii.com/tags/problem/"},{"name":"maven","slug":"maven","permalink":"https://blog.kuukokawaii.com/tags/maven/"}]},{"title":"SpringMVC（一）：简介","date":"2019-09-09T06:44:00.000Z","path":"posts/18696/","text":"服务器三层架构JavaEE 常基于 B/S 架构进行开发，而在 B/S 架构中系统标准的三层架构包括：表现层、业务层和持久层。 表现层（web 层）表现层用于接收客户端请求，并向客户端响应结果。它包括展示层和控制层，其中展示层负责展示结果，而控制层负责接收请求。因此表现层依赖于业务层，当接收到客户端的请求时一般会调用业务层进行处理，并将处理结果返回给客户端。 业务层（service 层）业务层负责业务逻辑的处理，当需要对数据进行持久化操作时需要保证事务的一致性，因此业务层可能依赖于持久层，且事务应该在业务层进行控制。 持久层（dao 层）持久层负责数据持久化操作，包括数据层即数据库和数据访问层，其中数据库是对数据进行持久化的载体，而数据访问层是业务层和持久层交互的接口。业务层需要通过数据访问层将数据持久化到数据库中。 MVC 设计模型MVC（Model View Controller）是一种用于设计创建 Web 应用程序表现层的模式，它包括 Model、View 和 Controller 三部分： Model（模型）：常指数据模型，一般用于封装数据。例如 JavaBean。 View（视图）：常指前端视图，一般用于显示数据。例如 Html。 Controller（控制器）：是应用程序中处理用户交互的部分，一般用于处理程序逻辑。例如 Servlet。 SpringMVC 架构 SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架。它通过一套注解让一个简单的 Java 类成为处理请求的控制器，而无需实现任何接口。同时它还支持 RESTful 编程风格的请求。 SpringMVC 拥有诸多优势，例如： 是基于模块化开发的架构，拥有清晰的角色划分。 可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 可定制，通过 HandlerMapping、ViewResolver 等能够非常简单的进行定制。 功能强大的数据验证、格式化、绑定机制。 利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 SpringMVC 工作流程 概念DispatcherServlet：Spring 前端控制器（中央调度器），它是整个请求响应的控制中心，组件的调用由它统一调度。HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler。HandlerAdapter：处理器适配器，它调用 Handler 执行具体的业务操作并返回逻辑视图 ModelAndView 对象。Handler：Handler，对用户具体请求进行处理（相当于 controller 类）。ModelAndView 对象：逻辑视图。ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图。 工作流程如图工作流程可以大致划分为如下步骤： 用户向服务器发送请求，请求被 DispatcherServlet 捕获。 DispatcherServlet 对请求的 URL 进行解析，得到 URI。然后根据 URI 调用 HandlerMapping 获得具体的处理器 Handler 并返回给 DispatcherServlet。 DispatcherServlet 根据获取的 Handler，选择一个合适的 HandlerAdapter。 提取 Request 中的模型数据作为 Handler 的参数并执行。（此处可做 HttpMessageConverter，数据转换、数据格式化和数据验证等操作。） Handler 执行完成后，HandlerAdapter向 DispatcherServlet 返回一个 ModelAndView 对象，其中 view 是视图名称，并不是真正的视图对象。 根据返回的 ModelAndView 对象选择一个合适的 ViewResolver 返回给 DispatcherServlet（必须是已经注册到Spring容器中的 ViewResolver）。 DispatcherServlet 将 ModelAndView 对象传给 ViewResolver。 ViewResolver 解析后返回具体的 View（例如 html、JSP 等）。 DispatcherServlet 对 View 进行渲染视图，即将数据模型填充到视图中。 DispatcherServlet 对用户进行响应。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"Spring（七）：Transaction","date":"2019-09-05T07:36:22.000Z","path":"posts/37736/","text":"什么是事务（Transaction）事务是逻辑上的一组操作，要么都执行，要么都不执行。例如某人要在商店使用电子货币购买100元的东西，当中至少包括两个操作：1.该人账户减少100元；2.商店账户增加100元。这两操作需要同时进行，否则就会出现100元平白消失或出现的情况。因此可以得知事务具有 ACID 的性质。 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）：执行事务前后，数据保持一致； 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 事务隔离 事务隔离级别即定义一个事务可能受其他并发时间事务影响的程度。例如多个用户对统一数据操作会导致如下问题的发生： 脏读（Dirty read）：当一个事务读取到另一个事务正在进行修改却还没有提交到数据库中的数据便称为脏读，而读取到的数据被称为脏数据，依据脏数据所作的操作可能是不对的。 丢失修改（Lost to modify）：两个事务同时读取修改同一数据，后提交事务的修改结果破坏了先提交事务的修改结果，导致先提交事务的修改被丢失。 不可重复读（Unrepeatable read）：指在一个事务内多次读同一数据。当事务 A 读取了数据还未进行提交操作时，而事务 B 也读取了该数据并对其数据进行了修改、提交。此时事务 A 再次读取数据时会发现第一次读取的数据可能与第二次读取的数据是不一样的。即同一个事务内两次读取同一数据其结果却不一样，这样的情况称为不可重复度。常发生于 update 操作之上。 幻读（Phantom read）：幻读与不可重复读相似，其区别在于幻读发生于 insert 操作之上。即事务 A 读取了数据还未进行提交操作时，事务 B 也读取了该数据并对其数据进行了插入、提交操作。导致事务 A 再次读取该数据时发现多出了一些不存在的记录，因此称为幻读。 事务隔离级别的出现就是为了解决如上四个问题的发生，常用事务隔离级别作用如下： 读未提交（Read uncommitted）：一个事务可以读取另一个未提交事务的数据。没有解决上述任何问题。 读已提交（Read committed）：一个事务要等另一个事务提交后才能读取数据。解决了脏读的问题。 可重复读（Repeatable read）：在事务开始读取数据时不再允许修改操作。解决了丢失修改、不可重复读和脏读的问题。 序列化（Serializable）：序列化是最高的事务隔离级别，在该级别下事务串行化顺序执行。解决了上述所有问题。 Spring 事务管理接口 PlatformTransactionManager（平台事务管理器）：Spring 必须使用事务管理器才能管理事务。 常用的事务管理器DataSourceTransactionManager：Jdbc 或 Mybatis 开发使用，采用 JdbcTemplate 或 整合 Mybatis。HibernateTransactionManager：Hibernate 开发使用，整合 Hibernate。 TransactionDefinition（事务属性）：Spring 用于确定事务具体详情。例如事务隔离级别、传播行为、超时、只读、回滚规则等。当进行事务配置时必须配置详情，Spring 会将配置项封装到该对象实例。 传播行为事务的传播行为规定了事务方法和事务方法发生嵌套调用时事务是如何进行传播，Spring 为其定义了七种类型的事务传播行为：1. PROPAGATION_REQUIRES（传播行为默认值）：如果当前有事务则加入该事务（即支持当前事务）;如果当前没事务则新建一个事务。 2. PROPAGATION_SUPPORTS：支持当前事务，如果当前没事务则以非事务方式执行。 3. PROPAGATION_MANDATORY：支持当前事务，如果当前没事务则抛出异常。 4. PROPAGATION_REQUIRES_NEW：无论有无事务都新建一个事务且如果当前有事务则挂起该事务（即不支持当前事务）。 5. PROPAGATION_NOT_SUPPORTED：无论有无事务都以非事务方式执行且不支持当前事务。 6. PROPAGATION_NEVER：如果当前有事务则抛出异常；如果当前没事务则以非事务方式执行。 7. PROPAGATION_NESTED：如果当前有事务则在该事务内嵌套一个事务执行；如果当前没事务则新建一个事务。 TransactionStatus（事务运行状态）：Spring 用于记录当前事务运行状态。例如事务是否有保存点、是否回滚、是否完成等。Spring 底层会根据状态进行相应的操作。 案例说明 通过事务模板 TransactionTemplate 进行操作（手动管理事务）。 Spring 配置 TransactionTemplate，并注入给 Service。 配置事务管理器（注入 TransactionTemplate，即注入 DataSource）。 工厂 bean 生成代理（半自动）。Spring 提供管理事务的代理工厂 bean：TransactionProxyFactoryBean。 获取代理对象。 Spring 配置代理。 AOP 配置基于 xml在 Spring XML 中配置 AOP 自动生成代理，并进行事务的管理。 配置事务管理器。 配置事务属性。 配置 AOP。 AOP 配置基于注解 配置事务管理器并交予 Spring。 在目标类或目标方法添加注解（@Transactional）。 使用到的部分 Jar 包 spring-tx.jar spring-jdbc.jar spring-orm.jar：Spring 提供对部分 ORM（对象关系映射将关系数据库中表的数据映射成为对象）框架的支持。 代码演示/** * @Author 喵粮都输光了 * @Date 2019/9/7 15:26 * @Description 账户持久层接口 */ public interface AccountDao { /** * 支出 * @param outer 支出者 * @param money 支出金额 */ void expense(String outer, Integer money); /** * 收入 * @param inner 收入者 * @param money 收入金额 */ void income(String inner, Integer money); } /** * @Author 喵粮都输光了 * @Date 2019/9/7 15:22 * @Description 账户持久层实现类 */ public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao { @Override public void expense(String outer, Integer money) { Objects.requireNonNull(this.getJdbcTemplate()).update(\"UPDATE account SET money = money - ? WHERE username = ?\", money, outer); } @Override public void income(String inner, Integer money) { Objects.requireNonNull(this.getJdbcTemplate()).update(\"UPDATE account SET money = money + ? WHERE username = ?\", money, inner); } } jdbc.driverClass=com.mysql.cj.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql://localhost:3306/所使用的库名 jdbc.user=账号 jdbc.password=密码 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- dao --> &lt;bean id=\"accountDao\" class=\"com.kuukokawaii.transaction.account.dao.AccountDaoImpl\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- service --> &lt;bean id=\"accountService\" class=\"com.kuukokawaii.transaction.account.service.AccountServiceImpl\"> &lt;property name=\"accountDao\" ref=\"accountDao\"/> &lt;property name=\"transactionTemplate\" ref=\"transactionTemplate\"/> &lt;/bean> &lt;!-- 创建 TransactionTemplate --> &lt;bean id=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\"> &lt;property name=\"transactionManager\" ref=\"txManager\"/> &lt;/bean> &lt;!-- 配置事务管理器，管理器管理事务，事务存在于 service、dao 等中，它们都可以从 Connection 中获得，而连接从连接池获得，所以需要配置的是连接池。 --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/7 15:34 * @Description Account Service */ public interface AccountService { /** * 转账 * @param outer 支出者 * @param inner 收入者 * @param money 金额 */ void transfer(String outer, String inner, Integer money); } 手动管理事务/** * @Author 喵粮都输光了 * @Date 2019/9/7 15:36 * @Description AccountService实现类 */ public class AccountServiceImpl implements AccountService { private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) { this.transactionTemplate = transactionTemplate; } @Override public void transfer(String outer, String inner, Integer money) { transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus status) { accountDao.expense(outer, money); accountDao.income(inner, money); } }); } } /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ public class AccountServiceImplTest { /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); AccountService accountService = applicationContext.getBean(\"accountService\", AccountService.class); accountService.transfer(\"jack\", \"r\", 1000); } } 半自动&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- dao --> &lt;bean id=\"accountDao\" class=\"com.kuukokawaii.transaction.account.dao.AccountDaoImpl\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- service --> &lt;bean id=\"accountService\" class=\"com.kuukokawaii.transaction.account.service.AccountServiceImpl\"> &lt;property name=\"accountDao\" ref=\"accountDao\"/> &lt;/bean> &lt;!-- service proxy： proxyInterfaces：目标类接口 target：目标类 transactionManager：事务管理器 transactionAttributes：配置 transactionDefinition key：确定哪些方法使用当前事务配置。（一般方法名） value：用于配置事务属性。即 transactionDefinition 格式：PROPAGATION, ISOLATION, readOnly, -Exception, +Exception（其中-Exception为发生这些异常就回滚，+Exception为发生这些异常仍然提交。） --> &lt;bean id=\"proxyAccountService\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"> &lt;property name=\"proxyInterfaces\" value=\"com.kuukokawaii.transaction.account.service.AccountService\"/> &lt;property name=\"target\" ref=\"accountService\"/> &lt;property name=\"transactionManager\" ref=\"txManager\"/> &lt;property name=\"transactionAttributes\"> &lt;props> &lt;prop key=\"transfer\">PROPAGATION_REQUIRED, ISOLATION_DEFAULT&lt;/prop> &lt;/props> &lt;/property> &lt;/bean> &lt;!-- dataSourceTransactionManager --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ public class AccountServiceImplTest { /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); AccountService accountService = applicationContext.getBean(\"proxyAccountService\", AccountService.class); accountService.transfer(\"jack\", \"r\", 1000); } } AOP 配置基于 xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd\"> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- dao --> &lt;bean id=\"accountDao\" class=\"com.kuukokawaii.transaction.account.dao.AccountDaoImpl\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- service --> &lt;bean id=\"accountService\" class=\"com.kuukokawaii.transaction.account.service.AccountServiceImpl\"> &lt;property name=\"accountDao\" ref=\"accountDao\"/> &lt;/bean> &lt;!-- dataSourceTransactionManager --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 事务通知（事务属性）：&lt;tx:method name=\"transfer\" propagation=\"REQUIRES_NEW\" isolation=\"DEFAULT\"/> --> &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"> &lt;tx:attributes> &lt;tx:method name=\"transfer\"/> &lt;/tx:attributes> &lt;/tx:advice> &lt;!-- AOP --> &lt;aop:config> &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.kuukokawaii.transaction.account.service.*.*(..))\"/> &lt;/aop:config> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ public class AccountServiceImplTest { /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); AccountService accountService = applicationContext.getBean(\"accountService\", AccountService.class); accountService.transfer(\"jack\", \"r\", 1000); } } AOP 配置基于注解此处Service层添加了@Service注解。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.transaction.account\"/> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- jdbcTemplate --> &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- dataSourceTransactionManager --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 事务注解开启： transaction-manager：将事务管理器交予 Spring。 proxy-target-class： true：底层强制使用 CGLIB 代理。 false：自动选择。 --> &lt;tx:annotation-driven transaction-manager=\"txManager\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/7 15:22 * @Description 账户持久层实现类 */ @Repository public class AccountDaoImpl implements AccountDao { private final JdbcTemplate jdbcTemplate; @Autowired public AccountDaoImpl(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @Override public void expense(String outer, Integer money) { jdbcTemplate.update(\"UPDATE account SET money = money - ? WHERE username = ?\", money, outer); } @Override public void income(String inner, Integer money) { jdbcTemplate.update(\"UPDATE account SET money = money + ? WHERE username = ?\", money, inner); } } /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class AccountServiceImplTest { @Autowired private AccountService accountService; /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { accountService.transfer(\"jack\", \"r\", 1000); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（六）：JDBCTemplate","date":"2019-09-04T08:49:50.000Z","path":"posts/63918/","text":"什么是 JDBCTemplateSpring 为传统的 JDBC 进行封装,简化持久层操作。通过使用 Spring 的注入功能，可以把 DataSource 注册到 JDBCTemplate 之中。 案例说明 通过 API 对 dbcp 进行操作。 通过 Spring 配置使用 DBCP。 使用 C3P0 连接池。 通过 JdbcDaoSupport 直接获取 JdbcTemplate，并用 properties 文件存储连接池属性。 使用到的部分 Jar 包 spring-tx.jar：负责在 Spring 框架中实现事务管理功能。 c3p0.jar：开源的 JDBC 连接池。 commons-dbcp.jar： 用于管理数据库连接池。依赖于 commons-pool。 commons-pool.jar： 数据库连接池。 mysql-connector-java.jar：Java 通过 JDBC 访问 mysql 数据库时使用。 commons-collections.jar：提供更多的接口。 spring-jdbc.jar：Spring 对 JDBC 数据访问进行封装的包。 代码演示直接使用 DBCP 方式/** * @Author 喵粮都输光了 * @Date 2019/9/4 18:33 * @Description 用户类 */ public class User { /** * 用户 id */ private Integer id; /** * 用户姓名 */ private String username; /** * 用户密码 */ private String password; } /** * @Author 喵粮都输光了 * @Date 09/04/2019 * @Description jdbc test */ public class UserTest { @Test public void test() throws Exception { // 创建数据源（连接池）：此处使用 dbcp BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/所使用的库名\"); dataSource.setUsername(\"账号\"); dataSource.setPassword(\"密码\"); // 创建模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); // 通过 api 操作 jdbcTemplate.update(\"INSERT INTO t_user(username, password) VALUES(?, ?);\", \"tom\", \"998\"); } } 通过 Spring 配置使用 DBCP/** * @Author 喵粮都输光了 * @Date 2019/9/4 19:15 * @Description 用户持久层类 */ public class UserDao { /** * jdbc 模板由 spring 注入。 */ private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public void update(User user) { String sql = \"UPDATE t_user SET username = ?, password = ? WHERE id = ?\"; Object[] args = {user.getUsername(), user.getPassword(), user.getId()}; jdbcTemplate.update(sql, args); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 创建数据源 --> &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"> &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/所使用的库名\"/> &lt;property name=\"username\" value=\"账号\"/> &lt;property name=\"password\" value=\"密码\"/> &lt;/bean> &lt;!-- 创建模板，需要注入数据源 --> &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 配置 dao --> &lt;bean id=\"userDao\" class=\"com.kuukokawaii.jdbctemplate.user.dao.UserDao\"> &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/04/2019 * @Description jdbc test */ public class UserTest { @Test public void test() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); UserDao userDao = applicationContext.getBean(\"userDao\", UserDao.class); User user = new User(); user.setId(1); user.setUsername(\"isolation\"); user.setPassword(\"998\"); userDao.update(user); } } C3P0仅 xml 数据池配置方式不同。 &lt;!-- 创建数据源 --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/所使用的库名\"/> &lt;property name=\"user\" value=\"账号\"/> &lt;property name=\"password\" value=\"密码\"/> &lt;/bean> JdbcDaoSupport如上述所示，那么每一个 dao 中都需要进行setJdbcTemplate的操作，造成代码的重复。而通过使用 JdbcDaoSupport，可以通过 JdbcDaoSupport 直接获取 JdbcTemplate 并对其进行应用。此处通过 properties 配置 jdbc 属性。 /** * @Author 喵粮都输光了 * @Date 2019/9/4 19:15 * @Description 用户持久层类 */ public class UserDao extends JdbcDaoSupport { public void update(User user) { String sql = \"UPDATE t_user SET username = ?, password = ? WHERE id = ?\"; Object[] args = {user.getUsername(), user.getPassword(), user.getId()}; assert this.getJdbcTemplate() != null; this.getJdbcTemplate().update(sql, args); } } jdbc.driverClass=com.mysql.cj.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql://localhost:3306/所使用的库名 jdbc.user=账号 jdbc.password=密码 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 加载配置文件 --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- 创建数据源 --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- 配置 dao，JdbcDaoSupport 通过给定的数据源自动创建模板。 --> &lt;bean id=\"userDao\" class=\"com.kuukokawaii.jdbctemplate.user.dao.UserDao\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;/beans> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（五）：AOP","date":"2019-09-02T05:52:48.000Z","path":"posts/43723/","text":"什么是 AOPAOP 是 OOP（Object Oriented Programming，缩写为OOP）的延续，利用 AOP 可以对业务逻辑的各个部件进行隔离，从而使得业务逻辑之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 假设有一需求如下：为 A 类中的所有方法开启事务且不修改 A 类的代码。为此需要再编写一个 B 类继承 A 类并且 B 类的所有方法都要调用 A 类的方法，且在调用方法的上下对事务进行开启和提交，这样做会发现一直在重复的编写开启提交事务的代码。而 AOP 采取横向抽取机制，取代了传统的纵向继承体系重复性代码，也就是说可以提取上述代码中的重复部分达到重复利用的效果。 手动代理JDK 动态代理JDK 动态代理即对装饰器设计模式的简化。 案例说明： 目标类：需要被代理的类，JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。 切面类：用于存放通知 MyAspect。 工厂类：用于生成代理。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:44 * @Description UserService 接口类。 */ public interface UserService { /** * 增加用户 */ void addUser(); /** * 更新用户 */ void updateUser(); /** * 删除用户 */ void deleteUser(); } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:46 * @Description UserService 实现类。 */ public class UserServiceImpl implements UserService { @Override public void addUser() { System.out.println(\"增加用户\"); } @Override public void updateUser() { System.out.println(\"更新用户\"); } @Override public void deleteUser() { System.out.println(\"删除用户\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ public class MyAspect { /** * 代理目标方法前运行。 */ public void before() { System.out.println(\"方法运行前\"); } /** * 代理目标方法后运行。 */ public void after() { System.out.println(\"方法运行后\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:49 * @Description 工厂类，用于生成代理类。 */ class MyBeanFactory { /** * 生成代理过的 UserService 对象。 * * @return 返回代理生成的 UserService 对象。 */ static UserService createProxy() { // 目标类 UserService userService = new UserServiceImpl(); // 切面类 MyAspect myAspect = new MyAspect(); /* * 代理类 = 目标类 + 切面类 * newProxyInstance参数： * 1.loader：类加载器，动态代理类运行时创建，任何类都需要类加载器将其加载到内存。一般情况使用→当前类.class.getClassLoader()。 * 2.Class[] interfaces：代理类需要实现的所有接口。 * 方式1：目标类实例.getClass().getInterfaces。该方法只能获得自己的接口，无法获得父元素的接口。 * 方式2：new Class[]{UserService.class}。该方法可以获得自己和父元素的接口。 * 3.InvocationHandler：处理类，是一个接口，必须进行实现，一般采用匿名内部类（推荐使用 lambda)。其中代理类的每一个方法执行时，都将调用一次 invoke。 * invoke参数:1.proxy： 代理对象。 * 2.method： 代理对象当前执行的方法的描述对象（反射）。 * 执行方法名：method.getName()； * 执行方法：method.invoke(对象，实际参数）； * 3.Object[] args： 方法实际参数。 */ return (UserService) Proxy.newProxyInstance(MyBeanFactory.class.getClassLoader(), userService.getClass().getInterfaces(), (proxy, method, args) -> { // 前执行 myAspect.before(); // 执行目标类的方法 Object obj = method.invoke(userService, args); // 后执行 myAspect.after(); return obj; }); } } /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { @Test public void test() throws Exception { UserService userService = MyBeanFactory.createProxy(); userService.addUser(); userService.updateUser(); userService.deleteUser(); } } 输出结果如下： CGLIB 字节码增强CGLIB 代理主要通过对字节码进行操作以控制对象的访问。CGLIB 在运行时创建目标类的子类，从而对目标类进行增强，因此无需接口便可以实现代理。 案例说明： 目标类：需要被代理的类，而 JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。 切面类：用于存放通知 MyAspect。 工厂类：用于生成代理。 使用到的 Jar 包： cglib.jar 或 spring-core.jar（Spring 核心包中整合了 cglib）。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:46 * @Description UserService 类。 */ class UserService { void addUser() { System.out.println(\"增加用户\"); } void updateUser() { System.out.println(\"更新用户\"); } void deleteUser() { System.out.println(\"删除用户\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:49 * @Description 工厂类，用于生成代理类。 */ class MyBeanFactory { /** * 生成代理后的 UserService 对象。 * * @return 返回代理生成的 UserService 对象。 */ static UserService createProxy() { // 目标类 UserService userService = new UserService(); // 切面类 MyAspect myAspect = new MyAspect(); /* * 代理类 = 目标类 + 切面类 * 1.创建核心类 Enhancer。 * 2.设置 Enhancer 需要代理的目标类。 * 3.设置 Enhancer 的回调函数。MethodInterceptor等效 InvocationHandler。 * o:代理对象。 * method:代理对象当前执行的方法的描述对象（反射）。 * objects:方法实际参数。 * methodProxy:方法的代理。 * 4.创建代理。 */ Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(userService.getClass()); enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -> { // 前执行 myAspect.before(); // 执行目标类的方法。该句等效于 methodProxy.invokeSuper(o, objects)。执行代理类的父类，执行目标类（目标类和代理类父子关系）。 Object obj = method.invoke(userService, objects); // 后执行 myAspect.after(); return obj; }); return (UserService) enhancer.create(); } } Spring AOP 代理Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强代码。 半自动需要手动再 Spring 配置文件中配置代理。 案例说明： 目标类：需要被代理的类，JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。（此处代码与JDK 动态代理代码同） 切面类：用于存放通知 MyAspect。 工厂类：工厂类由 Spring 容器管理（配置文件配置）。 使用到的部分 Jar 包： spring-aop.jar（AOP 的实现） aopalliance.jar（AOP 联盟的规范） 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ public class MyAspect implements MethodInterceptor { @Override public Object invoke(MethodInvocation invocation) throws Throwable { // 代理目标方法前运行 System.out.println(\"方法运行前\"); // 手动执行目标方法 Object obj = invocation.proceed(); // 代理目标方法后运行。 System.out.println(\"方法运行后\"); return obj; } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 目标类 --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.aop.UserServiceImpl\"/> &lt;!-- 切面类 --> &lt;bean id=\"myAspect\" class=\"com.kuukokawaii.aop.MyAspect\"/> &lt;!-- 代理类：使用工厂 bean，底层调用 getObject()，返回特殊 bean。 ProxyFactoryBean：用于创建代理工厂 bean，生成特殊代理对象。 interfaces：确定接口类。 通过&lt;array>可以设置多个值，单值可以仅使用&lt;value>。 target：确定目标类。 interceptorNames：通知切面类的名称，类型 String[]。 optimize：boolean true 意思为强制使用 cglib（无论有无接口）。（如果有接口默认使用 jdk 动态代理，没有则使用 cglib 字节码增强） --> &lt;bean id=\"proxyUserService\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"> &lt;property name=\"interfaces\" value=\"com.kuukokawaii.aop.UserService\"/> &lt;property name=\"target\" ref=\"userService\"/> &lt;property name=\"interceptorNames\" value=\"myAspect\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { /** * Method: addUser() */ @Test public void test() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); // 获取代理类 UserService userService = applicationContext.getBean(\"proxyUserService\", UserService.class); userService.addUser(); userService.updateUser(); userService.deleteUser(); } } 全自动在配置文件中标识所使用到的类，Spring 自动配置代理。 案例说明： 目标类：需要被代理的类，JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。（此处代码与半自动代码同） 切面类：用于存放通知 MyAspect。（此处代码与半自动代码同） 工厂类：工厂类又 Spring 容器管理（配置文件配置）。 使用到的部分 Jar 包： spring-aop.jar（AOP 的实现） aopalliance.jar（AOP 联盟的规范） aspectjweaver.jar（Spring 切入点表达式的实现） 代码演示： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 目标类 --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.aop.UserServiceImpl\"/> &lt;!-- 切面类 --> &lt;bean id=\"myAspect\" class=\"com.kuukokawaii.aop.MyAspect\"/> &lt;!-- AOP编程： 1.导入命名空间。 2.使用&lt;aop:config>进行配置。proxy-target-class=\"true\"，true：cglib；false：jdk动态代理 &lt;aop:pointcut>：切入点，从目标对象获得具体方法。 切入点表达式：execution(* com.kuukokawaii.aop.*.*(..))：修饰符(可省略) 返回值 包(可省略).类(可省略).方法(参数) throws(可省略)；expression=\"execution()||execution()\" 可匹配多个。 within：匹配包或子包中的方法。 this：匹配实现接口的代理对象中的方法。 target：匹配实现接口的目标对象中的方法。 args：匹配参数格式符合标准的方法。 bean：匹配指定 bean 中的方法。 &lt;aop:advisor>：特殊切面，包含一个通知和切入点。 advice-ref：通知引用， pointcut-ref：切入点引用。 --> &lt;aop:config> &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.kuukokawaii.aop.*.*(..))\"/> &lt;aop:advisor advice-ref=\"myAspect\" pointcut-ref=\"myPointcut\"/> &lt;/aop:config> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { /** * Method: addUser() */ @Test public void test() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); // 获取目标类 UserService userService = applicationContext.getBean(\"userService\", UserService.class); userService.addUser(); userService.updateUser(); userService.deleteUser(); } } AspectJAspectJ 是一个基于 Java 语言的 AOP 框架，它扩展了 Java 语言并提供了一个专门的编译器，在编译时提供横向代码的植入。Spring AOP 引入了对 AspectJ 的支持。 案例说明： 目标类：采用接口 + 实现类的方法。（此处代码与全自动代码同） 切面类：编写多个通知，采用 AspectJ 通知名称任意（方法名任意）。 使用到的部分 Jar 包： spring-aop.jar（AOP 的实现） aopalliance.jar（AOP 联盟的规范） aspectjweaver.jar（Spring 切入点表达式的实现） spring-aspects.jar（提供对 AspectJ 的支持） 代码演示： 基于 XML 配置 /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ public class MyAspect { /** * 前置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ void myBefore(JoinPoint joinPoint) { System.out.println(\"前置通知。\" + joinPoint.getSignature().getName()); } /** * 后置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 * @param returning 用于获取返回值。 */ void myAfterReturning(JoinPoint joinPoint, Object returning) { System.out.println(\"后置通知。\" + joinPoint.getSignature().getName() + \"，返回值：\" + returning); } /** * 环绕通知。 * * @param proceedingJoinPoint 连接点 * @return 返回目标方法。 * @throws Throwable 方法执行异常。 */ Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // 前 System.out.println(\"环绕前\"); // 手动执行目标方法。 Object obj = proceedingJoinPoint.proceed(); // 后 System.out.println(\"环绕后\"); return obj; } /** * 抛出异常通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ void myAfterThrowing(JoinPoint joinPoint, Throwable throwable) { System.out.println(\"抛出异常通知。\" + throwable.getMessage()); } /** * 最终通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ void myAfter(JoinPoint joinPoint) { System.out.println(\"最终通知。\" + joinPoint.getSignature().getName()); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 目标类 --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.aop.UserServiceImpl\"/> &lt;!-- 切面类 --> &lt;bean id=\"myAspect\" class=\"com.kuukokawaii.aop.MyAspect\"/> &lt;!-- aop编程： &lt;aop:aspect>：将切面类声明成“切面”，从而获得通知（方法）。 ref：引用切面类。 &lt;aop:pointcut>：声明一个切入点，所有的通知都可以使用。 expression：切入点表达式。 id：用于其他通知使用。 &lt;aop:before>: 前置通知，目标方法前执行。 method：通知及方法名。 pointcut：切入点表达式，此表达式只能当前通知使用。 pointcut-ref：切入点的引用，可以与其他通知共享切入点。 &lt;aop:after-returning>：后置通知，目标方法后执行，可获得返回值。 returning：类型 Object, 用于获取返回值，需要与方法中的参数名相对应。类型 Object。 &lt;aop:around>：环绕通知。前置通知优先环绕通知执行。 &lt;aop:after-throwing>：抛出异常通知。抛出异常之后的语句不再执行。 throwing：用于获取异常信息，需要与方法中的参数名相对应。类型 Throwable。 &lt;aop:after>：最终通知。相当于 try/catch 中的 finally，抛出异常也会执行。方法执行后执行，优先级高于环绕（后）通知 --> &lt;aop:config> &lt;aop:aspect ref=\"myAspect\"> &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.kuukokawaii.aop.*.*(..))\"/> &lt;aop:before method=\"myBefore\" pointcut-ref=\"myPointcut\"/> &lt;aop:after-returning method=\"myAfterReturning\" pointcut-ref=\"myPointcut\" returning=\"returning\"/> &lt;aop:around method=\"myAround\" pointcut-ref=\"myPointcut\"/> &lt;aop:after-throwing method=\"myAfterThrowing\" pointcut-ref=\"myPointcut\" throwing=\"throwable\"/> &lt;aop:after method=\"myAfter\" pointcut-ref=\"myPointcut\"/> &lt;/aop:aspect> &lt;/aop:config> &lt;/beans> 基于注解配置UserServiceImpl 类需要加上 @Service 注解。@Aspect 用于声明切面类。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.aop\"/> &lt;!-- aop 注解扫描，自动代理 --> &lt;aop:aspectj-autoproxy/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ @Component @Aspect public class MyAspect { /** * 声明公共切入点 */ @Pointcut(\"execution(* com.kuukokawaii.aop.UserServiceImpl.*(..))\") private void myPointcut() { } /** * 前置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ @Before(\"myPointcut()\") void myBefore(JoinPoint joinPoint) { System.out.println(\"前置通知。\" + joinPoint.getSignature().getName()); } /** * 后置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 * @param returning 用于获取返回值。 */ @AfterReturning(value = \"myPointcut()\", returning = \"returning\") void myAfterReturning(JoinPoint joinPoint, Object returning) { System.out.println(\"后置通知。\" + joinPoint.getSignature().getName() + \"，返回值：\" + returning); } /** * 环绕通知。 * * @param proceedingJoinPoint 连接点 * @return 返回目标方法。 * @throws Throwable 方法执行异常。 */ @Around(\"myPointcut()\") Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // 前 System.out.println(\"环绕前\"); // 手动执行目标方法。 Object obj = proceedingJoinPoint.proceed(); // 后 System.out.println(\"环绕后\"); return obj; } /** * 抛出异常通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ @AfterThrowing(value = \"myPointcut()\", throwing = \"throwable\") void myAfterThrowing(JoinPoint joinPoint, Throwable throwable) { System.out.println(\"抛出异常通知。\" + throwable.getMessage()); } /** * 最终通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ @After(\"myPointcut()\") void myAfter(JoinPoint joinPoint) { System.out.println(\"最终通知。\" + joinPoint.getSignature().getName()); } } /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class UserServiceImplTest { @Autowired private UserService userService; /** * Method: addUser() */ @Test public void test() throws Exception { userService.addUser(); userService.updateUser(); userService.deleteUser(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（四）：bean 装配","date":"2019-09-01T05:36:41.000Z","path":"posts/4364/","text":"实例化方式bean 有3种实例化的方式：默认构造、静态工厂和实例化工厂。 默认构造通过&lt;bean id=\"\" class=\"要装配的实现类全限定类名\" /&gt;的方式装配 bean 便是自动使用了默认构造。 静态工厂静态工厂用于生成实例对象，且所有的方法必须是静态的。常用于 Spring 整合其他框架（工具）。通过&lt;bean id=\"\" class=\"要整合的工厂实现类全限定类名\" factory-method=\"静态方法名\" /&gt;进行 bean 的装配。代码演示如下： /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:07 * @Description StaticFactoryService 接口类 */ public interface StaticFactoryService { /** * 测试输出语句 */ void test(); } /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:07 * @Description StaticFactoryService 实现类 */ public class StaticFactoryServiceImpl implements StaticFactoryService { @Override public void test() { System.out.println(\"静态工厂输出成功。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:08 * @Description 自定义 bean 静态工厂 */ public class MyStaticBeanFactory { /** * 创建 StaticFactoryService 实例。 * @return 返回 StaticFactoryService 实例对象。 */ public static StaticFactoryService createService(){ return new StaticFactoryServiceImpl(); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 将静态工厂创建的实例交予 Spring 管理。 class：输入静态工厂的全限定类名。 factory-method：输入需要获取的静态工厂中所存在的静态方法名。 --> &lt;bean id=\"staticFactoryService\" class=\"com.kuukokawaii.di.MyStaticBeanFactory\" factory-method=\"createService\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/01/2019 * @Description StaticFactoryServiceImpl test */ public class StaticFactoryServiceImplTest { /** * Method: test() */ @Test public void testTest() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 StaticFactoryService staticFactoryService = applicationContext.getBean(\"staticFactoryService\", StaticFactoryService.class); staticFactoryService.test(); } } 实例化工厂实例化工厂通过工厂实例对象创建对象，且所有的方法都是非静态的。代码演示如下： 此处代码与上述静态工厂共用 StaticFactoryService 、 StaticFactoryServiceImpl 和 测试类。 /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:08 * @Description 自定义 bean 实例工厂 */ public class MyBeanFactory { /** * 创建 StaticFactoryService 实例。 * @return 返回 StaticFactoryService 实例对象。 */ public StaticFactoryService createService(){ return new StaticFactoryServiceImpl(); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 1.将自定义实例工厂交予 Spring 管理。 class：输入实例工厂的全限定类名。 2.通过实例工厂配置 bean。 factory-bean：配置好的实例工厂的 bean 的 id。 factory-method：输入需要获取的实例工厂中所存在的方法名。 --> &lt;bean id=\"myBeanFactory\" class=\"com.kuukokawaii.di.MyBeanFactory\"/> &lt;bean id=\"staticFactoryService\" factory-bean=\"myBeanFactory\" factory-method=\"createService\"/> &lt;/beans> 作用域Spring 的作用域用于确定创建的 bean 的实例个数。通过 XML 配置 bean 时，添加scope属性进行配置（如&lt;bean id=\"\" class=\"\" scope=\"\" /&gt;）。常用的scope属性有singleton（单例）和prototype（多例）。 生命周期可以将 bean 的生命周期划分为11个部分，具体如下图所示：图中各部分效用如下： Instantiate：初始化 bean，调用构造函数创建实例。 Populate properties：封装属性，即进行 DI 操作。 BeanNameAware's setBeanName()：调用 BeanNameAware 接口的 setBeanName 方法获取 BeanName。 BeanFactoryAware's setBeanFactory()：调用 BeanFactoryAware 接口的 setBeanFactory 方法获取 BeanFactory。 Pre-initialization BeanPostProcessors：如果存在类实现 BeanPostProcessor,则执行 postProcessBeforeInitialization 方法进行预处理。 InitializingBean's afterPropertiesSet()：如果 bean 实现 InitializingBean，则执行 afterPropertiesSet 方法。 Call custom init-method：调用自定义的 init-method 方法。 Post-initialization BeanPostProcessors：如果存在类实现 BeanPostProcessor,执行 postProcessAfterInitialization 方法进行后处理。 Bean is ready to use / Container is Shutdown：执行业务处理。 DisposableBean's destroy()：如果 bean 实现 DisposableBean，则执行 destroy 方法。 Call custom destroy-method：调用自定义的 destroy-method。 bean 生命周期常用操作： 初始化和摧毁 如果需要进行初始化或摧毁的操作，可以通过使用init-method和destroy-method属性进行设置，其中destroy-method 只有在 scope=singleton 的时候才会生效。（如&lt;bean id=\"\" class=\"\" init-method=\"\" destory-method=\"\"/&gt;）。 1.在 beans 标签下的default-init-method可以设置所有默认的属性。2.优先级：InitializationBean 和 DisposableBean &gt; init-method 和 destroy-method &gt; default。 后处理 在 Spring 中实现 BeanPostProcessor 接口，并将实现类提供给 Spring 容器，Spring 容器就会自动的执行该实现类。在初始化方法前执行 before()，在初始化方法后执行 after()。 代码演示如下： /** * @Author 喵粮都输光了 * @Date 2019/9/1 16:13 * @Description 后处理 bean 实现类 */ public class MyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"初始化前\"); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"初始化后\"); return bean; } } /** * @Author 喵粮都输光了 * @Date 2019/9/1 16:16 * @Description BeanPostProcessorService 接口类 */ public interface BeanPostProcessorService { /** * 测试输出语句 */ void test(); } /** * @Author 喵粮都输光了 * @Date 2019/9/1 16:16 * @Description BeanPostProcessorService 实现类 */ public class BeanPostProcessorServiceImpl implements BeanPostProcessorService { @Override public void test() { System.out.println(\"测试方法内容。\"); } public void init() { System.out.println(\"初始化\"); } public void destroy(){ System.out.println(\"摧毁\"); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"beanPostProcessorService\" class=\"com.kuukokawaii.di.BeanPostProcessorServiceImpl\" init-method=\"init\" destroy-method=\"destroy\"/> &lt;bean class=\"com.kuukokawaii.di.MyBeanPostProcessor\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/01/2019 * @Description BeanPostProcessorServiceImpl test */ public class BeanPostProcessorServiceImplTest { /** * Method: test() */ @Test public void testTest() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 BeanPostProcessorService beanPostProcessorService = applicationContext.getBean(\"beanPostProcessorService\", BeanPostProcessorService.class); beanPostProcessorService.test(); applicationContext.close(); } } 输出结果如下： 属性依赖注入setter 方法关键代码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- setter 方法注入： &lt;bean id=\"\" class=\"\"> // 普通数据： &lt;property name=\"\" value=\"值\"/> // 引用数据： &lt;property name=\"\" ref=\"另一个 bean\"/> &lt;/bean> --> &lt;bean id=\"person\" class=\"com.kuukokawaii.setter.Person\"> &lt;property name=\"name\" value=\"老大\"/> &lt;property name=\"address\" ref=\"address\"/> &lt;/bean> &lt;bean id=\"address\" class=\"com.kuukokawaii.setter.Address\"> &lt;property name=\"companyAddress\" value=\"学校地址\"/> &lt;property name=\"homeAddress\" value=\"家庭地址\"/> &lt;/bean> &lt;/beans> P 命名空间对 setter 方法注入进行简化，替换&lt;property name=\"属性名\"/&gt;为&lt;bean p:属性名=\"值\" p:属性名-ref=\"引用值\"。P 命名空间需要在 xml 头部增加xmlns:p=\"http://www.springframework.org/schema/p\"。关键代码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"person\" class=\"com.kuukokawaii.setter.Person\" p:name=\"老大\" p:address-ref=\"address\"/> &lt;bean id=\"address\" class=\"com.kuukokawaii.setter.Address\" p:companyAddress=\"学校地址\" p:homeAddress=\"家庭地址\"/> &lt;/beans> SpEL对&lt;property&gt;进行统一编程，所有内容都使用value（如`&lt;property name=”” value=”#{表达式}”。表达式详情参考：Spring Expression Language 集合注入集合的注入就是给&lt;property&gt;添加子标签。数组使用&lt;array&gt;、List 使用&lt;list&gt;、Set 使用&lt;set&gt;、Map 使用&lt;map&gt;、Properties使用&lt;props&gt;。其中 Map 和 Properties 存放键值对时分别需要使用&lt;entry&gt;和&lt;prop&gt;描述。关键代码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"collData\" class=\"com.kuukokawaii.setter.CollData\"> &lt;property name=\"arrayData\"> &lt;array> &lt;value>array1&lt;/value> &lt;value>array2&lt;/value> &lt;/array> &lt;/property> &lt;property name=\"listData\"> &lt;list> &lt;value>list1&lt;/value> &lt;value>list2&lt;/value> &lt;/list> &lt;/property> &lt;property name=\"setData\"> &lt;set> &lt;value>set1&lt;/value> &lt;value>set2&lt;/value> &lt;/set> &lt;/property> &lt;property name=\"mapData\"> &lt;map> &lt;entry key=\"mk1\" value=\"mv1\"/> &lt;entry key=\"mk2\" value=\"mv2\"/> &lt;/map> &lt;/property> &lt;property name=\"propsData\"> &lt;props> &lt;prop key=\"pk1\">pv1&lt;/prop> &lt;prop key=\"pk2\">pv2&lt;/prop> &lt;/props> &lt;/property> &lt;/bean> &lt;/beans> 基于注解配置 注解就是一个使用了@注解名称的类，比 XML 使用起来更方便。使用注解前需要配置 Spring 包扫描，扫描含有注解的类。 在 web 开发中，常用3个 @Component 注解衍生注解 @Repository：用于 Dao 层。 @Service：用于 Service 层。 @Controller：用于 Web 层。 依赖注入（可以给私有字段设置，也可以给 setter 方法设置。） 普通值：@Value(“需要设置的值”) 引用值： 按照类型注入：@Autowired。 按照名称注入1：@Autowired 和 @Qualifier(“名称”)联合使用。 按照名称注入2：@Resource(“名称”)。 生命周期初始化：@PostConstruct销毁：@PreDestroy 作用域：@Scope(“属性”) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（三）：DI","date":"2019-08-30T13:07:35.000Z","path":"posts/639/","text":"什么是 DI在依赖注入中，如果对象 A 中使用到对象 B，则称对象 A 依赖于对象 B；而当你创建对象 A 时，由于对象 A 依赖于对象 B 需要额外创建一个对象 B，并调用对象 A 的 set 方法进行对象 B 的实例设置，这便称为注入。 案例说明 创建 BookService 接口和实现类。 创建 BookDao 接口和实现类。 通过依赖注入获得 dao 和 service。 通过 xml 配置的方式。 通过注解的方式。 使用到的 Jar 包 spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar commons-logging.jar junit.jar spring-test.jar 代码演示/** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookDao 接口类 */ public interface BookDao { /** * 增加书本 */ void insertBook(); } /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:21 * @Description BookDao 实现类 */ public class BookDaoImpl implements BookDao { @Override public void insertBook() { System.out.println(\"书本添加成功。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookService 接口类 */ public interface BookService { /** * 增加书本 */ void addBook(); } /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookService 实现类 */ public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDaoImpl bookDao) { this.bookDao = bookDao; } @Override public void addBook() { bookDao.insertBook(); } } XML 文件配置方式从 Spring 容器中获得实例对象。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 以下配置其实就执行了三个步骤： 1.BookService bookService = new BookServiceImpl(); 2.BookDao bookDao = new BookDaoImpl(); 3.bookService.setBookDao(bookDao); 其中&lt;property name=\"\" ref=\"\"/>就相当于上述的 set 方法。 --> &lt;bean id=\"bookService\" class=\"com.kuukokawaii.di.BookServiceImpl\"> &lt;property name=\"bookDao\" ref=\"bookDao\"/> &lt;/bean> &lt;bean id=\"bookDao\" class=\"com.kuukokawaii.di.BookDaoImpl\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 08/30/2019 * @Description BookServiceImpl test */ public class BookServiceImplTest { /** * Method: addBook() */ @Test public void testAddBook() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 BookService bookService = (BookService) applicationContext.getBean(\"bookService\"); bookService.addBook(); } } 注解方式从 Spring 容器中获得实例对象。（需要在 BookServiceImpl 类加上 @Service 注解以及 BookDaoImpl 类加上 @Repository 注解，让包扫描能够扫描到。） 此处修改了 BookServiceImpl 类 和 XML 配置。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;context:component-scan base-package=\"com.kuukokawaii\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookService 实现类 */ @Service public class BookServiceImpl implements BookService { private final BookDao bookDao; @Autowired public BookServiceImpl(BookDao bookDao) { this.bookDao = bookDao; } @Override public void addBook() { bookDao.insertBook(); } } /** * @Author 喵粮都输光了 * @Date 08/30/2019 * @Description BookServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class BookServiceImplTest { @Autowired private BookService bookService; /** * Method: addBook() */ @Test public void testAddBook() throws Exception { bookService.addBook(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（二）：IoC","date":"2019-08-29T04:48:33.000Z","path":"posts/6802/","text":"什么是 IoCIoC 可以理解为借助于“第三方”实现对象之间的解耦。Spring IoC 通过使用 IoC 容器调控系统内所有的对象，使得对象之间没有了耦合关系，而 IoC 容器成为了整个项目的核心部分，当 IoC 容器失效时，所有对象彼此之间都会失去联系。 案例说明 创建 UserService 接口和实现类。 获得 UserService 实现类的实例。 通过 XML 文件配置的方式，从 Spring 容器中获得实例对象。 通过注解的方式从 Spring 容器中获得实例对象。 使用到的 Jar 包 spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar commons-logging.jar junit.jar spring-test.jar 代码演示/** * @Author 喵粮都输光了 * @Date 2019/8/29 18:05 * @Description UserService 接口类 */ public interface UserService { /** * 增加用户 */ void addUser(); } /** * @Author 喵粮都输光了 * @Date 2019/8/29 18:06 * @Description UserService 实现类 */ public class UserServiceImpl implements UserService { @Override public void addUser() { System.out.println(\"增加用户。\"); } } XML 文件配置方式从 Spring 容器中获得实例对象。（Spring配置文件常用 ApplicationContext 命名。） &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 需要配置的 bean --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.ioc.UserServiceImpl\" /> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 08/29/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { @Test public void testAddUser() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 UserService userService = (UserService) applicationContext.getBean(\"userService\"); userService.addUser(); } } 注解方式通过注解从 Spring 容器中获得实例对象。（需要在 UserServiceImpl 类加上 @Service 注解，让包扫描能够扫描到。） 需要注意的是用 spring 进行 Junit 测试时，需要引入 spring-test.jar，并在测试类上加入 @RunWith 和 @ContextConfiguration 的注解配置。如果还有错误可以尝试更新 Junit.jar 的版本。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 配置包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 08/29/2019 * @Description UserServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class UserServiceImplTest { @Autowired private UserService userService; /** * Method: addUser() */ @Test public void testAddUser() throws Exception { userService.addUser(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（一）：简介","date":"2019-08-28T07:07:50.000Z","path":"posts/14546/","text":"Spring 优点 方便解耦，简化开发可以将所有对象的创建和依赖关系的维护交给 Spring 管理。 AOP 编程的支持Spring 提供面向切面的编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 声明式事务的支持无需手动编程，只需要通过配置就可以完成对事物的管理。 方便程序的测试Spring 支持 Junit，可以通过注解方便的测试 Spring 程序。 方便集成各种优秀框架Spring 内部提供了对各种优秀框架（Struts、Hibernate、MyBatis、Quartz……）的直接支持。 降低 JavaEE API 的使用难度Spring 封装了 JavaEE 开发中一些非常难用的 API(JDBC、JavaMail、远程调用……)，降低了这些 API 的应用难度。 Spring 体系结构Spring 框架是一个分层架构，它将一系列的功能要素分为 Data Access/Integration，Web，AOP，Core Container，Instrumentation 和 Test 等几大模块。 Core Container Beans：用于管理 Bean。 Core：Spring 的核心，主要用于实现反向控制 IoC（Inversion of Control）与依赖注入 DI（Dependency Injection）、Bean 配置以及加载。 Context：上下文，相当于配置文件。 Expression Language：即 SpEL，是 Spring 的一种表达式，用来动态的获取值、对象等。 AOP AOP：切面编程（Aspect Oriented Programming）。 Aspects：一个切面编程的框架。 Data Access/Integration JDBC：用于链接数据库，向数据库发送 sql 语句。 ORM：对象关系映射，用于整合持久层框架（Mybatis，Hibernate……）。 OXM：即 O/X 映射器，用于将 Java 对象和 XML 文档之间进行互相转换。 JMS：即 Java消息服务，用于两个应用程序之间传送消息，进行异步通信。 Transactions：事务管理。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]}]