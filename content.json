[{"title":"设计模式之适配器模式与外观模式","date":"2020-03-13T06:12:37.000Z","path":"posts/aa979c82/","text":"适配器模式 适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 使用场景：当需要使用一个现有的类而其接口并不符合你的需求时，就使用适配器。 对象适配器模式 对象适配器模式通过组合的方式实现适配器模式，比类适配器模式更灵活。其UML类图如下： 代码演示： 有一个鸭子类。 /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:55 * @Description 鸭子接口 */ public interface Duck { /** * 鸭子呱呱叫 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:57 * @Description 绿头鸭 */ public class MallardDuck implements Duck { @Override public void quack() { System.out.println(\"呱呱叫\"); } } 有一个火鸡类。 /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:55 * @Description 火鸡接口 */ public interface Turkey { /** * 火鸡咯咯叫 */ void gobble(); } /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:58 * @Description 野生火鸡 */ public class WildTurkey implements Turkey { @Override public void gobble() { System.out.println(\"咯咯叫\"); } } 将火鸡包装成鸭子并测试。 /** * @Author 喵粮都输光了 * @Date 2020/3/13 15:00 * @Description 火鸡适配器，火鸡→鸭子 */ public class TurkeyAdapter implements Duck { private Turkey turkey; TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } @Override public void quack() { turkey.gobble(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:59 * @Description 测试 */ public class Main { public static void main(String[] args) { // 鸭子 Duck duck = new MallardDuck(); duck.quack(); // 火鸡 Turkey turkey = new WildTurkey(); turkey.gobble(); // 将需要转换的火鸡变成鸭子 Duck turkeyAdapter = new TurkeyAdapter(turkey); turkeyAdapter.quack(); } } 类适配器模式 类适配器模式：通过继承的方式实现适配器模式。其UML类图如下： 代码演示（JAVA不支持多继承此处使用python）： class Duck: @staticmethod def quack(): print(\"呱呱叫\") class Turkey: @staticmethod def gobble(): print(\"咯咯叫\") class TurkeyAdapter(Duck, Turkey): def quack(self): self.gobble() if __name__ == '__main__': duck = Duck() duck.quack() turkey = Turkey() turkey.gobble() turkeyAdapter = TurkeyAdapter() turkeyAdapter.quack() 外观模式 外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 使用场景：当需要简化并统一一个很大的接口或者一群复杂的接口时，就使用外观模式。 设计原则：只和你的密友谈话，即最少知识原则。也就是说在对象的方法内调用属于一下范围的方法： 该对象本身。 被当作方法的参数而传递进来的对象。 此方法所创建或实例化的任何对象。 对象的任何组件，也就是构造方法传入的参数或对象。 最好不要使用对象的方法的方法所返回的值。当然不需要完全遵守，因为实现最少知识原则虽然减少了对象之间的依赖方便维护，但是导致系统复杂度和开发时间的增加并降低了运行时的性能。 外观模式可以这么来看。当有一批操作经常需要一起进行时，也就是说我想完成一个操作，而这个操作需要调用类A的a方法，类B的bc方法，类C…等等。这时候可以创建一个外观（类），在构造参数中传入每一个使用到的组件并把它们赋值给相应的实例变量，然后创建方法，在方法中执行之前所需执行的一系列操作。这样就使用上了外观模式，外观模式将客户从复杂的子系统中解耦。 外观模式UML类图： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之命令模式","date":"2020-03-12T05:30:23.000Z","path":"posts/933830c7/","text":"命令模式 命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。常用于队列请求（命令对象排队进行处理）和日志请求（所有操作记录于日志中，系统死机时可以按照日志恢复）。 命令模式UML类图： 原型设计一个遥控器，当按下遥控器上的按钮时，就会执行一个命令，例如打开风扇或关闭电灯。遥控器无需知道如何执行命令，只需要知道按下按钮即可完成命令。其实说白了就是将原来控制器直接调用具体方法变成了控制器调用命令对象，命令对象调用具体方法，有一个特别大的好处，就是控制器调用命令对象可以对一系列的方法进行操控，而不是像原来一个一个去new调用。代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 命令接口 */ public interface Command { /** * 命令执行 */ void execute(); } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:28 * @Description 开关门命令 */ public class DoorCommand implements Command { private Door door; DoorCommand(Door door) { this.door = door; } @Override public void execute() { if (door.getStatus() == 1) { door.off(); } else { door.on(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:22 * @Description 大门实体 */ public class Door { /** * 门关着 */ private static final int OFF = 0; /** * 门开着 */ private static final int ON = 1; /** * 门状态 */ private int status; Door() { status = OFF; } void off() { status = OFF; System.out.println(\"门关上了\"); } void on() { status = ON; System.out.println(\"门打开了\"); } int getStatus() { return status; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:15 * @Description 关灯命令 */ public class LightOffCommand implements Command { private Light light; LightOffCommand(Light light) { this.light = light; } @Override public void execute() { light.off(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启强光灯命令 */ public class LightOnStrongCommand implements Command { private Light light; LightOnStrongCommand(Light light) { this.light = light; } @Override public void execute() { light.strong(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启弱光灯命令 */ public class LightOnWeekCommand implements Command { private Light light; LightOnWeekCommand(Light light) { this.light = light; } @Override public void execute() { light.week(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:16 * @Description 灯实体 */ public class Light { /** * 强光 */ private static final int STRONG = 2; /** * 弱光 */ private static final int WEEK = 1; /** * 关闭 */ private static final int OFF = 0; /** * 灯光亮度 */ private int luminance; Light() { luminance = OFF; } void strong() { luminance = STRONG; System.out.println(\"开启了强光灯\"); } void week() { luminance = WEEK; System.out.println(\"开启了弱光灯\"); } void off() { luminance = OFF; System.out.println(\"灯关了\"); } int getLuminance() { return luminance; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:32 * @Description 控制器实体，相当于invoker */ public class RemoteControl { /** * 控制器按钮多个 */ private Command[] button; RemoteControl() { // 按钮5个 button = new Command[5]; } /** * 将具体按钮与需要执行的命令绑定 * @param location 按钮位置 * @param command 命令 */ void setCommand(int location, Command command) { button[location] = command; } /** * 按下按钮执行命令 */ void buttonWasPressed(int location) { button[location].execute(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 测试 */ public class Main { public static void main(String[] args) { // 控制器 RemoteControl remoteControl = new RemoteControl(); // 需要操控的对象 Door door = new Door(); Light light = new Light(); // 命令需要有执行的对象 Command doorCommand = new DoorCommand(door); Command lightOnWeekCommand = new LightOnWeekCommand(light); Command lightOnStrongCommand = new LightOnStrongCommand(light); Command lightOffCommand = new LightOffCommand(light); // 控制器按钮绑定需要执行的命令 remoteControl.setCommand(0, doorCommand); remoteControl.setCommand(1, lightOnWeekCommand); remoteControl.setCommand(2, lightOnStrongCommand); remoteControl.setCommand(3, lightOffCommand); // 操作控制器 remoteControl.buttonWasPressed(0); remoteControl.buttonWasPressed(0); remoteControl.buttonWasPressed(1); remoteControl.buttonWasPressed(2); remoteControl.buttonWasPressed(3); } } 增加undo方法为命令模式实现撤销方法。代码演示：修改Command和其实现类，对于门只有开关两种状态，检测一下当前状态将其向反方向执行就是撤销了。对于有多种状态的对象例如灯有强光、弱光和关闭，则需要变量先对其进行记录才能进行撤销。 /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 命令接口 */ public interface Command { /** * 命令执行 */ void execute(); /** * 撤销上一条执行的命令 */ void undo(); } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:28 * @Description 开关门命令 */ public class DoorCommand implements Command { private Door door; DoorCommand(Door door) { this.door = door; } @Override public void execute() { if (door.getStatus() == 1) { door.off(); } else { door.on(); } } @Override public void undo() { execute(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 18:52 * @Description 灯光命令 */ public class LightCommand implements Command { private Light light; /** * 记录灯光亮度 */ private int luminance; LightCommand(Light light) { this.light = light; } @Override public void execute() { } @Override public void undo() { if (luminance == Light.OFF) { light.off(); } else if (luminance == Light.WEEK) { light.week(); } else if (luminance == Light.STRONG) { light.strong(); } } public Light getLight() { return light; } public void setLuminance(int luminance) { this.luminance = luminance; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启弱光灯命令 */ public class LightOnWeekCommand extends LightCommand { LightOnWeekCommand(Light light) { super(light); } @Override public void execute() { setLuminance(getLight().getLuminance()); getLight().week(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启强光灯命令 */ public class LightOnStrongCommand extends LightCommand { LightOnStrongCommand(Light light) { super(light); } @Override public void execute() { setLuminance(getLight().getLuminance()); getLight().strong(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:15 * @Description 关灯命令 */ public class LightOffCommand extends LightCommand { LightOffCommand(Light light) { super(light); } @Override public void execute() { setLuminance(getLight().getLuminance()); getLight().off(); } } 修改RemoteControl类，在控制器中新增变量用于记录上一条执行的命令就可以实现撤销功能了。 /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:32 * @Description 控制器实体，相当于invoker */ public class RemoteControl { /** * 控制器按钮多个 */ private Command[] button; /** * 记录上一个执行的命令 */ private Command undoCommand; RemoteControl() { button = new Command[5]; } /** * 将具体按钮与需要执行的命令绑定 * @param location 按钮位置 * @param command 命令 */ void setCommand(int location, Command command) { button[location] = command; } /** * 按下按钮执行命令 */ void buttonWasPressed(int location) { button[location].execute(); undoCommand = button[location]; } /** * 撤销按钮 */ void undoButtonWasPushed() { if (undoCommand != null) { undoCommand.undo(); } } } 修改测试类（带结果）。 // 操作控制器 //门打开了 remoteControl.buttonWasPressed(0); //门关上了 remoteControl.undoButtonWasPushed(); //开启了弱光灯 remoteControl.buttonWasPressed(1); //灯关了 remoteControl.undoButtonWasPushed(); //开启了强光灯 remoteControl.buttonWasPressed(2); //灯关了 remoteControl.buttonWasPressed(3); 使用宏命令同时执行多个命令，例如同时打开灯和门。以及撤销宏命令。 /** * @Author 喵粮都输光了 * @Date 2020/3/12 19:06 * @Description 宏命令 */ public class MacroCommand implements Command { private Command[] commands; MacroCommand(Command[] commands) { this.commands = commands; } @Override public void execute() { for (Command command : commands) { command.execute(); } } @Override public void undo() { for (Command command : commands) { command.undo(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 测试 */ public class Main { public static void main(String[] args) { RemoteControl remoteControl = new RemoteControl(); Door door = new Door(); Light light = new Light(); Command doorCommand = new DoorCommand(door); Command lightOnStrongCommand = new LightOnStrongCommand(light); Command[] commands = {doorCommand, lightOnStrongCommand}; MacroCommand macroCommand = new MacroCommand(commands); remoteControl.setCommand(0, macroCommand); remoteControl.buttonWasPressed(0); remoteControl.undoButtonWasPushed(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之单件模式","date":"2020-03-12T03:30:49.000Z","path":"posts/9b1fa808/","text":"单件模式 单件模式确保一个类只有一个实例，并提供一个全局访问点。 应用场景：有些对象其实只需要一个而不是多个，例如线程池、缓存、注册表、全局设置等。因此当需要确保程序中的某个类只有一个实例时，就可以采用单件模式。 原型该单件模式是延迟实例化模式。代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:27 * @Description 单件模式 */ public class Singleton { /** * getInstance静态方法中使用了该变量因此需要在变量上加static，确保唯一性。 */ private static Singleton uniqueInstance; /** * 禁止new创建 */ private Singleton() { } /** * 当实例未被创建时，uniqueInstance为空，创建一个实例返回，否则返回已创建的实例。 * 此处static是因为无法通过new创建实例则无法调用实例的方法。通过static关键字可以直接使用类名调用方法。 * @return Singleton */ public static Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:29 * @Description 测试 */ public class Main { public static void main(String[] args) { Singleton singleton = Singleton.getInstance(); System.out.println(singleton); } } 处理多线程 问题：原型的单例模式在多线程情况下可能会创建多个不同的实例。 解决1：为getInstance()增加关键字synchronized，但是会造成性能非常低的问题。如果getInstance()的性能对应用程序不是很关键这个方法足够使用了。 代码演示1： 修改原型的getInstance()如下即可。 public static synchronized Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } 解决2：使用急切实例化的方法，而不是使用延迟实例化的做法。如果程序在创建和运行时方面的负担不太繁重，这样会让JVM在加载这个类时马上创建出此唯一的单件实例，就不存在线程安全问题啦。 代码演示2： /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:27 * @Description 急切实例化的单件模式 */ public class Singleton { private static Singleton uniqueInstance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return uniqueInstance; } } 解决3：用“双重检查加锁”，在getInstance()中减少使用同步。这样做会先检查实例是否创建了，未创建才进行同步，这样保证只有第一次调用方法实例化时才会同步。 代码演示3： /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:27 * @Description 双重检查加锁的单件模式 */ public class Singleton { /** * volatile关键词确保当uniqueInstance变量被初始化成Singleton实例时，多个线程能正确地处理uniqueInstance变量。 */ private volatile static Singleton uniqueInstance = new Singleton(); private Singleton() { } /** * 此处判断两次是为了防止当多个线程通过了第一次判断之后，其中一个线程加锁进行了实例化之后解锁， * 另一个线程加锁进来又一次实例化之后解锁，导致实例化对象不同的情况。因此在锁内还需要判断一次。 * @return Singleton */ public static Singleton getInstance() { if (uniqueInstance == null) { synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之工厂模式","date":"2020-03-11T07:23:40.000Z","path":"posts/bf53f1b3/","text":"工厂模式 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。 抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 设计原则：要依赖抽象，不要依赖具体类，即依赖倒置原则。 应用场景： 简单工厂：将实例化具体类的代码进行了封装，实现了解耦操作。缺点也很明显，不利于扩展，需要创建对象数量众多时，工厂会比较臃肿。且每次修改都需要对源代码进行修改，违反了关闭修改的设计原则。 工厂方法：拥有简单工厂的优点，并且便于扩展（新增不同的子类即可），适用于实现具体工厂。在编写新的具体产品类时，还要提供与之相对的具体工厂类，类的个数成对增长，在一定程度上增加了系统的复杂度。其UML类图如下： 抽象工厂：如果需要创建一系列同分类的产品时，使用抽象工厂是一个很好的选择，可以将相关产品都聚合起来。需要注意的是如果要新增一个产品需要对接口进行修改！所以常用于事先规划好且不会进行变更的产品。具体工厂实现经常使用工厂方式进行搭配。其UML类图如下： 原型设计一个比萨商店系统，出售各种类型的比萨（比萨商店类，比萨抽象类，具体比萨子类）。 简单工厂 问题：当通过比萨商店出售比萨时，需要按照所需比萨类型去实例化具体的比萨子类。当比萨商店新增不同的比萨时，需要修改商店的实例化部分代码，也就是说需要不断的修改源代码。 解决：将实例化部分代码提取出来设计成一个简单工厂，专门用该工厂实例化不同类型的比萨。此时，新增比萨则无需变动比萨商店类，只需修改简单工厂即可。 简单工厂UML类图： 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:06 * @Description 比萨抽象类 */ public abstract class BasePizza { /** * 比萨名字 */ private String name; /** * 面团种类 */ private String dough; /** * 准备材料过程 */ void prepare() { System.out.println(\"材料准备\"); } /** * 打包过程 */ void box() { System.out.println(\"打包\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDough() { return dough; } public void setDough(String dough) { this.dough = dough; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 芝士比萨子类 */ public class CheesePizza extends BasePizza { CheesePizza() { setName(\"芝士比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 素食比萨子类 */ public class VeggiePizza extends BasePizza { VeggiePizza() { setName(\"素食比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:21 * @Description 披萨简单工厂 */ public class SimplePizzaFactory { /** * 芝士比萨 */ public final static String CHEESE = \"cheese\"; /** * 素食比萨 */ public final static String VEGGIE = \"veggie\"; /** * 创建具体类型比萨 * @param type 比萨类型 * @return 具体类型比萨 */ BasePizza createPizza(String type) { BasePizza pizza = null; if (type.equals(CHEESE)) { pizza = new CheesePizza(); } else if (type.equals(VEGGIE)) { pizza = new VeggiePizza(); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:18 * @Description 披萨商店 */ public class PizzaStore { private SimplePizzaFactory factory; PizzaStore(SimplePizzaFactory factory) { this.factory = factory; } /** * 比萨订单 * @param type 比萨类型 * @return 具体类型比萨 */ BasePizza orderPizza(String type) { BasePizza pizza; pizza = factory.createPizza(type); pizza.prepare(); pizza.box(); return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:14 * @Description 测试 */ public class Main { public static void main(String[] args) { SimplePizzaFactory simplePizzaFactory = new SimplePizzaFactory(); PizzaStore pizzaStore = new PizzaStore(simplePizzaFactory); BasePizza cheesePizza = pizzaStore.orderPizza(SimplePizzaFactory.CHEESE); System.out.println(cheesePizza.getName() + \"完成\"); BasePizza veggiePizza = pizzaStore.orderPizza(SimplePizzaFactory.VEGGIE); System.out.println(veggiePizza.getName() + \"完成\"); } } 工厂方法模式 问题：此时如果要新增比萨商店，例如中国比萨商店、日本比萨商店，可以通过增加各地区简单工厂来实现。但是通过简单工厂的方式实现无法变更正在创建的产品，也就是说当需要增加新产品时就需要更改工厂类，违反了对修改关闭的原则。 解决：将简单工厂实现为继承PizzaStore的具体子类，PizzaStore中新增create的抽象方法。使用工厂方式模式一定程度可以克服以上问题。 工厂方法模式例子UML类图： 代码演示： 将PizzaStore类改变成BasePizzaStore抽象类。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:18 * @Description 披萨商店 */ public abstract class BasePizzaStore { /** * 芝士比萨 */ public final static String CHEESE = \"cheese\"; /** * 素食比萨 */ public final static String VEGGIE = \"veggie\"; /** * 比萨订单 * @param type 比萨类型 * @return 具体类型比萨 */ BasePizza orderPizza(String type) { BasePizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.box(); return pizza; } /** * 实例化具体的比萨 * @param type 比萨类型 * @return 具体类型比萨 */ abstract BasePizza createPizza(String type); } 新建中国比萨商店和日本比萨商店以及两商店所能产出的比萨。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 中国素食比萨子类 */ public class ChinaVeggiePizza extends BasePizza { ChinaVeggiePizza() { setName(\"中国素食比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 中国芝士比萨子类 */ public class ChinaCheesePizza extends BasePizza { ChinaCheesePizza() { setName(\"中国芝士比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 中国比萨商店子类 */ public class ChinaPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; if (type.equals(CHEESE)) { pizza = new ChinaCheesePizza(); } else if (type.equals(VEGGIE)) { pizza = new ChinaVeggiePizza(); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 日本素食比萨子类 */ public class JapanVeggiePizza extends BasePizza { JapanVeggiePizza() { setName(\"日本素食比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 日本芝士比萨子类 */ public class JapanCheesePizza extends BasePizza { JapanCheesePizza() { setName(\"日本芝士比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 日本比萨商店子类 */ public class JapanPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; if (type.equals(CHEESE)) { pizza = new JapanCheesePizza(); } else if (type.equals(VEGGIE)) { pizza = new JapanVeggiePizza(); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:14 * @Description 测试 */ public class Main { public static void main(String[] args) { BasePizzaStore chinaPizzaStore = new ChinaPizzaStore(); BasePizza chinaPizza = chinaPizzaStore.orderPizza(BasePizzaStore.CHEESE); System.out.println(chinaPizza.getName() + \"完成\"); BasePizzaStore japanPizzaStore = new JapanPizzaStore(); BasePizza japanPizza = japanPizzaStore.orderPizza(BasePizzaStore.VEGGIE); System.out.println(japanPizza.getName() + \"完成\"); } } 抽象工厂模式 问题：每个地区生产的比萨制作方法不同，原料也不尽相同，这时就需要一个原料工厂了。以面团为例，面团假设有厚面团和薄面团，通过使用工厂方式模式就需要建立一个父类面团，子类厚面团和薄面团。原料不可能只有面团，有无数个都需要如此建立父类子类，这是非常劳累的事情，而且他们都属于一个类别，通过工厂方式模式无法将这些原料归类在一起。 解决：使用抽象工厂模式，设计一个原料工厂接口用于创建所有所需原料，然后按地区划分创建原料工厂实现类，直接实例化具体的原料，例如厚面团。这样做的好处是可以聚集所有同类别的代码，相当于分类一样。 抽象工厂模式例子UML类图： 代码演示： 新增原料工厂接口，并实现具体地区的原料工厂。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:25 * @Description 比萨原料工厂接口 */ public interface PizzaIngredientFactory { /** * 生产面团 * @return 面团 */ Dough createDough(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:48 * @Description 中国比萨原料工厂 */ public class ChinaIngredientFactory implements PizzaIngredientFactory { @Override public Dough createDough() { // 使用厚皮 return new ThickCrustDough(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:49 * @Description 日本比萨原料工厂 */ public class JapanIngredientFactory implements PizzaIngredientFactory { @Override public Dough createDough() { // 使用薄皮 return new ThinCrustDough(); } } 新增面团原料接口，并实现具体的面团。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:26 * @Description 面团 */ public interface Dough { /** * 面团类型 * @return 面团类型 */ String doughType(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:46 * @Description 厚皮面粉实现类 */ public class ThickCrustDough implements Dough { @Override public String doughType() { return \"厚皮面粉\"; } @Override public String toString() { return doughType(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:46 * @Description 薄皮面粉实现类 */ public class ThinCrustDough implements Dough { @Override public String doughType() { return \"薄皮面粉\"; } @Override public String toString() { return doughType(); } } 修改pizza抽象类，将原料准备方法设置成抽象方法，修改dough的类型为Dough。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:06 * @Description 比萨抽象类 */ public abstract class BasePizza { /** * 比萨名字 */ private String name; /** * 面团种类 */ private Dough dough; /** * 准备材料过程 */ abstract void prepare(); /** * 打包过程 */ void box() { System.out.println(\"打包\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public Dough getDough() { return dough; } public void setDough(Dough dough) { this.dough = dough; } } 修改每一个具体的pizza实现类。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 中国素食比萨子类 */ public class ChinaVeggiePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; ChinaVeggiePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"中国素食比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 日本素食比萨子类 */ public class JapanVeggiePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; JapanVeggiePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"日本素食比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 中国芝士比萨子类 */ public class ChinaCheesePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; ChinaCheesePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"中国芝士比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 日本芝士比萨子类 */ public class JapanCheesePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; JapanCheesePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"日本芝士比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } 修改每一个商店类，在实例化具体pizza时添加对应地区原料。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 中国比萨商店子类 */ public class ChinaPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; PizzaIngredientFactory ingredientFactory = new ChinaIngredientFactory(); if (type.equals(CHEESE)) { pizza = new ChinaCheesePizza(ingredientFactory); } else if (type.equals(VEGGIE)) { pizza = new ChinaVeggiePizza(ingredientFactory); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 日本比萨商店子类 */ public class JapanPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; JapanIngredientFactory ingredientFactory = new JapanIngredientFactory(); if (type.equals(CHEESE)) { pizza = new JapanCheesePizza(ingredientFactory); } else if (type.equals(VEGGIE)) { pizza = new JapanVeggiePizza(ingredientFactory); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:14 * @Description 测试 */ public class Main { public static void main(String[] args) { BasePizzaStore chinaPizzaStore = new ChinaPizzaStore(); BasePizza chinaPizza = chinaPizzaStore.orderPizza(BasePizzaStore.CHEESE); System.out.println(chinaPizza.getDough() + \"\\n\" + chinaPizza.getName() + \"完成\"); BasePizzaStore japanPizzaStore = new JapanPizzaStore(); BasePizza japanPizza = japanPizzaStore.orderPizza(BasePizzaStore.VEGGIE); System.out.println(japanPizza.getDough() + \"\\n\" + japanPizza.getName() + \"完成\"); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之装饰者模式","date":"2020-03-11T04:12:09.000Z","path":"posts/2ba79d9e/","text":"装饰者模式 装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 设计原则：类应该对扩展开放，对修改关闭。 特性： 1.装饰者和被装饰对象有相同的超类型。 2.可以用一个或多个装饰者包装一个对象。 3.在任何需要被包装的场合，可以用装饰过的对象代替它。 4.装饰者可以在所委托被装饰者的行为前后增加自己的行为达到特定目的。 5.对象可以在任何时候不限量被装饰（比如运行时）。 装饰者模式UML类图： 原型设计一个饮品订单系统，抽象一个饮品类，让所有的饮品都继承该超类。 为饮品增加调料 问题：饮品中大多都会增加调料，例如咖啡加奶加糖等等。按照原型的设计思路需要新设计一个类（类名为饮品+调料）输出饮品增加了调料后的价格及介绍。这将导致类的数量爆炸式增长。 解决：在饮品抽象类中增加所有出现的调料变量（布尔型），并通过hasX和setX的方式获取和设置调料变量的布尔值。在其子类中需要修改cost方法，调用父类cost方法得知调料价格，再加上子类饮品的价格输出。这样做只需要保留所需的饮品子类即可。 以装饰的方式对饮品增加调料 问题：上述解决方法没有封装变化的部分（出现新的调料就需要不断修改抽象类），而且可能会出现一些饮品不能增加的调料（例如茶+奶泡）或是需要双倍份的调料。 解决：以饮品为主体，在运行时以调料来装饰饮品。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/11 12:20 * @Description 饮品抽象类 */ public abstract class BaseBeverage { /** * 饮品描述 */ String description = \"未知饮品\"; /** * 获取饮品描述 * @return 饮品描述 */ public String getDescription() { return description; } /** * 饮品价格 * @return 饮品价格 */ abstract double cost(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:18 * @Description 调料装饰者抽象类 */ public abstract class BaseCondimentDecorator extends BaseBeverage { /** * 重新实现获取描述的方法 * @return 描述 */ @Override public abstract String getDescription(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:00 * @Description 深焙咖啡饮品实现类 */ public class DarkRoast extends BaseBeverage { DarkRoast() { description = \"深焙咖啡\"; } @Override double cost() { return 0.99; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:03 * @Description 蒸馏咖啡饮品实现类 */ public class Espresso extends BaseBeverage { Espresso() { description = \"浓缩咖啡\"; } @Override double cost() { return 1.99; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:23 * @Description 摩卡调料装饰器实现类 */ public class Mocha extends BaseCondimentDecorator { private BaseBeverage beverage; Mocha(BaseBeverage beverage) { this.beverage = beverage; } @Override public String getDescription() { return beverage.getDescription() + \"+摩卡\"; } @Override double cost() { return beverage.cost() + 0.2; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:26 * @Description 奶泡调料装饰器实现类 */ public class Whip extends BaseCondimentDecorator { private BaseBeverage beverage; Whip(BaseBeverage beverage) { this.beverage = beverage; } @Override public String getDescription() { return beverage.getDescription() + \"+奶泡\"; } @Override double cost() { return beverage.cost() + 0.1; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { BaseBeverage beverage1 = new DarkRoast(); beverage1 = new Mocha(beverage1); System.out.println(\"描述：\" + beverage1.getDescription()); System.out.println(\"价格：\" + beverage1.cost()); BaseBeverage beverage2 = new Espresso(); beverage2 = new Mocha(beverage2); beverage2 = new Whip(beverage2); System.out.println(\"描述：\" + beverage2.getDescription()); System.out.println(\"价格：\" + beverage2.cost()); } } 自定义JAVA I/O装饰者 需求：装饰Reader类，将从控制台读入的所有大写字母转换成小写。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/11 15:17 * @Description Reader组件装饰器：大写转小写 */ public class LowerCaseInputStream extends Reader { private final StreamDecoder sd; public LowerCaseInputStream(InputStream in) { super(in); try { sd = StreamDecoder.forInputStreamReader(in, this, (String) null); } catch (UnsupportedEncodingException e) { throw new Error(e); } } @Override public int read() throws IOException { // 针对字节 int result = super.read(); return result == -1 ? result : Character.toLowerCase(result); } @Override public int read(char[] cbuf, int off, int len) throws IOException { // 针对字节数组 int result = sd.read(cbuf, off, len); for (int i = off; i &lt; off + result; i++) { cbuf[i] = Character.toLowerCase(cbuf[i]); } return result; } @Override public void close() throws IOException { sd.close(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(new LowerCaseInputStream(System.in)); String s = scanner.next(); System.out.println(s); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之观察者模式","date":"2020-03-09T10:08:00.000Z","path":"posts/168b5985/","text":"观察者模式 观察者模式定义了对象之间的一(subject)对多(observer)依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。类似关注up主，up主更新视频时就会推送视频给关注该up主的用户。 设计原则：为了交互对象之间的松耦合设计而努力。（松耦合：当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。） 观察者模式UML图： 原型设计一个气象站发布栏，要求气象站数据更新时，推送最新的数据至订阅了该气象站的用户手中，用户可以自定义数据的显示样式。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:00 * @Description 主题接口 */ public interface Subject { /** * 注册观察者 * @param observer 观察者接口 */ void registerObserver(Observer observer); /** * 删除观察者 * @param observer 观察者接口 */ void removeObserver(Observer observer); /** * 状态更新，通知观察者 */ void notifyObservers(); } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:00 * @Description 观察者接口 */ public interface Observer { /** * 通知观察者状态更新的接口 * @param args 更新数据 */ void update(Object[] args); } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:05 * @Description 信息显示样式接口 */ public interface DisplayElement { /** * 数据展示样式 */ void display(); } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:12 * @Description 主题具体实现类 */ public class WeatherData implements Subject { private ArrayList&lt;Observer> observers; private Object[] args; public WeatherData() { observers = new ArrayList&lt;>(); } @Override public void registerObserver(Observer observer) { int index = observers.indexOf(observer); if (index &lt; 0) { observers.add(observer); } } @Override public void removeObserver(Observer observer) { int index = observers.indexOf(observer); if (index >= 0) { observers.remove(index); } } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(args); } } /** * 通知观察者。 */ public void measurementsChanged() { notifyObservers(); } /** * 设气象数据并通知观察者。 * @param args 更新数据 */ public void setMeasurements(Object[] args) { this.args = args; measurementsChanged(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:21 * @Description 信息显示样式具体实现：目前状况样式 */ public class CurrentConditionsDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private float pressure; @Override public void display() { System.out.println(\"当前状态：\\n温度：\" + temperature + \"\\n湿度：\" + humidity + \"\\n气压：\" + pressure + \"\\n\"); } @Override public void update(Object[] args) { this.temperature = (float) args[0]; this.humidity = (float) args[1]; this.pressure = (float) args[2]; display(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(); weatherData.registerObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{10f, 20f, 30f}); weatherData.setMeasurements(new Float[]{40f, 50f, 60f}); weatherData.removeObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{70f, 80f, 90f}); } } 新增pull功能 问题：上面设计的观察者模式只能通过主题推送数据至观察者，不能由观察者从主题上拉取自己所需数据，当观察者所需数据很小时，这就是个很头疼的问题了，获取了一堆没用的数据。 解决：新增pull功能，当主题更新了数据时通知观察者但不发送数据，观察者从主题处拉取自己所需数据。 代码演示： 修改Observer接口中的update方法。 /** * 通知观察者状态更新的接口 * @param subject 订阅的主题 * @param args 主题参数 */ void update(Subject subject, Object[] args); 修改Subject接口中的notifyObservers方法。 /** * 状态更新，通知观察者 * @param args 参数 */ void notifyObservers(Object[] args); 修改WeatherData类notifyObservers方法和measurementsChanged方法。 @Override public void notifyObservers(Object[] args) { for (Observer observer : observers) { observer.update(this, args); } } /** * 通知观察者。 */ public void measurementsChanged() { // null不推送数据，否则填需要推送的数据。（此处可以提取成动态运行设置是pull还是push） notifyObservers(null); } 弹性更新 问题：当气象站发生很细微的温度变更时就会通知观察者，这并不是我们想要的结果。 解决：将其改成变动半度以上时才更新，可以通过加入tag来标记状态是否进行更新。 代码演示： 新增Subject接口中的方法。 /** * 设置为允许推送 */ void setChanged(); /** * 设置为不允许推送 */ void clearChanged(); /** * 查看是否可推送 */ boolean hasChanged(); 修改WeatherData类的实现。 @Override public void setChanged() { changed = true; } @Override public void clearChanged() { changed = false; } @Override public boolean hasChanged() { return changed; } /** * 通知观察者。 */ public void measurementsChanged() { setChanged(); // null不推送数据，否则填需要推送的数据。（此处可以提取成动态运行设置是pull还是push） notifyObservers(null); } @Override public void removeObserver(Observer observer) { if (changed) { int index = observers.indexOf(observer); if (index >= 0) { observers.remove(index); } clearChanged(); } } 修改CurrentConditionsDisplay类，当没有获取到信息时，手动获取数据。 @Override public void update(Subject subject, Object[] args) { if (subject instanceof WeatherData) { if (args == null) { args = ((WeatherData) subject).getArgs(); } this.temperature = (float) args[0]; this.humidity = (float) args[1]; this.pressure = (float) args[2]; display(); } } JAVA内置观察者模式支持通过使用JAVA内置的Observable和Observer实现观察者模式。 代码演示： 只留下CurrentConditionsDisplay、Main、WeatherData类和DisplayElement接口。并修改前面三个类。 import java.util.Observable; /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:12 * @Description 主题具体实现类 */ public class WeatherData extends Observable { private Object[] args; /** * 通知观察者。 */ public void measurementsChanged() { setChanged(); // 无参则不推送数据，否则填需要推送的数据。（此处可以提取成动态运行设置是pull还是push） notifyObservers(); } /** * 设气象数据并通知观察者。 * @param args 更新数据 */ public void setMeasurements(Object[] args) { this.args = args; measurementsChanged(); } /** * 数据访问 getter * @return 数据 */ public Object[] getArgs() { return args; } } import java.util.Observable; import java.util.Observer; /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:21 * @Description 信息显示样式具体实现：目前状况样式 */ public class CurrentConditionsDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private float pressure; @Override public void display() { System.out.println(\"当前状态：\\n温度：\" + temperature + \"\\n湿度：\" + humidity + \"\\n气压：\" + pressure + \"\\n\"); } @Override public void update(Observable o, Object arg) { if (o instanceof WeatherData) { if (arg == null) { WeatherData weatherData = (WeatherData) o; this.temperature = (float) weatherData.getArgs()[0]; this.humidity = (float) weatherData.getArgs()[1]; this.pressure = (float) weatherData.getArgs()[2]; } else { Object[] args = (Object[]) arg; this.temperature = (float) args[0]; this.humidity = (float) args[1]; this.pressure = (float) args[2]; } display(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(); weatherData.addObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{10f, 20f, 30f}); weatherData.setMeasurements(new Float[]{40f, 50f, 60f}); weatherData.deleteObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{70f, 80f, 90f}); } } Observable注意：Observable是一个类不是接口，限制了复用潜力（无法多继承），违反了针对接口编程的原则。而且Observable是乱序通知观察者的，每次的次序是不相同的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"概率论与数理统计","date":"2020-03-07T10:50:02.000Z","path":"posts/28d5cef4/","text":"概率论的基本概念随机试验随机试验：$\\begin{cases} 在相同条件下可重复。\\\\结果不止一个。\\\\无法预测。 \\end{cases}$ 样本空间、随机事件 样本空间：所有基本事件的集合。 样本点：样本空间的元素。 $A\\subset B$：事件B包含事件A。 $A\\bigcup B=\\{x|x∈A 或 x∈B\\}$：事件A与事件B的和事件（也可以记为$A+B$），即A，B中至少一个发生，事件$A\\bigcup B$发生。 $A\\bigcap B=\\{x|x∈A 且 x∈B\\}$：事件A与事件B的积事件（也可以记为$AB$），即仅当A，B同时发生时，事件$A\\bigcup B$发生。 $A-B=\\{x|x∈A 且 x∈B\\}$：事件A与事件B的差事件，即当且仅当A发生、B不发生时，事件$A-B$发生。 $A\\bigcap B=\\emptyset$：事件A与B是互不相容的（或互斥的），即事件A与事件B不能同时发生。 $A\\bigcup B=S$且$A\\bigcap B=\\emptyset$，事件A与事件B互为逆事件（或事件A与事件B互为对立事件），即事件A、B中必有一个发生，且仅有一个发生（A的对立事件记为$\\hat{A}$，$\\hat{A}=S-A$，S为总事件）。 频率与概率 频率：描述了事件发生的频繁程度，即大量实验统计。 概率：在一次试验中发生的可能性大小的数。频率的稳定值即统计概率。 公理化：$\\begin{cases} 非负性，概率不为负\\\\规范性，P(S)=1\\\\可列可加性 \\end{cases}$。 概率性质：$\\begin{cases} p(\\emptyset)=0。\\\\P(A_1+A_2+\\dots+A_n)=P(A_1)+P(A_2)+\\dots+P(A_n)。\\\\若A\\subset B，则P(B-A)=P(B)-P(A)，P(B)≥P(A)。\\\\对于任一事件A，P(A)≤1。\\\\对于任一事件A，P(\\hat{A})=1-P(A)。\\\\P(A\\bigcup B)=P(A)+P(B)-P(AB)=P(A)+P(B-AB)。 \\end{cases}$ 古典概型 古典概型：$\\begin{cases} 样本点个数有限。\\\\每个基本事件发生的概率相同。 \\end{cases}$，也可称为等可能概型。 $P(A)=\\frac{有利样本点}{样本总数}$，例如$\\frac{骰子偶数点数3}{总骰子数6}$。 不重复排列：$\\begin{cases}P_n^m=n(n-1)(n-2)\\dots(n-m+1)=\\frac{n!}{(n-m)!}\\\\P_n^n=n(n-1)×\\dots×3×2×1=n! \\end{cases}$。重复排列：$\\begin{cases}C_n^m=\\frac{P_n^m}{m!}=\\frac{n!}{m!(n-m)!}\\\\C_n^m=C_n^{n-m}\\\\C_n^0=C_n^n=1 \\end{cases}$。 几何概型：$p(A)=\\frac{\\mu(G)}{\\mu(S)}$，$\\mu$表几何区域内的一种度量（如线段中即长度），与古典概型性质唯一不同的在于几何概型拥有完全可加性，古典概型是有限可加性。 条件概率 条件概率：S样本空间，A，B两个事件，其中$P(B)&gt;0$，称$P(A|B)=\\frac{P(AB)}{P(B)}$为在事件A发生的条件下事件B发生的条件概率。 乘法公式：$P(ABC)=P(A)P(B|A)P(C|AB)$，即先发生了A，然后在A发生的条件下发生了B，最后在AB发生的条件下发生了C。n项的话依次类推。 全概率公式：$A_1,A_2\\dots A_n$是E的完备事件组（互不相容，并是S），$P(A_i)&gt;0$，$P(B)=\\sum_{i=1}^nP(A_i)P(B|A_i)$。知原因推结果。 贝叶斯公式：$A_1,A_2\\dots A_n$是E的完备事件组，B是任一事件，$P(A_i)&gt;0$，$P(B)&gt;0$，$P(A_k|B)=\\frac{P(A_k)P(B|A_k)}{\\sum_{i=1}{n}P(A_i)P(B|A_i}=\\frac{P(A_kB)}{P(B)}$。知结果推原因。 独立性 若$P(A)&gt;0$，$P(B)&gt;0$，$P(A|B)=P(A)$或$P(AB)=P(A)P(B)$，即A的概率不受B发生与否的影响称为独立性。 若事件A与B相互独立，则A与$\\hat{B}$，$\\hat{A}$与B，$\\hat{A}$与$\\hat{B}$都相互独立。 A，B，C三个事件，若满足等式：$\\begin{cases} P(AB)=P(A)P(B)\\\\P(AC)=P(A)P(C)\\\\P(BC)=P(B)P(C)\\\\P(ABC)=P(A)P(B)P(C) \\end{cases}$，则事件A，B，C相互独立。 随机变量及其分布随机变量 在样本空间$S={e}$中，$X=X(e)$每一个样本都对应一个实值单值函数，则称$X=X(e)$为随机变量。 离散型：有限个或无限可列个。 连续型（非离散型）：取值一个或多个区间。 离散型随机变量及其分布律 离散型随机变量X所有可能取的值为$x_k(k=1,2,\\dots)$，X取各个可能值的概率，即事件$\\{X=x_k\\}$的概率为$P\\{X=x_k\\}=p_k$。且$p_k≥0$，$\\sum_{k=1}^\\infty p_k=1$。 伯努利试验：试验只有A和$\\hat{A}$两种可能。 n重伯努利试验：将伯努利试验重复n次，试验之间彼此独立。 $(0-1)$分布：随机变量X只能取0与1两个值，其分布律为$P\\{X=k\\}=p^k(1-p)^{1-k}, k=0,1（0&lt;p&lt;1）$。 几何分布：设$P(A)=p$，第k次首次发生，即前$k-1$次未发生，则$P\\{X=k\\}=(1-p)^{k-1}p，k=1,2,3,\\dots$，记为$X\\sim G(p)$。 二项分布：即n重伯努利试验，记为$X\\sim B(n, p)$。$P(A)=p$，n次试验发生了k次，则$P\\{X=k\\}=C_n^kp^k(1-p)^{n-k}，k=0,1,\\dots,n$。当$n=1$时，二项分布化为$(0-1)$分布。二项分布最可能值：$\\begin{cases} (n+1)p不为整数，[(n+1)p]达到最大值。\\\\(n+1)p是整数，(n+1)p和(n+1)p-1都是最大值。 \\end{cases}$ 泊松分布：$P\\{X=k\\}=\\frac{\\lambda^ke^{-\\lambda}}{k!}，k=0,1,\\dots$，其中$\\lambda&gt;0$，记为$X\\sim P(\\lambda)$或$X\\sim \\pi(\\lambda)$。 超几何分布：不放回抽样试验，N个元素，$N_1$属于第一类，$N_2$属于第二类，取n个，X：n个中属于第一类的个数，$P\\{X=k\\}=\\frac{C_{N_1}^kC_{N_2}^{n-k}}{C_N^n}$，$k=0,1,\\dots,min{n,N_1}$。 不放回抽样实验，当N很大，n相对于N很小时，可以当作放回抽样试验。$P=\\frac{M}{N}$改变小，即$\\frac{n}{N}$小（N总数，M样本数），则$P=\\{X=k\\}=\\frac{C_M^kC_{N-M}^{n-k}}{C_N^n}\\approx C_n^kP^k(1-p)^{n-k}$。 随机变量的分布函数 $F(x)=P\\{X≤x\\}(-\\infty＜x＜\\infty)$，称为X的分布函数（对于离散型，连续型都成立）。 $F(x)$是一个不减函数（或增或保持不变）；$0≤F(x)≤1$,即$F(-\\infty)=\\lim \\limits_{x \\to -\\infty} F(x)=0$，$F(\\infty)=\\lim \\limits_{x \\to \\infty} F(x)=1$。 $F(x)$对于离散型是右连续的（即$F(x+0)=F(x)$），$F(X)$对于连续型是连续的。 连续型随机变量及其概率密度 非负可积$f(x)$，$f(x)≥0$,$a≤b$，则$P\\{a&lt;x≤b\\}=\\int_a^bf(x){\\rm d}x$，记为$X\\sim f(x)$。连续型随机变量不注重端点值，且$f(x)≥0$，$\\int_{-\\infty}^\\infty f(x){\\rm d}x=1$。 对于任意$x_1≤x_2$，$P\\{x_1&lt;X≤x_2\\}=F(x_2)-F(x_1)=\\int_{x_1}^{x_2}f(x){\\rm d}x$。 若$f(x)$在点x处连续，则$F\\prime(x)=f(x)$。 连续变量取个别值的概率为零。 均匀分布：$f(x)=\\begin{cases} \\frac{1}{b-a}，&amp;a&lt;x&lt;b，\\\\0，&amp;其他，\\end{cases}$，记为$X\\sim U(a, b)$。 指数分布：$f(x)=\\begin{cases} \\lambda e^{-\\lambda x}，&amp;x&gt;0，\\\\0，&amp;x≤0，\\end{cases}$，其中$\\lambda &gt;0$，记为$X\\sim Exp(\\lambda)$。 正态分布（高斯分布）：$f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$，$-\\infty&lt;x&lt;\\infty$，记为$X\\sim N(\\mu, \\sigma^2)$。当$x=\\mu$时取得最大值。曲线关于$x=\\mu$对称，对于任意$h&gt;0$都有$P\\{\\mu-h&lt;X≤\\mu\\}=P\\{\\mu&lt;X≤\\mu+h\\}$。$\\sigma$固定，$\\mu$变化，图像左右移动；$\\mu$固定，$\\sigma$变化，$\\begin{cases} \\sigma变小，最高点上移，图像变陡。\\\\\\sigma变大，最高点下移，图像变缓。 \\end{cases}$ 标准正态分布$\\phi_o(x)$：当$\\mu=0$，$\\sigma=1$时，$\\phi_o(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}$。$\\Phi_o(-x)=1-\\Phi_o(x)$，$\\phi_o(x)=\\phi_o(-x)$。$\\phi(x)=\\frac{1}{\\sigma}\\phi_o(\\frac{x-\\mu}{\\sigma})$。若$X\\sim N(\\mu, \\sigma^2)$，则$Z=\\frac{X-\\mu}{\\sigma}\\sim N(0, 1)$。 随机变量的函数的分布 离散型：X代入函数，p不变。若X代入函数之后有相同值则合并（p相加）。 连续型：设X的$f_X(x)$，$y=g(x)$，$Y=g(X)$，则求解步骤为： 得出$F_Y(x)$，$F_Y(x)=P\\{Y≤x\\}$，将其化成$F_X(x)$，$F_X(x)=P\\{X≤x\\}$。 对$F_Y(x)=F_X(x)$求导得$f_Y(x)=f_X(x)$，根据$f_X(x)$写出$f_Y(x)$的分段函数。 多维随机变量及其分布二维随机变量 联合分布函数：$F(x, y)$=$P\\{(X≤x)\\bigcap(Y≤y)\\}$=$P\\{X≤x, Y≤y\\}$。 $F(x, y)$是不减h函数，y固定时，$x_1＜x_2$，$F(x_1, y)≤F(x_2, y)$。 $0≤F(x, y)≤1$，当y固定时$F(-\\infty, y)=0$，$当x固定时F(x, -\\infty)=0$，$F(-\\infty, -\\infty)=0$，$F(\\infty, \\infty)=1$。 对于任意$(x_1, y_1)$，$(x_2, y_2)$，$x_1&lt;x_2$，$y_1&lt;y_2$，则$F(x_2, y_2)-F(x_2, y_1)+F(x_1, y_1)-F(x_1, y_2)≥0$。 边缘分布 离散型边缘分布：简单说就是确定$x_i$，将$x_i$所在的%y_j%概率相加，即为该$x_i$的边缘分布。 连续型边缘分布：$F(x, y)$=$P\\{X≤x, Y≤y\\}$=$\\int_{-\\infty}^x \\int_{-\\infty}^y f(s, t){\\rm d}s{\\rm d}t$，其中$F(x, y)$是联合分布，$f(x, y)$是联合密度。G是XY平面上的一个区域，$P\\{(X, Y)∈G\\}$=${\\int \\int}_G f(x, y){\\rm d}x{\\rm d}y$。 联合分布可唯一确认边缘分布；边缘分布不能确定联合分布；当X，Y独立时，边缘分布才能确定联合分布。 边缘密度函数：已知$f(x, y)$，求$f_X(x)=\\int_{-\\infty}^{+\\infty} f(x, y){\\rm d}y$，$f_Y(x)=\\int_{-\\infty}^{+\\infty} f(x, y){\\rm d}x$，且$f(x, y)$=$f_X(x)f_Y(y)$。 二维正态分布的边缘分布也是正态。 两边缘分布是正态的，二维并非一定是二维正态的。 条件分布 条件分布：$P\\{X=x_i|Y=y_j\\}$=$\\frac{P\\{X=x_i, Y=y_j\\}}{P\\{Y=y_j\\}}$=$\\frac{P_{ij}}{P_j}$。 离散型的条件分布即$\\frac{某点概率}{边缘分布概率}$。 连续型的条件分布：$(X, Y)$，$f(x, y)$，$f_X(x)$，$f_Y(y)$，若$f_Y(y)&gt;0$，在$Y=y$的条件下，$F(x|y)=\\int_{-\\infty}^x \\frac{f(x, y)}{f_Y(y)}{\\rm d}y$。 相互独立的随机变量 二维离散型的独立性：$P_{ij}=x_iy_j$。 二维连续型的独立性：$f(x, y)=f_X(x)f_Y(y)$。 变量独立，则变量构造的函数也独立。 两个随机变量的函数的分布 二维离散型的函数分布：X和Y代入函数，求XY相乘所有的可能，p不变，若有重复的则合并（p相加）。 二维连续型的函数分布：$(X, Y)$，$f(x, y)$，$Z=g(X, Y)$，$F(\\xi)=P\\{Z≤\\xi\\}=P\\{g(X, Y)≤\\xi\\}={\\int\\int}_{D_\\xi} f(x, y){\\rm d}x{\\rm d}y$，求出$f_Z(\\xi)$。 卷积公式：$f_X*f_Y=f_{X+Y}(z)=\\int_{-\\infty}^{\\infty}f_X(z-y)f_Y(y){\\rm d}y=\\int_{-\\infty}^{\\infty}f_X(x)f_Y(z-x){\\rm d}x$。 $Z=\\frac{Y}{X}$：$f_{\\frac{Y}{X}}(z)=\\int_{-\\infty}^{\\infty}|x|f_X(x)f_Y(xz){\\rm d}x$。 $Z=XY$：$f_{XY}(z)=\\int_{-\\infty}^{\\infty}\\frac{1}{|x|}f_X(x)f_Y(\\frac{z}{x}){\\rm d}x$。 $M=max\\{X, Y\\}$：$F_{max}(z)=F_X(z)F_Y(z)$。 $N=min\\{X, Y\\}$：$F_{min}(z)=1-[1-F_X(z)][1-F_Y(z)]$。 随机变量的数字特征数学期望 离散型的期望：若分布律为$P\\{X=x_k\\}=P_k$，$EX=\\sum_{k=1}^\\infty x_kP_k$（$EX$或$E(X)$数学期望），离散型的期望即值乘以概率值相加。 连续型的期望：若概率密度为$\\int_{-\\infty}^{\\infty} xf(x){\\rm d}x$，$EX=\\int_{-\\infty}^{\\infty} xf(x){\\rm d}x$。 离散型函数的期望：$Y=g(X)$，则$EY=\\sum_{k=1}^\\infty g(x_k)P_k$。 连续型函数的期望：$Y=g(X)$，则$EY=\\int_{-\\infty}^{\\infty} g(x)f(x){\\rm d}x$。 二维离散型函数的期望：$Z=g(X, Y)$，则$EZ=\\sum_i\\sum_j g(x_i, y_j)P_{ij}$。 二维连续型函数的期望：$Z=g(X, Y)$，则$EZ=\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty g(x, y)f(x, y){\\rm d}x{\\rm d}y$。 期望的性质：$\\begin{cases} EC=C\\\\E(X+C)=EX+C\\\\E(CX)=CEX\\\\E(kX+b)=kEX+b\\\\E(X±Y)=EX±EY\\\\若X，Y独立，E(XY)=EX EY \\end{cases}$ 条件期望：一个变量取某值，另一个变量的期望。$\\begin{cases} E(X|Y=y_j)=\\sum x_iP(X=x_i|Y=y_j)&amp;离散型\\\\E(X|Y=y)=\\int_{-\\infty}^\\infty xf(x|y){\\rm d}x&amp;连续型 \\end{cases}$。 方差 方差：即随机变量与期望偏离的程度，记为$DX=E(X-EX)^2=EX^2-(EX)^2$，量纲$\\sqrt{DX}$。 离散型方差：$DX=\\sum_k (x_k-EX)^2P_k$。 连续型方差：$DX=\\int_{-\\infty}^\\infty (x-EX)^2f(x){\\rm d}x$。 方差的性质：$\\begin{cases} DC=0\\\\D(X+C)=DX\\\\D(CX)=C^2DX\\\\D(kX+b)=k^2DX\\\\若X，Y独立，D(X±Y)=DX+DY\\\\DX=0\\Leftrightarrow P(X=EX)=1 \\end{cases}$ 若$X^\\ast=\\frac{X-EX}{\\sqrt{DX}}$，则$EX^\\ast=0$，$DX^\\ast=1$。 $(0-1)$分布的期望与方差：$EX=p$，$DX=p(1-p)$。 二项分布的期望与方差：$EX=np$，$DX=np(1-p)$。 几何分布的期望与方差：$EX=\\frac{1}{p}$，$DX=\\frac{1-p}{p^2}$。 泊松分布的期望与方差：$EX=\\lambda$，$DX=\\lambda$。 均匀分布的期望与方差：$EX=\\frac{a+b}{2}$，$DX=\\frac{(b-a)^2}{12}$。 指数分布的期望与方差：$EX=\\frac{1}{\\lambda}$，$DX=\\frac{1}{\\lambda^2}$。 正态分布的期望与方差：$EX=\\mu$，$DX=\\sigma^2$。 协方差及相关系数 协方差：$Cov(X, Y)=E[(X-EX)(Y-EY)]=E(XY)-EXEY$。 $D(X±Y)=DX+DY±2Cov(X, Y)$。 协方差相关性质：$\\begin{cases} Cov(X, Y)=Cov(Y, X)\\\\Cov(aX, bY)=abCov(X, Y)\\\\Cov(X_1+X_2, Y)=Cov(X_1, Y)+Cov(X_2, Y)\\\\Cov(C, X)=0\\\\若X，Y独立，Cov(X, Y)=0 \\end{cases}$。 标准化：若$X^\\ast=\\frac{X-EX}{\\sqrt{DX}}$，$Y^\\ast=\\frac{Y-EY}{\\sqrt{DY}}$，则$Cov(X^\\ast, Y^\\ast)=\\rho=\\frac{Cov(X, Y)}{\\sqrt{DX}\\sqrt{DY}}$。 相关系数：$\\begin{cases} |\\rho|≤1\\\\ [E(XY)]^2≤EX^2EY^2\\\\|\\rho|=1\\Leftrightarrow P\\{Y=a+bX\\}=1，即XY成线性关系 \\end{cases}$ $\\rho=1$则X，Y完全正相关；$\\rho=-1$则X，Y完全负相关；$|\\rho|$接近0则X，Y线性关系不弱；$\\rho=0$则X，Y不存在线性关系。 X，Y独立则X，Y不相关；X，Y不相关则X，Y不一定独立。独立与不相关是等价的。 矩、协方差矩阵 原点矩：$EX^k$，以原点为中心；中心距：$E(X-EX)^k$，以期望为中心。 离散型原点矩：$\\sum x_i^kP_i$。 离散型中心距：$\\int_{-\\infty}{\\infty}x^kf(x){\\rm d}x$。 连续型原点矩：$\\sum (x_i-EX)^kP_i$。 连续型中心距：$\\int_{-\\infty}{\\infty}(x-EX)^kf(x){\\rm d}x$。 大数定律及中心极限定理大数定律 切比雪夫大数定理：$X_1,\\dots,X_n$不相关的变量，$EX_i$和$DX_i$都存在，方差有界，即$DX_i≤M$，对$\\forall \\epsilon&gt;0$时，有$\\lim \\limits_{n \\to \\infty} P\\{|\\frac{1}{n}\\sum_{i=1}^nX_i-\\frac{1}{n}\\sum_{i=1}^nEX_i|&lt;\\epsilon\\}=1$。 伯努利大数定理：假设n重伯努利试验，事件A发生了m次，P是其发生概率，$\\frac{m_n}{n}$即为其频率，当$n \\to \\infty$时，即$\\lim \\limits_{n \\to \\infty}P\\{|\\frac{m_n}{n}-P|&lt;\\epsilon\\}=1$，其概率依概率收敛于它的概率。也有$\\lim \\limits_{n \\to +\\infty}P\\{|\\frac{m_n}{n}-P|≥\\epsilon\\}=0$。 辛钦大数定理：$X_1,\\dots,X_n$独立同分布，且$EX_i=M$，$DX_i=\\sigma^2$，有$\\forall \\epsilon&gt;0$，则$\\lim \\limits_{n \\to \\infty} P\\{|\\frac{1}{n}\\sum_{i=1}^nX_i-\\mu|&lt;\\epsilon\\}=1$。 中心极限定理 $X_1,\\dots,X_n$独立同分布，$EX_i=\\mu$，$DX_i=\\sigma^2$，$0&lt;\\sigma^2&lt;+\\infty$，$\\lim \\limits_{n \\to \\infty}F_n(x)$=$\\lim \\limits_{n \\to \\infty}P\\{\\frac{\\sum_{k=1}^nX_k-n\\mu}{\\sqrt{n}\\sigma}≤x\\}$=$\\int_{-\\infty}^x\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}{\\rm d}t$=$\\Phi(x)$。当n充分大时，$\\frac{\\sum x_i-n\\mu}{\\sqrt{n}\\sigma}\\sim N(0, 1)$，$\\sum_{i=1}^nX_i\\sim N(n\\mu, n\\sigma^2)$。 $Y_n$，n，p二项分布近似正态分布，$\\Phi_o(x)=\\lim \\limits_{n \\to \\infty}P\\{\\frac{Y_n-np}{\\sqrt{np(1-p)}}≤x\\}$，其中$Y_n=\\sum_{i=1}^nX_i$，$X_i=\\begin{cases} 1&amp;发生\\\\0&amp;未发生 \\end{cases}$，$EX_i=P$，$DX_i=p(1-P)$。 样本及抽样分布随机样本$X:(0-1)分布$：$P(X_1=x_1,\\dots,X_n=x_n)$=$P(X_1=x_1)\\dots P(X_n=x_n)$=$P^{x_1}(1-p)^{1-x_1}\\dots P^{x_n}(1-p)^{1-x_n}$=$P^{x_1+\\dots+x_n}(1-p)^{n-(x_1+\\dots +x_n)}$。 抽样分布 统计量：不含任何未知参数的样本构造的函数。 样本平均值：$\\hat{X}=\\frac{1}{n}\\sum_{i=1}^nX_i$。 未修正样本方差：$S_o^2=\\frac{1}{n}\\sum_{i=1}^n(X_i-\\hat{X})^2$。$S^2=\\frac{n}{n-1}S_o^2$。 样本方差：$S^2=\\frac{1}{n-1}\\sum_{i=1}^n(X_i-\\hat{X})^2$。 样本标准方差：$S=\\sqrt{S^2}$。 样本k阶（原点）矩：$A_k=\\frac{1}{n}\\sum_{i=1}^nX_i^k,(k=1,2,\\dots)$。$A_1=\\hat{X}$。 样本k阶中心距：$B_k=\\frac{1}{n}\\sum_{i=1}^n(X_i-\\hat{X})^k,(k=2,3,\\dots)$。$B_2=S_o^2$。$S^2=\\frac{n}{n-1}B_2$。 协方差：$S_{1,2}=\\frac{1}{n}(X_i-\\hat{X})(Y_i-Y)$。 两样本之间的相关系数：$R=\\frac{S_{1,2}}{S_1S_2}$。 总体X的均值为$EX=\\mu$，方差为$DX=\\sigma^2$，样本（$X_1,X_2,\\dots,X_n$）来自总体X，则$E\\hat{X}=\\mu$，$D\\hat{X}=\\frac{1}{n}\\sigma^2$，$ES^2=\\sigma^2$。 卡方分布： $X_1,\\dots,X_n$独立且是来自$N(0, 1)$的样本，则$\\chi^2=\\sum_{i=1}^nx_i^2\\sim \\chi^2(n)$。 $EX=n$，$DX=2n$。 由中心极限定理得$X\\sim \\chi^2(n)$，$Y\\sim \\chi^2(m)$，X, Y独立，则$X+Y\\sim \\chi^2(m+n)$。 $X_i\\sim \\chi^2(m_i)$，独立，$\\sum_{i=1}^nX_i\\sim \\chi^2(\\sum_{i=1}^nm_i)$。 上$\\alpha$分位数：$P(\\chi^2&gt;\\chi^2_alpha(n))=\\alpha$。$\\chi^2$相当于变量，$\\chi^2_alpha(n)$相当于一个点，$\\alpha$相当于面积。 $\\chi^2(2)$是$\\lambda=\\frac{1}{2}$的指数分布。 $\\chi^2(n)$是单峰曲线，在$n-2$时取得最大值。 当$n=2$时曲线不对称，当n增大图像越接近对称，且在n很大时，可用正态分布近似。 t分布： 若$X\\sim N(0, 1)$，$Y\\sim \\chi^2(n)$，X, Y独立，则$t(n)\\sim\\frac{X}{\\sqrt{\\frac{Y}{n}}}$。 上$\\alpha$分位数：$P(T&gt;t_\\alpha(n))=\\alpha$。 $t_{1-\\alpha}(n)$=$-t_\\alpha(n)$。 n越小，其图像与正态分布差距越大（$n≥30$，与正态分布区别很小）。 F分布： $X\\sim \\chi^2(n_1)$，$Y\\sim \\chi^2(n_2)$，X, Y独立，$F(n_1, n_2)\\sim \\frac{\\frac{X}{n_1}}{\\frac{Y}{n_2}}$。 $\\frac{1}{F}\\sim F(n_2, n_1)$。 上$\\alpha$分位数：$P(F&gt;F_\\alpha(n_1, n_2)=\\alpha$。 $F_{1-\\alpha}(n_1, n_2)=\\frac{1}{F_\\alpha(n_2, n_1)}$。 正态总体下的抽样分布： $X\\sim N(\\mu, \\sigma^2)$，$\\{X_1,\\dots,X_n\\}$样本，则$E\\hat{X}=\\mu$，$D\\hat{X}=\\frac{\\sigma^2}{n}$，$\\frac{\\hat{X}-\\mu}{\\sigma}\\sqrt{n}\\sim N(0, 1)$，即$E(S^2)=\\sigma^2$。 $\\hat{X}\\sim N(\\mu, \\frac{\\sigma^2}{n})$。 $\\frac{(n-1)S^2}{\\sigma^2}\\sim \\chi^2(n-1)$，$\\hat{X}$与$S^2$独立。 $\\frac{1}{\\sigma^2}\\sum_{i=1}^n(X_i-\\mu)^2\\sim \\chi^2(n)$。 $\\frac{\\hat{X}-\\mu}{S}\\sqrt{n}\\sim t(n-1)$。 两个正态总体：$X\\sim N(\\mu_1, \\sigma_1^2)$，$Y\\sim N(\\mu_2, \\sigma_2^2)$，样本$\\{X_1,\\dots,X_{n_1}\\}$，$\\{Y_1,\\dots,Y_{n_2}\\}$，$\\begin{cases} \\frac{(\\hat{X}-\\hat{Y})-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}}\\sim N(0, 1)\\\\\\frac{\\frac{S_1^2}{\\sigma_1^2}}{\\frac{S_2^2}{\\sigma_2^2}}\\sim F(n_1-1, n_2-1)\\\\ \\sigma_1^2=\\sigma_2^2=\\sigma 时，T=\\frac{(\\hat{X}-\\hat{Y})-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}}\\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}}}\\sim t(n_1+n_2-2) \\end{cases}$ 参数估计点估计 点估计：通过一个样本估计总体未知参数。 矩估计法：以样本矩的连续函数作为相应的总体矩的连续函数的估计量。$A_n=\\frac{1}{n}\\sum X_i^2$。 极大似然估计法： 1.写出总体的概率函数或密度函数。 2.写出似然函数$L(\\lambda)=\\prod_{i=1}^2\\frac{\\lambda^{x_i}}{x_i!}e^{-\\lambda}$（此处以泊松分布为例，似然函数即将样本观测值代入1.式并连乘）。 3.需使似然函数取最大值，两边取$ln$。 4.对$\\lambda$求导（此处$\\lambda$根据概率函数或者密度函数改变）。 估计量的评选标准 无偏性： 估计的参数的估计值的期望是其真实的值，即$E\\hat{\\theta}=\\theta$。 总体$X$，$EX=\\mu$，$DX=\\sigma^2$，$(X_1,\\dots,X_n)$，总体与任何分布无关，则$\\begin{cases}\\hat{X}是\\mu的无偏估计，E\\hat{X}=\\mu。\\\\样本方差S^2是\\sigma^2的无偏估计，ES^2=\\sigma^2。\\\\未修正样本方差S_o^2是\\sigma^2的有偏估计。\\\\n \\to \\infty，渐进无偏估计。\\\\ \\hat{\\theta}是\\theta的无偏估计，g(\\hat{\\theta})不一定是g(\\theta)的无偏估计。\\\\DS=\\sigma^2-(ES)^2，ES=\\sqrt{\\sigma^2-DS}≤\\sigma（一般不等于）。 \\end{cases}$ 有效性：$D(\\hat{\\theta}_1)≤D(\\hat{\\theta}_2)$，方差越小越有效。 相合性（一致性）：$\\lim \\limits_{n \\to +\\infty}P(|\\hat{\\theta}-\\theta|&lt;\\epsilon)=1$。 区间估计 置信区间：$[\\hat{\\theta_1},\\hat{\\theta_2}]$能套住$\\theta$的概率，即以区间估计的区域套住$\\theta$的概率。 枢轴变量：即通过先确定两个数来确定未知数。 $I=I(T, \\theta)$，其中$T$已知，$\\theta$未知，枢轴变量I的分布F已知且与$\\theta$无关。 给定$1-\\alpha$，确定F分布的上$$分位数，上$$分位数，即$P\\{V_{1-\\frac{\\alpha}{2}}≤I(T, \\theta)≤V_{\\frac{\\alpha}{2}}\\}=1-\\alpha$。 正态总体均值与方差的区间估计 若给定置信水平$1-\\alpha$，$X_1,\\dots,X_n$为$N(\\mu, \\sigma^2)$的样本，已知$\\hat{X}$，$S^2$。 $\\sigma^2$已知，枢轴变量$\\frac{\\hat{X}-\\mu}{\\frac{\\sigma}{\\sqrt{n}}}$，$1-\\alpha$的置信区间$(\\hat{X}±\\frac{\\sigma}{\\sqrt{n}}z_{\\frac{\\alpha}{2}})$。 $\\sigma^2$未知，枢轴变量$\\frac{\\hat{X}-\\mu}{\\frac{\\sigma}{\\sqrt{n}}}\\sim t(n-1)$，$1-\\alpha$的置信区间$(\\hat{X}±\\frac{S}{\\sqrt{n}}t_{\\frac{\\alpha}{2}}(n-1))$。 单个总体$N(\\mu, \\sigma^2)$情况表 估计表 $\\mu$ $\\sigma^2$已知 $\\frac{\\hat{X}-\\mu}{\\sigma}\\sqrt{n}\\sim N(0, 1)$ $[\\hat{X}-\\frac{\\sigma}{\\sqrt{n}}\\mu_{\\frac{\\alpha}{2}}, \\hat{X}+\\frac{\\sigma}{\\sqrt{n}}\\mu_{\\frac{\\alpha}{2}}]$ $\\mu$ $\\sigma^2$未知 $\\frac{\\hat{X}-\\mu}{S}\\sqrt{n}\\sim t(n-1)$ $[\\hat{X}-\\frac{S}{\\sqrt{n}}t_{\\frac{\\alpha}{2}}(n-1), \\hat{X}+\\frac{S}{\\sqrt{n}}t_{\\frac{\\alpha}{2}}(n-1)]$ $\\sigma^2$ $\\mu$已知 $\\frac{1}{\\sigma^2}\\sum_{i=1}^n(X_i-\\mu)^2\\sim \\chi^2(n)$ $[\\frac{\\sum(X_i-\\mu)^2}{\\chi^2_{\\frac{\\alpha}{2}}(n)}, \\frac{\\sum(X_i-\\mu)^2}{\\chi^2_{1-\\frac{\\alpha}{2}}(n)}]$ $\\sigma^2$ $\\mu$未知 $\\frac{(n-1)S^2}{\\sigma^2}\\sim \\chi^2(n-1)$ $[\\frac{(n-1)S^2}{\\chi^2_{\\frac{\\alpha}{2}}(n-1)}, \\frac{(n-1)S^2}{\\chi^2_{1-\\frac{\\alpha}{2}}(n-1)}]$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"高等数学","date":"2020-03-02T05:00:25.000Z","path":"posts/93e4730e/","text":"函数与极限映射 $D_f$是定义域(domain)，$R_f$是值域(range)。$x∈X$，对应的 y 是唯一的。（$R_f\\subset Y, R_f≠Y$） 满射：$R_f=Y$。 单射：$x_1≠x_2, f(x_1)≠f(x_2)$，即x和f(x)唯一对应。 一一映射：满足单射和满射。 逆映射：设$f:X→Y$且满足单射，每个$y∈R_f$，有唯一的$x∈X, f(x)=y, g:R_f→X$，则$D_{f^{-1}}=R_f, R_{f^{-1}}=X$。 复合映射：$g:X→Y_1, f:Y_2→Z$，且$Y_1 \\subset Y_2, x∈X$，则$f[g(x)]∈Z$。 函数 函数特性：有界性、单调性、奇偶性和周期性。 反函数：若$f:D→f(D)$，且满足单射，则$f^{-1}:f(D)→D$。$f$与$f^{-1}$关于$y=x$对称，所以$f$单调增(减)时，$f^{-1}$也单调增(减)。 复合函数：$y=f(t), t=g(x)$，则$y=f(g(x))$，其中$t=g(x)$的值域必须落在$y=f(t)$的定义域内。 初等函数：由常数和基本初等函数（幂、指数、对数、三角和反三角函数）经过有限次的四则运算和函数复合所构成的函数。 极限 数列极限定义：$\\forall \\epsilon &gt;0$，$\\exists 正整数N$，当$n&gt;N$时，$|x_n-a|&lt;\\epsilon$，其中a就是极限，记作$\\lim \\limits_{n \\to \\infty} x_n=a$或$x_n \\to a(n \\to \\infty)$。也就是说N是数列中的某一项，$n&gt;N$表示该项后面的所有项，$|x_n-a|&lt;\\epsilon$表示该项后面的所有项都落在$\\epsilon$那么大的小区域中。 自变量趋于有限值时函数的极限定义：$\\forall \\epsilon &gt;0$，$\\exists \\delta&gt;0$，当$0&lt;|x-x_0|&lt; \\delta$时，有$|f(x)-A|&lt;\\epsilon$，记作$\\lim \\limits_{x \\to x_0} f(x)=A$或$f(x) \\to A(x \\to x_0)$。也就是说当x趋于$x_0$时，函数f(x)趋于A，f(x)在$x_0$的去心领域内有定义（注在$x_0$处可以没有定义）。 自变量趋于无穷大时函数的极限定义：$\\forall \\epsilon &gt;0$，$\\exists X&gt;0$，当$|x|&gt; X$时，有$|f(x)-A|&lt;\\epsilon$，记作$\\lim \\limits_{x \\to \\infty} f(x)=A$或$f(x) \\to A(x \\to \\infty)$。 单侧极限： 左极限：$\\lim \\limits_{x \\to x_o^-} f(x)=A$，从左边逼近； 右极限：$\\lim \\limits_{x \\to x_o^+} f(x)=A$，从右边逼近； f(x)极限存在。$\\Leftrightarrow$左右极限均存在且相等。 极限性质 类型 性质 数列 1.极限唯一；2.有界性；3.保号性；4.若数列$\\{x_n\\}$收敛于a，那么它的任一子数列也收敛，且极限也是a。 函数 1.极限唯一；2.局部有界性；3.局部保号性；4.海涅定理：若$\\lim \\limits_{x \\to x_o} f(x)=A$，且$\\{x_n\\} \\to x_0$，则$\\lim \\limits_{n \\to \\infty} f(x_n)=\\lim \\limits_{x \\to x_o} f(x)=A$。 无穷小和无穷大 无穷小定义：$x \\to x_0(x \\to \\infty)$，$f(x)$的极限是0。（0是可以作为无穷小的唯一常数。） 无穷大定义：$x \\to x_0(x \\to \\infty)$，$f(x)$的极限是$\\infty$。 $f(x)$是无穷小，则$\\frac{1}{f(x)}$是无穷大；$f(x)$是无穷大，则$\\frac{1}{f(x)}$是无穷小。 极限运算法则 有限个无穷小的和(差)是无穷小。 有界函数与无穷小的乘积是无穷小。 常数与无穷小的乘积是无穷小。 有限个无穷小的乘积是无穷小。 若$\\phi(x)≥\\psi(x)$，则$\\lim \\phi(x)≥\\lim \\psi(x)$。 $\\lim \\limits_{x \\to \\infty} \\frac{a_0x^m+a_1x^{m-1}+\\cdots+a_m}{b_0x^n+b_1x^{n-1}+\\cdots+b_n} = \\begin{cases} 0,&amp;当n&gt;m,\\\\\\frac{a_0}{b_0},&amp;当n=m,\\\\\\infty,&amp;当n&lt;m. \\end{cases}$ 极限存在准则，两个重要极限 夹逼准则：$g(x)≤f(x)≤h(x)$，若$\\lim g(x)=A$,$\\lim h(x)=A$，则$\\lim f(x)=A$。 $\\lim \\limits_{x \\to 0} \\frac{sinx}{x}=A$。 单调有界数列必有极限。 $\\lim \\limits_{x \\to \\infty} (1+\\frac{1}{x})^x=e$或$\\lim \\limits_{x \\to 0} (1+x)^\\frac{1}{x}=e$。即$(1+0)^\\infty$的样子。 柯西极限存在准则：$\\{x_n\\}$收敛$\\Leftrightarrow$$\\forall \\epsilon, \\exists N, m&gt;N, n&gt;N$时，则$|x_n-x_m|&lt;\\epsilon$。即任取某一项N，在该项之后任取两项m和n，他们之间的距离很小。 无穷小的比较无穷小的比较即比较趋向于0的速度快慢。 $\\lim \\frac{\\beta}{\\alpha}=0$，则$\\beta$是比$\\alpha$高阶的无穷小，记作$\\beta=o(\\alpha)$。 $\\lim \\frac{\\beta}{\\alpha}=\\infty$，则$\\beta$是比$\\alpha$低阶的无穷小。 $\\lim \\frac{\\beta}{\\alpha}=c≠0$，则$\\beta$与$\\alpha$是同阶无穷小。 $\\lim \\frac{\\beta}{\\alpha^k}=c≠0$，则$\\beta$是关于$\\alpha$的k阶无穷小 $\\lim \\frac{\\beta}{\\alpha}=1$，则$\\beta$与$\\alpha$是等价无穷小，记作$\\alpha\\sim\\beta$。 $\\beta$与$\\alpha$等价。$\\Leftrightarrow$$\\beta=\\alpha+o(\\alpha)$。 $\\alpha\\sim\\widetilde{\\alpha}$，$\\beta\\sim\\widetilde{\\beta}$，且$\\lim \\frac{\\widetilde{\\beta}}{\\widetilde{\\alpha}}$存在，则$\\lim \\frac{\\beta}{\\alpha}=\\lim \\frac{\\widetilde{\\beta}}{\\widetilde{\\alpha}}$ 当$x \\to 0$时，求两个无穷小比(做乘除运算)的极限时，分子及分母可用等价无穷小来替换。常用等价替换：$sinx\\sim x$$tanx\\sim x$$arcsinx\\sim x$$arctanx\\sim x$$ln(1+x)\\sim x$$e^x-1\\sim x$$a^x\\sim 1+xlna$$1-cosx\\sim \\frac{1}{2}x^2$$(1+x)^\\frac{1}{n}-1\\sim \\frac{1}{n}x$$(1+x)^\\alpha\\sim 1+\\alpha x$ 函数的连续性与间断点 $\\lim \\limits_{\\Delta x \\to 0} \\Delta y=\\lim \\limits_{\\Delta x \\to 0} [f(x_0+\\Delta x)-f(x_0)]=0$。 $\\lim \\limits_{x \\to x_0} f(x)=f(x_0)$。即连续性的条件为$\\begin{cases} 1.在x_0处有极限。\\\\2.在x_0处有定义。\\\\3.极限等于函数值。 \\end{cases}$ 连续。$\\Leftrightarrow$左、右连续。 左连续：$\\lim \\limits_{x \\to x_0^-} f(x)=f(x_0)$。 右连续：$\\lim \\limits_{x \\to x_0^+} f(x)=f(x_0)$。 间断即不满足连续的条件。间断点类型： 第一类间断点(左右极限都存在)：可去间断点、跳跃间断点。 第二类间断点(左右极限至少一个不存在)：无穷间断点、震荡间断点。 连续函数的运算与初等函数的连续性 函数$f(x)$和$g(x)$在点$x_0$连续，则它们的和(差)、积(商)都在点$x_0$处连续。 如果函数$y=f(x)$在区间$I_x$上单调递增(或单调递减)且连续，那么它的反函数$x=f^{-1}(y)$也在对应的区间$I_y$上单调递(或单调递减)增且连续。 $y=f[g(x)]$由$u=g(x)$与$y=f(u)$复合而成，若$\\lim \\limits_{x \\to x_0} g(x)=u_0$，而$y=f(u)$在$u=u_0$连续，则$\\lim \\limits_{x \\to x_0} f[g(x)]=\\lim \\limits_{u \\to u_0} f(u)=f(u_0)$。即$\\lim \\limits_{x \\to x_0} f[g(x)]=f[\\lim \\limits_{x \\to x_0} g(x)]$。 $y=f[g(x)]$由$u=g(x)$与$y=f(u)$复合而成，若$u=g(x)$在$x=x_0$连续，且$g(x_0)=u_0$，而$y=f(u)$在$u=u_0$连续，则$y=f[g(x)]$在$x=x_0$也连续。 基本初等函数在其定义域内都是连续的；一切初等函数在其定义区间内都是连续的。 闭区间上连续函数的性质 在闭区间上连续的函数在该区间上有界且一定能取得它的最大值和最小值。 零点定理：函数$f(x)$在闭区间$[a, b]$上连续，且$f(a)$与$f(b)$异号(即$f(a)*f(b)&lt;0$)，则在开区间$(a, b)$内至少有一点$\\xi$，使得$f(\\xi)=0$。 介值定理：函数$f(x)$在闭区间$[a, b]$上连续，且在该区间的端点取不同的函数值$f(a)=A$及$f(b)=B$，则对于A与B之间的任意一个数C，在开区间$(a, b)$内至少有一点$\\xi$，使得$f(\\xi)=C(a&lt;\\xi&lt;b)$。 在闭区间$[a, b]$上连续的函数$f(x)$的值域为闭区间$[m, M]$，其中m与M依次为$f(x)$在$[a, b]$上的最小值与最大值。 导数与微分导数概念 由于自变量x的变化引起函数$y=f(x)$变化的“快慢”问题，即函数的变化率称为导数。 $y=f(x)$在点$x_0$的某个邻域内有定义，当$x$在$x_0$处取得增量$\\Delta x$时，$x_0 \\to x_0+\\Delta x$，$\\Delta y = f(x_0+\\Delta x)-f(x_0)$。若$\\Delta y$与$\\Delta x$之比当$\\Delta x\\to 0$时的极限存在，则称$y=f(x)$在点$x_0$处可导，记为$f^\\prime (x_0)$=$\\lim \\limits_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x}$=$\\lim \\limits_{\\Delta x \\to 0} \\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}$=$\\lim \\limits_{x \\to x_0} \\frac{f(x)-f(x_0)}{x-x_0}$或记为$y^\\prime |_{x=x_0}$=$\\frac{dy}{dx}|_{x=x_0}$=$\\frac{df(x)}{dx}|_{x=x_0}$。其中$\\frac{dy}{dx}$表示y对x求导。 单侧导数： 左导数：$f^\\prime_-$=$\\lim \\limits_{h \\to 0^-} \\frac{f(x_0+h)-f(x_0)}{h}$=$\\lim \\limits_{x \\to x_0^-} \\frac{f(x)-f(x_0)}{x-x_0}$，从左边逼近； 右导数：$f^\\prime_+$=$\\lim \\limits_{h \\to 0^+} \\frac{f(x_0+h)-f(x_0)}{h}$=$\\lim \\limits_{x \\to x_0^+} \\frac{f(x)-f(x_0)}{x-x_0}$，从右边逼近； 可导。$\\Leftrightarrow$左右导数均存在且相等。 导数的几何意义： 在某一点的导数即该点的切线的斜率，$k_切=f^\\prime(x_0)=tan\\alpha$，$k_法=-\\frac{1}{f^\\prime(x_0)}$。 若$y=f(x)$，$f^\\prime(x_0)=\\infty$，表切线垂直于x轴。 可导必连续，连续不一定可导。（$\\lim \\limits_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x}$存在即可导，$\\lim \\limits_{\\Delta x \\to 0} \\Delta y=0$即连续。） 函数的求导法则 常数和基本初等函数的导数公式：$(C)^\\prime=0$$(x^\\mu)^\\prime=\\mu x^{\\mu-1}$$(a^x)^\\prime=a^xlna(a&gt;0, a≠1)$$(e^x)^\\prime=e^x$$(lnx)^\\prime=\\frac{1}{x}$$(log_ax)^\\prime=\\frac{1}{xlna}(a&gt;0, a≠1)$$(sinx)^\\prime=cosx$$(cosx)^\\prime=-sinx$$(tanx)^\\prime=sec^2x$$(cotx)^\\prime=-csc^2x$$(sec)^\\prime=secxtanx$$(cscx)^\\prime=-cscxcotx$$(arcsinx)^\\prime=\\frac{1}{\\sqrt{1-x^2}}$$(arccosx)^\\prime=-\\frac{1}{\\sqrt{1-x^2}}$$(arctanx)^\\prime=\\frac{1}{1+x^2}$$(arccotx)^\\prime=-\\frac{1}{1+x^2}$$(shx)^\\prime=chx$$(chx)^\\prime=shx$$(thx)^\\prime=\\frac{1}{ch^2x}$$(arshx)^\\prime=\\frac{1}{\\sqrt{1+x^2}}$$(archx)^\\prime=\\frac{1}{\\sqrt{x^2-1}}$$(arthx)^\\prime=\\frac{1}{1-x^2}$ 函数的和、差、积、商的求导法则：$(u±v)^\\prime=u^\\prime±v^\\prime$$(Cu)^\\prime=Cu^\\prime(C是常数)$$(uv)^\\prime=u^\\prime v+uv^\\prime$$(\\frac{u}{v})^\\prime=\\frac{u^\\prime v-uv^\\prime}{v^2}$ 反函数求导：$x=f(y)$在$I_y$内单调、可导且$f^\\prime(y)≠0$，则其反函数$y=f^\\prime(x)$在对应区间内也可导，$[f^\\prime(x)]^\\prime=\\frac{1}{f^\\prime(y)}$或$\\frac{dy}{dx}=\\frac{1}{\\frac{dx}{dy}}$。即反函数的导数等于直接函数导数的倒数。 复合函数求导：若$u=g(x)$在点x可导，而$y=f(u)$在点$u=g(x)$可导，则$y=f[g(x)]$在点x可导，$\\frac{dy}{dx}=f^\\prime(u)·g^\\prime(x)$或$\\frac{dy}{dx}=\\frac{dy}{du}·\\frac{du}{dx}$。 高阶导数 对函数做n次求导叫做n阶导数，记作$\\frac{d^ny}{dx^n}$或$y^{(n)}(x)$。 常用高阶导数：$(a^x)^{(n)}=a^x(lna)^n$$(sinx)^{(n)}=sin(x+\\frac{n\\pi}{2})$$(cosx)^{(n)}=cos(x+\\frac{n\\pi}{2})$$(x^n)^{(n)}=n!$$(x^n)^{(n+k)}=0(k=1, 2, \\dots)$$(uv)^{(n)}=\\sum_{k=0}^n C_n^ku^{(n-k)}v^{(k)}$$[ln(1+x)]^{(n)}=(-1)^{(n-1)}\\frac{(n-1)!}{(1+x)^n}$ 隐函数及参数方程求导 $y=sinx$类型是显函数，$x+y^3-1=0$类型是隐函数。此处隐函数同时两边对x求导得到$y^\\prime=\\dots$的型式即可。 参数方程$\\begin{cases} x=\\phi(t)\\\\y=\\Phi(t) \\end{cases}$，$\\frac{dy}{dx}=\\frac{\\frac{dy}{dt}}{\\frac{dx}{dt}}=\\frac{\\Phi^\\prime}{\\phi^\\prime}$。 函数的微分 由于自变量x的微小改变（增量$|\\Delta x|$很小时）引起$y=f(x)$的改变量$\\Delta y$的近似值问题，即微分问题。 $y=f(x)$在某区间内有定义，若$x_0 \\to x_0+\\Delta x$，则$\\Delta y=f(x_0+\\Delta x)-f(x_0)$（精确值）可表示成$\\Delta y=A\\Delta x+o(\\Delta x)$（近似值，$o(\\Delta x)$可忽略不计），A是不依赖$\\Delta x$的常数，称$y=f(x)$可微。其中$A\\Delta x$叫做$y=f(x)$在点$x_0$相应于$\\Delta X$的微分，记作$dy=A\\Delta x$。 可微。$\\Leftrightarrow$可导，$dy=f^\\prime(x)dx$（$\\Delta x=dx$，$A=f^\\prime(x)$）。 函数的微分运算法则微分公式与法则都和导数差不多。 微分的几何意义通过$\\Delta y=f(x_0+\\Delta x)-f(x_0)$与$dy=f^\\prime(x_0)\\Delta x$作图即可得知。（曲线，切线，$x_0$，$x_0+\\Delta x$，$\\Delta y$和$dy$） 微分中值定理与导数的应用微分中值定理 费马引理：$f(x)$在点$x_0$的某邻域$U(x_0)$内有定义，且在$x_0$处可导，若$f(x)≤f(x_0)$（$f(x)≥f(x_0)$），$\\forall x∈U(x_0)$，则$f^\\prime(x_0)=0$。 罗尔定理：$f(x)$满足$\\begin{cases} 1.在[a, b]上连续。\\\\2.在(a, b)内可导。\\\\3.f(a)=f(b)。 \\end{cases}$，则至少有一点$\\xi∈(a, b)$，使得$f^\\prime(\\xi)=0$。 拉格朗日中值定理：$f(x)$满足$\\begin{cases} 1.在[a, b]上连续。\\\\2.在(a, b)内可导。 \\end{cases}$，则至少有一点$\\xi∈(a, b)$，使得$f(b)-f(a)=f^\\prime(\\xi)(b-a)$。即$f^\\prime(\\xi)=\\frac{f(b)-f(a)}{b-a}$，相当于求斜率。 柯西中值定理：$f(x)$及$F(x)$满足$\\begin{cases} 1.在[a, b]上连续。\\\\2.在(a, b)内可导。\\\\3.\\forall x∈(a, b)，F^\\prime(x)≠0。 \\end{cases}$，则至少有一点$\\xi∈(a, b)$，使得$\\frac{f(b)-f(a)}{F(b)-F(a)}=\\frac{f^\\prime(\\xi)}{F^\\prime(\\xi)}$。 $f(x)$在区间I上连续，在I内可导且导数恒为零，则$f(x)=C$（C为常数）。 洛必达法则若$\\begin{cases} 1.当x \\to a时，f(x)和F(x) \\to 0。\\\\2.在点a的某去心邻域内，f^\\prime(x)及F^\\prime(x)都存在且F^\\prime≠0。\\\\3.\\lim \\limits_{x \\to a} \\frac{f^\\prime(x)}{F^\\prime(x)}存在或为无穷大。\\\\ \\end{cases}$，则$\\lim \\limits_{x \\to a} \\frac{f(x)}{F(x)}=\\lim \\limits_{x \\to a} \\frac{f^\\prime(x)}{F^\\prime(x)}$。（将条件$x \\to a$改为$x \\to \\infty$同样适用。） 泰勒公式 泰勒中值定理1：$f(x)$在$x_0$处有n阶导数，$\\exists x_0$的一个邻域，对于该邻域内的任一x，有$f(x)=f(x_0)+f^\\prime(x_0)(x-x_0)+\\frac{f^{\\prime\\prime}(x_0)}{2!}(x-x_0)^2+\\dots+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)$，其中$R_n(x)=o((x-x_0)^n)$。 泰勒中值定理2：$f(x)$在$x_0$的某个邻域$U(x_0)$内具有(n+1)阶导数，$\\forall x∈U(x_0)$，有泰勒中值定理1的公式，其中$R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{n+1}$($\\xi$是$x_0$与$x$之间的某个值)。 当泰勒中值定理2的公式中$n=0$时，就变成了拉格朗日中值公式。 当泰勒中值定理1的公式中$x_0=0$时，就变成了带有佩亚诺余项的麦克劳林公式，$f(x)=f(0)+f^\\prime(0)x+\\frac{f^{\\prime\\prime}(0)}{2!}x^2+\\dots+\\frac{f^{(n)}(0)}{n!}x^n+o(x^n)$。 当泰勒中值定理2的公式中$x_0=0$时，就变成了带有拉格朗日余项的麦克劳林公式，$f(x)=f(0)+f^\\prime(0)x+\\frac{f^{\\prime\\prime}(0)}{2!}x^2+\\dots+\\frac{f^{(n)}(0)}{n!}x^n+\\frac{f^{(n+1)}(\\theta x)}{(n+1)!}x^{n+1}(0&lt;\\theta&lt;1)$。 函数的单调性与曲线的凹凸性 $y=f(x)$在$[a, b]$上连续，在$(a, b)$内可导。则在$(a, b)$内$f^\\prime(x)≥0$($f^\\prime(x)≤0$)，且等号仅在有限多个点处成立，则$y=f(x)$在$[a, b]$上单调增加(减少)。 $y=f(x)$在$[a, b]$上连续，在$(a, b)$内具有一阶和二阶导数。则在$(a, b)$内$f^{\\prime\\prime}(x)&gt;0$($f^{\\prime\\prime}(x)&lt;0$)，$y=f(x)$在$[a, b]$上的图形是凹(凸)的。 导数为零的点称为驻点或临界点；在$f^{\\prime\\prime}(x)=0$或二阶导数不存在的点左右异号则该点就是拐点。 函数的极值与最大值最小值 $f(x)$在$x_0$处可导，且在$x_0$处取得极值，则$f^\\prime(x_0)=0$。 $f(x)$在$x_0$处连续，且在$x_0$的某去心邻域可导。 若$x∈(x_0-\\delta, x_0)$时，$f^\\prime(x)&gt;0$，而$x∈(x_0, x_0+\\delta)$，$f^\\prime(x)&lt;0$，则$f(x)$在$x_0$处取得极大值。 若$x∈(x_0-\\delta, x_0)$时，$f^\\prime(x)&lt;0$，而$x∈(x_0, x_0+\\delta)$，$f^\\prime(x)&gt;0$，则$f(x)$在$x_0$处取得极小值。 若$x∈(x_0-\\delta, x_0)\\bigcup(x_0, x_0+\\delta)$时，$f^\\prime(x)$的符号保持不变，则$f(x)$在$x_0$处没有极值。 $f(x)$在$x_0$处具有二阶导数且$f^\\prime(x_0)=0$，$f^{\\prime\\prime}≠0$，则当$f^{\\prime\\prime}&lt;0$($f^{\\prime\\prime}&gt;0$)时，$f(x)$在$x_0$处取得极大值(极小值)。 将驻点及不可导点带入函数取区间上的最大值和最小值就是函数的最大值和最小值。 函数图形的描绘描绘步骤为： 确定定义域和间断点，判断函数的奇偶性和周期性。 求$f^\\prime(x)$和$f^{\\prime\\prime}$，根据$f^\\prime(x)=0$、$f^{\\prime\\prime}=0$以及间断点分开区间。 确定$y=f(x)$的单调增、减区间，求出极值。 确定$y=f(x)$的凹凸区间和拐点。 取间断点求渐近线方程，共三种： 斜率渐近线：$k=\\lim \\limits{x \\to +\\infty} \\frac{f(x)}{x}$，$b=\\lim \\limits{x \\to +\\infty}[f(x)-kx]$。 垂直渐近线：$x \\to x_0$时，$f(x) \\to \\infty$，则$x=x_0$就是渐近线。 水平渐近线：$k=0$时的渐近线。 作表作图。 不定积分不定积分的概念与性质 $F^\\prime(x)=f(x)$，$F(x)+C$($C$是常数)是原函数，$f(x)$称为导函数。原函数存在的条件为连续函数一定有原函数。 在区间I上，$f(x)$带有任意常数项的原函数称为$f(x)$(或$f(x)dx$)在区间I上的不定积分，记作$\\int f(x){\\rm d}x$，即$\\int f(x){\\rm d}x=F(x)+C$($C$是常数)。 不定积分的几何含义：即一组平行的曲线簇。 不定积分的性质：$\\int [f(x)+g(x)]{\\rm d}x=\\int f(x){\\rm d}x+\\int g(x){\\rm d}x$$\\int kf(x){\\rm d}x=k\\int f(x){\\rm d}x$ 基本积分表：$\\int k{\\rm d}x=kx+C$($k是常数$)$\\int x^\\mu{\\rm d}x=\\frac{x^{\\mu+1}}{\\mu+1}+C$$\\int \\frac{1}{x}{\\rm d}x=ln|x|+C$$\\int \\frac{1}{1+x^2}{\\rm d}x=arctanx+C$$\\int \\frac{1}{\\sqrt{1-x^2}}{\\rm d}x=arcsinx+C$$\\int cosx{\\rm d}x=sinx+C$$\\int sinx{\\rm d}x=-cosx+C$$\\int sec^2x{\\rm d}x=tanx+C$$\\int csc^2x{\\rm d}x=-cotx+C$$\\int secxtanx{\\rm d}x=secx+C$$\\int cscxcotx{\\rm d}x=-cscx+C$$\\int e^x{\\rm d}x=e^x+C$$\\int a^x{\\rm d}x=\\frac{a^x}{lna}+C$$\\int shx{\\rm d}x=chx+C$$\\int chx{\\rm d}x=shx+C$$\\int tanx{\\rm d}x=-ln|cosx|+C$$\\int cotx{\\rm d}x=ln|sinx|+C$$\\int secx{\\rm d}x=ln|secx+tanx|+C$$\\int cscx{\\rm d}x=ln|cscx-cotx|+C$$\\int \\frac{1}{a^2+x^2}{\\rm d}x=\\frac{1}{a}arctan\\frac{x}{a}+C$$\\int \\frac{1}{x^2-a^2}{\\rm d}x=\\frac{1}{2a}ln|\\frac{x-a}{x+a}|+C$$\\int \\frac{1}{\\sqrt{a^2-x^2}}{\\rm d}x=arcsin\\frac{x}{a}+C$$\\int \\frac{1}{\\sqrt{x^2+a^2}}{\\rm d}x=ln(x+\\sqrt{x^2+a^2})+C$$\\int \\frac{1}{\\sqrt{x^2-a^2}}{\\rm d}x=ln|x+\\sqrt{x^2-a^2}|+C$$\\int \\sqrt{x^2+a^2}{\\rm d}x=\\frac{a^2}{2}ln(\\sqrt{a^2+x^2}+x)+\\frac{x}{2}\\sqrt{a^2+x^2}+C$$\\int \\sqrt{x^2-a^2}{\\rm d}x=\\frac{a^2}{2}ln(\\sqrt{x^2-a^2}+x)+\\frac{x}{2}\\sqrt{x^2-a^2}+C$ 换元积分法 第一类换元法：$\\int f(\\phi(x))\\phi^\\prime(x){\\rm d}x=\\int f(\\phi(x)){\\rm d}\\phi(x)=F(\\phi(x))+C$。 第二类换元法：$\\int f(x)dx=\\int f(\\phi(t))\\phi^\\prime(t)dt=g(t)+C$，其中$t=\\phi^{-1}(x)$，因此$g(t)+C$=$g(\\phi^{-1}(x))+C$。做题步骤： 1.设$x=\\phi(t)$，并求积。 2.将t换回x。（此处可画直角三角形辅助，例$sinx=\\frac{x}{a}$，则斜边a、对边x、临边$\\sqrt{a^2-x^2}$，$cosx$就等于$\\frac{\\sqrt{a^2-x^2}}{a}$） 分部积分法 $\\int u {\\rm d}v=uv-\\int v {\\rm d}u$。 选择$\\int u {\\rm d}v$中u的优先级顺序：对数函数、反三角函数、幂函数、三角函数和指数函数（对反幂三指，其中对反可以互换，三指也可以互换）。 有理函数的积分 $R(x)=\\frac{P_m(x)}{Q_n(x)}\\begin{cases} m≥n，&amp;有理假分式。\\\\m&lt;n，&amp;有理真分式。 \\end{cases}$，其中$P(x)$和$Q(x)$是两个多项式，m和n是多项式的最高次幂。有理假分式需要通过长除法变成有理真分式进行求解。 $\\frac{A}{(x-a)^n}$型式化成$\\frac{A_1}{(x-a)^n}+\\frac{A_2}{(x-a)^{n-1}}+\\dots+\\frac{A_n}{x-a}$； $\\frac{Bx+C}{(x^2+px+q)^n}$型式化成$\\frac{B_1x+C_1}{(x^2+px+q)^n}+\\frac{B_2x+C_2}{(x^2+px+q)^{n-1}}+\\dots+\\frac{B_nx+C_n}{x^2+px+q}$。 $\\int \\frac{1}{ax^2+bx+c}{\\rm d}x$$\\int \\frac{dx+e}{ax^2+bx+c}{\\rm d}x$b^2-4ac=0$a(x-x_1)^2$$a(x-x_1)^2$，将d凑成和分母类似b^2-4ac&gt;0$a(x-x_1)(x-x_2)$，化成$\\frac{A_1}{x-x_1}+\\frac{A_2}{x-x_2}$型式与左边相同。b^2-4ac&lt;0先配方，然后将d凑成和分母类似与左边相同。 $\\int R(sinx, cosx){\\rm d}x$另$t=tan\\frac{x}{2}$。$\\int R(tanx){\\rm d}x$&lt;br&gt;$\\int R(sin^2x, cos^2 x){\\rm d}x$&lt;br&gt;$\\int R(sin2x, cos2x){\\rm d}x$另$t=tanx$。$\\int R(x, \\sqrt[n]{\\frac{ax+b}{cx+h}}){\\rm d}x$另$t=\\sqrt[n]{\\frac{ax+b}{cx+h}}$。$\\int R(x, \\sqrt{ax^2+bx+c}){\\rm d}x$先配方，然后对根式选择适当的三角变换去掉根式，化为三角函数有理式的积分。 定积分定积分的概念与性质 $f(x)$在$[a, b]$上有界，在$[a, b]$上任意插入若干个分点将其分成n个小区间$\\Delta x_1,\\Delta x_2,\\dots,\\Delta x_n$，在每个小区间上任取一点$\\xi_i$，$I=\\lim \\limits_{\\lambda \\to 0} \\sum_{i=1}^n f(\\xi_i)\\Delta x_i$($\\lambda=max\\{\\Delta x_1,\\Delta x_2,\\dots,\\Delta x_n\\}$)，称这个极限I为$f(x)$在$[a, b]$上的定积分，记作$\\int_a^b f(x){\\rm d}x$。就是说若要取一个曲边梯形的面积，则可以用若干个小长方形的面积相加近似的获取其面积。 $f(x)$在$[a, b]$上连续，则$f(x)$在$[a, b]$上可积。 $f(x)$在$[a, b]$上有界，且只有有限个间断点，则$f(x)$在$[a, b]$上可积。 当$b=a$时，则$\\int_a^a f(x){\\rm d}x=0$。 $\\int_a^b f(x){\\rm d}x$=$-\\int_b^a f(x){\\rm d}x$。 $\\int_a^b [\\alpha f(x)+\\beta g(x)]{\\rm d}x$=$\\alpha\\int_a^b f(x){\\rm d}x$+$\\beta\\int_a^b g(x){\\rm d}x$。 当$a&lt;c&lt;b$时，$\\int_a^b f(x){\\rm d}x$=$\\int_a^c f(x){\\rm d}x$+$\\int_c^b f(x){\\rm d}x$。 在$[a, b]$上$f(x)\\equiv 1$，则$\\int_a^b 1{\\rm d}x$=$\\int_a^b {\\rm d}x$=$b-a$。 在$[a, b]$上$f(x)≥0$($f(x)≤0$)，则$\\int_a^b f(x){\\rm d}x≥0$($\\int_a^b f(x){\\rm d}x≤0$)，其中$a&lt;b$。 在$[a, b]$上$f(x)≤g(x)$，则$\\int_a^b f(x){\\rm d}x≤\\int_a^b g(x){\\rm d}x$，其中$a&lt;b$。 $|\\int_a^b f(x){\\rm d}x|≤\\int_a^b |f(x)|{\\rm d}x$，其中$a&lt;b$。 若M及m分别是$f(x)$在$[a, b]$上的最大值和最小值，则$m(b-a)≤\\int_a^b f(x){\\rm d}x≤M(b-a)$，其中$a&lt;b$。 定积分中值定理：若$f(x)$在$[a, b]$上连续，$\\exists \\xi∈[a, b]$，使得$\\int_a^b f(x){\\rm d}x=f(\\xi)(b-a)$。 微积分基本共识 $f(x)$在$[a, b]$上连续，则积分上限的函数在$[a, b]$上可导，其导数为$\\Phi^\\prime(x)=\\frac{d}{dx}\\int_a^xf(t){\\rm d}t=f(x)$，其中($a≤x≤b$)。 $\\int_{\\psi(x)}^{\\phi(x)}[f(t){\\rm d}t]^\\prime=f(\\phi(x))\\phi^\\prime(x)-f(\\psi(x))\\psi^\\prime(x)$。 牛顿-莱布尼茨公式：$F(x)$是连续函数$f(x)$在$[a, b]$上的一个原函数，则$\\int_a^bf(x){\\rm d}x=F(b)-F(a)$。 定积分的换元法和分部积分法 $x=\\phi(t)$，若$\\phi(\\alpha)=a$，$\\phi(\\beta)=b$，则$\\int_a^bf(x){\\rm d}x=\\int_{\\alpha}^{\\beta}f[\\phi(t)]\\phi^\\prime(t){\\rm d}t$。（一定要注意上下限也要替换。） $f(x)$在$[-a, a]$上连续且为偶函数，则$\\int_{-a}^af(x){\\rm d}x=2\\int_0^af(x){\\rm d}x$；$f(x)$在$[-a, a]$上连续且为奇函数，则$\\int_{-a}^af(x){\\rm d}x=0$。 $f(x)$在$[0, 1]$上连续，则$\\int_0^{\\frac{\\pi}{2}}f(sinx){\\rm d}x=\\int_0^{\\frac{\\pi}{2}}f(cosx){\\rm d}x$，$\\int_0^{\\pi}xf(sinx){\\rm d}x=\\frac{\\pi}{2}\\int_0^{\\pi}f(sinx){\\rm d}x$。 $f(x)$是连续的周期函数，则$\\int_a^{a+T}f(x){\\rm d}x=\\int_0^Tf(x){\\rm d}x$，$\\int_a^{a+nT}f(x){\\rm d}x=n\\int_0^Tf(x){\\rm d}x$（$n∈N$）。 $\\int_a^b u {\\rm d}v=[uv]_a^b-\\int_a^b v {\\rm d}u$。 反常积分（广义积分） 无穷限的反常积分： $\\int_a^{+\\infty}f(x)dx=\\lim \\limits_{t \\to +\\infty}\\int_a^tf(x){\\rm d}x$，若极限存在则收敛，否则发散。 $\\int_{-\\infty}^{a}f(x)dx=\\lim \\limits_{t \\to -\\infty}\\int_t^af(x){\\rm d}x$，若极限存在则收敛，否则发散。 $\\int_{-\\infty}^{+\\infty}f(x)dx=\\int_{-\\infty}^{0}f(x)dx+\\int_{0}^{+\\infty}f(x)dx$，若右式均收敛则左式收敛，否则发散。 无界函数的反常积分：（注意函数无定义点。） 若$f(x)$在$(a, b]$上连续，则a就是$f(x)$的瑕点。任取$t&gt;a$，则$\\int_a^bf(x){\\rm d}x=\\lim \\limits_{t \\to a^+}\\int_t^bf(x){\\rm d}x$。 若$f(x)$在$[a, b)$上连续，则b就是$f(x)$的瑕点。任取$t&lt;b$，则$\\int_a^bf(x){\\rm d}x=\\lim \\limits_{t \\to b^-}\\int_a^tf(x){\\rm d}x$。 若$f(x)$在$[a, c)$及$(c, b]$上连续，则c就是$f(x)$的瑕点。$\\int_a^bf(x){\\rm d}x=\\int_a^cf(x){\\rm d}x+\\int_c^bf(x){\\rm d}x$。 $\\Gamma$函数 $\\Gamma(s)$=$\\int_0^{+\\infty}e^{-x}x^{s-1}{\\rm d}x$，其中$s&gt;0$。 $\\Gamma(s+1)$=$s\\Gamma(s)$，其中$s&gt;0$。 $\\Gamma(n+1)=n!$。 定积分的应用定积分在几何学上的应用 平面图形的面积：$A=\\int_a^bf(x){\\rm d}x$。 X型区域：若在x轴的$[a, b]$上$g(x)≤f(x)$，则$S=\\int_a^b[f(x)-g(x)]{\\rm d}x$。 Y型区域：若在y轴的$[c, e]$上$g(y)≤f(y)$，则$S=\\int_c^e[f(y)-g(y)]{\\rm d}y$。 椭圆的面积：$S=\\frac{ab\\pi}{4}$。 根据$sin^2t+cos^2t=1$与$(\\frac{x}{a})^2+(\\frac{y}{b})^2=1$推出$\\begin{cases} x=acost\\\\y=bsint \\end{cases}$，其中$0≤t≤\\frac{\\pi}{2}$。 $S=4\\int_0^ay{\\rm d}x=\\int_0^{\\frac{\\pi}{2}}absin^2t{\\rm d}t=\\frac{\\pi ab}{4}$ 极坐标情形：$A=\\int_\\alpha^\\beta\\frac{1}{2}[p(\\theta)]^2{\\rm d}\\theta$。 旋转体的体积： X型区域：若在x轴的$[a, b]$上，$\\int_a^b\\pi f^2(x){\\rm d}x$=$\\int_a^bA(x){\\rm d}x$。 Y型区域：若在y轴的$[c, e]$上，$\\int_c^e\\pi \\phi^2(y){\\rm d}y$=$\\int_c^eA(y){\\rm d}y$。 旋转体的侧面积：曲线$y=f(x)≥0$，$a≤x≤b$，绕X轴旋转，得到的旋转体侧面积为$S=\\int_a^b2\\pi f(x)\\sqrt{1+f^{\\prime 2}(x)}{\\rm d}x$。 光滑曲线弧是可求长的，求弧长公式为： $\\begin{cases} x=\\phi(t)\\\\y=\\psi(t) \\end{cases}$，其中$\\alpha≤t≤\\beta$，则$s=\\int_\\alpha^\\beta\\sqrt{\\phi^{\\prime 2}(t)+\\psi^{\\prime 2}(t)}{\\rm d}t$。 $\\begin{cases} x=x\\\\y=f(x) \\end{cases}$，其中$a≤x≤b$，则$s=\\int_a^b\\sqrt{1+y^{\\prime 2}}{\\rm d}x$。 $\\rho=\\rho(\\theta)$，($\\alpha≤\\theta≤\\beta$)，$\\begin{cases} x=x(\\theta)=\\rho(\\theta)cos\\theta\\\\y=y(\\theta)=\\rho(\\theta)sin\\theta \\end{cases}$，$s=\\int_\\alpha^\\beta\\sqrt{\\rho^2(\\theta)+\\rho^{\\prime 2}(\\theta)}{\\rm d}\\theta$。 微分方程微分方程的基本概念 通俗说含导数的即微分方程。 任意常数的个数与微分方程的阶数相同，这样的解叫做微分方程的通解。 可分离变量的微分方程$y^\\prime=f(x, y)$化为$g(y){\\rm d}y=f(x){\\rm d}x$，两边同时作积。 齐次方程 齐次方程：$\\frac{dy}{dx}=\\phi(\\frac{y}{x})$，例如：$\\frac{dy}{dx}=\\frac{1+(\\frac{y}{x})^2}{1-2(\\frac{y}{x})^2}$，即$\\frac{y}{x}$是整体出现的。求解步骤： $u=\\frac{y}{x}$。 $y=xu$。 $\\frac{dy}{dx}=u+x\\frac{du}{dx}$。 分离变量。 可化为齐次方程：$\\frac{dy}{dx}=\\frac{ax+by+c}{a_1x+b_1y+c_1}$，当$c=c_1$时是其次的，否则是非齐次的。将非齐次化作齐次方程令$x=X+h$，$y=Y+k$，所以$\\frac{dY}{dX}=\\frac{aX+bY+ah+bk+c}{a_1X+b_1Y+a_1h+b_1k+c_1}$，若方程组$\\begin{cases} ah+bk+c=0,\\\\a_1h+b_1k+c_1=0\\end{cases}$中： 若$\\frac{a_1}{a}≠\\frac{b_1}{b}$，则$\\frac{dY}{dX}=\\frac{aX+bY}{a_1X+b_1Y}$。 若$\\frac{a_1}{a}=\\frac{b_1}{b}$，则令$\\frac{a_1}{a}=\\frac{b_1}{b}=\\lambda$，$\\frac{dy}{dx}=\\frac{ax+by+c}{\\lambda(ax+by)+c_1}$，引入变量$v=ax+by$，则$\\frac{dv}{dx}=a+b\\frac{dy}{dx}$或$\\frac{dy}{dx}=\\frac{1}{b}(\\frac{dv}{dx}-a)$，于是最终方程为$\\frac{1}{b}(\\frac{dv}{dx}-a)=\\frac{v+c}{\\lambda v+c_1}$。 一阶线性微分方程$\\frac{dy}{dx}+P(x)y=Q(x)$称为一阶线性微分方程： 若$Q(x)\\equiv 0$则称为齐次线性微分方程，其通解为$y=Ce^{-\\int P(x){\\rm d}x}$，其中$C=±e^{C_1}$。 若$Q(x)≠0$则称为非齐次线性微分方程，另$y=ue^{-\\int P(x){\\rm d}x}$代入原方程可得到其特解$y=e^{-\\int P(x){\\rm d}x}(\\int Q(x)e^{\\int P(x){\\rm d}x}{\\rm d}x+C)$，其解为通解加上特解为$y=Ce^{-\\int P(x){\\rm d}x}+e^{-\\int P(x){\\rm d}x}\\int Q(x)e^{\\int P(x){\\rm d}x}{\\rm d}x$。 可降阶的高阶微分方程 $y^{(n)}=f(x)$：几阶导就求几次积分。 $y^{\\prime\\prime}=f(x, y^\\prime)$：设$y^\\prime=p$，则$y^{\\prime\\prime}=p^\\prime$，$p^\\prime=f(x, p)$，分离变量求积。 $y^{\\prime\\prime}=f(y, y^\\prime)$：设$y^\\prime=p$，则$y^{\\prime\\prime}=p^\\prime=\\frac{dp}{dx}=\\frac{dp}{dy}\\frac{dy}{dx}=p\\frac{dp}{dy}$，分离变量求积。 高阶线性微分方程 二阶齐次线性方程：$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=0$，其解为$y=C_1y_1(x)+C_2y_2(x)$。 二阶非齐次线性方程：$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=f(x)$，设$y^(x)$是特解，$Y(x)$是通解，则其解为$y=Y(x)+y^(x)$。 常系数齐次线性微分方程将$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=0$写为$y^{\\prime\\prime}+py^\\prime+qy=0$，求解： $r^2+pr+q=0$$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=0$$p^2-4q&gt;0$，$r=\\frac{-p±\\sqrt{p^2-4q}}{2}$$y=C_1e^{r_1x}+C_2e^{r_2x}$$p^2-4q=0$，$r=-\\frac{p}{2}$$y=(C_1+C_2x)e^{r_1x}$$p^2-4q&lt;0$，$r=\\alpha ±\\beta i$，$\\alpha=-\\frac{p}{2}, \\beta=\\frac{\\sqrt{4q-p^2}}{2}$$e^{\\alpha x}(C_1cos\\beta x+C_2sin\\beta x)$ 常系数非齐次线性微分方程 $f(x)=e^{\\lambda x}P_m(x)$，其特解为：$y*=e^{\\lambda x}Q_m(x)$， $\\lambda=\\begin{cases} 0,&amp;\\lambda与特征方程两个特征根均不相等\\\\1&amp;\\lambda与特征方程其中一个特征根相等\\\\2&amp;\\lambda与特征方程两个特征根均相等 \\end{cases}$。 $Q_m(x)$与$P_m(x)$是同次的多项式，例如$P_m(x)=x^2+3$，则$Q_m(x)=ax^2+bx+c$。 $f(x)=e^{\\lambda x}[P_l(x)cos\\psi x+Q_n(x)sin \\psi x]$，其特解为：$y^*=x^ke^{\\lambda x}[R_m^{(1)}(x)cos\\psi x+R_m^{(2)}(x)sin\\psi x]$， $\\lambda=\\begin{cases} 0,&amp;\\lambda±i\\psi不是特征方程的根 \\\\1,&amp;\\lambda±i\\psi是特征方程的根 \\end{cases}$。 $P_l(x)$和$Q_n(x)$是两个多项式，$R_m(x)$中的$m=Max\\{l, n\\}$。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数","date":"2020-01-18T06:41:20.000Z","path":"posts/c23efd5b/","text":"行列式行列式定义 $\\begin{vmatrix} a&amp;b\\\\ c&amp;d \\end{vmatrix}=ad-bc$ 三阶行列式：展开式共六项，其中三个正项，三个负项。（n 阶行列式展开式共 n! 项。） n 阶行列式：行取自然排列（例123），列取排列所有可能（例123、132、$\\dots$），不同行不同列取 n 个元素相乘，符号由列标排列逆序数的奇偶决定。 下三角、上三角和对角形的行列式为主对角线元素相乘。 山寨下三角、山寨上三角和山寨对角形的行列式为 $(-1)^{\\frac{n(n-1)}{2}}$ 与次对角线元素相乘。 行列式性质 转置：$D^T=D$ 交换两行（列），行列式变号。 两行（列）元素相等，D=0。 某一行（列）有公因子 k，k 外提一次。所有行（列）都有公因子 k，k 外提 n 次。 两行（列）元素成比例，D=0。 某一行（列）元素全为0，D=0。 某一行（列）元素全是两数之和，拆成两个行列式。（只拆该行或列，其余行或列保持不变。） 某一行（列）乘以一个数加到另一行（列），D 不变。 行列式展开 D = 某一行（列）元素与其代数余子式乘积之和。（将$(i, j)$所在的行列划去留下的就是余子式，代数余子式是带符号的余子式，其符号为$(-1)^{i+j}$。） 异乘变零：某行（列）元素与其他行（列）的代数余子式乘积之和为0。 拉普拉斯定理：任取 k 行（列），由这 k 行（列）元素组成的所有 k 阶子式与其代数余子式乘积之和为 D。（常用于解某一块都是0的行列式。） 克拉默法则：n 个方程 n 个未知数的方程组，系数行列式若不等于0则有唯一解：$x_i=\\frac{D_i}{D}$，其中 $D_i$ 为用常数项替代 i 列，而其他列不变的行列式的值。n 个方程 n 个未知数的齐次方程组，系数行列式若不等于0则有零解；若等于0则有非零解。 范德蒙德行列式： $$\\begin{vmatrix} 1&amp;1&amp;\\cdots&amp;1\\\\ x_1&amp;x_2&amp;\\cdots&amp;x_n\\\\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots\\\\ {x_{1}}^{n-1}&amp;{x_{2}}^{n-1}&amp;\\cdots&amp;{x_{n}}^{n-1} \\end{vmatrix}=\\prod_{1≤j&lt;i≤n}(x_i-x_j)$$ 对称行列式主对角线无要求，上下位置对应相等；反对称行列式主对角线全为零，上下位置对应成相反数。 矩阵及其运算矩阵的运算 负矩阵：A，-A；n阶方阵：行数=列数，$A_{n×n}=A_n$；单位阵：方阵对角线都是1，其余为0，记作E。 矩阵加（减）法：同型矩阵，对应元素相加（减）。 矩阵数乘：kA，用 k 乘以 A 的每个元素。 矩阵提公因子：每个元素都有公因子则向外提一次。 AB 相乘条件：A 的列数=B 的行数。 C=AB，结果矩阵形状：C 的行数=A 的行数；C 的列数=B 的列数。 矩阵乘法不满足： AB 一般不等于 BA。 AB=AC，且 A≠0，推不出 B=C。 AB=0，推不出 A=0，或 B=0。 与零矩阵相乘：$A_{4×3}O_{3×2}=O_{4×2}$； 与E相乘：$AE=A$，$EB=B$； 运算规则：$\\begin{cases}(AB)C=A(BC)\\\\(A+B)C=AC+BC\\\\k(A+B)=(kA)B=A(kB)\\end{cases}$。 次幂：$A^k=AA\\cdots A$（k 个 A 相乘）。 $A^m×A^n=A^{m+n}$$(A^m)^n=A^{mn}$$(P^{-1}AP)^n=P^{-1}A^nP$ $(A^T)^T=A$$(kA)^T=kA^T$$(A+B)^T=A^T+B^T$$(AB)^T=B^TA^T$ $diag(1, 2, 3)=\\begin{bmatrix}1&amp;0&amp;0\\\\0&amp;2&amp;0\\\\0&amp;0&amp;3\\end{bmatrix}$。 对称矩阵：$A^T=A$反对称矩阵：$A^T=-A$ $|A^T|=|A|$$|kA|=k^n|A|$$|AB|=|A||B|$ 分块矩阵求转置分两步： 将分块矩阵的块看作普通元素求转置。 对每一个块求转置。 $\\begin{bmatrix} A_1&amp;0&amp;0&amp;0\\\\0&amp;A_2&amp;0&amp;0\\\\0&amp;0&amp;A_3&amp;0\\\\0&amp;0&amp;0&amp;A_4 \\end{bmatrix}$=$\\begin{bmatrix} A_1^{-1}&amp;0&amp;0&amp;0\\\\0&amp;A_2^{-1}&amp;0&amp;0\\\\0&amp;0&amp;A_3^{-1}&amp;0\\\\0&amp;0&amp;0&amp;A_4^{-1} \\end{bmatrix}$；$H=\\begin{bmatrix} A&amp;C\\\\0&amp;B \\end{bmatrix}$，$H^{-1}=\\begin{bmatrix} A^{-1}&amp;A^{-1}CB^{-1}\\\\0&amp;B^{-1} \\end{bmatrix}$。 标准形： 对角线全0或全1。 对角线从上到下是连续的1和连续的0。 可以不是方阵。 逆矩阵 逆矩阵：$AB=BA=E$，逆矩阵一定是方阵。推论：$AB=E$，A, B 均可逆，所以 $A^{-1}=B$, $B^{-1}=A$ 求 $A^{-1}$： 伴随矩阵法：$A^{-1}=\\frac{1}{|A|}A^*$ 初等变换法：$(\\begin{array}{c:c}A&amp;E\\end{array}) \\longrightarrow (\\begin{array}{c:c}E&amp;A^{-1}\\end{array})$ $(A^{-1})^{-1}=A$$(AB)^{-1}=B^{-1}A^{-1}$ $(A^T)^{-1}=(A^{-1})^T$$(kA)^{-1}=\\frac{1}{k}A^{-1}$ $|A^{-1}|=\\frac{1}{|A|}$$(A^{-1})^{\\ast}=(A^*)^{-1}=\\frac{1}{|A|}A$ A 可逆则 $|A|≠0$。 伴随矩阵 按行求代数余子式，按列放，伴随矩阵一定是方阵。 $AA^{\\ast}=A^{\\ast}A=|A|E$ $|A^{\\ast}|=|A|^{n-1}$ $A^{-1}=\\frac{1}{|A|}A^{\\ast} \\longrightarrow A^{\\ast}=|A|A^{-1}$ $R(A^{\\ast})=\\begin{cases} n,&amp;若 R(A)=n\\\\ 1,&amp;若 R(A)=n-1\\\\ 0,&amp;若 R(A)&lt;n-1 \\end{cases}$ 矩阵的初等变换初等矩阵初等变换 三种初等行变换，三种初等列变换： 交换两行（列）。 用一个非0数乘某一行（列）。 某一行（列）的 k 倍加到另一行（列）上去。 等价：AB 是同型矩阵，A 经初等变换得到 B（同型矩阵行列相等）。 等价：AB 是同型矩阵，存在可逆 P, Q，使得 $PAQ=B$。 初等矩阵即对E做y一次初等变换得到的矩阵。 初等矩阵均可逆，其逆矩阵也是初等矩阵，转置矩阵也是初等矩阵。 初等矩阵左乘 A，相当于对 A 做初等行变换。初等矩阵右乘 A，相当于对 A 做初等列变换。 初等矩阵 $E(i, j)$ 表示交换 i, j 行。其中 $|E(i, j)|=-1$，$E^{-1}(i, j)=E(i, j)$。初等矩阵 $E(i(k))$ 表示用 k 乘第 i 行。其中 $|E(i(k))|=k$，$E^{-1}(i(k))=E(i(\\frac{1}{k}))$。初等矩阵 $E(i, j(k))$ 表示用第 j 行的 k 倍加到第 i 行上。其中 $|E(i, j(k))|=1$，$E^{-1}(i, j(k))=E(i, j(-k))$。 矩阵的秩 R(A)：非零子式的最高阶数。 零矩阵的秩为0。 $0≤R(A)≤min\\{行数, 列数\\}$，若$R(A)=min\\{行数, 列数\\}$则称为满秩，若$R(A)＜min\\{行数, 列数\\}$则称为降秩。 若A是方阵且满秩即|A|≠0，则A可逆。 $R(A)=r \\Longleftrightarrow $有一个 r 阶非零子式，所有 r+1 阶子式均为0。 初等变换（行, 列）不改变矩阵的秩。 求 R(A)，将 A 化为阶梯型（初等行列变换均可），数非零行的行数。阶梯型画线横线可跨多个数，竖线只能跨一个数。行简化阶梯型：在阶梯型的基础上，非零行的首非零元是1；首非零元所在列其余元素是0。 $R(A)=R(A^T)$ P, Q 可逆，$R(A)=R(PA)=R(AQ)=R(PAQ)$。 $max\\{R(A), R(B)\\}≤R(A, B)≤R(A)+R(B)$ $R(A+B)≤R(A)+R(B)$ $R(AB)≤min\\{R(A), R(B)\\}$ $A_{m×n}·B_{n×l}=0$，则 $R(A)+R(B)≤n$。 $A·B=0$，若 A 为列满秩矩阵，则 $B=0$。（列满秩矩阵即矩阵的秩等于矩阵的列数。） 向量组的线性相关性向量的线性组合 $kα=0 \\Longleftrightarrow k=0 或 α=0$ 零向量可由任意向量组表示。 向量组中的一个向量可由该向量组表示。 任意向量可由单位向量组表示。 向量组等价：两向量组可相互表示。 线性相关 &amp;&amp; 线性无关 线性相关：存在不全是0的 $k_1, \\cdots, k_n$，使 $kα_1+ \\cdots +kα_n=0$。 线性无关：$kα_1+ \\cdots +kα_n=0$ 成立，$k_1, \\cdots, k_n$ 全取0。 线性相关、无关的性质 向量组中两个向量分量成比例，向量组线性相关。 一个零向量线性相关，一个非零向量线性无关。 含零向量的向量组必线性相关。 部分组线性相关，则整体组线性相关。整体组线性无关，则部分组线性无关。 向量组线性无关，则接长组线性无关。向量组线性相关，则截短组线性相关。 n 个 n 维向量线性无关 $\\Longleftrightarrow D≠0$n 个 n 维向量线性相关 $\\Longleftrightarrow D=0$ 线性相关、无关的定理 向量线性相关 $\\Longleftrightarrow$ 至少一个向量是其余向量的线性组合。 $α_1, \\cdots, α_s$ 线性无关，$α_1, \\cdots, α_s, β$ 线性相关，则 β 可由 $α_1, \\cdots, α_s$ 唯一线性表示。 $α_1, \\cdots, α_s$ 线性无关，可由 $β_1, \\cdots, β_t$ 线性表示，则 $s≤t$。 $α_1, \\cdots, α_s$ 可由 $β_1, \\cdots, β_t$ 线性表示，且 $s&gt;t$，则 $α_1, \\cdots, α_s$ 线性相关。 向量个数 &gt; 向量维数，向量组线性相关。 n+1 个 n 维向量必线性相关。 等价的线性无关的向量组，含相同个数的向量。 极大线性无关组 线性无关组的定义：$α_1, α_2, \\cdots, α_r$ 的部分组如 $α_1, α_2$ 无关且每个向量均可由 $α_1, α_2$ 表示。 线性无关向量组的极大无关组是本身。 向量组与其极大无关组等价。 向量组的不同极大无关组含向量个数相同。 向量组的秩：极大无关组含向量的个数。 $0≤R(α_1, \\cdots, α_s)≤min\\{向量个数, 向量维数\\}$ A 的行秩=A 的列秩= R(A) $R(AB)≤min\\{R(A), R(B)\\}$ 求极大线性无关组： 不管向量是行或列，均按行构成矩阵。 只做初等行变化，化成行最简形矩阵。 首非零元所在列做极大无关组。 其余向量表示系数直接写出即可。 线性方程组AX=B 有解判定 $R(A)=R(Ā)=n$，有唯一解。（$R(Ā)$是带上等式右边的矩阵的秩。） $R(A)=R(Ā)&lt;n$，有无穷解。 $R(A)≠R(Ā)$，无解。 一般解计算方法： 写出Ā。 通过初等行变化转换成阶梯型。 判断解的个数。 化为行简化阶梯型，非零行的首非零元留在等式左边，其余变量留在等式右边得一般解。 AX=0 齐次方程组 齐次方程组一定有解，至少有零解。 齐次方程组仅有零解 $\\Longleftrightarrow R(A)=n$。 齐次方程组有非零解 $\\Longleftrightarrow R(A)&lt;n$。 齐次方程组中，方程个数&lt;未知数个数，有非零解。 齐次方程组中，方程个数=未知数个数，有非零解 $\\Longleftrightarrow$ 系数行列式等于零；仅有零解 $\\Longleftrightarrow$ 系数行列式不等于零。 AX=0 解的结构 $AX=0$ 的两个解相加仍然是解。 η 是 $AX=0$ 的解，则 cη 也是解。 $AX=0$ 的解的线性组合仍然是解。 基础解系：$η_1, \\cdots, η_s$ 是解，满足： $η_1, \\cdots, η_s$ 线性无关。 任意解可有 $η_1, \\cdots, η_s$ 表示。 $AB=0$，则 $R(A)+R(B)≤n$。 AX=B 解的结构 $AX=B \\longrightarrow AX=0$（导出组） $AX=B$ 的两个解相减是 $AX=0$ 的解。 $AX=B$ 的一个解和 $AX=0$ 的一个解相加是 $AX=B$ 的另一个解。 $AX=B$ 的通解：特解 + 基础解系的线性组合。 $AX=B$ 的一个特解。 $AX=0$ 的基础解系。 相似矩阵及其二次型特征值 &amp;&amp; 特征向量 $Aα=λα$，其中$λ$是特征值，$α$是对应于$λ$的特征向量。特征值可以是零，特征向量是非零向量。 $|λE-A|=0$，用于求特征值。$(λE-A)X=0$ 的非零解，用于求特征向量。解法： 1.写出$|λE-A|$。 2.把某行尽可能转化为零后再按行展开。 3.提关于$λ$的公因子。 4.将$λ$代入$|λE-A|$，做初等行变化转换成行简化阶梯型，计算其基础解系。 A 和 $A^T$ 有相同的特征值。 $\\sum λ_i=\\sum a_{ii}$$λ_1, \\cdots, λ_n=|A|$ 矩阵的迹 $tr(A)=\\sum a_{ii}$ 不同特征值对应的特征向量线性无关。（实对称矩阵，不同特征值对应的特征向量一定正交。） k 重特征值的线性无关的特征向量个数小于等于 k 个。 kλ 是 kA 的特征值。 $λ^k$ 是 $A^k$ 的特征值。 求 A 的多项式的特征值：A 替换成 λ，E 替换成 1。 $λ^{-1}$ 是 $A^{-1}$ 的特征值。 $\\frac{1}{λ}|A|$ 是 $A^*$ 的特征值 相似矩阵 A, B 是同阶方阵，存在可逆 P，$P^{-1}AP=B$。 相似矩阵具有反身性，对称性和传递性。 $A\\sim B\\begin{cases} A, B 有相同的特征值。\\\\ |A|=|B|\\\\ tr(A)=tr(B)\\\\ |A|和|B| 同时为零或同时不为零，因此 A, B 同时不可逆或同时可逆。\\\\ A, B 若可逆则 A^{-1}\\sim B^{-1}。\\\\ A^m\\sim B^m \\end{cases}$ 对角化 A 相似于对角行 $\\Longleftrightarrow$ A 有 n 个线性无关的特征向量。 A 有 n 个互异特征值，可对角化。 不管单根，若每个 k 重特征根，都有 k 个特征向量，则可对角化。 特征向量做列构成 P， 特征值做主对角线构成 A，特征值和特征向量位置对应。 内积 $[α, β]=α^Tβ$，若 α, β 是列向量。 内积是一个数。 $[α, α]≥0$, $[α, α]=0$ $\\Longleftrightarrow$ $α=0$ $[α, β]=[β, α]$$[kα, β]=k[β, α]=k[α, β]$$[α+β, γ]=[α, γ]+[β, γ]$ 长度 $||α||=\\sqrt{[α, α]}$$||α||^2=[α, α]$$[α, α]=||α||^2$ $||α||≥0$, $||α||=0$ $\\Longleftrightarrow$ $α=0$ $||kα||=|k|·||α||$$|[α, β]|≤||α||·||β||$ $||α+β||≤||α||+||β||$ $[α, β]=0$，即正交，$α \\bot β$。 正交向量组：不含零向量，两两正交。 标准正交向量组：正交向量组，每个向量都是单位向量。 施密特正交化：$α_1, α_2, α_3$ | $β_1, β_2, β_3$$β_1=α_1$$β_2=α_2-\\frac{[α_2, β_1]}{[β_1, β_1]}β_1$$β_3=α_3-\\frac{[α_3, β_1]}{[β_1, β_1]}β_1-\\frac{[α_3, β_2]}{[β_2, β_2]}β_2$$\\cdots$ 正交 A 是方阵，$A^TA=E$，A 为正交矩阵。 A 正交，$|A|=1 或 -1$，$|A^{-1}|=A^T$。 A 正交，$A^{-1}$ 和 $A^T$ 也正交。A, B 正交，$AB$ 也正交。 A 正交，$[Aα, Aβ]=[α, β]$。 A 正交 $\\Longleftrightarrow$ 列（行）向量组是标准正交向量组。 正交相似 实对称矩阵 A 的不同特征值的特征向量必正交。 正交相似：A, B 是同阶方阵，存在正交 P，$P^{-1}AP=B$。 A 是实对称矩阵，存在正交 Q，$Q^{-1}AQ=\\bigwedge$。 Q：正交单位化后的特征向量做列。$\\bigwedge$：特征值作为主对角线元素。 二次型 二次型 $\\longrightarrow$ 矩阵： 平方项系数做主对角线。 交叉项系数除以二放两对称位置。 矩阵 $\\longrightarrow$ 二次型： 主对角线做平方项系数。 主对角线右上角元素乘以二做交叉项系数。（如矩阵不对称则先将矩阵化为对称矩阵） 二次型的矩阵对称。 $X=CY$，线性替换。 合同 A, B 是 n 阶方阵，存在可逆 C，$C^TAC=B$。 合同矩阵具有反身性，对称性和传递性。 $A\\simeq B\\begin{cases} R(A)=R(B)\\\\ A 对称 \\Longleftrightarrow B 对称\\\\ A, B 可逆，A^{-1}\\simeq B^{-1}\\\\ A^T\\simeq B^T \\end{cases}$ 标准形 标准形：只有平方项，没有交叉项。 标准形不唯一。 化标准形三种方法： 配方法：先处理 $x_1$，使后边的项中不再出现 $x_1$，再依次对 $x_2, x_3, \\cdots, x_n$ 进行配方法处理。 初等变换法：$(\\begin{array}{c:c}A\\\\E\\end{array}) \\longrightarrow (\\begin{array}{c:c}\\bigwedge\\\\C\\end{array})$（对 A, E 做列变换，只对 A 做相应的行变换，$\\bigwedge$是对角矩阵即除了对角线以外都是零。） 正交替换法：正交 Q，$Q^TAQ=\\bigwedge$。， 规范形 规范形：只有平方项，系数只能为1, -1, 0，且变量的下标是连着的。（1, -1, 0 系数不可变换位置） 规范形是唯一的。 正惯性指数：规范形的正项个数。负惯性指数：规范形的负项个数。符号差：正惯性指数-负惯性指数。 $A\\simeq B$ $\\Longleftrightarrow$ 有相同的秩和正惯性指数。 正定 二次型 $X^TAX$，任意 $X≠0$： $X^TAX&gt;0$，正定。 $X^TAX&lt;0$，负定。 $X^TAX≥0$，半正定。 $X^TAX≤0$，半负定。 正定二次型经过非退化替换仍化为正定二次型。 二次型正定 $\\Longleftrightarrow$ 标准形每个变量的系数都大于零。 二次型正定 $\\Longleftrightarrow$ 正惯性指数为 n。 A 正定，$|A|&gt;0$。 A 正定 $\\Longleftrightarrow$ A 的特征值都大于零。 A 正定 $\\Longleftrightarrow$ A 各阶顺序主子式大于零。 A 正定 $\\longrightarrow$ ①$A^{-1}正定$②${A^*正定}$③$A^k正定$④A 主对角线元素都大于零。 A 正定，B（半）正定 $\\longrightarrow$ A+B 正定。 总结外提 k 行列式一行（列）有公因子 k，向外提一次。 矩阵所有元素都有公因子 k，向外提一次。 向量所有分量都有公因子 k，向外提一次。 $|kA|=k^n|A|$ $(kA)^{-1}=\\frac{1}{k}A^{-1}$ $(kA)^=k^{n-1}A^$ $(kA)^T=kA^T$ $[kα, β]=k[α, β]$ $||kα||=|k|·||α||$ 方阵 A 可逆充要条件 $|A|≠0$ A 满秩。（R(A)=行，R(A)=列。） A 的标准形是 E。 $A=E_1E_2 \\cdots E_s$，$E_i$是初等矩阵。 A 的所有特征值不为0。 $R(A)=n$ $A 的行秩=A 的列秩=R(A)=n$ A 的行（列）向量组无关。 A 的非零子式最高阶数为 n。 AX=0 只有零解。AX=B 有唯一解。 等价、相似、正交相似、合同 $\\cong$ 等价：A, B 同型，存在可逆 P, Q，$PAQ=B$。 $\\sim$ 相似：A, B 方阵，存在可逆 P，$P^{-1}AP=B$。 $\\sim$ 正交相似：A, B 方阵，存在正交 P，$P^{-1}AP=B$。 $\\simeq$ 合同：A, B 方阵，存在可逆 P，$P^TAP=B$。 正交相似肯定相似，且一定合同（$P^{-1}=P^T$）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Django（二）：ORM","date":"2019-12-21T13:15:33.000Z","path":"posts/b179370b/","text":"ORMDjango ORM 默认使用 SQLite 数据库，它是一款轻型的数据库，是遵守ACID的关系型数据库管理系统，它包含在一个相对小的 C 库中。也可以使用其他数据库，例如 MySQL，修改 Django 的默认连接为 MySQL 方式之后，即可通过 Django 的 ORM 操作 MySQL 数据库。 默认数据库连接修改默认数据库连接可以通过修改主目录文件夹下的 settings.py 文件中的 DATABASES 参数。此处以 MySQL 为例，代码如下： DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': '数据库名', 'HOST': '127.0.0.1', 'PORT': '3306', 'USER': '', 'PASSWORD': '', } } 如果是低版本的 pymysql 连接数据库则还需要再主目录文件夹下的 __init__.py 文件夹中输入如下代码： import pymysql pymysql.install_as_MySQLdb() 数据表操作Django 支持在应用的 models.py 中进行数据表的增删改操作，示例代码如下： # models.py from django.db import models # 此处User在数据库中的表名为user.user，因为该models在user应用下，其中类名会自动小写。 class User(models.Model): username = models.CharField(max_length=45, unique=True) password = models.CharField(max_length=45) # 此处department在数据库中的字段名为department_id，Django会自动增加_id为尾缀 department = models.ForeignKey(\"Department\") class Department(models.Model): name = models.CharField(max_length=32) 字段参考 字段名 作用 models.AutoField int 类型=int(11)。如果类中没有 models.AutoField，则默认会创建一个字段名为 id 的自增列，且默认标注为主键。 models.CharField 字符串类型=varchar。必须有 max_length 参数。 models.BooleanField boolean 类型=tinyint(1)。不能为空，Blank=True。 models.ComaSeparatedIntegerField 用逗号分割的数字=varchar。继承CharField，所以必须 max_length 参数。 models.DateField 日期类型=date。对于参数，auto_now=True 则每次更新都会更新这个时间；auto_now_add=True 则只是第一次创建时添加，之后的更新不再改变。 models.DateTimeField 日期类型=datetime。同 DateField 的参数。 models.Decimal 十进制小数类型=decimal。必须指定整数位 max_digits 和小数位 decimal_places。 models.EmailField 字符串类型（正则表达式邮箱）=varchar。对字符串进行邮箱正则表达式验证。 models.FloatField 浮点类型=double。 models.IntegerField 整型=int。 models.BigIntegerField 长整型=bigint。 models.IPAddressField 字符串类型（ip4 正则表达式） models.GenericIPAddressField 字符串类型（ip4 或 ip6 正则表达式）。参数 protocol 可以是：both、ipv4 或 ipv6 models.NullBooleanField 允许为空的布尔类型。 models.PositiveIntegerFile 正 integer。 models.PositiveSmallIntegerField 正 smallInteger。 models.SlugField 减号、下划线、字母和数字。 models.SmallIntegerField 整型，对应数据库中的 tinyint、smallint、int、bigint。 models.TextField 字符串类型=longtext。 models.TimeField 时间。HH:MM[:ss[.uuuuuu]]。 models.URLField 字符串类型（正则表达式地址）。 models.BinaryField 二进制=binary。 models.ImageField 图片。存储图片名，常与 upload_to 参数连用，设置图片路径。 models.FilePathField 文件。存储文件名常与 upload_to 参数连用，设置文件路径。 models.ForeignKey(其他表类名) 多对一，参数 on_delete 必须。例如动物和狗，则在狗中添加 ForeignKey。 models.OneToOneField(其他表类名) 一对一，参数 on_delete 必须。例如主表和从表，则在从表中添加 OneToOneField。 models.ManyToManyField(其他表类名) 多对多。 参数参考 参数（默认值） 作用 null=True 数据库中字段是否可以为空，True 可以。 blank=True django 的 admin 中添加数据时是否可允许空值，True 可以。 primary_key=False 主键，对 AutoField 设置主键后会代替原来的自增 id 列 ，True 作为主键列。 auto_now 自动创建，无论添加或修改都是会修改成当前操作的时间。 auto_now_add 自动创建，时间永远是创建时的时间。 choices 常用于下拉菜单。例如使用M可以获得Male：class Person(models.Model): GENDER_CHOICES = ( (‘M’, ‘Male’), (‘F’, ‘Female’), ) models.CharField(max_length=2, choices=GENDER_CHOICES)Person(gender=”M”) max_length 最大长度。 default 该字段默认值。 verbose_name admin 中字段的显示名称。 name db_column unique=True 是否允许重复，True 不允许。 db_index=True 是否允许数据库索引，True 允许。 editable=True 在 admin 里是否可编辑。 error_messages=None 错误信息提示，True 允许。 auto_created=False 自动创建，True 允许。 help_text 在 admin 中提示帮助信息。 upload_to 常用于设置文件、图片的上传路径。 on_delete 有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值。CASCADE：级联删除，常用。PROTECT：报完整性错误。SET_NULL：把外键设置为 null，前提是允许为 null。SET_DEFAULT：为外键设置默认值。SET()：此调用其他值，可以是一个函数。 数据行操作进行数据库行操作时，首先需要导入该模块的 models。例如导入 user 模块的 models，代码如下： from user import models 增加 自动提交（传对应参数） models.User.objects.create(username='root', password='123456') 自动提交（传字典，字典中 key 与数据库字段名一一对应） user_info = {\"username\": \"root\", \"password\": \"123456\"} models.User.objects.create(**user_info) 手动提交 obj = models.objects(username='root', password='123456') obj.save() 删除models.User.objects.filter(username='root').delete() 修改 自动提交 models.User.objects.filter(username='root').update(password='654321') 手动提交 obj = models.User.objects.get(username='root') obj.password = '654321' obj.save() 查询 根据条件查找单个 # 查找 username 为 root 的用户 models.User.objects.get(username=\"root\") 查找所有 models.User.objects.all() 查找所有，但只取 values 参数中选定的列 # 只取 username 列 models.User.objects.all().values('username') 查找所有，但只取 values_list 参数中选定的列，并返回一个 list（默认 tuple）。 models.User.objects.all().values_list('username', 'password') 获取所查表行数。 # 查 user 表一共有多少条数据 models.User.objects.count() 根据条件查找。 # 查找 id = 1 的 models.User.objects.filter(id=1) # 查找 id > 1 的 models.User.objects.filter(id__gt=1) # 查找 id &lt; 1 的 models.User.objects.filter(id__lt=1) 自定义 SQL 语句操作获取 django.db.connection 后，直接通过 pymysql 进行操作。 from django.db import connection cursor = connection.cursor() # 增加(插入一条数据成功返回主键，失败返回0) def create_one(): sql = \"insert语句\" result = 0 try: cursor.execute(sql) # 获取插入的数据 id result = connection.insert_id() connection.commit() except Exception as ex: print(\"插入异常：\", ex) connection.rollback() return result # 增加(插入多条数据成功返回更新条数，失败返回0) def create_many(): sql = \"insert语句\" info_list = [(\"root\", \"123\"), (\"admin\", \"321\")] result = 0 try: result = cursor.executemany(createmany_sql, info_list) connection.commit() except Exception as ex: print(\"插入异常：\", ex) connection.rollback() return result # 更新一条数据，返回影响条数 def update(): sql = \"update|delete语句\" result = 0 try: cursor.execute(sql) result = cursor.rowcount connection.commit() except Exception as ex: print(\"更新异常：\", ex) connection.rollback() return result # 查询数据，返回查询的数据，失败返回None def get(): sql = \"selete语句\" result = None try: cursor.execute(sql) # 查询单条用fetchone，查询多条用fetchall result = cursor.fetchone() except Exception as ex: print(\"查找异常：\", ex) return result 事务from django.db import transaction with transaction.atomic(): 数据库操作语句 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"django","slug":"django","permalink":"https://blog.kuukokawaii.com/tags/django/"}]},{"title":"Django（一）：简介","date":"2019-12-21T08:43:22.000Z","path":"posts/1e026f1b/","text":"MTV 框架模式Django 是一个遵循 MVC 设计模式的框架，采用了 MTV 的框架模式（T 即 Template），其中控制器接受用户输入的部分由框架自行处理，因此 Django 更关注模板部分。 项目搭建Django 所需命令可以通过django-admin help查看所拥有的命令，使用django-admin help 命令名字可以查看该命令如何使用。 Django 目录结构 templates：存放视图文件。 static：存放静态文件。 django_temp：存放项目相关文件。 settings.py：项目相关配置。 urls.py：路由配置。 user：存放应用模块相关文件。 admin.py：后台管理相关配置。 dao.py：数据库操作相关。 models.py：自定义类，并根据类创建数据库表。 tests.py：单元测试。 views.py：业务处理。 配置静态文件夹在 settings 中配置静态文件夹，代码如下： STATIC_URL = '/static/' STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'), ] 配置模板文件夹在 settings 中配置模板文件夹，修改DIRS中的templates即可修改模板文件夹位置。代码如下： TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 创建一个应用首先通过命令python manage.py startapp 名字创建应用。其次在 settings 中添加新增的应用即可。例如新创建的应用名为user，代码如下： INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'user', ] 配置路由 在 urls.py 中的urlpatterns新增路由即可。path 中第一个参数为 URI 映射位置，后一个参数为需要映射到的服务位置（方法），代码如下： urlpatterns = [ path('admin/', admin.site.urls), path('login/', user_controller.login), path('register/', user_controller.register), ] URL 也可以动态匹配，常用于 Restful 设计风格。函数只需多加变量，即可获得该匹配的 URI 地址，代码如下： urlpatterns = [ # 匹配0和任意整数 path('user/&lt;int:uid>/', user_controller.update), # 匹配除了'/'以外的非空字符串 path('user/&lt;str:username>/', user_controller.update), # 匹配任意由 ASCII 字母或数字以及连字符和下划线组成的短标签 path('user/&lt;slug:username>/', user_controller.update), ] def update(uid): return HttpResponse(uid) 项目主文件夹的 urls.py 还可以通过 include() 函数包含其他子文件夹的路由映射。例如在主文件中包含 user 文件夹下的 urls.py，此时所有 user 文件夹下的路径都会加上user/的前缀： # main.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('user/', include(\"user.urls\")), ] # user文件夹下的 urls.py from django.urls import path from user.views import login, register, index, temp urlpatterns = [ path('login/', login), path('register/', register), path('index/', index), path('temp/&lt;str:slug>/', temp), ] path 可以取别名，此时在前端页面可以通过花括号内% url 名字 [参数] %的形式调用。当目录过深时，会使用别名取代长路径，代码如下： urlpatterns = [ path('temp/&lt;str:slug>/', temp), ] &lt;form action=\"{% url 名字 参数%}\" method=\"POST\"> 花括号内输入% csrf_token % &lt;/form>411 初始化 Django 数据库 Django 拥有自带的数据库，但此处使用 Mysql 数据库为例（需要安装 mysqlclient），在应用的models.py中通过表创建数据库。此处建立一个 User 表，代码如下： from django.db import models class User(models.Model): username = models.CharField(max_length=45, unique=True) password = models.CharField(max_length=45) 通过命令行输入python manage.py makemigrations保存修改在本地。 输入python manage.py migrate提交本地修改至数据库，即可完成建表操作。 注意事项Django CSRF 提交问题Django 中设置防跨站请求伪造功能，当用 POST 提交数据的时候，Django 会去检查是否有一个 CSRF 的随机字符串，如果没有则会报错（Forbidden 403）。 在表单中通过 POST 方法提交出现问题，则需要再表单中输入花括号内包含% csrf_token %即可完成完成操作。代码如下： &lt;form action=\"\" method=\"POST\"> 花括号内输入% csrf_token % &lt;/form> 通过 AJAX 提交 POST 请求，需要在 data 中添加csrfmiddlewaretoken数据即可完成提交。代码如下： $.ajax({ url: \"/\", type: \"POST\", data: { csrfmiddlewaretoken: \"{{ csrf_token }}\" }, success: function (data) { }, error: function (error) { } }); 支持 PUT 和 DELETE支持 PUT 和 DELETE 请求，修改 ajaxSetup 函数即可。代码如下：function csrfSafeMethod(method) { return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method)); } $.ajaxSetup({ beforeSend: function (xhr, settings) { if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) { xhr.setRequestHeader(\"X-CSRFToken\", \"{{ csrf_token }}\"); } } }); 后台获取 DELETE 和 PUT 请求携带的参数代码如下：from django.http import QueryDict QueryDict(request.body).get(\"参数名\") session 存储对象session 存储对象需要对对象进行序列化。Django 中用 session 序列化对象需要在 settings.py 中添加如下代码： SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer' document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"django","slug":"django","permalink":"https://blog.kuukokawaii.com/tags/django/"}]},{"title":"Python：邮件发布","date":"2019-12-17T00:55:21.000Z","path":"posts/1530706b/","text":"发送模板import smtplib from email.mime.text import MIMEText smtp_obj = None # QQ邮箱host host = \"smtp.qq.com\" # QQ邮箱port port = 465 password = \"\" # 邮件内容 content = \"内容\" # MIMIE邮件体 message = MIMEText(content) # 邮件标题 message[\"Subject\"] = \"标题\" message[\"From\"] = \"1398524980@qq.com\" message[\"To\"] = \"1134177664@qq.com\" try: # 基于SSL安全协议和发送邮件 smtp_obj = smtplib.SMTP_SSL(host, port) # 邮件发送人验证 smtp_obj.login(message[\"From\"], password) smtp_obj.sendmail(message[\"From\"], message[\"To\"], message.as_string()) except Exception as e: print(\"发送失败\", e) finally: smtp_obj.close() print(\"发送成功\") document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"python","slug":"python","permalink":"https://blog.kuukokawaii.com/tags/python/"}]},{"title":"SpringBoot（十四）：监控管理","date":"2019-12-06T07:30:31.000Z","path":"posts/81ac1c26/","text":"监控管理SpringBoot 通过引入 actuator 依赖，可以获得应用监控和管理功能。可以通过 HTTP、JMX 和 SSH 协议来进行操作，自动得到审计、健康及指标信息等。监控和管理端点信息如下： 端点名 描述 autoconfig 所有自动配置信息 auditevents 审计事件 beans 所有 Bean 的信息 configprops 所有配置属性(application.yml中的配置) dump 线程状态信息 env 当前环境信息（服务器设置，系统环境变量等） health 应用健康信息 info 当前应用信息（内存大小，剩余用量等） metrics 应用的各项指标 mappings 应用@RequestMapping映射路径 shutdown 关闭当前应用（默认关闭） trace 追踪信息（获取最新的 HTTP 请求） SpringBoot 整合监控管理 引入 actuator 依赖&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId> &lt;/dependency> 通过 HTTP 方式访问监控端点，如http://localhost:8080/actuator/获取可访问地址列表。 定制端点信息 定制端点一般通过 endpoints + 原端点名 + 属性名来设置。 修改端点 ID，如endpoints.beans.id=myBean。 开启远程应用关闭功能，如endpoints.shutdown.enabled=true。 关闭端点，如endpoints.beans.enabled=false。 关闭所有端点访问：endpoints.enabled=false。 开启所需端点：endpoints.beans.enabled=true。（如关闭所有端点访问，该开启端点可以进行访问。） 定制端点访问路径，如management.context-path=/manage。 关闭 HTTP 端点，如management.port=-1；也可以修改端口，如management.port=8181。 自定义 healthIndicator实现 healthIndicator 接口，指示器名必须为xxxHealthIndicator。代码如下： /** * @Author 喵粮都输光了 * @Date 2019/12/6 16:31 * @Description 自定义状态监测 */ @Component public class CustomHealthIndicator implements HealthIndicator { @Override public Health health() { /* * 自定义检查方法： * Health.up().build() 表健康。 * Health.down().withDetail(\"message\", \"服务异常\").build() 表关闭，附带关闭信息。 */ return Health.down().withDetail(\"message\", \"服务异常\").build(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十三）：热部署","date":"2019-12-06T06:19:11.000Z","path":"posts/64a44bcd/","text":"热部署在开发中修改一个 Java 文件后想要看到效果不得不重启应用，这将导致花费大量的时间，因此希望在不重启应用的情况下，程序可以自动部署（热部署）。 热部署方式模板引擎 在 Spring Boot 中开发情况下禁用模板引擎的 cache。 页面模板改变时重新编译当前页面生效。 Spring LoadedSpring 官方提供的热部署程序，实现修改类文件的热部署。 下载 Spring Loaded。 添加运行时参数：-javaagent:[热部署程序jar包所在位置] -noverify。 JRebelJRebel 是收费的一个热部署软件，在idea 或 eclipse 安装相应插件即可使用。 Spring Boot Devtools 引入依赖&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;optional>true&lt;/optional> &lt;/dependency> 修改编辑器的运行应用程序更新策略（此处以 IDEA 为例）。 update resources：更新资源（如果引入了依赖则为热部署更新）。 update classes and resources：更新类文件和资源（如果引入了依赖则为热部署更新）。 hot swap classes and uodate trigger file if failed：热部署更新类和目标文件，当热部署更新失败时重启应用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十二）：分布式","date":"2019-12-04T14:29:05.000Z","path":"posts/e0109747/","text":"应用架构单一应用架构当网站流量很小时，只需一个应用将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架（ORM）是关键。 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web 框架（MVC）是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。在分布式系统中，国内常用 Dubbo + Zookeeper 组合，而 SpringBoot 推荐使用全栈的 Spring、SpringBoot + SpringCloud。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等现象逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键。 Zookeeper 和 DubboZookeeperZookeeper 是一个分布式的，开放源码的分布式应用程序协调服务（即注册中心）。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步和组服务等。 DubboDubbo 是 Alibaba 开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象处服务提供方（Provider）和服务消费方（Consumer）两个角色。 Container 在启动时负责加载运行 Provider。 Provider 在运行时将所拥有的服务信息注册至 Registry。 Consumer 在启动时会从 Registry 订阅所需服务，Registry 将 Consumer 所需服务的地址列表返回给 Registry。当 Provider 的服务信息有变更时，Registry 会基于长连接的方式将更新推送给 Consumer。 Consumer 需要调用服务时，可以根据负载均衡机制找到服务提供者位置并调用服务，如调用失败则可从服务地址列表中查找该服务的其他提供者调用服务直至调用成功为止。 Monitor 用于监控调用信息。 SpringBoot 整合 Dubbo、Zookeeper 父类 MAVEN 项目 springboot_dubbo，仅用于控制模块的依赖版本。pom 文件如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>springboot_dubbo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;artifactId>provider-ticket&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>provider-ticket&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-dependencies-zookeeper&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 项目模块 provider-ticket，用于继承父类依赖实现出票功能。 pom 文件继承父类 Dubbo 和 zookeeper 依赖版本。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>springboot_dubbo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;artifactId>provider-ticket&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>provider-ticket&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-dependencies-zookeeper&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置注册中心相关信息以及服务提供者所在位置，并通过@Service注解暴露服务。 application.yml配置包扫描+@Service配置方式（注意此处导入的一定要是import org.apache.dubbo.config.annotation.Service）。dubbo: application: name: provider-ticket registry: address: zookeeper://localhost:21810 scan: base-packages: com.kuukokawaii.ticket.service import org.apache.dubbo.config.annotation.Service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 10:42 * @Description 出票 service 实现 */ @Service public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"取到票了！！\"; } } @DubboComponentScan或@EnableDubbo注解+@Service的配置方式。@DubboComponentScan和@EnableDubbo注解二选一标注于主程序类上，接口实现类仍需@Service注解（注意导入 dubbo 的注解），而application.yml中则无需配置包扫描。/** * @Author 喵粮都输光了 * @Date 2019/12/6 10:47 * @Description 主程序 */ @SpringBootApplication //@DubboComponentScan(\"com.kuukokawaii.ticket.service\") @EnableDubbo(scanBasePackages = \"com.kuukokawaii.ticket.service\") public class ProviderTicketApplication { public static void main(String[] args) { SpringApplication.run(ProviderTicketApplication.class, args); } } import org.apache.dubbo.config.annotation.Service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 10:42 * @Description 出票 service 实现 */ @Service public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"取到票了！！\"; } } 项目模块 consumer-user，用于继承父类依赖调用 provider-ticket 模块的出票功能。 pom 文件继承父类 Dubbo 和 zookeeper 依赖版本。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>springboot_dubbo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;artifactId>consumer-user&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>consumer-user&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-dependencies-zookeeper&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置注册中心地址（与 provider-ticket 模块同）。 dubbo: application: name: consumer-user registry: address: zookeeper://localhost:21810 consumer-user 模块通过@Reference注解远程引用 provider-ticket 模块的服务则需要先编写服务接口，必须是与 provider-ticket 模块服务接口相同的全限定名。例如此处的com.kuukokawaii.ticket.service.TicketService;（不需要实现类）。 package com.kuukokawaii.ticket.service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 11:21 * @Description 远程调用出票服务 */ public interface TicketService { /** * 出票服务 * * @return 出票String */ String getTicket(); } 通过 dubbo 的@Reference注解远程引用服务，注意此处导入的@Service注解为org.springframework.stereotype.Service。 import org.apache.dubbo.config.annotation.Reference; import org.springframework.stereotype.Service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 11:22 * @Description 用户 service */ @Service public class UserService { @Reference private TicketService ticketService; public void hello() { System.out.println(ticketService.getTicket()); } } Spring Cloud Spring Cloud 是一个分布式的整体解决方案。Spring Cloud 为开发者提供了在分布式系统中快速构建的工具，使用 Spring Cloud 的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 Spring Cloud 分布式开发五大常用组件： Netflix Eureka：服务发现。 Netflix Ribbon：客户端负载均衡。 Netflix Hystrix：断路器。 Netflix Zuul：服务网关。 Spring Cloud Config：分布式配置。 Spring Cloud 对配置管理、服务发现、熔断、路由、微代理、控制总线、一次性 token、全局锁、leader 选举、分布式 session 和集群管理等问题都提供了相应的解决方案。 Spring Cloud 注册中心Spring Cloud 使用 eureka server 作为注册中心。 引入 Spring Cloud eureka server 依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>eureka-server&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>eureka-server&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.RELEASE&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置 eureka server 信息 server: port: 8761 eureka: instance: hostname: eureka-server client: # 是否注册到 eureka 服务器，此处没必要自己注册自己到服务器 register-with-eureka: false # 不从 eureka 上获取服务的注册信息 fetch-registry: false # 设置注册中心地址 service-url: defaultZone: http://localhost:${server.port}/eureka/ 通过@EnableEurekaServer注解标注主程序启用 eureka server。 /** * @Author 喵粮都输光了 * @Date 2019/12/6 12:39 * @Description 注册中心主程序 */ @EnableEurekaServer @SpringBootApplication public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } provider 服务提供者 引入 Spring Cloud Eureka Discovery Client 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>provider-ticket&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>provider-ticket&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.RELEASE&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置 eureka client provider 信息server: port: 8001 spring: application: name: provider-ticket eureka: instance: # 注册服务时使用服务的IP地址作为前缀 prefer-ip-address: true client: service-url: # 必须要和 eureka server 相同 defaultZone: http://localhost:8761/eureka/ eureka 提供服务 /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:12 * @Description 出票 service */ public interface TicketService { /** * 出票功能 * @return 出票String */ String getTicket(); } /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:08 * @Description 出票 service 实现 */ @Service public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"出票了！！\"; } } /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:10 * @Description 出票 controller */ @RestController public class TicketController { @Resource private TicketServiceImpl ticketService; @GetMapping(\"/ticket\") public String getTicket() { return ticketService.getTicket(); } } consumer 服务使用者 引入 Spring Cloud Eureka Discovery Client 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>consumer-user&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>consumer-user&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.RELEASE&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置 eureka client consumer 信息server: port: 8002 spring: application: name: consumer-user eureka: instance: # 注册服务时使用服务的IP地址作为前缀 prefer-ip-address: true client: service-url: # 必须要和 eureka server 相同 defaultZone: http://localhost:8761/eureka/ 通过@EnableDiscoveryClient注解开启发现服务功能/** * @Author 喵粮都输光了 * @Date 2019/12/6 12:43 * @Description consumer 主程序 */ @EnableDiscoveryClient @SpringBootApplication public class ConsumerUserApplication { public static void main(String[] args) { SpringApplication.run(ConsumerUserApplication.class, args); } /** * \"@LoadBalanced\"启用负载均衡机制。 * \"RestTemplate\"是Spring提供的用于访问Rest服务的客户端，提供了多种便捷访问远程Http服务的方法。 * 此处用于远程引用provider的服务。 * @return Rest服务客户端对象 */ @LoadBalanced @Bean public RestTemplate restTemplate() { return new RestTemplate(); } } consumer 调用 provider 服务/** * @Author 喵粮都输光了 * @Date 2019/12/6 13:53 * @Description 用户 controller */ @RestController public class UserController { @Resource private RestTemplate restTemplate; @GetMapping(\"/buy\") public String buyTicket() { // getForObject根据URL获取服务（此处填写需要获取的provider名和服务名），第二个参数为返回类型。 return restTemplate.getForObject(\"http://PROVIDER-TICKET/ticket\", String.class); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十一）：安全","date":"2019-12-04T09:54:41.000Z","path":"posts/f4c26338/","text":"安全机制安全机制主要包含认证（注册主体）和授权（访问权限控制）两个区域的控制。 认证：是建立一个声明主体的过程（主体通常指用户、设备或一些可以在应用程序中执行动作的其他系统）。 授权：确定一个主体是否允许在应用程序中执行一个动作的过程(授权前主体的身份必须通过了认证过程的建立)。 Spring SecuritySpring Security 是针对 Spring 项目的安全框架，也是 Spring Boot 底层安全模块默认的技术选型。对于安全控制，只需引入 Security 模块并进行少量的配置即可实现安全管理。Spring Security 通过WebSecurityConfigurerAdapter和AuthenticationManagerBuilder两个类提供自定义 Security 策略和认证策略功能。 引入 Security 依赖。&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-security&lt;/artifactId> &lt;/dependency> 编写 SpringSecurity 配置类，需要通过@EnableWebSecurity注解开启 SpringSecurity 支持。/** * @Author 喵粮都输光了 * @Date 2019/12/4 19:22 * @Description Security 配置类 */ @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Resource private DataSource dataSource; @Override protected void configure(HttpSecurity http) throws Exception { /* * 自定义授权规则： * 1.放行静态资源。 * 2.管理员页面需要管理员身份。 * 3.来宾页面需要来宾身份。 * 4.开启自动配置的登陆功能，如未登陆将自动跳转`/login`登陆界面，登陆失败将跳转至`/login?error`页面; * `successForwardUrl`自定义登陆成功跳转页面，`failureForwardUrl`自定义登陆失败跳转页面； * 默认'POST'请求'/login'表示进行登陆验证，'GET'请求'/login'表示跳转登陆页面； * `loginPage`自定义登陆界面，此时该页面的`GET`和`POST`分别成为了登陆验证和跳转登陆页面功能， * 可以通过`loginProcessingUrl`设置成默认的登陆验证； * `usernameParameter`可以自定义账号参数名，`passwordParameter`可以自定义密码参数名。 * 5.开启自动配置的注销功能，访问`/logout`表示用户注销，清空session，如果注销成功跳转至`/login?logout`页面； * `logoutSuccessUrl`设置注销成功跳转页面。 * 6.开启记住我功能，即自动帮忙登陆（该功能会保存cookie，注销会删除该cookie）， * 通过`rememberMeParameter()`可以自定义HTML中`checkbox`表单的`name`实现该功能。 */ http.authorizeRequests() .antMatchers(\"/css/**\", \"/\").permitAll() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"guest/**\").hasRole(\"GUEST\") .and() .formLogin() .and() .logout().logoutSuccessUrl(\"/\") .and() .rememberMe(); } /* @Bean @Override protected UserDetailsService userDetailsService() { // 使用默认的加密方式 bcrypt，PasswordEncoderFactories.createDelegatingPasswordEncoder()中实现了 10 种加密方式。 PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder(); UserDetails root = User.withUsername(\"root\") .password(passwordEncoder.encode(\"root\")).roles(\"GUEST\", \"ADMIN\").build(); UserDetails guest = User.withUsername(\"guest\") .password(passwordEncoder.encode(\"guest\")).roles(\"GUEST\").build(); // 用户信息存储于内存中 return new InMemoryUserDetailsManager(root, guest); }*/ @Bean @Override protected UserDetailsService userDetailsService() { // 使用自定义的加密方式 Map&lt;String, PasswordEncoder> encoders = new HashMap&lt;>(); encoders.put(\"MD5\", new org.springframework.security.crypto.password.MessageDigestPasswordEncoder(\"MD5\")); PasswordEncoder passwordEncoder = new DelegatingPasswordEncoder(\"MD5\", encoders); // 项目启动时默认创建两个用户 UserDetails root = User.withUsername(\"root\") .password(passwordEncoder.encode(\"root\")).roles(\"GUEST\", \"ADMIN\").build(); UserDetails guest = User.withUsername(\"guest\") .password(passwordEncoder.encode(\"guest\")).roles(\"GUEST\").build(); JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager(dataSource); jdbcUserDetailsManager.createUser(root); jdbcUserDetailsManager.createUser(guest); // 用户信息持久化 return jdbcUserDetailsManager; } } 在 HTML 界面显示授权信息，需要先整合 thymeleaf 和 security，即引入相关依赖即可。&lt;!-- spring security 和 thymeleaf 整合--> &lt;dependency> &lt;groupId>org.thymeleaf.extras&lt;/groupId> &lt;artifactId>thymeleaf-extras-springsecurity5&lt;/artifactId> &lt;/dependency> &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/extras/spring-security\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>首页&lt;/title> &lt;link rel=\"stylesheet\" th:href=\"@{/css/bootstrap.min.css}\"> &lt;/head> &lt;body> &lt;!-- 是否认证，如果认证成功了则不显示登陆超链接 --> &lt;div sec:authorize=\"!isAuthenticated()\"> &lt;a href=\"/login\">登陆页面&lt;/a> &lt;/div> &lt;!-- 是否认证，如果认证成功了则显示注销超链接和认证信息 --> &lt;div sec:authorize=\"isAuthenticated()\"> &lt;h2>账号：&lt;span sec:authentication=\"name\">&lt;/span>&lt;/h2> &lt;h2>所有身份信息：&lt;span sec:authentication=\"principal.authorities\">&lt;/span>&lt;/h2> &lt;a href=\"/logout\">注销&lt;/a> &lt;/div> &lt;!-- 是否拥有管理员权限，有则显示管理员信息超链接 --> &lt;div sec:authorize=\"hasRole('ADMIN')\"> &lt;a href=\"/admin/info\">管理员信息&lt;/a> &lt;/div> &lt;!-- 是否拥有来宾权限，有则显示来宾信息超链接 --> &lt;div sec:authorize=\"hasRole('GUEST')\"> &lt;a href=\"/guest/info\">来宾信息&lt;/a> &lt;/div> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十）：任务","date":"2019-12-04T06:16:25.000Z","path":"posts/454051ae/","text":"异步任务spring 提供了异步任务的功能。 在主程序类上开启异步注解支持@EnableAsync。@EnableAsync @SpringBootApplication public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } 在方法上使用异步注解@Async。/** * @Author 喵粮都输光了 * @Date 2019/12/4 14:20 * @Description 异步任务 service */ @Service public class AsyncService { @Async public void hello() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"处理数据中...\"); } } 定时任务Spring 通过TaskExecutor和TaskScheduler接口提供了异步执行任务调度的方式。 在主程序类上开启定时任务注解支持@EnableScheduling。 @EnableScheduling @SpringBootApplication public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } 在方法上使用异步注解@Scheduled。 /** * @Author 喵粮都输光了 * @Date 2019/12/4 14:52 * @Description 定时任务 service */ public class ScheduledService { @Scheduled(cron = \"0 * * * * MON-FRI\") public void hello() { System.out.println(\"hello\"); } } cron 表达式cron表达式一共有六个字段，分别为秒，分，时，日，月和周几，每个字段之间通过空格来间隔。 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 时 0-23 , - * / 日 1-31 , - * ? / L W C 月 1-12 , - * / 星期 0-7 或 SUN-SAT(0和7都是周日) , - * ? / L C # 特殊字符 含义 , 枚举，例如0,1,2代表这几个值都会被匹配。 - 区间，例如0-2代表0,1,2这几个值都会被匹配。 * 任意，所有允许值都会被匹配。 / 步长，例如0-2，在秒字段代表从0开始每2秒就会被匹配。 ? 日和星期冲突时，在日或者星期上标?表示按照另一个未标?的时间来匹配。 L 最后，具体看标识字段。例如0 0 2 ? * 6L表每个月最后一个周六，0 0 2 LW * ?表每个月最后一个工作日。 W 工作日，匹配工作日，只能标识在日上。 C 和 calendar 联系后计算过的值 # 第几个星期，如4#2表示第二个星期四，只能标识在星期上。 邮件任务SpringBoot 使用了jakarta-mail作为默认的邮件模块，通过引入相应的 starter 并配置些许配置即可使用邮件功能。 引入 mail 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-mail&lt;/artifactId> &lt;/dependency> application.yml中配置 mail 相关配置 spring: mail: username: 账号 password: 授权码 host: smtp.qq.com # 如果不加 port 则无需配置 properties。（此处为使用 SSL 加密方式发送邮件） port: 465 properties: mail: smtp: ssl: enable: true 简单邮件发送 @Resource private JavaMailSender javaMailSender; @Test public void send() { SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setSubject(\"邮件标题\"); simpleMailMessage.setText(\"邮件内容\"); simpleMailMessage.setTo(\"目标邮箱\"); simpleMailMessage.setFrom(\"发送邮箱\"); javaMailSender.send(simpleMailMessage); } 复杂邮件发送 @Resource private JavaMailSender javaMailSender; @Test public void send() throws MessagingException { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); // 第二个参数为是否要上传文件编码。 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); mimeMessageHelper.setSubject(\"邮件标题\"); // 第二个参数为是否开启 html 支持。 mimeMessageHelper.setText(\"&lt;b style='color: red'>邮件内容&lt;/b>\", true); mimeMessageHelper.setTo(\"目标邮箱\"); mimeMessageHelper.setFrom(\"发送邮箱\"); // 上传附件 mimeMessageHelper.addAttachment(\"1.jpg\", new File(\"附件地址\")); mimeMessageHelper.addAttachment(\"2.jpg\", new File(\"附件地址\")); javaMailSender.send(mimeMessage); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（九）：检索","date":"2019-12-02T15:02:04.000Z","path":"posts/8146c289/","text":"ElasticSearch ElasticSearch 是一个开源的分布式搜索服务，且提供 Restful API，底层基于 Lucene，采用多 shard（分片）的方式保证数据安全，并且提供自动 Resharding 的功能。SpringBoot 通过整合 Spring Data ElasticSearch 提供了便捷的检索功能支持。 ElasticSearch 概念 它是面向文档的，意味着它存储整个对象或文档，并索引每个文档的内容使之可以被检索。 将 JSON 作为文档的序列化格式。 将存储数据至 ElasticSearch 的行为称之为索引。一个 ElasticSearch 集群可以包含多个索引，每个索引可以包含多个类型，每个类型可以包含多个文档，而每个文档又可以有多个属性（例如雇员文档，一个文档代表一个雇员）。索引文档前需要确定文档存储位置。 在 ElasticSearch 中通过PUT、DELETE、PUT和HEAD请求来对文档进行增删改查（增加修改都用PUT）。 ElasticSearch 采用 Restful 风格请求处理数据（例如GET /index/type/id）。 ElasticSearch 相关文档查看ElasticSearch 官方权威指南。 SpringBoot 整合 ElasticSearchSpringBoot 默认支持两种技术来和 ElasticSearch 交互：Jest（需要引入依赖） 和 SpringData Elasticsearch（默认使用）。 Jest 引入 Jest 依赖 &lt;dependency> &lt;groupId>io.searchbox&lt;/groupId> &lt;artifactId>jest&lt;/artifactId> &lt;/dependency> 存储和查询数据 /** * @Author 喵粮都输光了 * @Date 2019/12/4 12:49 * @Description 文章 entity（JestId标识主键） */ @Data public class Article { @JestId private Integer id; private String title; private String author; private String content; } @Resource private JestClient jestClient; @Test void index() { Article article = new Article(); article.setId(1); article.setTitle(\"新闻标题\"); article.setAuthor(\"张三\"); article.setContent(\"新闻内容！！！！\"); // 构建一个索引功能。索引构建器，索引位置，类型，[.id()文档id]，构建 Index index = new Index.Builder(article).index(\"article\").type(\"news\").build(); try { // 执行存储操作（出现读取时间超时，在application.yml中设置读取时间） jestClient.execute(index); } catch (IOException e) { e.printStackTrace(); } } @Test void search() { String json = \"{\\n\" + \" \\\"query\\\": {\\n\" + \" \\\"match\\\": {\\n\" + \" \\\"content\\\": \\\"内容\\\"\\n\" + \" }\\n\" + \" }\\n\" + \"}\"; // 构建一个检索功能。检索构建器，索引位置，类型，[.id()文档id]，构建 Search search = new Search.Builder(json).addIndex(\"article\").addType(\"news\").build(); try { SearchResult searchResult = jestClient.execute(search); System.out.println(searchResult.getJsonString()); } catch (IOException e) { e.printStackTrace(); } } SpringData Elasticsearch 引入 SpringData Elasticsearch 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-elasticsearch&lt;/artifactId> &lt;/dependency> 通过 ElasticsearchRepository 调用 Elasticsearch /** * @Author 喵粮都输光了 * @Date 2019/12/4 12:32 * @Description 书本 entity */ @Data @Document(indexName = \"kuukokawaii\", type = \"book\") public class Book { private Integer id; private String bookName; private String author; } @Resource private BookRepository bookRepository; @Test void index() { Book book = new Book(); book.setId(1); book.setBookName(\"书本名\"); book.setAuthor(\"书本作者\"); bookRepository.index(book); } @Test void search() { for (Book book : bookRepository.findBooksByBookNameLike(\"书\")) { System.out.println(book); } } 通过 ElasticsearchTemplate 调用 Elasticsearch /** * @Author 喵粮都输光了 * @Date 2019/12/4 12:32 * @Description 书本 entity */ @Data @Document(indexName = \"kuukokawaii\", type = \"book\") public class Book { private Integer id; private String bookName; private String author; } @Resource private ElasticsearchRestTemplate elasticsearchRestTemplate; @Test void index() { Book book = new Book(); book.setId(1); book.setBookName(\"书本名\"); book.setAuthor(\"书本作者\"); // 构建索引构建器 IndexQuery indexQuery = new IndexQueryBuilder().withObject(book).build(); // 存储数据 elasticsearchRestTemplate.index(indexQuery); } @Test void search() { // 查询语句 MatchQueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(\"bookName\", \"书本\"); // 根据查询语句构建查询构建器 SearchQuery searchQuery = new NativeSearchQueryBuilder().withQuery(matchQueryBuilder).build(); // 进行查询，查询构建器，查询的类 for (Book book : elasticsearchRestTemplate.queryForList(searchQuery, Book.class)) { System.out.println(book); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://blog.kuukokawaii.com/tags/elasticsearch/"}]},{"title":"SpringBoot（八）：消息队列","date":"2019-12-01T02:51:55.000Z","path":"posts/2b1dfb69/","text":"消息队列大多应用中可通过消息服务中间件来提升系统异步通信、扩展解耦能力。在消息服务中有消息代理和目的地两个重要的概念，即当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。在消息队列中主要拥有两种形式的目的地，分别为队列和主题，前者用于点对点消息通信，后者用于发布/订阅消息通信。 JMS 和 AMQP 比对 JMS AMQP 定义 Java api 网络线级协议 跨语言 否 是 跨平台 否 是 Model 提供两种消息模型：1.Peer-2-Peer2.Pub/Sub 提供五种消息模型：1.direct exchange2.fanout exchange3.topic exchange4.headers exchange5.system exchange本质来讲，后四种和 JMS 的 Pub/Sub 模型没有太大差别，仅是在路由机制上做了更详细的划分。 支持消息类型 多种消息类型：1.TextMessage2.MapMessage3.BytesMessage4.StreamMessage5.ObjectMessage6.Message（只有消息头和属性） byte[]当实际应用时，有复杂的消息，可以将消息序列化后发送。 综合评价 JMS 定义了 JAVA API 层面的标准。在 JAVA 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。 AMQP 定义了 wire-level 层的协议标准，天然具有跨平台、跨语言特性。 SpringBoot 中的消息队列 spring-jms 提供了对 JMS 的支持。 spring-rabbit 提供了对 AMQP 的支持。 需要ConnectionFactory的实现来连接消息代理。 提供JmsTemplate和RabbitTemplate来发送消息。 将@JmsListener（JMS）和@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息。 @EnableJms和@EnableRabbit开启注解支持。 RabbitMQ 简介RabbitMQ 是一个由 erlang 开发的 AMQP（Advanced Message Queue Protocol） 的开源实现。 核心概念 组件 作用 Message 消息由消息头和消息体组成。其中消息体是不透明的，消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键，决定消息目的地）、priority（相对于其他消息的优先权）和delivery-mode（标明该消息是否需要持久性存储）等。 Publisher 消息的生产者，用于向交换器发布消息，即向消息代理发送消息。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列（根据路由键选择队列）。 Queue 消息队列，用来保存消息直到发送给消费者，一个消息可投入一个或多个队列。 Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列l连接起来的又有规则，Exchange 和 Queue 的绑定可以是多对多的关系。 Connection 网络连接，比如一个 TCP 连接。 Channel 信道是建立在真实的 TCP 连接内的虚拟连接，AMQP 的命令都是通过信道发送出去。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。（类似线程与进程） Consumer 消息的消费者，用于从消息队列中获取消息。 Virtual Host 虚拟主机（简称 vhost），是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个缩小版的 RabbitMQ 服务器，消息代理中可以有多个 vhost 。在连接时，必须指定具体的 vhost，RabbitMQ 默认的 vhost 是 / Broker 消息代理，表示消息队列服务器的实体 Exchange 类型 direct：当消息中的路由键和 Binding 中的 binding key 一致时，交换器就将消息发到对应的队列中。 fanout：交换器会将消息发送到所有与自己绑定的队列上，速度是交换器中最快的（类似广播）。 topic：交换器通过模式匹配分配消息的路由键属性，将路由器和某一个模式进行匹配，此时队列需要绑定到一个模式上。通过识别两个通配符#和*对路由键和绑定键的字符串进行切分，其中前者匹配0个或多个单词，后者匹配一个单词。 header：header 匹配 AMQP 消息的 header 而不是路由键，与 direct 交换器类似但性能差许多，通常不用。 整合 RabbitMQ 引入 RabbitMQ 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-amqp&lt;/artifactId> &lt;/dependency> application.yml中配置 RabbitMQ 相关配置 spring: rabbitmq: username: 账号 password: 密码 virtual-host: \"/\" RabbitTemplate 用于发送和接收消息 @Resource private RabbitTemplate rabbitTemplate; @Test void sendMessage() { // 自动序列化发送消息（使用send方法不会自动序列化） rabbitTemplate.convertAndSend(\"study.direct\", \"study.news\", \"消息体可以是对象\"); } @Test void receiveMessage() { // 自动反序列化转化接收的消息 Object message = rabbitTemplate.receiveAndConvert(\"study.news\"); System.out.println(message); } 配置消息转换器序列化方式 /** * @Author 喵粮都输光了 * @Date 2019/12/2 22:04 * @Description AMQP 配置 */ @Configuration public class AmqpConfig { @Bean public MessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); } } @EnableRabbit+@RabbitListener注解用于监听消息队列 /** * @Author 喵粮都输光了 * @Date 2019/11/21 22:07 * @Description SpringBoot应用主程序 */ @EnableRabbit @SpringBootApplication public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } /** * @Author 喵粮都输光了 * @Date 2019/12/2 22:14 * @Description 书 service */ @Service public class BookService { @RabbitListener(queues = \"study.news\") public void receive(Book book) { System.out.println(\"收到的消息：\" + book); } @RabbitListener(queues = \"study\") public void receive1(Message message) { // 获取消息体 System.out.println(Arrays.toString(message.getBody())); // 获取消息头 System.out.println(message.getMessageProperties()); } } AmqpAdmin 系统管理功能组件，用于创建删除 exchange，queue 和 binding。 @Resource private AmqpAdmin amqpAdmin; @Test void createExchange() { // 创建 exchange amqpAdmin.declareExchange(new DirectExchange(\"study.direct\")); // 创建 queue，是否开启持久化 amqpAdmin.declareQueue(new Queue(\"study.queue\", true)); // 创建 binding （绑定目的地名[此处队列名]，绑定目的地类型[此处队列]，交换名，路由键，参数） amqpAdmin.declareBinding(new Binding(\"study.queue\", Binding.DestinationType.QUEUE, \"study.direct\", \"study\", null)); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（七）：缓存","date":"2019-11-30T04:06:19.000Z","path":"posts/676006d6/","text":"JSR-107Java Caching 定义了5个核心接口，分别为： CachingProvider：定义了创建、配置、获取、管理和控制多个 CacheManager。一个应用可以在运行期间访问多个 CachingProvider。 CacheManager：定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cache 存在于 CacheManager 的上下文中。且一个 CacheManager 仅被一个 CachingProvider 所拥有。 Cache：类似 Map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 所拥有。 Entry： 存储在 Cache 中的 Key-Value 对。 Expiry： 每一个存储在 Cache 中的条目有一个定义的有效期。一旦超过这个时间，Entry 就变为了过期状态。一旦过期，Entry 将不可访问、更新和删除。缓存有效期可以通过 ExpiryPolicy设置。 JSR-107 只需引入如下依赖即可使用： &lt;dependency> &lt;groupId>javax.cache&lt;/groupId> &lt;artifactId>cache-api&lt;/artifactId> &lt;/dependency> Spring 缓存抽象为了简化开发，Spring 定义了 Cache 和 CacheManager 接口来统一不同的缓存技术，同时 Spring 也支持使用 JCache（JSR-107）注解简化开发。 Spring 缓存注解 注解及参数 作用 参数 @Cacheable 根据方法的请求参数对其结果进行缓存，常用于创建。 1.cacheNames/value：指定缓存组件名（可以多个）。2.key：缓存数据使用的 Key（默认使用方法参数的值，可以使用 SpEL 表达式）。3.keyGenerator：Key 的生成器，可以指定 Key 生成器的组件 id（与key二选一）。4.cacheManager：指定缓存管理器。5.cacheResolver：指定获取解析器（与cacheManager二选一）。6.condition：指定符合条件的情况下才缓存。unless：指定符合条件的情况下不进行缓存，并且可以获取缓存结果进行判断。7.sync：是否使用异步模式，此时不支持unless参数。 @CachePut 保证方法一定会被调用且结果会被缓存，常用于更新，如果指定 key 被更新则需要同时更新 key。 @CacheEvict 清空缓存，常用于删除，需要指定删除的 key。 1.key：如未指定则会使用默认策略生成的 key。2.allEntries：是否删除指定 cache 中的所有数据。3.beforeInvocation：缓存的清除是否在方法之前执行（默认 false）。 @EnableCaching 开启基于注解的缓存。 @Caching 是@Cacheable、@CachePut和@CacheEvict的组合注解。 @CacheConfig 抽取缓存的公共配置，标注于类上，类中的缓存注解会默认使用公共配置的参数。 keyGenerator 缓存数据时 Key 的生成策略。 serialize 缓存数据时 Value 序列化策略。 @Cacheable可用 SpEL 表达式 名字 位置 作用 示例 methodName root object 当前被调用的方法名。 #root.methodName method root object 当前被调用的方法。 #root.method.name target root object 当前被调用的目标对象。 #root.target targetClass root object 当前被调用的目标对象类。 #root.targetClass args root object 当前被调用的方法的参数列表。 #root.args[0] caches root object 当前方法调用的缓存列表（如@Cacheable(cacheNames={\"cache1\",\"cache2\"})）。 #root.caches[0].name argument name evaluation context 方法参数的名字，可以直接#参数名，也可以使用#p0或#a0的形式，其中0代表参数的的索引。 #iban、#a0、#p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效）。 #result 缓存使用注意事项 缓存注解不能定义在接口上。 加缓存注解的方法必须为公有（public）的。 @Cahcheable必须指定至少一个cacheNames。 注解使用示例 @Cacheable @Override @Cacheable(cacheNames = \"employee\") public Employee getEmployee(Integer id) { return employeeMapper.getEmployeeById(id); } @CachePut @Override @CachePut(cacheNames = \"employee\", key = \"#result.id\") public Employee updateEmployee(@RequestBody Employee employee) { return employeeMapper.updateEmployee(employee); } @CacheEvict @Override @CacheEvict(cacheNames = \"employee\", key = \"#id\") public int removeEmployee(Integer id) { return employeeMapper.removeEmployeeById(id); } @Caching @Override @Caching( cacheable = { @Cacheable(cacheNames = \"employee\", key = \"#lastName\") }, put = { @CachePut(cacheNames = \"employee\", key = \"#result.id\"), @CachePut(cacheNames = \"employee\", key = \"#result.email\") } ) public Employee getEmployee(String lastName) { return employeeMapper.getEmployeeByLastName(lastName); } @CacheConfig @Service @CacheConfig(cacheNames = \"employee\") public class EmployeeServiceImpl implements EmployeeService { @Resource private EmployeeMapper employeeMapper; @Override @Cacheable public Employee getEmployee(Integer id) { return employeeMapper.getEmployeeById(id); } } 整合 RedisRedis 是一个开源的，内存中的数据结构存储系统，可以用作数据库、缓存和消息中间件。 引入 Redis 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId> &lt;/dependency> application.yml中配置 Redis 相关配置 spring: redis: host: xxx.xxx.xxx.xxx 使用RedisTemplate或StringRedisTemplate操作 Redis RedisTemplate用于操作 K-V 都是字符串的数据。 StringRedisTemplate用于操作 K-V 都是对象的数据。 Redis 常见的五大数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）和ZSet（有序集合）。分别通过五类方法操作：opsForValue()、opsForList()、opsForSet()、opsForHash()和opsForZSet()。 Redis 命令查询 配置RedisCacheManager，并修改 Key 和 Value 的保存格式。之后便可使用 Spring 缓存抽象操作 Redis。 @Configuration public class RedisConfig { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { // Key 使用 StringRedisSerializer 的方式保存 RedisSerializer&lt;String> redisSerializer = new StringRedisSerializer(); // Value 使用 Jackson2JsonRedisSerializer 的方式保存 Jackson2JsonRedisSerializer&lt;Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;>(Object.class); // 解决查询缓存反序列化出错问题 ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); // entryTtl(Duration.ofHours(1))设置生存周期 RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofHours(1)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)).disableCachingNullValues(); return RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(redisCacheConfiguration).build(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（六）：数据访问","date":"2019-11-27T05:15:47.000Z","path":"posts/fd098bd4/","text":"SpringDataSpringData 主要用于简化数据库的访问，开发者只需声明持久层接口即可。SpringData 支持 NoSQL 和关系数据库存储。 JDBC 引入 JDBC 依赖。 &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> application.yml 配置数据源。 spring: datasource: username: 账号 password: 密码 url: jdbc:mysql://localhost:3306/表名?serverTimezone=UTC driver-class-name: 数据库驱动 # 表初始化，默认加载schema.sql（冒号后无空格，不使用请注释） schema: - classpath:sql/department.sql # 数据初始化，默认加载data.sql（冒号后无空格，不使用请注释） data: - classpath:sql/department_data.sql # 初始化模式（不使用请注释） initialization-mode: always # department.sql DROP TABLE IF EXISTS department; CREATE TABLE department( id INT PRIMARY KEY NOT NULL, departmentName varchar(45) NOT NULL ); # department_data.sql INSERT INTO department (id, departmentName) SELECT '1', 'AA' FROM dual WHERE NOT EXISTS(SELECT id from department WHERE id = '1'); 使用 JdbcTemplate 进行查询。 /** * @Author 喵粮都输光了 * @Date 2019/11/27 14:50 * @Description 查询 controller */ @Controller public class QueryController { private final JdbcTemplate jdbcTemplate; @Autowired public QueryController(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @GetMapping(\"/query\") @ResponseBody public Map&lt;String, Object> map() { List&lt;Map&lt;String, Object>> list = jdbcTemplate.queryForList(\"SELECT id, departmentName FROM department\"); return list.get(0); } } 配置 druid 连接池。（在spring.datasource下配置） druid: # 初始化大小，最小，最大 initial-size: 5 min-idle: 10 max-active: 20 # 配置获取连接等待超时的时间 max-wait: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 min-evictable-idle-time-millis: 300000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 time-between-eviction-runs-millis: 600000 validation-query: SELECT 1 test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙。（stat,wall,log4j） filters: stat,wall # 通过connection-properties属性来打开mergeSql功能；慢SQL记录 connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 use-global-data-source-stat: true # 配置DruidStatFilter web-stat-filter: enabled: true url-pattern: \"/*\" exclusions: \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\" # 配置DruidStatViewServlet stat-view-servlet: enabled: true url-pattern: \"/druid/*\" # IP白名单(没有配置或者为空，则允许所有访问) allow: 127.0.0.1 # IP黑名单 (存在共同时，deny优先于allow) deny: # 禁用HTML页面上的“Reset All”功能 reset-enable: false # 登录名 login-username: root # 登录密码 login-password: root MyBatis 引入 Mybatis 依赖。 &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>2.1.0&lt;/version> &lt;/dependency> 注解的方式进行 dao 操作。（可以去掉@Mapper注解，应用入口程序处添加@MapperScan注解批量扫描包。） /** * @Author 喵粮都输光了 * @Date 2019/11/27 19:00 * @Description 部门 dao */ @Mapper public interface DepartmentDao { /** * 根据部门id查询部门对象 * * @param id 部门id * @return 部门对象 */ @Select(\"SELECT id, departmentName FROM department WHERE id = #{id}\") Department getDepartmentById(Integer id); /** * 根据部门id删除部门 * * @param id 部门id * @return 更新条数 */ @Delete(\"DELETE FROM department WHERE id = #{id}\") int removeDepartmentById(Integer id); /** * 根据部门对象增加部门。（useGeneratedKeys 注解让自增的主键会重新封装入 Department 对象中。） * * @param department 部门对象 * @return 更新条数 */ @Insert(\"INSERT INTO department (departmentName) value (#{departmentName})\") @Options(useGeneratedKeys = true, keyProperty = \"id\", keyColumn = \"id\") int createDepartment(Department department); /** * 根据id更新部门信息 * * @param department 部门对象 * @return 更新条数 */ @Update(\"UPDATE department set departmentName = #{department} WHERE id = #{id}\") int updateDepartment(Department department); } 配置文件的方式进行 dao 操作。再配置注解扫描的基础上配置 xml 文件所在位置，即通过在application.yml中配置 xml 文件的位置，例如mybatis.mapper-locations: com/kuukokawaii/springbootstudy/**/dao/**.xml，即可实现配置文件的方式进行 dao 操作。 mybatis: # 下划线转驼峰命名 configuration: map-underscore-to-camel-case: true # xml 配置文件路径 mapper-locations: com/kuukokawaii/springbootstudy/**/dao/**.xml /** * @Author 喵粮都输光了 * @Date 2019/11/29 14:34 * @Description 员工 dao */ @Mapper public interface EmployeeMapper { /** * 根据 id 查找对应的员工信息。 * @param id 员工id * @return 员工对象 */ Employee getEmployeeById(int id); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.kuukokawaii.springbootstudy.employee.dao.EmployeeMapper\"> &lt;resultMap id=\"BaseResultMap\" type=\"com.kuukokawaii.springbootstudy.employee.entity.Employee\"> &lt;!--@mbg.generated--> &lt;!--@Table employee--> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"last_name\" jdbcType=\"VARCHAR\" property=\"lastName\"/> &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\"/> &lt;result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\"/> &lt;result column=\"d_id\" jdbcType=\"INTEGER\" property=\"dId\"/> &lt;/resultMap> &lt;sql id=\"Base_Column_List\"> &lt;!--@mbg.generated--> id, last_name, email, gender, d_id &lt;/sql> &lt;select id=\"getEmployeeById\" resultMap=\"BaseResultMap\"> select &lt;include refid=\"Base_Column_List\"/> from employee where id = #{id,jdbcType=INTEGER} &lt;/select> &lt;/mapper> Spring Data JPA 基本功能 JpaRepository 基本功能。 Spring Data JPA 具有统一的 Repository 接口，通过继承该接口可以实现 CRUD 和分页等操作。 定义符合规范的方法命名。 在接口中只需要声明符合规范的方法，即拥有对应的功能。 通过@Query自定义查询，定制查询 SQL。 支持动态查询（Specifications 查询）。 引入 JPA 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId> &lt;/dependency> 使用 JPA 根据 entity 自动建表，在application.yml中加入如下配置。 spring: jpa: hibernate: # 根据 entity 更新或者创建数据表结构 ddl-auto: update # 控制台显示 SQL show-sql: true 新建 entity。 @Entity用于标注该类是实体类。 @Table可以标明该表的表名和所属 schema。 @Id用于标注该属性是主键。 @GeneratedValue包含strategy和generator两个参数。前者包含AUTO、IDENTITY、SEQUENCE和Table四个属性，其作用分别为主键由程序控制（默认值）、主键由数据库生成采用数据库的自增形式（Oracle 不支持）、主键通过数据库的序列生成（Mysql 不支持）和提供特定的数据库产生主键方式（利于数据库移植）；后者用于声明主键生成器的名称。 @Column用于标注数据库列名及该列属性。/** * @Author 喵粮都输光了 * @Date 2019/11/29 15:53 * @Description 用户 entity */ @Entity @Data @Table(name = \"user\", schema = \"springboot_study\") @JsonIgnoreProperties(value = { \"hibernateLazyInitializer\"}) public class User { /** * 用户id */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; /** * 用户名 */ @Column(name = \"last_name\", length = 45, nullable = false) private String lastName; /** * 用户邮箱 */ @Column(name = \"email\", length = 45, nullable = false) private String email; } 编写接口继承JpaRepository接口。接口上泛型分别写对应的实体类和该实体类的主键。 /** * @Author 喵粮都输光了 * @Date 2019/11/29 16:09 * @Description 用户 repository */ public interface UserRepository extends JpaRepository&lt;User, Integer> {} JpaRepository接口的使用。如果 get 方法出现com.fasterxml.jackson.databind.exc.InvalidDefinitionException:错误，则需要在实体类上加@JsonIgnoreProperties(value={\"hibernateLazyInitializer\"})的注解，防止jsonplugin操作hibernateLazyInitializer属性。 /** * @Author 喵粮都输光了 * @Date 2019/11/29 16:38 * @Description 用户 controller */ @RestController public class UserController { private final UserRepository userRepository; @Autowired public UserController(UserRepository userRepository) { this.userRepository = userRepository; } @GetMapping(\"/user/{id}\") public User getUser(@PathVariable(\"id\") int id) { return userRepository.getOne(id); } @PostMapping(\"/user\") public User createUser(@RequestBody User user) { return userRepository.save(user); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（五）：Docker","date":"2019-11-27T01:45:29.000Z","path":"posts/3096723d/","text":"什么是 DockerDocker 是基于 Go 语言并遵从 Apache 协议开源的一个开源的应用容器引擎，支持将软件编译成一个镜像并设置镜像中各软件的配置，获得镜像的其他使用者可以直接使用镜像。Docker 容器是完全使用沙箱机制的，相互之间不会有任何接口，更重要的是容器性能开销极低。 Docker 核心概念Docker 主机从仓库下载所需镜像并通过 daemon 运行镜像产生容器之后，Docker 客户端就可以连接主机进行操作。 Docker 镜像（Images）：Docker 镜像是用于创建 Docker 容器的模板。 Docker 容器（Container）：容器是独立运行的一个或一组应用。 Docker 客户端（Client）：客户端通过命令行或者其他工具使用 Docker。 Docker 主机（Host）：一个物理或虚拟的机器用于执行 Docker 守护进程和容器。 Docker 仓库（Registry）：Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub提供了庞大的镜像集合供使用。 Docker 常用操作镜像操作| 操作 | 命令 | 说明 | | --- | ---- | ---- | | 检索 | docker search 关键字 | 常用于检索镜像的详细信息，或镜像版本。 | | 拉取 | docker pull 镜像名:tag | `:tag`是可选的，tag 表示标签，多为软件的版本，默认是 latest。 | | 列表 | docker images | 查看所有本地镜像。 | | 删除 | docker rmi image-id | 删除指定的本地镜像。 |容器操作| 操作 | 命令 | 说明 | | --- | ---- | ---- | | 运行 | docker run --name container-name &lt;br&gt; -d image-name | `--name`：自定义容器名; &lt;br&gt;`-d`：后台运行; &lt;br&gt;`image-name`：指定镜像模板（推荐加上版本号）。 | | 列表 | docker ps | 查看运行中容器，加上`-a`可以查看所有容器。 | | 停止 | docker stop container-name/container-id | 停止指定的运行中容器。 | | 启动 | docker start container-name/container-id | 启动指定的容器。 | | 删除 | docker rm container-id | 删除指定容器。 | | 端口映射 | 输入运行容器命令时添加`-p`命令 &lt;br&gt;例：docker run -d -p 6379:6379 镜像名 | `-p`主机端口映射至容器内部的端口。 | | 容器日志 | docker logs container-name/container-id | 查看容器日志。 | document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"},{"name":"docker","slug":"docker","permalink":"https://blog.kuukokawaii.com/tags/docker/"}]},{"title":"SpringBoot（四）：WEB 开发","date":"2019-11-24T06:27:09.000Z","path":"posts/4fa653eb/","text":"静态资源映射规则SpringBoot 的静态资源与 SSM 框架整合的静态资源所在位置不同，SSM 框架静态资源存储于 webapp 的 static 中，而 SpringBoot 的静态资源存储于 resources 中。SpringBoot 默认有两种静态资源映射模式： webjars 模式 应用使用 MAVEN 导入 webjars 的静态资源依赖，则所有通过该方法导入的静态资源都存储于classpath:/META-INF/resources/webjars/中。需要访问时，只需要通过类似http://localhost:8080/webjars/所需资源名的方式即可完成调用。 自定义模式 通过查看 SpringBoot 源码中的WebMvcAutoConfiguration和ResourceProperties类的SERVLET_LOCATIONS和CLASSPATH_RESOURCE_LOCATIONS常量，可以得出静态资源的默认存储位置为classpath:/META-INF/resources/、classpath:/resources/、classpath:/static/、classpath:/public/和/。调用方式与 webjars 模式类似，例如静态文件存储于classpath:/static/，则调用方式如http://localhost:8080/所需资源名即可。欢迎页静态资源文件夹下的所有index.html页面都会被映射为/，也就是说当你输入http://localhost:8080/时，就会自动跳转至index.html页面。修改静态资源位置可以在application.yml中通过spring.resources.static-locations设置默认的静态资源位置，使用该条命令会使 SpringBoot 本身的默认静态资源位置失效，因此不推荐修改。 Thymeleaf 模板引擎 模板引擎用于将视图和数据进行整合解析，而不同的模板引擎之间的区别仅在于模板引擎获取数据的语法不同。 SpringBoot 推荐使用 Thymeleaf 模板引擎，因为其语法更简洁，功能共强大。通过 MAVEN 引入 Thymeleaf 模板引擎的依赖。（如需修改 thymeleaf 版本则需注意thymeleaf-layout-dialect.version） &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> Thymeleaf 将classpath:/templates/作为默认的视图存储位置，只需将 HTML 页面放入该文件夹中，Thymeleaf 就能自动渲染。 Thymeleaf 的使用&amp;语法： 导入 Thymeleaf 的命名空间。(不导入不会出错，但是 HTML 页面不会有 Thymeleaf 语法提示。) &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> 后端通过Model、ModelMap、ModelAndView或Map向前端传输数据。 @RequestMapping(\"/helloPage\") public String hello(ModelMap modelMap) { modelMap.addAttribute(\"hello\", \"helloValue\"); return \"hello\"; } 在对应的 HTML 中使用 Thymeleaf 语法。 &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;p th:text=\"${hello}\">&lt;/p> &lt;/body> &lt;/html> WebMvc 扩展与全面接管SpringBoot 在自动配置组件时，会先扫描容器中是否有用户自定义的配置，如果有则使用用户自定义的配置文件或将用户自定义的配置文件与默认的自动配置文件组合起来，没有则执行 SpringBoot 的自动配置。例如&lt;mvc:view-controller path=\"/hello\" view-name=\"hello\"/&gt;映射/hello至hello.html页面。而在 SpringBoot 中可以通过@Configuration注解 + 实现WebMvcConfigurer接口中addViewControllers方法的形式实现该功能，SpringBoot 不仅保留了所有的自动配置，而且还加载了自定义的扩展功能。 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/hello\").setViewName(\"hello\"); } } 当需要对 WebMvc 进行全面接管时（即使得 SpringBoot 不进行自动配置，而是按照自定义的配置加载），通过使用@EnableWebMvc注解即可实现该效果，此时 SpringBoot 自动配置将失效且仅保留 SpringMVC 最进本的效果。 错误处理机制SpringBoot 错误的默认处理机制是通过ErrorMvcAutoConfiguration为容器添加了DefaultErrorAttributes、BasicErrorController、ErrorPageCustomizer和DefaultErrorViewResolver组件。一旦应用出现错误，ErrorPageCustomizer就会向/error/控制器发起请求（类似web.xml注册错误页面的规则），此时会进入BasicErrorController控制器。该控制器根据请求头向用户发送错误 HTML 页面或 JSON 数据，最终通过DefaultErrorAttributes中的错误状态码响应至特定的页面。 定制错误 HTML 页面 在拥有模板引擎的情况下，将错误状态码.html放置在模板引擎文件夹下的 error 文件夹中，SpringBoot 就会自动进行错误页面的配置。也可以将错误页面命名为4xx.html或5xx.html等，表示匹配所有 4 开头或者 5 开头的错误状态码，当项目下同时拥有类似4xx.html和404.html时，则会按精确优先的方式响应至404.html的错误页面。 在没有模板引擎的情况下，SpringBoot 将会在静态资源文件夹下的 error 文件夹中寻找错误页面。 如上述两处都没有发现错误页面，将跳转至 SpringBoot 默认的错误提示页面。 使用模板引擎的错误页面可以通过语法获取页面的错误信息，如timestamp：时间戳、status：状态码、error：错误提示、exception：异常对象、message：异常消息和errors：JSR303 数据校验错误。（如获取不到exception，则需要在application.yml中将server.error.include-exception开启） 定制错误 JSON 数据 自定义异常处理数据，浏览器和客户端返回的都是 JSON 数据。 /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:42 * @Description 异常处理器 */ @ControllerAdvice public class CustomExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String, Object> handleException(Exception e) { Map&lt;String, Object> map = new HashMap&lt;>(2); map.put(\"code\", \"userNotExist\"); map.put(\"message\", e.getMessage()); return map; } } 将异常请求转发至/error页面，通过 SpringBoot 自行产生自适应 /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:42 * @Description 异常处理器 */ @ControllerAdvice public class CustomExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public String handleException(HttpServletRequest request, Exception e) { // 设置错误状态码 request.setAttribute(\"javax.servlet.error.status_code\", 500); return \"/error\"; } } 拥有自适应效果且能携带定制数据/** * @Author 喵粮都输光了 * @Date 2019/11/26 16:36 * @Description 自定义 ErrorAttributes */ @Component public class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map&lt;String, Object> errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace); errorAttributes.put(\"customError\", webRequest.getAttribute(\"customError\", 0)); return errorAttributes; } } /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:42 * @Description 异常处理器 */ @ControllerAdvice public class CustomExceptionHandler { @ExceptionHandler(UserNotExistException.class) public String handleException(HttpServletRequest request, Exception e) { // 设置错误状态码 request.setAttribute(\"javax.servlet.error.status_code\", 500); Map&lt;String, Object> map = new HashMap&lt;>(2); map.put(\"code\", \"userNotExist\"); map.put(\"message\", e.getMessage()); request.setAttribute(\"customError\", map); return \"/error\"; } } SpringBoot 嵌入式 Servlet 容器 SpringBoot 默认使用 Tomcat 作为嵌入式的 Servlet 容器，需要对 Servlet 容器进行修改可以通过如下两种方式： 在application.yml中通过server.xxxx修改，如需修改 Tomcat 配置则通过server.tomcat.xxx进行修改。 编写一个嵌入式的 Servlet 容器定制器WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;来修改 Servlet 容器的配置。（优先级高于配置文件）@Bean public WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory> webServerFactoryCustomizer() { return new WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory>() { @Override public void customize(ConfigurableServletWebServerFactory factory) { factory.setPort(8081); } }; } SpringBoot 默认时以 Jar 包的方式启动嵌入式的 Servlet 容器来启动 Web 应用，没有 web.xml 文件，因此提供ServletRegistrationBean、FilterRegistrationBean和ServletListenerRegistrationBean三大组件用于注册 Servlet、Filter 和Listener。 ServletRegistrationBean /** * @Author 喵粮都输光了 * @Date 2019/11/26 17:17 * @Description 自定义 servlet */ public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().write(\"Hello Servlet！！！\"); } } @Bean public ServletRegistrationBean&lt;MyServlet> servletRegistrationBean() { return new ServletRegistrationBean&lt;>(new MyServlet(), \"/myServlet\"); } FilterRegistrationBean /** * @Author 喵粮都输光了 * @Date 2019/11/26 17:31 * @Description 自定义 filter */ public class MyFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"MyFilter process...\"); chain.doFilter(request, response); } } @Bean public FilterRegistrationBean&lt;MyFilter> filterFilterRegistrationBean() { FilterRegistrationBean&lt;MyFilter> filterFilterRegistrationBean = new FilterRegistrationBean&lt;>(); filterFilterRegistrationBean.setFilter(new MyFilter()); // 设置要拦截的请求 filterFilterRegistrationBean.setUrlPatterns(Arrays.asList(\"/hello\", \"/\")); return filterFilterRegistrationBean; } ServletListenerRegistrationBean /** * @Author 喵粮都输光了 * @Date 2019/11/26 17:40 * @Description 自定义 listener */ public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"web 应用启动\"); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\"web 应用销毁\"); } } @Bean public ServletListenerRegistrationBean&lt;MyListener> servletListenerRegistrationBean() { return new ServletListenerRegistrationBean&lt;>(new MyListener()); } 其他内嵌式的 Servlet 容器 Jetty 适用于长连接应用。 Undertow 高性能非阻塞，并发性能非常强，但不支持 JSP。 内嵌式的 Servlet 容器切换方法：只需将默认的 Tomcat 依赖排除，然后引入其他内嵌式 Servlet 容器依赖即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（三）：日志","date":"2019-11-23T02:39:48.000Z","path":"posts/1d79677f/","text":"日志框架市场上存在多种日志框架，日志接口有 JCL、SLF4j 和 jboss-logging，日志具体实现有 Log4j、Logback、JUL 和 Log4j2。其中 JUL 是 JAVA 官方日志；JCL 和 Log4j2 是 apache 开发的日志接口；SLF4j、Log4j 和 Logback 是由同一作者开发完成，所以适配性较好，当中的 Log4j 存在性能问题，其升级版为 Logback。 SLF4j SLF4j 是针对日志框架开发的一个统一接口层，因此只需实现 SLF4j 即可使用日志功能，这样分层的好处是更改日志接口的实现框架依赖便可完成日志框架的升级。 SpringBoot 的底层是 Spring 框架，而 Spring 框架默认是用 JCL 日志接口，但是 SpringBoot 默认排除了 JCL 依赖，使用 SLF4j 和 Logback 作为自己的日志框架。 SLF4j 针对按自己接口实现的日志框架只需导入日志实现框架依赖即可，而针对不是按自己接口的日志实现框架则需要额外导入一个适配依赖，才能完成日志功能。适配依赖的原理即实现 SLF4j 接口，实现方式就是包装对应的日志实现框架方法。 每个日志实现框架都有自己的配置文件，即使使用了 SLF4j，配置文件还是使用日志实现框架的配置文件。 统一日志框架SpringBoot 整合了许多框架，而每一个框架使用的可能都不是同一个日志框架，因此需要对这些框架的日志框架进行统一。将日志框架统一成 SLF4j 的步骤如下： 先排除系统中其他日志实现框架的依赖。 用中间包来替换排除的日志实现框架依赖，否则会报错。中间包的原理即覆写排除了的日志实现框架，将其所有方法的原有调用都转为调用 SLF4j 的方法，这样即可防止报错并实现功能。 之后导入 SLF4j 和日志实现框架依赖。（根据日志实现框架选择是否需要添加适配依赖） 日志默认配置全局常规设置SpringBoot 自配配置了默认的日志配置，可以在application.yml中修改部分配置。 修改日志输出文件位置在application.yml中可以通过logging.file和logging.path指定配置文件位置。（只能二选一，两个都写默认生效logging.file） logging.file在不指定路径时则在当前项目下生成 springboot.log 日志文件，指定路径时则按指定的完整路径存放日志文件。例如：logging.file: G:/springboot.log。 logging.path在指定路径下创建文件夹并使用 spring.log 作为默认日志文件。例如：logging.path: /spring/log则表示在项目所在磁盘的根目录下创建 spring 文件夹和其中的 log 文件夹并生成一个 spring.log 的日志文件。 自定义日志配置文件当要使用自定义日志配置文件而非 SpringBoot 的默认日志配置时，可以通过在类路径下放上相应的日志实现框架的配置文件即可。| 日志系统 | 自定义配置文件 || ——- | ————————————– || Logback | logback-spring.xml 或 logback.xml || Log4j2 | log4j2-spring.xml 或 log4j2.xml || JUL | logging.properties | 其中没有加spring尾缀的配置会跳过 SpringBoot 直接被日志实现框架识别；增加了尾缀的日志实现框架不直接加载日志配置，而是由 SpringBoot 解析日志配置，因此可以在日志的配置文件中使用 SpringBoot 的高级 Profile 功能。 &lt;springProfile name=\"dev\"> &lt;!-- 可以指定该日志配置只在 dev 应该环境下才被加载。修改 dev 可以修改为其它应用环境。 --> &lt;/springProfile> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（二）：配置文件","date":"2019-11-22T01:43:31.000Z","path":"posts/2250b4d3/","text":"YAMLSpringBoot 可以使用 YAML 进行全局配置。YAML 是以数据为中心的标记语言，比 JSON、XML 等更适合做配置文件。YAML 通过缩进表示层级关系，且支持三种数据结构：对象（键值对集合）、数组和字面量（单个、不可再分的值）。 字面量即数字、字符串和布尔值。通过k: v的方式书写，字符串默认不用加上引号。也可以使用单引号或双引号，其中单引号会转义特殊字符。字符串也可以写成多行，但从第二行开始必须有一个空格缩进，换行符会被转义为空格。 对象假设有一对象为 student，其中有 lastName 和 age 的属性，其 YAML 写法如下： student: lastName: xx age: 12 也可以采用行内写法：student: {lastName: xx, age: 12} 数组用连线词-来表示数组中的一个元素，一组-开头的行构成一个数组，其写法如下: pets: - cat - dog - pig 也可以采用行内写法：pets: [cat, dog, pig] 复合结构即字面量、对象和数组的复合使用。 将配置文件中的属性值映射至 bean/** * @Author 喵粮都输光了 * @Date 2019/11/22 10:50 * @Description dog entity */ @Data public class Dog { private String name; private Integer age; } person: lastName: LaoZhang age: 11 boss: false birth: 2019/5/5 map: key1: value1 key2: value2 list: - LaoWang - LaoLi dog: name: 小狗 age: 2 可以在 resources 下新建 META-INF 文件夹，并新建 additional-spring-configuration-metadata.json 输入如下代码为 yaml 添加 person { \"properties\": [ { \"name\": \"person.dog.name\", \"type\": \"java.lang.String\", \"description\": \"Description for person.dog.name.\" }, { \"name\": \"person.dog.age\", \"type\": \"java.lang.Integer\", \"description\": \"Description for person.dog.age.\" } ] } 1. 使用`@ConfigurationProperties`注解，需要添加依赖`spring-boot-configuration-processor`。 ```java /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component @ConfigurationProperties(\"person\") public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Dog dog; } ``` 2. 使用`@Value()`注解获取值，其中可以用SpEL表达式获取值，不支持复杂类型封装。 ```java /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component public class Person { @Value(\"${person.lastName}\") private String lastName; @Value(\"#{11*2}\") private Integer age; @Value(\"false\") private Boolean boss; private Date birth; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Dog dog; } ``` 3. `@ConfigurationProperties`支持 JSR303 数据校验。在类上添加注解`@validated`用于支持 JSR303，在需要接收的数据上加上需要校验格式的注解，例如`@Email`。 ```java /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component @ConfigurationProperties(\"person\") @validated public class Person { @Email private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Dog dog; } ``` ## 自定义配置文件加载 ### `@PropertySource` 通过组合`@PropertySource`和`@ConfigurationProperties`可以读取指定 properties 文件中的属性值并映射至 bean。 ```properties person.lastName=LaoZhang person.age=11 person.boss=false person.birth=2019/5/5 person.map.key1=value1 person.map.key2=value2 person.list=LaoWang, LaoLi person.dog.name=小狗 person.dog.age=2/** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component @PropertySource(\"classpath:person.properties\") @ConfigurationProperties(\"person\") public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object> map; private List&lt;Object> list; private Dog dog; } @ImportResource该注解用于导入自定义的 Spring 的配置文件，将注解添加至 SpringBoot 应用主程序类上即可，可添加多个 Spring 配置文件。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"helloService\" class=\"com.kuukokawaii.springbootstudy.service.HelloService\"/> &lt;/beans> @SpringBootApplication @ImportResource(locations = {\"classpath:beans.xml\"}) public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } @ConfigurationSpringBoot 推荐使用全注解的方式添加组件代替配置文件，只需要在类上加@Configuration的注解即可指明该类是配置类。 /** * @Author 喵粮都输光了 * @Date 2019/11/22 12:42 * @Description 应用注解配置 */ @Configuration public class MyApplicationConfig { /** * 将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名。相当于&lt;bean id=\"helloService\", clas==\"\">&lt;/bean> * @return 返回 HelloService 对象。 */ @Bean public HelloService helloService() { System.out.println(1); return new HelloService(); } } 配置文件占位符配置文件中可以使用随机数和占位符，且占位符可设置默认值。例如：person.dog.name引用了person.lastName的值，而person.dog.age引用了hello.age的值，因没有定义hello.age的值，会使用默认值10，最终person.dog.age的值为10。 person: lastName: LaoZhang${random.uuid} age: ${random.int} boss: false birth: 2019/5/5 map: key1: value1 key2: value2 list: - ${random.value} - LaoLi dog: name: ${person.lastName}的小狗 age: ${hello.age:10} 环境配置选择多文件形式SpringBoot 可以在application.yml/properties中通过spring.profiles.active = {profile}来选择应用环境，其中其他配置文件名应为application-{profile}.yml/properties的形式。例如此处应用的主配置应用端口号为 8080，dev 配置文件中应用端口号为 8081，在主配制中激活 dev 配置，则应用端口号变为 8081。 #application-dev.yml server: port: 8081 #application.yml server: port: 8080 spring: profiles: active: dev 多文档块形式（仅 YAML 支持）在application.yml中可以通过三横杠---的方式划分文档块，每一个文档块相当于一个自定义的配置文件，可以通过spring.profiles = {profile}定义文档块的名字，并使用spring.profiles.active = {profile}的形式激活选定的文档块。 server: port: 8080 spring: profiles: active: dev --- server: port: 8081 spring: profiles: dev --- server: port: 8082 spring: profiles: prod 激活 profile 通过配置文件指定，如上。 通过命令行参数指定，如在Program arguments中输入--spring.profiles.active=dev或java -jar xxx.jar --spring.profiles.active=dev 通过虚拟机参数指定，如在VM options中输入-Dspring.profiles.active=dev。 配置文件加载位置SpringBoot 会自定扫描如下位置的application.properties/yml文件作为默认配置文件。配置加载优先级高低从上至下，其中高优先级的配置会覆盖低优先级的内容。所有位置的文件都会被加载，当配置项相同时会按优先级进行覆盖，而配置项不同时则会全部加载，也就是所谓的配置互补。 file:./config/即项目根目录下的config文件夹。 file:./即项目根目录。 classpath:/config/即resources文件夹下的config文件夹。 classpath:/即resources文件夹。 SpringBoot 允许通过spring.config.location来改变默认的配置文件位置。如java -jar xxx.jar --spring.config.location=G:/application.yml。（只能在命令行运行 Jar 包时通过该参数改变默认的配置文件位置，会遵循优先级和互补原则） 外部配置文件加载顺序SpringBoot 也可以从以下位置加载配置（优先级从高到低），会遵循优先级和互补原则。 命令行参数。 来自java:comp/env的JNDI属性。 JAVA 系统属性。 操作系统环境变量。 RandomValuePropertySource 配置的random.*属性值。 JAR 包外部的application-{profile}.properties或application.yml（带Spring.profile）配置文件。 JAR 包内部的application-{profile}.properties或application.yml（带Spring.profile）配置文件。 JAR 包外部的application.properties或application.yml（带Spring.profile）配置文件。 JAR 包内部的application.properties或application.yml（带Spring.profile）配置文件。 @Configuration注解类上的@PropertySource。 通过 SpringApplication.setDefaultProperties 指定的默认属性。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（一）：简介","date":"2019-11-21T04:31:51.000Z","path":"posts/1bc2c8b5/","text":"服务架构 传统 WEB 应用服务架构是单体应用模式，即一个 WAR 包包含了项目所有功能，其所带来的优势是使得项目的开发，测试和部署极其方便。但是所带来的缺陷也是极其明显的，当某一功能进行修改时，项目需要重新进行部署。 微服务架构即一个应用便是一组小型服务的集合，并且各个服务之间可以通过 HTTP 协议进行互通。当使用微服务架构时，每一个功能元素最终都是一个可独立替换或独立升级的软件单元，而 SpringBoot 可以快速的开发每一个软件单元，之后可通过 SpringCloud 将所开发软件单元联系起来。 SpringBoot 优点 无需手动管理依赖 JAR 包的版本 无须配置XML，自动配置，简化开发且可修改默认值 使用嵌入式的 Servlet 容器，应用无需达成 WAR 包 外部化配置SpringBoot 可以使用 properties 文件，YAML文件，环境变量，命令行参数等来外部化配置。 无缝集成 Spring 技术栈SpringBoot 通过stater pom来导入这些依赖，且自动进行配置。 devtools提供的开发时特性SpringBoot 的 devtools 模块可以为应用增加开发时特性，例如开发环境属性默认值。 Actuator提供的生产特性Actuator 提供准生产环境的运行时应用监控。 天然集成云计算 SpringBoot 环境搭建 搭建完成的目录层级。 通过 IDEA 创建 MAVEN 项目。 配置 pom.xml 文件（可参考 SpringBoot 构建 RESTful 项目）。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>spring-boot&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;properties> &lt;!-- jdk版本 --> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;!-- 用于管理SpringBoot应用中所有的依赖版本 --> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;/parent> &lt;dependencies> &lt;!-- 导入WEB模块正常运行所依赖的组件 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;!-- 导入测试模块正常运行所依赖的组件 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- 导入JSON模块正常运行所依赖的组件 --> &lt;dependency> &lt;groupId>com.jayway.jsonpath&lt;/groupId> &lt;artifactId>json-path&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;!-- 将程序打包成可执行的JAR包 --> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 编写 SpringBoot 应用运行主程序 /** * @Author 喵粮都输光了 * @Date 2019/11/21 20:32 * @Description SpringBoot主程序 */ @SpringBootApplication public class Main { public static void main(String[] args) { // 运行SpringBoot应用(SpringBootApplication会自动扫描该类所在包及其下所有子包内的组件添加入Spring容器) SpringApplication.run(Main.class, args); } } 编写简单 Controller 类向页面返回数据/** * @Author 喵粮都输光了 * @Date 2019/11/21 20:34 * @Description HelloController */ @Controller public class HelloController { @RequestMapping(\"/hello\") @ResponseBody public String hello() { return \"Hello world!\"; } } SpringBoot 应用快速构建此处以 IDEA 为例通过 Spring Initializr 快速构建 SpringBoot 项目。 通过 New -&gt; Project -&gt; Spring Initializr 单击下一步。 填写项目配置之后单击下一步。 勾选项目所需服务之后单击下一步后，IDEA 自动从 Spring 官网下载快速构建的项目。 SpringBoot 配置原理SpringBoot 将所有的功能场景抽取成为一个个 Starter，只需要在项目中引入这些 Starters，其相关环境的所有依赖都会导入进来。 @SpringBootApplication该注解应用于某一个 JAVA 类上是指该类是 SpringBoot 的主配置类，SpringBoot 将会运行该类的 main 方法来启动 SpringBoot 应用。 @SpringBootConfiguration该注解是@SpringBootApplication所包含的注解之一，标注在某一个 JAVA 类上是指该类是 SpringBoot 的配置类。该注解中包含 @Configuration 用于表明该类是一个配置类（即配置文件），通过@Component注解表明配置类是一个组件并能被 Spring 容器扫描到。 @EnableAutoConfiguration该注解是@SpringBootApplication所包含的注解之一，用于扫描组件并进行自动配置。该注解通过@AutoConfigurationPackage中的@Import(\"AutoConfigurationPackages.Registrar.class\")将@SpringBootApplication标注的类所在包及其下所有子包内的所有组件扫描入 Spring 容器中，最后通过@Import(EnableAutoConfigurationImportSelector.class)获取需要导入组件的选择器全限定类名添加入 Spring 容器中，并通过自动配置类（xxxAutoConfiguration）为组件自动配置。自动配置类文件包含在 spring-boot-autoconfiguration.jar 包下。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SSM整合","date":"2019-11-20T02:54:59.000Z","path":"posts/12cc57d7/","text":"目录层级 web.xml 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!-- spring容器监听器 --> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:applicationContext.xml&lt;/param-value> &lt;/context-param> &lt;!-- 前端控制器 --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 加载springMVC配置文件 --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springMVC.xml&lt;/param-value> &lt;/init-param> &lt;!-- 服务器启动时初始化该servlet --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;!-- 编码过滤器 --> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;/web-app> spring 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 注解扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii\"> &lt;!-- 不扫描controller --> &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &lt;!-- aop --> &lt;aop:aspectj-autoproxy/> &lt;!-- 事务管理 --> &lt;tx:annotation-driven/> &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- mybatis start --> &lt;!-- 加载jdbc.properties --> &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/> &lt;!-- alibaba druid --> &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"> &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> &lt;property name=\"url\" value=\"${jdbc.url}\"/> &lt;property name=\"username\" value=\"${jdbc.username}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;!-- 配置初始化大小、最小、最大 --> &lt;property name=\"initialSize\" value=\"1\"/> &lt;property name=\"minIdle\" value=\"1\"/> &lt;property name=\"maxActive\" value=\"20\"/> &lt;!-- 配置获取连接等待超时的时间 --> &lt;property name=\"maxWait\" value=\"10000\"/> &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --> &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/> &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --> &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/> &lt;!-- 这里建议配置为TRUE，防止取到的连接不可用 --> &lt;property name=\"testWhileIdle\" value=\"true\"/> &lt;property name=\"testOnBorrow\" value=\"true\"/> &lt;property name=\"testOnReturn\" value=\"false\"/> &lt;!-- 这里配置提交方式，默认就是TRUE，可以不用配置 --> &lt;property name=\"defaultAutoCommit\" value=\"true\"/> &lt;!-- 验证连接有效与否的SQL，不同的数据配置不同 --> &lt;property name=\"validationQuery\" value=\"${validationQuery}\"/> &lt;property name=\"filters\" value=\"stat\"/> &lt;!-- 打开removeAbandoned功能 --> &lt;property name=\"removeAbandoned\" value=\"true\"/> &lt;!-- 1800s --> &lt;property name=\"removeAbandonedTimeout\" value=\"1800\"/> &lt;!-- 关闭abandoned链接时输出错误日志 --> &lt;property name=\"logAbandoned\" value=\"true\"/> &lt;/bean> &lt;!-- sqlSessionFactory --> &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;property name=\"mapperLocations\" value=\"classpath:com/kuukokawaii/**/**.xml\"/> &lt;/bean> &lt;!-- dao接口所在包 --> &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"> &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/> &lt;property name=\"basePackage\" value=\"com.kuukokawaii.**.dao\"/> &lt;/bean> &lt;!-- mybatis end --> &lt;/beans> jdbc.driverClassName=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC jdbc.username=账号 jdbc.password=密码 validationQuery=SELECT 1 springMVC 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 注解扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii\"> &lt;!-- 只扫描controller --> &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &lt;!-- 视图解析器 thymeleaf start --> &lt;bean id=\"templateResolver\" class=\"org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"/> &lt;property name=\"suffix\" value=\".html\"/> &lt;property name=\"templateMode\" value=\"HTML\"/> &lt;property name=\"characterEncoding\" value=\"UTF-8\"/> &lt;property name=\"cacheable\" value=\"false\"/> &lt;/bean> &lt;bean id=\"templateEngine\" class=\"org.thymeleaf.spring5.SpringTemplateEngine\"> &lt;property name=\"templateResolver\" ref=\"templateResolver\"/> &lt;/bean> &lt;bean class=\"org.thymeleaf.spring5.view.ThymeleafViewResolver\"> &lt;property name=\"templateEngine\" ref=\"templateEngine\"/> &lt;property name=\"characterEncoding\" value=\"UTF-8\"/> &lt;/bean> &lt;!-- 视图解析器 thymeleaf end --> &lt;!-- 过滤静态资源 --> &lt;mvc:resources mapping=\"/static/css/\" location=\"/static/css/**\"/> &lt;mvc:resources mapping=\"/static/js/\" location=\"/static/js/**\"/> &lt;mvc:resources mapping=\"/static/images/\" location=\"/static/images/**\"/> &lt;!-- FAST_JSON解析 --> &lt;mvc:annotation-driven> &lt;mvc:message-converters> &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"/> &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\"> &lt;property name=\"supportedMediaTypes\"> &lt;list> &lt;value>text/html;charset=UTF-8&lt;/value> &lt;value>application/json;charset=UTF-8&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;/mvc:message-converters> &lt;/mvc:annotation-driven> &lt;!-- 注解支持 --> &lt;mvc:annotation-driven/> &lt;/beans> log4j 配置文件###################################### # log4j配置相关说明 ###################################### #%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL #%r 输出自应用启动到输出该log信息耗费的毫秒数 #%c 输出所属的类目，通常就是所在类的全名 #%t 输出产生该日志事件的线程名 #%m 输出代码中指定的信息 #%n 输出一个回车换行符，Windows平台为“\\r\\n”，Unix平台为“\\n” #%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MM dd HH:mm:ss,SSS}，输出类似： 2002年10月18日 22：10：28，921 #%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) #log4j提供4种布局: #org.apache.log4j.HTMLLayout（以HTML表格形式布局） #org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， #org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， #org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息 #log4j中有五级logger 输出级别: #FATAL 0 #ERROR 3 #WARN 4 #INFO 6 #DEBUG 7 ###################################### # log4j相关配置 ###################################### #日志输出级别 log4j.rootLogger=INFO,stdout,other #设置stdout的日志输出控制台 log4j.appender.stdout=org.apache.log4j.ConsoleAppender #输出日志到控制台的方式，默认为System.out log4j.appender.stdout.Target=System.out #设置使用灵活布局 log4j.appender.stdout.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.stdout.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %m %n #设置other的日志输出控制台(RollingFileAppender)/每天生产一个日志文件(DailyRollingFileAppender) log4j.appender.other=org.apache.log4j.DailyRollingFileAppender #设置other的输出日志 log4j.appender.other.File=src/main/webapp/WEB-INF/logs/ssm.log #设置other的日志最大限制 log4j.appender.other.MaxFileSize=1024KB #最多只保存20个备份文件 log4j.appender.other.MaxBackupIndex=1000 #输出INFO级别以上的日志 log4j.appender.other.Threshold=INFO #设置使用灵活布局 log4j.appender.other.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.other.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %t %m %n ###显示SQL语句部分 log4j.logger.com.mybatis=DEBUG log4j.logger.com.mybatis.common.jdbc.SimpleDataSource=DEBUG log4j.logger.com.mybatis.common.jdbc.ScriptRunner=DEBUG log4j.logger.com.mybatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG JAVA 类controller/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:28 * @Description 账户Controller */ @Controller(\"accountController\") @RequestMapping(\"/account\") public class AccountController { private final AccountService accountService; @Autowired public AccountController(AccountService accountService) { this.accountService = accountService; } @RequestMapping(\"/findAll\") public String findAll(ModelMap modelMap) { modelMap.put(\"list\", accountService.findAllAccount()); return \"list\"; } } dao/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:21 * @Description 账户dao */ @Repository public interface AccountMapper { /** * 查找所有账户 * @return 账户集合 */ List&lt;Account> findAllAccount(); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.kuukokawaii.account.dao.AccountMapper\"> &lt;resultMap id=\"accountResultMap\" type=\"com.kuukokawaii.account.entity.Account\"> &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/> &lt;result column=\"name\" property=\"name\" jdbcType=\"VARCHAR\"/> &lt;result column=\"money\" property=\"money\" jdbcType=\"DOUBLE\"/> &lt;/resultMap> &lt;sql id=\"account_column_List\"> &lt;!--@sql SELECT --> account.id, account.name, account.money &lt;!--@sql FROM account --> &lt;/sql> &lt;select id=\"findAllAccount\" resultMap=\"accountResultMap\"> SELECT &lt;include refid=\"account_column_List\"/> FROM account &lt;/select> &lt;/mapper> entity/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:19 * @Description 账户实体 */ @Data public class Account implements Serializable { private int id; private String name; private double money; } service/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:25 * @Description 账号Service */ public interface AccountService { /** * 查找所有账户 * @return 账户集合 */ List&lt;Account> findAllAccount(); } /** * @Author 喵粮都输光了 * @Date 2019/11/20 13:27 * @Description 账号Service实现 */ @Service(\"accountService\") public class AccountServiceImpl implements AccountService { private final AccountMapper accountMapper; @Autowired public AccountServiceImpl(AccountMapper accountMapper) { this.accountMapper = accountMapper; } @Override public List&lt;Account> findAllAccount() { return accountMapper.findAllAccount(); } } HTML 页面&lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>list&lt;/title> &lt;/head> &lt;body> &lt;!--/*@thymesVar id=\"list\" type=\"java.util.List\"*/--> &lt;div th:each=\"account : ${list}\"> &lt;p th:text=\"${account.id}\">&lt;/p> &lt;p th:text=\"${account.name}\">&lt;/p> &lt;p th:text=\"${account.money}\">&lt;/p> &lt;/div> &lt;/body> &lt;/html> pom.xml 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>ssm&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;packaging>war&lt;/packaging> &lt;name>ssm Maven Webapp&lt;/name> &lt;url>http://www.example.com&lt;/url> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;spring.version>5.1.9.RELEASE&lt;/spring.version> &lt;/properties> &lt;dependencies> &lt;!-- Spring --> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-beans&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-core&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.aspectj&lt;/groupId> &lt;artifactId>aspectjweaver&lt;/artifactId> &lt;version>1.9.4&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-aop&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-tx&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-test&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-jdbc&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;!-- SpringMVC --> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-web&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-webmvc&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;!-- Mybatis --> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis-spring&lt;/artifactId> &lt;version>2.0.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.17&lt;/version> &lt;/dependency> &lt;!-- thymeleaf --> &lt;dependency> &lt;groupId>org.thymeleaf&lt;/groupId> &lt;artifactId>thymeleaf&lt;/artifactId> &lt;version>3.0.11.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.thymeleaf&lt;/groupId> &lt;artifactId>thymeleaf-spring5&lt;/artifactId> &lt;version>3.0.11.RELEASE&lt;/version> &lt;/dependency> &lt;!-- alibaba --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.1.20&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>fastjson&lt;/artifactId> &lt;version>1.2.61&lt;/version> &lt;/dependency> &lt;!-- junit --> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.13-beta-3&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- lombok --> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;version>1.18.10&lt;/version> &lt;/dependency> &lt;!-- servlet --> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>javax.servlet-api&lt;/artifactId> &lt;version>4.0.1&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> &lt;!-- log --> &lt;dependency> &lt;groupId>log4j&lt;/groupId> &lt;artifactId>log4j&lt;/artifactId> &lt;version>1.2.17&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.slf4j&lt;/groupId> &lt;artifactId>slf4j-api&lt;/artifactId> &lt;version>2.0.0-alpha0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.slf4j&lt;/groupId> &lt;artifactId>slf4j-log4j12&lt;/artifactId> &lt;version>2.0.0-alpha0&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;finalName>ssm&lt;/finalName> &lt;!-- 编译java目录下的mapper文件 --> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>true&lt;/filtering> &lt;/resource> &lt;/resources> &lt;pluginManagement> &lt;plugins> &lt;plugin> &lt;artifactId>maven-clean-plugin&lt;/artifactId> &lt;version>3.1.0&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-resources-plugin&lt;/artifactId> &lt;version>3.0.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.8.0&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-surefire-plugin&lt;/artifactId> &lt;version>2.22.1&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-war-plugin&lt;/artifactId> &lt;version>3.2.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-install-plugin&lt;/artifactId> &lt;version>2.5.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-deploy-plugin&lt;/artifactId> &lt;version>2.8.2&lt;/version> &lt;/plugin> &lt;/plugins> &lt;/pluginManagement> &lt;/build> &lt;/project> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"},{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"Mybatis（六）：注解开发","date":"2019-10-14T05:26:13.000Z","path":"posts/13944/","text":"CRUD 注解写法在 Mybatis 中如果使用注解，那么在该 DAO 下就不能使用 XML 的方式进行开发。 select 的注解写法/** * 查询指定的user * * @param id 需要查询的user id * @return 返回查找到的user */ @Select(\"select * from user where id = #{id};\") User getUser(Integer id); /** * 查找所有User * * @return 返回User集合 */ @Select(\"select * from user\") List&lt;User> findUsers(); insert 的注解写法/** * 插入一个User * * @param user 需要插入的user * @return 返回插入结果 */ @Insert(\"insert into user (id, name, birthday, sex, address) values (#{id}, #{name}, #{birthday}, #{sex}, #{address});\") int createUser(User user); update 的注解写法 /** * 更新已给user * @param user 需要更新的user * @return 返回更新结果 */ @Update(\"update user set id = #{id}, name = #{name}, birthday = #{birthday}, sex = #{sex}, address = #{address} where id = #{id};\") int updateUser(User user); delete 的注解写法/** * 删除指定用户 * * @param id 需要删除用户的id * @return 返回删除结果 */ @Delete(\"delete from user where id = #{id};\") int deleteUser(Integer id); resultMap 注解写法Mybatis 提供了 @Results、@Result 和 @ResultMap 三个注解用于调用和实现 XML 配置中的 ResultMap 标签。其中 @Results 相当于 XML 配置中的 ResultMap 标签；@Result 相当于 XML 配置中 ResultMap 的子标签 result；而 @ResultMap 相当于 XML 配置中 CRUD 标签中的 resultMap 属性，通过填入 ResultMap 的 id 与之对应。 /** * 查找所有User * * @return 返回User集合 */ @Select(\"select * from user\") @Results(id = \"UserResultMap\", value = { @Result(id = true, column = \"id\", jdbcType = JdbcType.INTEGER, property = \"id\"), @Result(column = \"name\", jdbcType = JdbcType.VARCHAR, property = \"name\"), @Result(column = \"birthday\", jdbcType = JdbcType.DATE, property = \"birthday\"), @Result(column = \"sex\", jdbcType = JdbcType.VARCHAR, property = \"sex\"), @Result(column = \"address\", jdbcType = JdbcType.VARCHAR, property = \"address\") }) List&lt;User> findUsers(); /** * 查询指定的user * * @param id 需要查询的user id * @return 返回查找到的user */ @Select(\"select * from user where id = #{id};\") @ResultMap(\"UserResultMap\") User getUser(Integer id); 多表查询与延迟加载注解写法Mybatis 提供了 @One 和 @Many 两个注解用于实现 XML 配置中的 association 标签 和 collection 标签。其中 fetchType 属性可以选择快速加载或延迟加载。 一对一查询/** * 查找所有Account（立即加载） * * @return 返回Account集合 */ @Select(\"select * from account\") @Results(id = \"AccountResultMap\", value = { @Result(id = true, column = \"id\", jdbcType = JdbcType.INTEGER, property = \"id\"), @Result(column = \"username\", jdbcType = JdbcType.VARCHAR, property = \"username\"), @Result(column = \"password\", jdbcType = JdbcType.DATE, property = \"password\"), @Result(column = \"id\", jdbcType = JdbcType.INTEGER, property = \"user\", one = @One( select = \"com.kuukokawaii.user.dao.UserDao.getUser\", fetchType = FetchType.EAGER )) }) List&lt;Account> findAccounts(); 一对多查询/** * 查找所有User（延迟加载） * * @return 返回User集合 */ @Select(\"select * from user\") @Results(id = \"UserResultMap\", value = { @Result(id = true, column = \"id\", jdbcType = JdbcType.INTEGER, property = \"id\"), @Result(column = \"name\", jdbcType = JdbcType.VARCHAR, property = \"name\"), @Result(column = \"birthday\", jdbcType = JdbcType.DATE, property = \"birthday\"), @Result(column = \"sex\", jdbcType = JdbcType.VARCHAR, property = \"sex\"), @Result(column = \"address\", jdbcType = JdbcType.VARCHAR, property = \"address\"), @Result(column = \"id\", property = \"accounts\", many = @Many( select = \"com.kuukokawaii.user.dao.AccountDao.getAccount\", fetchType = FetchType.LAZY )) }) List&lt;User> findUsers(); 二级缓存注解写法Mybatis 提供了 @CacheNamespace 用于实现 XML 配置中 cache 标签的功能，需要注意的是该注解使用于 Dao 类上而非方法上。二级缓存可以在 SqlMapConfig.xml 中进行开启（默认开启）。 注解说明： readWrite：读写模式，True：必须实现序列化接口； flushInterval：刷新时间，单位：毫秒；这里的刷新是指缓存数据的有效期； implementation：缓存实现自定义对象； eviction：缓存策略的算法； size：是引用的缓存结果，这里是指1024次查询的结果，是序列化之后的结果； blocking：防止缓存击穿，对应的实现类：BlockingCache.putObject； 代码演示： &lt;settings> &lt;!-- 开启二级缓存支持。（可以不进行配置，默认 true。） --> &lt;setting name=\"cacheEnabled\" value=\"true\"/> &lt;/settings> @CacheNamespace(blocking = true) public interface UserDao { // 内容省略 } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（五）：缓存","date":"2019-10-13T09:42:50.000Z","path":"posts/2305/","text":"缓存适用性 经常查询且不经常改变的数据适用于缓存。 数据的正确与否对最终结果影响不大适用于缓存。相反，商品的库存、银行的汇率和股市的牌价等皆不适用于缓存。 一级缓存Mybatis 的一级缓存指的是 SqlSession 对象的缓存。当执行查询之后，查询的结果会同时存入到 SqlSession 中的一块 Map 结构的存储区域中。当我们再次执行查询同样的数据时，Mybatis 会先去 SqlSession 中查询是否拥有该数据，有则直接从缓存中获取。需要注意的是当调用 SqlSession 对象的修改、添加、删除、commit()、close()等方法时，Mybatis 的一级缓存将会被清空。 二级缓存Mybatis 的二级缓存指的是 SqlSessionFactory 对象的缓存。由同一个 SqlSessionFactory 对象创建的 SqlSession 对象将共享该缓存。不同于一级缓存，二级缓存需要手动配置。 二级缓存配置方法 让 Mybatis 框架支持二级缓存（在 SqlMapConfig.xml 中配置）。 让当前的映射文件支持二级缓存（在 UserMapper.xml 中配置）。 让当前的操作支持二级缓存（在 select 标签中配置）。 代码演示： SqlMapConfig.xml &lt;settings> &lt;!-- 开启二级缓存支持。（可以不进行配置，默认 true。） --> &lt;setting name=\"cacheEnabled\" value=\"true\"/> &lt;/settings> UserMapper.xml &lt;!-- 在 mapper 标签下开启二级缓存支持 --> &lt;cache/> select 标签 &lt;!-- 通过 userCache 属性开启二级缓存 --> &lt;select id=\"findUsers\" resultMap=\"UserResultMap\" useCache=\"true\"> select &lt;include refid=\"User_Column_List\"/> from user &lt;/select> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（四）：延迟加载","date":"2019-10-11T11:56:30.000Z","path":"posts/4576/","text":"立即加载和延迟加载 疑问在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候，要不要查询关联的账户。 在查询账户的时候，是否需要查询关联的用户。 解决 在查询用户的时候，是否查询关联的账户是按需查询。因此此处采用延迟加载（按需加载、懒加载），即数据只在需要的时候进行加载。 在查询账户的时候，关联的用户信息会随着账户查询一并查询显示。因此此处采用立即加载，即无论数据是否需要，再发起查询的时候都立即加载。 总结 一对多，多对多：通常情况下都是采用延迟加载。 一对一（多对一）：通常情况下都是采用立即加载。 代码演示/** * @Author 喵粮都输光了 * @Date 2019/9/30 14:53 * @Description 账户实体 */ public class Account implements Serializable { // 此处省略 get 和 set private Integer id; private String username; private String password; private User user; @Override public String toString() { return \"Account{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 此处省略 get 和 set private Integer id; private String name; private Date birthday; private String sex; private String address; private List&lt;Account> accounts; @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '}'; } } /** * @Author 喵粮都输光了 * @Date 2019/9/23 17:12 * @Description 用户持久层接口 */ public interface UserDao { /** * 查找指定的User * @param id 通过id查找User * @return 返回找到的User对象 */ User getUser(String id); /** * 查找所有User * @return 返回User集合 */ List&lt;User> findUsers(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 15:37 * @Description 账号持久层接口 */ public interface AccountDao { /** * 查找指定的Account * @param id 通过id查找Account * @return 返回找到的Account对象 */ Account getAccount(String id); /** * 查找所有Account * @return 返回Account集合 */ List&lt;Account> findAccounts(); } 在 SqlMapConfig.xml 中开启延迟加载 &lt;settings> &lt;!-- 开启延迟加载开关 --> &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/> &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/> &lt;/settings> 一对多延迟加载：一个 User 拥有多个 Account，通过 UserMapper 中的 collection 标签的 select 调用 Account 中的 getAccount 方法进行延迟加载。 &lt;sql id=\"Account_Column_List\"> &lt;!--@sql select --> account.id, username, password &lt;!--@sql from account --> &lt;/sql> &lt;select id=\"getAccount\" parameterType=\"string\" resultType=\"com.kuukokawaii.user.entity.Account\"> select &lt;include refid=\"Account_Column_List\"/> from account where account.id = #{id}; &lt;/select> &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;!-- 延迟加载一对多。 select：表示调用其他查询（可以是其他mapper中的查询），此处为查询用户的唯一标识。 column：用户根据 id 查询时，所需要的参数的值。即为 select 中查询提供所需的 id 进行查询。 --> &lt;collection column=\"id\" property=\"accounts\" select=\"com.kuukokawaii.user.dao.AccountDao.getAccount\"/> &lt;/resultMap> &lt;sql id=\"User_Column_List\"> &lt;!--@sql select --> user.id, name, birthday, sex, address &lt;!--@sql from user --> &lt;/sql> &lt;select id=\"findUsers\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/> from user &lt;/select> 一对一（多对一）延迟加载：多个 Account 对应一个 User，通过 AccountMapper 中的 association 标签的 select 调用 User 中的 getUser 方法进行延迟加载。 &lt;sql id=\"User_Column_List\"> &lt;!--@sql select --> user.id, name, birthday, sex, address &lt;!--@sql from user --> &lt;/sql> &lt;select id=\"getUser\" parameterType=\"string\" resultType=\"com.kuukokawaii.user.entity.User\"> select &lt;include refid=\"User_Column_List\"/> from user where user.id = #{id}; &lt;/select> &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;!-- 延迟加载一对一（多对一）。 select：表示调用其他查询（可以是其他mapper中的查询），此处为查询用户的唯一标识。 column：用户根据 id 查询时，所需要的参数的值。即为 select 中查询提供所需的 id 进行查询。 --> &lt;association column=\"id\" property=\"user\" select=\"com.kuukokawaii.user.dao.UserDao.getUser\"/> &lt;/resultMap> &lt;sql id=\"Account_Column_List\"> &lt;!--@sql select --> account.id, username, password &lt;!--@sql from account --> &lt;/sql> &lt;select id=\"findAccounts\" resultMap=\"AccountResultMap\"> select &lt;include refid=\"Account_Column_List\"/> from account &lt;/select> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"设计模式之策略模式","date":"2019-10-09T09:19:54.000Z","path":"posts/36970/","text":"策略模式 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。即将各个功能拆分封装成模块，最终通过组合的方式实现效果。 设计原则： 1.找出应用中可能需要变化之处，把它们独立出来，不要和哪些不需要变化的代码混在一起。 2.针对接口编程，而不是针对实现编程。 3.多用组合，少用继承。 原型根据 OO 标准，设计一个鸭子超类，并让各类鸭子继承此超类。 新增飞行功能 问题：在超类上新增功能飞行，导致子类不能飞行的鸭子也能够飞行。 解决：覆盖不能飞行的鸭子的飞行方法，让不能飞行的鸭子不再拥有飞行功能。如此修改代码的话会导致以后每增加一个继承鸭子超类的子类都需要检查并可能覆盖飞行方法，这是非常痛苦的一件事情！因此将飞行方法抽取出来，让需要该功能的鸭子实现接口即可。 实现飞行接口 问题：当抽取了飞行功能时，发现每次新增子类时都需要实现一次飞行接口，这造成了大量代码的重复！ 解决：这里可以对飞行接口进行实现，让能飞、不能飞的鸭子在初始化实例变量时调用所需接口即可。 UML图： 代码演示：/** * @Author 喵粮都输光了 * @Date 2019/10/9 17:46 * @Description 鸭子超类 */ abstract class AbstractDuck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; /** * 执行飞行功能 */ void performFly() { flyBehavior.fly(); } /** * 执行叫声功能 */ void performQuack() { quackBehavior.quack(); } /** * 游泳功能 */ void swim() { System.out.println(\"会游泳。\"); } /** * 外观 */ abstract void display(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:35 * @Description 飞行接口 */ public interface FlyBehavior { /** * 飞行功能。 */ void fly(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:58 * @Description 飞行接口实现类：不能飞 */ public class FlyNowayImpl implements FlyBehavior { @Override public void fly() { System.out.println(\"不能飞。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:59 * @Description 飞行接口实现类：能飞 */ public class FlyWithWingsImpl implements FlyBehavior{ @Override public void fly() { System.out.println(\"能飞。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:35 * @Description 叫声接口 */ public interface QuackBehavior { /** * 叫声功能。 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 19:01 * @Description 叫声接口实现类：呱呱叫 */ public class QuackImpl implements QuackBehavior{ @Override public void quack() { System.out.println(\"呱呱叫。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 19:01 * @Description 叫声接口实现类：吱吱叫 */ public class SqueakImpl implements QuackBehavior { @Override public void quack() { System.out.println(\"吱吱叫。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 17:48 * @Description 红头鸭 */ public class RedheadDuck extends AbstractDuck { public RedheadDuck() { quackBehavior = new QuackImpl(); flyBehavior = new FlyWithWingsImpl(); } @Override void display() { System.out.println(\"外观是红头鸭。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:20 * @Description 橡皮鸭 */ public class RubberDuck extends AbstractDuck { public RubberDuck() { quackBehavior = new SqueakImpl(); flyBehavior = new FlyNowayImpl(); } @Override void display() { System.out.println(\"外观是橡皮鸭。\"); } } 遗留的小问题 问题：实现飞行功能的解决方法在构造器中制造了一个具体的实现类实例，该行为违反了不对具体实现编程的设计原则。 解决：可以通过其他设计模式解决。 动态设定行为 需求：实现飞行接口的方案可以动态的设定行为，即在运行时修改鸭子的功能，而不是通过构造器实例化。 代码演示（主要代码）： 在 Duck 类新增 setFlyBehavior 和 setQuackBehavior 方法。 /** * @Author 喵粮都输光了 * @Date 2019/10/9 17:46 * @Description 鸭子超类 */ abstract class AbstractDuck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; /** * 执行飞行功能 */ void performFly() { flyBehavior.fly(); } /** * 执行叫声功能 */ void performQuack() { quackBehavior.quack(); } /** * 设置具体飞行功能。 * * @param flyBehavior 具体飞行功能 */ void setFlyBehavior(FlyBehavior flyBehavior) { this.flyBehavior = flyBehavior; } /** * 设置具体叫声功能。 * * @param quackBehavior 具体叫声功能 */ void setQuackBehavior(QuackBehavior quackBehavior) { this.quackBehavior = quackBehavior; } /** * 游泳功能 */ void swim() { System.out.println(\"会游泳。\"); } /** * 外观 */ abstract void display(); } 在运行中修改橡皮鸭的叫声为呱呱叫。 /** * @Author 喵粮都输光了 * @Date 2019/10/9 19:18 * @Description 主函数 */ public class Main { public static void main(String[] args) { AbstractDuck rubberDuck = new RubberDuck(); rubberDuck.swim(); rubberDuck.display(); rubberDuck.performFly(); rubberDuck.performQuack(); System.out.println(\"--------改变了橡皮鸭的叫声为呱呱叫--------\"); rubberDuck.setQuackBehavior(new QuackImpl()); rubberDuck.performQuack(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Mybatis（三）：多表操作","date":"2019-10-09T04:58:18.000Z","path":"posts/44025/","text":"一对多、一对一 案例说明：用户和账户 一个用户可以有多个账户，使用 collection。 一个账户只能属于一个用户，使用 association。（多个账户也可以属于同一个用户） 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 此处省略 get 和 set private Integer id; private String name; private Date birthday; private String sex; private String address; private List&lt;Account> accounts; } /** * @Author 喵粮都输光了 * @Date 2019/9/30 14:53 * @Description 账户实体 */ public class Account implements Serializable { // 此处省略 get 和 set private Integer id; private String username; private String password; private User user; } UserMapper（一对多） &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;collection property=\"accounts\" resultMap=\"AccountResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;/resultMap> AccountMapper（一对一） &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;association property=\"user\" resultMap=\"AccountResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;/resultMap> 多对多 案例说明：用户和角色 一个用户可以有多个角色。 一个角色可以赋予多个用户。 数据库中需要一个中间表来记录角色和用户之间的对应关系。（需要中间表） 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 此处省略 get 和 set private Integer id; private String name; private Date birthday; private String sex; private String address; private List&lt;Role> roles; } /** * @Author 喵粮都输光了 * @Date 2019/10/9 16:50 * @Description 角色实体 */ public class Role implements Serializable { // 此处省略 get 和 set private Integer id; private String roleName; private String roleDesc; private List&lt;User> users; } UserMapper（一对多） &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;collection property=\"roles\" resultMap=\"RoleResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"RoleResultMap\" type=\"com.kuukokawaii.user.entity.Role\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/> &lt;result column=\"role_desc\" jdbcType=\"VARCHAR\" property=\"roleDesc\"/> &lt;/resultMap> AccountMapper（一对多） &lt;resultMap id=\"RoleResultMap\" type=\"com.kuukokawaii.user.entity.Role\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/> &lt;result column=\"role_desc\" jdbcType=\"VARCHAR\" property=\"roleDesc\"/> &lt;collection property=\"users\" resultMap=\"UserResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;/resultMap> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（二）：mapper.xml 文件语法","date":"2019-09-29T10:24:31.000Z","path":"posts/30243/","text":"resultMap resultMap 可以实现将查询结果映射为复杂类型的pojo。 id：用于定义 resultMap 的 id。 type：复杂类型的实体全限定名。 result：对数据库字段和 java 变量进行映射。 column：数据库字段。 jdbcType：数据库字段类型。 property：java 变量。 collection：一个复杂类型的关联，可以关联另一个 resultMap。 案例说明： 创建一个 Account 类，包含 username 和 password。 创建一个 User 类，包含 id、name、birthday、sex 和 address。 定义 User 类的 resultMap。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/30 14:53 * @Description 账户实体 */ public class Account { // 此处省略了 set 和 get。 private String username; private String password; private Integer id; } /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ @Data public class User implements Serializable { // 此处省略了 set 和 get。 private Integer id; private String name; private Date birthday; private String sex; private String address; private Account account; } &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;association property=\"account\" resultMap=\"AccountResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;/resultMap> sql sql 被用来定义可重用的 sql 代码段，可以通过&lt;include&gt;标签进行调用。 案例说明：用 sql 定义 user 和 account 表的字段集。 代码演示： &lt;sql id=\"User_Column_List\"> &lt;!--@sql select --> user.id, name, birthday, sex, address &lt;!--@sql from user --> &lt;/sql> &lt;sql id=\"Account_Column_List\"> &lt;!--@sql select --> account.id, username, password &lt;!--@sql from account --> &lt;/sql> if if 提供了一种可选的查找文本功能，符合条件即执行。 案例说明：当 sex 非 null 时语句查询指定的 name 和 sex 条件，否则只查询 name。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id where name = #{name} &lt;if test=\"sex != null\"> and sex = #{sex} &lt;/if> &lt;/select> choose, when, otherwise choose 从多个条件中挑选一个，类似于 switch 语句。 案例说明：当 sex 非空时根据 name 和 sex 查询，当 birthday 非空时根据 name 和 birthday 查询，当 address 非空时根据 name 和 address 查询，否则仅根据 name 查询。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id where name = #{name} &lt;choose> &lt;when test=\"sex != null\"> and sex = #{sex} &lt;/when> &lt;when test=\"birthday != null\"> and birthday = #{birthday} &lt;/when> &lt;otherwise> and address = #{address} &lt;/otherwise> &lt;/choose> &lt;/select> trim, where, set 当使用 if 进行条件匹配时，如果一个条件都不匹配则语句末尾可能以 where 结尾导致 sql 报错。若匹配的条件非第一项而是其他项则会导致 where and xxx 的语句情况同样会报错。因此 mybatis 的 where 标签会自动处理该情况。set 同理。当 where 和 set 标签没有发挥作用时可以通过 trim 自定义格式执行。 案例说明： 当条件非空时查询指定条件否则查询所有。 当条件非空时更新非空条件。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id &lt;where> &lt;if test=\"name != null\"> name = #{name} &lt;/if> &lt;if test=\"sex != null\"> and sex = #{sex} &lt;/if> &lt;/where> &lt;/select> &lt;!-- where 等价于 trim 的如下情形 --> &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"> &lt;!-- 内容 --> &lt;/trim> &lt;update id=\"updateUser\" parameterType=\"com.kuukokawaii.user.entity.User\"> update user, account &lt;set> &lt;if test=\"id != null\"> user.id = #{id}, &lt;/if> &lt;if test=\"name != null\"> name = #{name}, &lt;/if> &lt;if test=\"birthday != null\"> birthday = #{birthday}, &lt;/if> &lt;if test=\"sex != null\"> sex = #{sex}, &lt;/if> &lt;if test=\"address != null\"> address = #{address}, &lt;/if> &lt;if test=\"account.id != null\"> account.id = #{account.id}, &lt;/if> &lt;if test=\"account.username != null\"> account.username = #{account.username}, &lt;/if> &lt;if test=\"account.password != null\"> account.password = #{account.password}, &lt;/if> &lt;/set> where user.id = account.id and user.id = #{id} &lt;/update> &lt;!-- set 等价于 trim 的如下情形 --> &lt;trim prefix=\"SET\" prefixOverrides=\",\"> &lt;!-- 内容 --> &lt;/trim> foreach 通常是在构建 IN 条件语句的时候使用，对一个集合进行遍历操作。 案例说明：搜索 id 在列表中的 user。 代码演示： &lt;select id=\"selectUserIn\" resultMap=\"UserResultMap\"> select * from user where user.id in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"> #{item} &lt;/foreach> &lt;/select> bind bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。 案例说明：搜索符合条件的 user。 代码演示： &lt;select id=\"selectUsersLike\" resultMap=\"UserResultMap\"> &lt;bind name=\"pattern\" value=\"'%' + _parameter.getTitle() + '%'\" /> select * from user where name like #{pattern} &lt;/select> select select 是 mybatis 的查询语句。 id：用于定义 select 的 id，需要与 DAO 中的方法名对应。方法名为 get 表获取单个元素，find 表获取元素集。 parameterType：表传入的参数类型。 resultType：表示返回类型（与 resultMap 二选一），如果返回的是集合则填写集合所包含的类型。 resultMap：表示返回类型（与 resultType 二选一），返回定义的 resultMap。 案例说明： 查找一个指定名称的 User 对象。 查找所有 User 对象。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id where name = #{name}; &lt;/select> &lt;select id=\"findUser\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id &lt;/select> delete delete 是 mybatis 的删除语句。 案例说明：删除一个指定 id 的 User 和 Account 对象。 代码演示： &lt;delete id=\"deleteUser\" parameterType=\"int\"> delete from user, account using user, account where user.id = account.id and user.id = #{id}; &lt;/delete> update update 是 mybatis 的更新语句。 useGeneratedKeys：更新后返回主键（默认 false）。 keyProperty：指定在 Java 实体中对应的主键变量名。 keyColumn：当主键列不是表中的第一列的时候需要设置，用于指定数据库的主键（默认数据库第一列为主键）。 案例说明：更新指定User对象。 代码演示： &lt;update id=\"updateUser\" parameterType=\"com.kuukokawaii.user.entity.User\"> update user, account &lt;set> &lt;if test=\"id != null\"> user.id = #{id}, &lt;/if> &lt;if test=\"name != null\"> name = #{name}, &lt;/if> &lt;if test=\"birthday != null\"> birthday = #{birthday}, &lt;/if> &lt;if test=\"sex != null\"> sex = #{sex}, &lt;/if> &lt;if test=\"address != null\"> address = #{address}, &lt;/if> &lt;if test=\"account.id != null\"> account.id = #{account.id}, &lt;/if> &lt;if test=\"account.username != null\"> account.username = #{account.username}, &lt;/if> &lt;if test=\"account.password != null\"> account.password = #{account.password}, &lt;/if> &lt;/set> where user.id = account.id and user.id = #{id} &lt;/update> insert insert 是 mybatis 的插入语句。 案例说明：插入一个User对象。(如果在插入一个 User 对象的同时插入 Account 对象，需要在 Service 中开启事务并调用 User 插入和 Account 插入语句。) 代码演示： &lt;insert id=\"createUser\" parameterType=\"com.kuukokawaii.user.entity.User\" useGeneratedKeys=\"true\" keyProperty=\"id\"> insert into user &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\"> &lt;if test=\"name != null\"> name, &lt;/if> &lt;if test=\"birthday != null\"> birthday, &lt;/if> &lt;if test=\"sex != null\"> sex, &lt;/if> &lt;if test=\"address != null\"> address, &lt;/if> &lt;/trim> &lt;trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\"> &lt;if test=\"name != null\"> #{name}, &lt;/if> &lt;if test=\"birthday != null\"> #{birthday}, &lt;/if> &lt;if test=\"sex != null\"> #{sex}, &lt;/if> &lt;if test=\"address != null\"> #{address}, &lt;/if> &lt;/trim> &lt;/insert> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（一）：简介","date":"2019-09-22T04:12:57.000Z","path":"posts/13712/","text":"Mybatis 概述 Mybatis 封装了 jdbc，让开发无需花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 Mybatis 通过 XML 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象 和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 Mybatis 框架执行 sql 并将结果映射为 java 对象并返回。 Mybatis 采用 ORM 思想解决了实体和数据库映射的问题，因此不需要直接操作 JDBC API 便可以完成对数据库的持久化操作。 案例说明 在 mysql 数据库中建立 user 表。 创建 User 实体和 dao 接口。 创建映射配置文件（UserMapper.xml），注意 mybatis 的映射位置文件位置必须和 dao 接口的包结构相同。 配置 mybatis 配置文件（SqlMapConfig.xml）。 Demo 目录层级如下： 使用到的 Jar 包 mybatis.jar log4j.jar junit.jar mysql-connector-java.jar 代码演示use mybatis; create table user( id int(11) not null primary key auto_increment, username varchar(30) not null comment '用户名称', birthday datetime default null comment '生日', sex char(1) default null comment '性别', address varchar(256) default null comment '地址' ) engine=innodb default charset=utf8mb4; insert into user (username, birthday, sex, address) values('update user clear cache', '2018-02-10', '男', '北京xx1'); insert into user (username, birthday, sex, address) values('123', '2018-03-10', '女', '北京xx81'); insert into user (username, birthday, sex, address) values('13535', '2018-05-10', '女', '北京xx71'); insert into user (username, birthday, sex, address) values('456436', '2018-07-10', '男', '北京xx19'); insert into user (username, birthday, sex, address) values('asda', '2018-02-15', '女', '北京xx1'); insert into user (username, birthday, sex, address) values('啊沙发沙发', '2018-08-20', '男', '北京xx12'); insert into user (username, birthday, sex, address) values('让他人', '2018-09-10', '女', '北京xx17'); insert into user (username, birthday, sex, address) values('啊实打实的', '2018-10-01', '男', '北京xx21'); /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 省略了 get 和 set。 private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() { return \"User{id=\" + id + \", username='\" + username + \", birthday=\" + birthday + \", sex='\" + sex + \", address\" + \"='\" + address + \"}\"; } } ###################################### # log4j配置相关说明 ###################################### #%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL #%r 输出自应用启动到输出该log信息耗费的毫秒数 #%c 输出所属的类目，通常就是所在类的全名 #%t 输出产生该日志事件的线程名 #%m 输出代码中指定的信息 #%n 输出一个回车换行符，Windows平台为“\\r\\n”，Unix平台为“\\n” #%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MM dd HH:mm:ss,SSS}，输出类似： 2002年10月18日 22：10：28，921 #%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) #log4j提供4种布局: #org.apache.log4j.HTMLLayout（以HTML表格形式布局） #org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， #org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， #org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息 #log4j中有五级logger 输出级别: #FATAL 0 #ERROR 3 #WARN 4 #INFO 6 #DEBUG 7 ###################################### # log4j相关配置 ###################################### #日志输出级别 log4j.rootLogger=INFO,stdout,other #设置stdout的日志输出控制台 log4j.appender.stdout=org.apache.log4j.ConsoleAppender #输出日志到控制台的方式，默认为System.out log4j.appender.stdout.Target=System.out #设置使用灵活布局 log4j.appender.stdout.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.stdout.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %m %n #设置other的日志输出控制台(RollingFileAppender)。/每天生产一个日志文件(DailyRollingFileAppender),没有MaxFileSize和MaxBackupIndex属性。 #log4j.appender.other=org.apache.log4j.DailyRollingFileAppender log4j.appender.other=org.apache.log4j.RollingFileAppender #设置other的输出日志 log4j.appender.other.File=设置输出位置，例如 D:\\\\JetBrains。 #设置other的日志最大限制 log4j.appender.other.MaxFileSize=1024KB #最多只保存20个备份文件 log4j.appender.other.MaxBackupIndex=1000 #输出INFO级别以上的日志 log4j.appender.other.Threshold=INFO #设置使用灵活布局 log4j.appender.other.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.other.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %t %m %n ###显示SQL语句部分 log4j.logger.com.mybatis=DEBUG log4j.logger.com.mybatis.common.jdbc.SimpleDataSource=DEBUG log4j.logger.com.mybatis.common.jdbc.ScriptRunner=DEBUG log4j.logger.com.mybatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG /** * @Author 喵粮都输光了 * @Date 2019/9/25 14:33 * @Description mybatis demo 测试 */ public class UserDaoTest { public static void main(String[] args) throws IOException { // 读取配置文件。 InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建 sqlSessionFactory 工厂 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); // 使用工厂生产 sqlSession 对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 使用 sqlSession 创建 Dao 接口的代理对象 UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User> userList = userDao.findAllUser(); for (User user : userList) { System.out.println(user); } // 释放资源 sqlSession.close(); inputStream.close(); } } XML 配置方式/** * @Author 喵粮都输光了 * @Date 2019/9/23 17:12 * @Description 用户持久层接口 */ public interface UserDao { /** * 查询所有用户 * @return 返回用户 list */ List&lt;User> findAllUser(); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.kuukokawaii.user.dao.UserDao\"> &lt;!-- 配置查询所有用户 --> &lt;select id=\"findAllUser\" resultType=\"com.kuukokawaii.user.entity.User\"> select * from user &lt;/select> &lt;/mapper> &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 配置环境 --> &lt;environments default=\"mysql\"> &lt;!-- 配置 mysql 的环境 --> &lt;environment id=\"mysql\"> &lt;!-- 配置事务的类型 --> &lt;transactionManager type=\"JDBC\"/> &lt;!-- 配置数据源（连接池） --> &lt;dataSource type=\"POOLED\"> &lt;!-- 配置连接数据库的基本信息 --> &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC\"/> &lt;property name=\"username\" value=\"账号\"/> &lt;property name=\"password\" value=\"密码\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个 dao 独立的配置文件 --> &lt;mappers> &lt;mapper resource=\"com/kuukokawaii/user/dao/UserMapper.xml\"/> &lt;/mappers> &lt;/configuration> 注解方式/** * @Author 喵粮都输光了 * @Date 2019/9/23 17:12 * @Description 用户持久层接口 */ public interface UserDao { /** * 查询所有用户 * * @return 返回用户 list */ @Select(\"select * from user\") List&lt;User> findAllUser(); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 配置环境 --> &lt;environments default=\"mysql\"> &lt;!-- 配置 mysql 的环境 --> &lt;environment id=\"mysql\"> &lt;!-- 配置事务的类型 --> &lt;transactionManager type=\"JDBC\"/> &lt;!-- 配置数据源（连接池） --> &lt;dataSource type=\"POOLED\"> &lt;!-- 配置连接数据库的基本信息 --> &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC\"/> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"qwe123\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个 dao 独立的配置文件。如果使用注解方式来配置则此处应该使用 class 属性指定被注解的 dao 全限定类名 --> &lt;mappers> &lt;mapper class=\"com.kuukokawaii.user.dao.UserDao\"/> &lt;/mappers> &lt;/configuration> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"SpringMVC（八）：拦截器","date":"2019-09-21T11:18:43.000Z","path":"posts/27588/","text":"Filter 与 Interceptor 的区别FilterFilter 依赖于 Servlet 容器，它的实现基于函数回调，几乎可以对所有的请求进行过滤，通常于容器初始化时调用。 InterceptorInterceptor 依赖于 SpringMVC 框架，它的实现基于 Java 的反射机制，属于 AOP 的一种运用。通常对处理器方法进行预处理和后处理。 案例说明 编写两个拦截器类，实现 HandlerInterceptor 接口。其中预处理方法中返回值为布尔型，作用分别如下： true：表放行，执行下一个拦截器，没有则执行 controller 中的方法。 false：表不放行，会执行 preHandle() 和 afterCompletion() 方法，但不对 controller 中的方法和 postHandle() 进行执行。 两个拦截器分别为拦截器1和拦截器2，执行顺序为：1pre()→2pre()→controller方法→2post()→1post()→2after()→1after() SpringMVC 配置文件中配置拦截器。 代码演示/** * @Author 喵粮都输光了 * @Date 2019/9/21 19:44 * @Description 自定义拦截器类1 */ public class MyInterceptor1 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"1拦截器预处理，controller 方法执行前运行\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"1拦截器后处理，controller 方法执行后运行\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"1在视图渲染之后运行，还要再拦截器后处理方法运行之后。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/21 19:44 * @Description 自定义拦截器类2 */ public class MyInterceptor2 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"2拦截器预处理，controller 方法执行前运行\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"2拦截器后处理，controller 方法执行后运行\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"2在视图渲染之后运行，还要再拦截器后处理方法运行之后。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 拦截器 */ @Controller @RequestMapping(\"/user\") public class UserController { @RequestMapping(\"/testInterceptor\") String testInterceptor() { System.out.println(\"controller 方法\"); return \"success\"; } } &lt;!-- 配置拦截器 --> &lt;mvc:interceptors> &lt;mvc:interceptor> &lt;!-- 配置需要拦截的方法。&lt;mvc:mapping>表需要拦截的方法，&lt;mvc:exclude-mapping>表不需要拦截的方法。path 填写需要拦截的 URI --> &lt;mvc:mapping path=\"/user/*\"/> &lt;!-- 配置拦截器对象 --> &lt;bean id=\"myInterceptor1\" class=\"com.kuukokawaii.springmvc.interceptor.MyInterceptor1\"/> &lt;/mvc:interceptor> &lt;mvc:interceptor> &lt;mvc:mapping path=\"/**\"/> &lt;bean id=\"myInterceptor2\" class=\"com.kuukokawaii.springmvc.interceptor.MyInterceptor2\"/> &lt;/mvc:interceptor> &lt;/mvc:interceptors> index 界面 拦截器 拦截器 success 界面 执行成功 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（七）：异常处理","date":"2019-09-21T08:28:18.000Z","path":"posts/47299/","text":"异常处理方式SpringMVC 常用的异常处理方式有两种： 使用 SpringMVC 提供的 HandlerExceptionResolver 接口自定义异常处理器。 使用 @ControllerAdvice + @ExceptionHandler 注解实现异常处理。 接口方式 案例说明： 编写自定义异常种类。 编写异常处理器。 配置异常处理器并编写异常跳转页面。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/21 17:06 * @Description 自定义异常 */ public class CustomException extends Exception { /** * 存储提示信息（此处省略了 get 和 set） */ private String message; public CustomException(String message) { this.message = message; } } /** * @Author 喵粮都输光了 * @Date 2019/9/21 17:14 * @Description 自定义异常处理器 */ public class CustomExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { // 获取异常对象 CustomException customException; if (ex instanceof CustomException) { customException = (CustomException) ex; } else { customException = new CustomException(\"系统维护中。\"); } // 创建 ModelAndView 存储异常信息并设置返回页面。 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"errorMsg\", customException.getMessage()); modelAndView.setViewName(\"error\"); return modelAndView; } } /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 异常处理 */ @Controller @RequestMapping(\"/user\") public class UserController{ @RequestMapping(\"/testException\") String testException() throws CustomException { try { // 模拟异常 int i = 1 / 0; } catch (Exception e) { // 打印异常信息 e.printStackTrace(); // 抛出自定义异常信息 throw new CustomException(\"除数不能为0。\"); } return \"success\"; } } &lt;!-- 配置异常处理器 --> &lt;bean id=\"customExceptionResolver\" class=\"com.kuukokawaii.springmvc.exception.CustomExceptionResolver\"/> 异常处理界面 ${errorMsg} index 界面 异常处理 异常处理 注解方式 案例说明： 编写自定义异常种类。(CustomException、Controller 类同上) 使用 @ControllerAdvice + @ExceptionHandler(xx.class) 注解编写全局异常处理器。其中有 @ControllerAdvice 这个注解的类中的方法的某些注解会应用到所有的 Controller 里，例如 @ExceptionHandler。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/21 17:37 * @Description 基于 @ExceptionHandler 处理异常。 */ @ControllerAdvice public class CustomExceptionHandler { /** * 基于 @ExceptionHandler 的异常处理。 * @param exception 异常信息 * @return 返回视图模型 */ @ExceptionHandler(Exception.class) ModelAndView exceptionHandler(Exception exception) { // 获取异常对象 CustomException customException; if (exception instanceof CustomException) { customException = (CustomException) exception; } else { customException = new CustomException(\"系统维护中。\"); } // 创建 ModelAndView 存储异常信息并设置返回页面。 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"errorMsg\", customException.getMessage()); modelAndView.setViewName(\"error\"); return modelAndView; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（六）：文件上传","date":"2019-09-20T06:31:37.000Z","path":"posts/2009/","text":"前提 form 表单的 enctype 取值必须是 multipart/form-data。（enctype 默认值为 application/x-www-form-urlencoded） enctype：表单请求正文的类型。 method 取值必须是 Post。 提供文件选择域&lt;input type=\"file\" name=\"\"&gt;，该标签 name 属性必须有，否者会导致 fileItem 获取不到值。 原理 当 form 表单的 enctype 取值不是默认值后，request.getParameter()将失效。 当enctype=\"application/x-www-form-urlencoded\"时，form 表单的正文内容是：key=value&amp;key=value。 当enctype=\"multipart/form-data\"时， form 表单的正文内容就变成每一部分都是 MIME 类型描述的正文。 后端解析请求体获取 MIME 类型描述的正文（即上传的文件），并将上传文件写回磁盘存储。 传统方式 案例说明： 通过 commons-fileupload.jar 原生 API 解析请求体。 代码演示： index 界面 文件上传 选择文件： /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 文件上传 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 利用 fileupload 解析请求体。 * @param request 请求 * @return 返回到 success 页面。 * @throws Exception 异常 */ @RequestMapping(\"/testOldFileUpload\") String testOldFileUpload(HttpServletRequest request) throws Exception { // 1.上传位置创建文件夹。 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); File file = new File(path); if (!file.exists()) { file.mkdirs(); } // 2.创建 DiskFileItemFactory 存储大于 10kb 的临时文件。 DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory(); // 3.创建 ServletFileUpload 负责处理上传的文件数据。 ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory); List&lt;FileItem> fileItems = servletFileUpload.parseRequest(request); for (FileItem fileItem : fileItems) { // 判断当前 fileItem 对象是否是上传文件项,true 不是，false 是。 if (!fileItem.isFormField()) { // 设置文件名称为唯一值 uuid。 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 获取上传文件的名称，并与 uuid 组合。 String fileName = uuid + \"_\" + fileItem.getName(); // 上传文件 fileItem.write(new File(path, fileName)); // 删除临时 fileItem 文件。 fileItem.delete(); } } return \"success\"; } } SpringMVC 方式 案例说明： 在 SpringMVC 的配置文件中配置文件解析器，要求 id 名称必须为 multipartResolver。 SpringMVC 框架提供了 MultipartFile 对象表示上传的对象，该对象要求变量名称和表单 file 标签的 name 属性名称相同。 代码演示： 选择文件： &lt;!-- 文件解析器，要求 id 名称必须为 multipartResolver --> &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"> &lt;property name=\"maxUploadSize\" value=\"10485760\"/> &lt;/bean> /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 文件上传 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 使用 MultipartFile 对象上传文件。 * @param upload 参数名称必须与文件上传 input 标签的 name 相同。 * @return 返回到 success 页面。 * @throws IOException io 异常 */ @RequestMapping(\"/testSpringMvcFileUpload\") String testSpringMvcFileUpload(MultipartFile upload) throws IOException { // 1.上传位置创建文件夹。 String path = \"D:\\\\JetBrains\\\\IdeaProjects\\\\springmvc\\\\target\\\\springmvc\\\\uploads\\\\\"; File file = new File(path); if (!file.exists()) { file.mkdirs(); } // 设置文件名称为唯一值 uuid。 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 获取上传文件的名称，并与 uuid 组合。 String fileName = uuid + \"_\" + upload.getOriginalFilename(); // 上传文件 upload.transferTo(new File(path, fileName)); return \"success\"; } } 跨服务器上传文件 案例说明： 新建一个 maven 的 webapp 项目，在 webapp 目录下新建 uploads 目录，启动该项目的 Tomcat（注意端口不要重复）。 在客户端项目下导入 com.sun.jersey 下的 jersey-core.jar 和 jersey-client.jar 包，编写服务程序并启动 Tomcat。 如果报错的话，需要注意第一个项目的 Tomcat 中的 webapp 中以及 target 或 out 目录下适当位置是否有创建 uploads 目录。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 文件上传 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 跨服务器上传文件。 * @param upload 参数名称必须与文件上传 input 标签的 name 相同。 * @return 返回到 success 页面。 * @throws IOException io 异常 */ @RequestMapping(\"/testCrossServerFileUpload\") String testCrossServerFileUpload(MultipartFile upload) throws IOException { // 1.定义上传文件服务器路径。 String path = \"http://127.0.0.1:8081/uploads/\"; // 设置文件名称为唯一值 uuid。 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 获取上传文件的名称，并与 uuid 组合。 String fileName = uuid + \"_\" + upload.getOriginalFilename(); // 创建客户端对象 Client client = Client.create(); // 和图片服务器进行连接（文件名可能中文转码） WebResource webResource = client.resource(path + URLEncoder.encode(fileName, \"UTF-8\")); // 上传文件 webResource.put(upload.getBytes()); return \"success\"; } } 选择文件： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（五）：响应数据和结果视图","date":"2019-09-19T05:32:01.000Z","path":"posts/46928/","text":"响应数据返回值类型 String 案例说明： 创建一个拥有姓名、密码和年龄的 User 类。 通过在 JSP 页面发起请求，控制器类中返回一个封装好了数据的 User 类。 在跳转成功的界面获取 User 类中封装的数据。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:43 * @Description 用户类 */ public class User implements Serializable { // 此处省略了 get 和 set private String username; private String password; private Integer age; } /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 测试返回字符串 * @param model 模型 * @return 返回 */ @RequestMapping(\"/testString\") String testString(Model model) { // 模拟从数据库中查询出 User 对象 User user = new User(); user.setUsername(\"12\"); user.setPassword(\"123\"); user.setAge(11); model.addAttribute(\"user\", user); return \"success\"; } } index 界面 响应数据和结果视图 testString success 界面 跳转成功 账户：${user.username} 密码：${user.password} 年龄：${user.age} 返回值类型 void 案例说明： 创建一个拥有姓名、密码和年龄的 User 类。 通过在 JSP 页面发起请求，控制器类中分别进行转发、重定向和直接响应的方法响应视图页面。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 测试无返回值类型。1、转发 2、重定向 3、直接响应 * @param request Servlet 原生API request * @param response Servlet 原生API response */ @RequestMapping(\"/testVoid\") void testVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1、转发（不会使用视图解析器） request.getRequestDispatcher(\"/WEB-INF/pages/success2.jsp\").forward(request, response); /*2、重定向（无法跳转至 WEB-INF 下，且不会使用视图解析器） response.sendRedirect(\"/success2.jsp\");*/ /*3、直接响应 // 设置中文编码，防止中文乱码。 response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=UTF-8\"); response.getWriter().print(\"你好\");*/ } } index 界面 testVoid success 界面 跳转成功 success2 界面 跳转成功 返回值类型 ModelAndView 案例说明： 创建一个拥有姓名、密码和年龄的 User 类。 通过在 JSP 页面发起请求，控制器类中返回一个封装好了数据的 User 类。 在跳转成功的界面获取 User 类中封装的数据。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 测试 ModelAndView * @param modelAndView 模型与视图 * @return 返回 modelAndView 对象 */ @RequestMapping(\"/testModelAndView\") ModelAndView testModelAndView(ModelAndView modelAndView) { User user = new User(); user.setUsername(\"12\"); user.setPassword(\"123\"); user.setAge(11); modelAndView.addObject(\"user\", user); modelAndView.setViewName(\"success\"); return modelAndView; } } index 界面 testModelAndView success 界面 跳转成功 账号：${user.username} 密码：${user.password} 年龄：${user.age} 使用 forward 和 redirect 关键字 案例说明： 通过在 JSP 页面发起请求，控制器类中分别使用 SpringMVC 的关键字进行转发和重定向的方法响应视图页面。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 使用关键字的方式进行转发或重定向（不会使用视图解析器）。 * @return 转发或重定向的目标位置 */ @RequestMapping(\"/testForwardOrRedirect\") String testForwardOrRedirect() { /*1、转发（不会使用视图解析器） return \"forward:/WEB-INF/pages/success.jsp\";*/ // 2、重定向（无法跳转至 WEB-INF 下，且不会使用视图解析器） return \"redirect:success2.jsp\"; } } index 界面 testForwardOrRedirect success 界面 跳转成功 success2 界面 跳转成功 JSON 数据处理过滤静态资源 案例说明： 由于 dispatcherServlet 会拦截所有的资源，导致在请求静态资源时也会被拦截。为此需要通过 SpringMVC 的配置文件配置对静态资源不进行拦截。 代码演示： &lt;!-- 设置不拦截的资源（静态资源），静态资源在 WEB-INF 的 static 文件夹下。 --> &lt;mvc:resources mapping=\"/static/**\" location=\"/static/\"/> index 界面 $(function () { $(\"#testAjax\").click(function () { alert(\"hello\"); }); }); JSON 数据处理 发送 AJAX 发送 AJAX 请求 案例说明： 通过 AJAX 携带 JSON 格式的数据发送 POST 请求给后端。 代码演示：/** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 模拟异步请求响应。 * @param user 获得封装好的 User 类数据。 */ @RequestMapping(\"/testAjax\") void testAjax(@RequestBody String user) { System.out.println(user); } } index 界面 $(function () { $(\"#testAjax\").click(function () { $.ajax({ url: \"/user/testAjax\", contentType: \"application/json;charset=UTF-8\", data: '{\"username\": \"你\",\"password\": 123,\"age\": 11}', dataType: \"json\", type: \"POST\", success: function (data) { //此处 data 是服务器端响应的 json 格式的数据。 } }); }); }); JSON 数据处理 发送 AJAX 响应 JSON 格式数据 案例说明： 使用 @RequestBody 将接收到的前端 JSON 格式的数据转换成 User 对象进行操作。SpringMVC 默认使用 MappingJacksonHttpMessageConverter 对 JSON 格式的数据进行转换，其中需要加入三个 jackson 的包。 jackson-annotation.jar jackson-databind.jar jackson-core.jar 使用 @ResponseBody 将 User 对象转换成 JSON 格式的数据响应给前端。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 模拟异步请求响应。 * @param user 获得封装好的 User 类数据。 */ @RequestMapping(\"/testAjax\") @ResponseBody User testAjax(@RequestBody User user) { // 客户端发送 AJAX 请求传送的是 JSON 格式的数据，后端把 JSON 格式的数据封装到对应的对象中（此处为 User）。 System.out.println(user); // 将获得的对象修改其中姓名属性并返回。 user.setUsername(\"我\"); return user; } } index 界面 $(function () { $(\"#testAjax\").click(function () { $.ajax({ url: \"/user/testAjax\", contentType: \"application/json;charset=UTF-8\", data: '{\"username\": \"你\",\"password\": 123,\"age\": 11}', dataType: \"json\", type: \"POST\", success: function (data) { //此处 data 是服务器端响应的 json 格式的数据。 console.log(\"username:\" + data.username); console.log(\"password\" + data.password); console.log(\"age\" + data.age); } }); }); }); JSON 数据处理 发送 AJAX document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（四）：常用注解","date":"2019-09-19T05:19:32.000Z","path":"posts/54418/","text":"RequestParam 作用：把请求中指定名称的参数赋值给控制器中的形参。 属性： value：请求参数中的名称。 required：请求参数中是否必须提供此参数。（默认 true） 关键代码演示： @requestParam /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试 */ @Controller @RequestMapping(\"/annotation\") public class AnnotationController { /** * 测试 @RequestParam * @param username 账户名 * @param password 密码 * @return 返回到 success 页面 */ @RequestMapping(\"/testRequestParam\") String testRequestParam(@RequestParam String username, @RequestParam(\"pw\") String password) { // 此处前端必须提供 username 和 pw 的值，此处将前端 username 的值传给 username，而 pw 的值传给 password。 System.out.println(\"username=\" + username + \";password=\" + password); return \"success\"; } } RequestBody 作用：用于获取请求体内容，得到 key = value 格式的数据，不适用于 get 请求。 属性： required：请求参数中是否必须提供此参数（默认 true）。为 true 时，get 请求方式报错；为 false 时，get 请求得到 null 值。 关键代码演示： 账号： 密码： /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试 */ @Controller @RequestMapping(\"/annotation\") public class AnnotationController { /** * 测试 @RequestBody * @param requestBody 请求参数体 * @return 返回到 success 页面 */ @RequestMapping(\"/testRequestBody\") String testRequestBody(@RequestBody String requestBody) { System.out.println(requestBody); return \"success\"; } } PathVariable 作用：用于绑定 URL 中的占位符，常用于 REST 风格URL。例如：/delete/{id}，其中{id}就是 URL 占位符。 属性： value：用于指定 URL 中占位符名称。 required：是否必须提供占位符。 关键代码演示： @PathVariable /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试 */ @Controller @RequestMapping(\"/annotation\") public class AnnotationController { /** * 测试 @PathVariable * @param username REST 风格 URL 参数 * @return 返回到 success 页面 */ @RequestMapping(\"/testPathVariable/{username}\") String testPathVariable(@PathVariable String username) { System.out.println(username); return \"success\"; } } 衍生问题：form 只支持 GET 与 POST 请求，因此可以使用 HiddenHttpMethodFilter 过滤器更改指定的请求。如果 controller 方法上不添加 @ResponseBody 会报 jsp 不支持该方法，这是因为在tomcat8以上版本是不支持 delete 和 post 请求，此时可以通过 @ResponseBody 注解解决问题，但后端无法直接跳转页面。 解决方法： &lt;!-- 支持更多的表单提交方式，出现 web-app 报错需要升级 xml 的头部信息 --> &lt;filter> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> 账号： /** * 测试 @PathVariable。 * * @param username REST 风格 URL 参数 * @return 返回到 success 页面 */ @RequestMapping(value = \"/testPathVariable/{username}\", method = RequestMethod.DELETE) @ResponseBody String testPathVariable(@PathVariable String username) { System.out.println(\"删除：\" + username); return \"success\"; } RequestHeader 作用：用于获取请求消息头。 属性： 提供消息头名称。 是否必须有此消息头。 关键代码演示： @RequestHeader /** * 测试 @RequestHeader * @param header 获取某个具体头属性的值。 * @return 返回到 success 页面。 */ @RequestMapping(\"testRequestHeader\") String testRequestHeader(@RequestHeader(\"Accept\") String header) { System.out.println(header); return \"success\"; } CookieValue 作用：用于把指定 cookie 名称的值传入控制器方法参数。 属性： value：指定 cookie 的名称。 required：是否必须有此 cookie。 关键代码演示： @CookieValue /** * 测试 @CookieValue * @param cookieValue 获取某个具体 cookie 的值。 * @return 返回到 success 页面。 */ @RequestMapping(\"testCookieValue\") String testCookieValue(@CookieValue(\"JSESSIONID\") String cookieValue) { System.out.println(cookieValue); return \"success\"; } ModelAttribute 作用：可以作用于参数和方法上。作用于参数上时，获取指定的数据给参数赋值；作用于方法上时，表示当前方法会在控制器的其它方法执行前执行。 属性： value：用于获取数据的 key。key 可以是 POJO的属性名称，也可以是 map 结构的 key。 应用场景：当表单提交的数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原有的数据。例如用户类拥有账号和密码两个字段，而对数据库用户进行更新时规定账号不能进行修改，只能对密码进行修改，因此一旦进行更新时账号字段就会变为 null，此时就可以使用此注解解决该问题。 案例说明：提交的 User 类是没有被填充 Date 属性的，在 controller 方法中将 Date 属性进行填充。 关键代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/16 22:03 * @Description 用户实体 */ public class User implements Serializable { // 省略了 get 和 set private String userName; private Integer age; private Date date; @Override public String toString() { return \"User{userName=\" + userName + \", age=\" + age + \", date=\" + date + \"}\"; } } 姓名： 年龄： ModelAttribute 修饰方法带返回值 constUserName() 会先获得一个拥有 Date 属性的 User 类，然后将 testModelAttribute() 获得的 User 类其他属性填充入之前的 User 类。 /** * 测试 @ModelAttribute * @param user 获取用户设置好名字和年龄的 User 类属性，并将该 User 类的属性填充入之前 constUserName 的 User 类中，最终获得的是在 constUserName * 返回的类上填充了名字和年龄的 User 类。 * @return 返回到 success 页面。 */ @RequestMapping(\"testModelAttribute\") String testModelAttribute(User user) { System.out.println(user); return \"success\"; } /** * 提前获取到 User 类，并为 User 类填充 Date 属性。 * @param user 不带 Date 的 User 封装类。 * @return 将设置了 Date 的 User 封装类返回。 */ @ModelAttribute User constUserName(User user) { user.setDate(new Date()); return user; } ModelAttribute 修饰方法不带返回值 /** * 测试 @ModelAttribute * @param user 从 map 获取 User 类，并将从请求中获得的 User 类属性封装入该 User 类中。 * @return 返回到 success 页面。 */ @RequestMapping(\"testModelAttribute\") String testModelAttribute(@ModelAttribute(\"user\") User user) { System.out.println(user); return \"success\"; } /** * 提前获取到 User 类，并为 User 类填充 Date 属性，将封装好的 User 装入 map 中。 * @param user 不带 Date 的 User 封装类。 * @param map 用于存储封装好的 User 类。 */ @ModelAttribute void constUserName(User user, Map&lt;String, User> map) { user.setDate(new Date()); map.put(\"user\", user); } SessionAttributes 作用：用于多次执行控制器方法间的参数共享，作用于类上。（SessionAttribute 作用于参数前，为形参赋值。） 属性： value：用于指定存入的属性名称。 type：用于指定存入的数据类型。 关键代码演示： index 界面 SpringMVC 常用注解 @SessionAttribute Get @SessionAttribute Delete @SessionAttribute /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试。 @SessionAttributes(\"test\") 表示将request 域中的 key 为 test 的值存一份在 session 域中。 */ @Controller @RequestMapping(\"/annotation\") @SessionAttributes(\"test\") public class AnnotationController { /** * 测试 @SessionAttribute * @param model 可以将值存入 request 域，map 格式。 * @return 返回到 success 页面。 */ @RequestMapping(\"testSessionAttributes\") String testSessionAttributes(Model model) { // 此处将值存入 request 域。 model.addAttribute(\"test\", \"测试用数据。\"); return \"success\"; } /** * 测试获取 session 域中的值。 * @param modelMap 可以从 session 域获取值，map 格式。 * @return 返回到 success 页面。 */ @RequestMapping(\"testGetSessionAttributes\") String testGetSessionAttributes(ModelMap modelMap) { String test = (String) modelMap.get(\"test\"); System.out.println(test); return \"success\"; } /** * 清空 session 域。 * @param sessionStatus 获得 session 域的状态。 * @return 返回到 success 页面。 */ @RequestMapping(\"testDeleteSessionAttributes\") String testDeleteSessionAttributes(SessionStatus sessionStatus) { sessionStatus.setComplete(); return \"success\"; } } success 界面 跳转成功 request:${requestScope.get(\"test\")} session:${sessionScope.get(\"test\")} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（三）：请求参数绑定","date":"2019-09-16T13:02:47.000Z","path":"posts/25820/","text":"请求参数绑定机制 请求的数据都是 key = value 格式的。 SpringMVC 的参数绑定过程是把请求的参数绑定至控制器中方法的参数上。 提交数据的 key 和参数的名称必须相同。 支持的数据类型有三种： 基本数据类型和字符串类型。 实体类型。 集合数据类型。 GET 请求参数绑定 案例说明：通过 JSP 页面&lt;a&gt;标签向 controller 发起 GET 请求（携带 username 和 password 两参数）。 代码演示：基本数据类型和字符串类型。/** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * GET 请求基本类型参数绑定测试 * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/testGetParam\") String testGetParam(String username, String password) { System.out.println(\"执行成功。username = \" + username + \";password = \" + password); return \"success\"; } } index 界面 SpringMVC 请求参数绑定 请求参数绑定测试 POST 请求参数绑定 案例说明： Account 实体类中包含 User 实体类。 JSP 页面通过表单向 controller 发起 POST 请求（携带 Account 实体）。 使用 POST 提交数据中如果有中文会导致 controller 获得的数据是乱码。此处可以通过在 web.xml 中配置 filter 解决乱码问题(filter 标签必须在 servlet 标签之前）。 代码演示1：实体类型。&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" > &lt;web-app> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!-- 中文乱码解决过滤器，filter 需要放置在 servlet 前，否则&lt;/web-app>标签会报错。 --> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;!-- 该类存在 servlet-api.jar 中，用于直接配置 servlet 拦截请求（前端控制器） --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 配置 springmvc 启动 --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring-mvc.xml&lt;/param-value> &lt;/init-param> &lt;!-- 启动服务器就创建了 servlet 对象。（不配置时，只有请求过来时才会进行创建。） --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> /** * @Author 喵粮都输光了 * @Date 2019/9/16 22:03 * @Description 用户实体 */ public class User implements Serializable { // 省略了 get 和 set private String userName; private Integer age; @Override public String toString() { return \"User{userName=\" + userName + \", age=\" + age + \"}\"; } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:42 * @Description 账户实体类 */ public class Account implements Serializable { // 省略了 get 和 set private String username; private String password; private Double money; private User user; @Override public String toString() { return \"Account{username=\" + username + \", password=\" + password + \", money=\" + money + \", \" + user + \"}\"; } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * POST 请求实体参数绑定测试 * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/testPOSTParam\") String testPOSTParam(Account account) { System.out.println(account); return \"success\"; } } index 界面 SpringMVC 请求参数绑定 账号： 密码： 金额： 姓名： 年龄： 代码演示2：集合类型。（与上区别仅在 Account、ParamController 类和 index.jsp 页面。且在开发中，前端使用这样的方法进行传值会遭成高耦合性，因此都是通过 json 的格式来传递参数。）/** * @Author 喵粮都输光了 * @Date 2019/9/16 21:42 * @Description 账户实体类 */ public class Account implements Serializable { private String username; private String password; private Double money; private List&lt;User> list; private Map&lt;String, User> map; // 省略了 get 和 set @Override public String toString() { return \"Account{username=\" + username + \", password=\" + password + \", money=\" + money + \", list=\" + list + \", map=\" + map + \"}\"; } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * POST 请求集合类型参数绑定测试 * * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/testPostCollectionsParam\") String testPostCollectionsParam(Account account) { System.out.println(account); return \"success\"; } } index 界面 SpringMVC 请求参数绑定 账号： 密码： 金额： 姓名（list）： 年龄（list）： 姓名（map）： 年龄（map）： 自定义类型转换器 案例说明： User 实体类包含姓名、年龄和生日日期。 JSP 页面通过表单向 controller 发起 POST 请求（携带 User 实体）。 使用 POST 提交数据如果日期的格式不是yyyy/MM/dd会发生格式转换错误，此时新建自定义类型转换器类实现 Converter 并在 spring-mvc.xml 中配置转换器解决该问题。 代码演示：/** * @Author 喵粮都输光了 * @Date 2019/9/18 12:00 * @Description 字符串转换日期的自定义类型转换器。（String 表示传入进来的值，Date 是需要将String 转换成的目标类型。） */ public class StringToDateConverter implements Converter&lt;String, Date> { @Override public Date convert(String source) { if (source != null) { // 自定义需要转换成的格式。 DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); // 进行转换。 try { return dateFormat.parse(source); } catch (ParseException e) { throw new RuntimeException(\"数据类型转换出现异常。\"); } } else { throw new RuntimeException(\"请您传入数据。\"); } } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * POST 请求自定义类型转换器测试 * * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/customTypeConverter\") String customTypeConverter(User user) { System.out.println(user); return \"success\"; } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.springmvc\"/> &lt;!-- 视图解析器对象 --> &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> &lt;!-- 配置自定义类型转换器（需要在 SpringMVC 框架注解支持上填入配置的 ConversionServiceFactoryBean 的 id。 --> &lt;bean id=\"conversionServiceFactoryBean\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"> &lt;property name=\"converters\"> &lt;set> &lt;bean class=\"com.kuukokawaii.utils.StringToDateConverter\"/> &lt;/set> &lt;/property> &lt;/bean> &lt;!-- 开启 SpringMVC 框架注解的支持 --> &lt;mvc:annotation-driven conversion-service=\"conversionServiceFactoryBean\"/> &lt;/beans> index 界面 SpringMVC 请求参数绑定 姓名： 年龄： 生日： Servlet 原生 API 案例说明：在 controller 中使用 servlet 的原生 API。 关键代码演示：Servlet 原生 API 测试 /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * 测试 servlet 原生 API * @param request servlet 请求 * @param response servlet 响应 * @return 返回到 success 页面 */ @RequestMapping(\"/testServlet\") String testServlet(HttpServletRequest request, HttpServletResponse response) { HttpSession session = request.getSession(); System.out.println(request); System.out.println(session); System.out.println(response); return \"success\"; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（二）：环境搭建","date":"2019-09-14T02:42:03.000Z","path":"posts/39549/","text":"案例说明 启动服务器时加载一些配置文件。 DispatcherServlet 对象创建。 SpringMVC 配置文件加载。 HelloController 对象创建。 发送请求，通过 HelloController 处理请求并跳转至 success.jsp 页面。 使用到的 Jar 包 spring-context.jar spring-web.jar（Spring Web 整合） spring-webmvc.jar（SpringMVC 核心） servlet-api.jar(用于提供 DispatcherServlet 类) jsp-api.jar（servlet-api 的依赖） 注解作用@RequestMapping(path\\value = \"\", method = {RequestMethod.POST}, params = {\"\"}, headers = {\"\"\"})：用于建立请求 URL 和处理请求方法之间的对应关系。 可作用于方法和类上。作用于类上便相当于请求 URL 的第一级访问目录，需要以/开头；而作用于方法就相当于请求 URL 的第二级访问目录。 path 和 value 作用是相同的，都是请求路径的映射（如果只有 value 单个属性则可省略）。 method：用于指定请求的方法（GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE）。 params：用于指定限制请求参数的条件。要求请求的参数的 key 和 value 必须和配置的一模一样。 headers：用于指定限制请求消息头的条件，即发送的请求中必须包含的请求头。 代码演示&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.springmvc\"/> &lt;!-- 视图解析器对象 --> &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> &lt;!-- 开启 SpringMVC 框架注解的支持 --> &lt;mvc:annotation-driven/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/13 13:36 * @Description a 标签跳转 controller 类 */ @Controller public class HelloController { /** * 输出测跳转 * @return 返回到 success.jpg 页面 */ @RequestMapping(path = \"/hello\") String sayHello() { System.out.println(\"Hello SpringMVC\"); return \"success\"; } } &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" > &lt;web-app> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!-- 该类存在 servlet-api.jar 中，用于直接配置 servlet 拦截请求（前端控制器） --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 配置 springmvc 启动 --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring-mvc.xml&lt;/param-value> &lt;/init-param> &lt;!-- 启动服务器就创建了 servlet 对象。（不配置时，只有请求过来时才会进行创建。） --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> index 界面 SpringMVC 测试 跳转小程序 success 界面 跳转成功 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"Maven：No Archetype Found","date":"2019-09-12T13:53:17.000Z","path":"posts/6576/","text":"问题在创建 maven 项目时，选择 org.apache.maven.archetypes:maven-archetype-webapp 的 archetype 时，出现项目初始化失败的情况。报错情况如下： 解决方法在创建项目时，配置 archetypeCatalog 的属性为 internal 即可解决问题。 分析给 maven 配置了阿里源导致了如上问题，可能是阿里源的 archetype-catalog.xml 文件出现了问题。其中 archetype-catalog.xml 能提供 Archetype 的信息，常用的属性有 internal、local 和 remote 三个属性。 internal：maven-archetype-plugin 内置的 Archetype Catalog。 local：指向本地的 Archetype Catalog ，其位置为~/.m2/archetype-catalog.xml。需要注意的是，该文件默认是不存在的。 remote：指向了Maven中央仓库的Archetype Catalog。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"problem","slug":"problem","permalink":"https://blog.kuukokawaii.com/tags/problem/"},{"name":"maven","slug":"maven","permalink":"https://blog.kuukokawaii.com/tags/maven/"}]},{"title":"SpringMVC（一）：简介","date":"2019-09-09T06:44:00.000Z","path":"posts/18696/","text":"服务器三层架构JavaEE 常基于 B/S 架构进行开发，而在 B/S 架构中系统标准的三层架构包括：表现层、业务层和持久层。 表现层（web 层）表现层用于接收客户端请求，并向客户端响应结果。它包括展示层和控制层，其中展示层负责展示结果，而控制层负责接收请求。因此表现层依赖于业务层，当接收到客户端的请求时一般会调用业务层进行处理，并将处理结果返回给客户端。 业务层（service 层）业务层负责业务逻辑的处理，当需要对数据进行持久化操作时需要保证事务的一致性，因此业务层可能依赖于持久层，且事务应该在业务层进行控制。 持久层（dao 层）持久层负责数据持久化操作，包括数据层即数据库和数据访问层，其中数据库是对数据进行持久化的载体，而数据访问层是业务层和持久层交互的接口。业务层需要通过数据访问层将数据持久化到数据库中。 MVC 设计模型MVC（Model View Controller）是一种用于设计创建 Web 应用程序表现层的模式，它包括 Model、View 和 Controller 三部分： Model（模型）：常指数据模型，一般用于封装数据。例如 JavaBean。 View（视图）：常指前端视图，一般用于显示数据。例如 Html。 Controller（控制器）：是应用程序中处理用户交互的部分，一般用于处理程序逻辑。例如 Servlet。 SpringMVC 架构 SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架。它通过一套注解让一个简单的 Java 类成为处理请求的控制器，而无需实现任何接口。同时它还支持 RESTful 编程风格的请求。 SpringMVC 拥有诸多优势，例如： 是基于模块化开发的架构，拥有清晰的角色划分。 可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 可定制，通过 HandlerMapping、ViewResolver 等能够非常简单的进行定制。 功能强大的数据验证、格式化、绑定机制。 利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 SpringMVC 工作流程 概念DispatcherServlet：Spring 前端控制器（中央调度器），它是整个请求响应的控制中心，组件的调用由它统一调度。HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler。HandlerAdapter：处理器适配器，它调用 Handler 执行具体的业务操作并返回逻辑视图 ModelAndView 对象。Handler：Handler，对用户具体请求进行处理（相当于 controller 类）。ModelAndView 对象：逻辑视图。ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图。 工作流程如图工作流程可以大致划分为如下步骤： 用户向服务器发送请求，请求被 DispatcherServlet 捕获。 DispatcherServlet 对请求的 URL 进行解析，得到 URI。然后根据 URI 调用 HandlerMapping 获得具体的处理器 Handler 并返回给 DispatcherServlet。 DispatcherServlet 根据获取的 Handler，选择一个合适的 HandlerAdapter。 提取 Request 中的模型数据作为 Handler 的参数并执行。（此处可做 HttpMessageConverter，数据转换、数据格式化和数据验证等操作。） Handler 执行完成后，HandlerAdapter向 DispatcherServlet 返回一个 ModelAndView 对象，其中 view 是视图名称，并不是真正的视图对象。 根据返回的 ModelAndView 对象选择一个合适的 ViewResolver 返回给 DispatcherServlet（必须是已经注册到Spring容器中的 ViewResolver）。 DispatcherServlet 将 ModelAndView 对象传给 ViewResolver。 ViewResolver 解析后返回具体的 View（例如 html、JSP 等）。 DispatcherServlet 对 View 进行渲染视图，即将数据模型填充到视图中。 DispatcherServlet 对用户进行响应。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"Spring（七）：Transaction","date":"2019-09-05T07:36:22.000Z","path":"posts/37736/","text":"什么是事务（Transaction）事务是逻辑上的一组操作，要么都执行，要么都不执行。例如某人要在商店使用电子货币购买100元的东西，当中至少包括两个操作：1.该人账户减少100元；2.商店账户增加100元。这两操作需要同时进行，否则就会出现100元平白消失或出现的情况。因此可以得知事务具有 ACID 的性质。 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）：执行事务前后，数据保持一致； 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 事务隔离 事务隔离级别即定义一个事务可能受其他并发时间事务影响的程度。例如多个用户对统一数据操作会导致如下问题的发生： 脏读（Dirty read）：当一个事务读取到另一个事务正在进行修改却还没有提交到数据库中的数据便称为脏读，而读取到的数据被称为脏数据，依据脏数据所作的操作可能是不对的。 丢失修改（Lost to modify）：两个事务同时读取修改同一数据，后提交事务的修改结果破坏了先提交事务的修改结果，导致先提交事务的修改被丢失。 不可重复读（Unrepeatable read）：指在一个事务内多次读同一数据。当事务 A 读取了数据还未进行提交操作时，而事务 B 也读取了该数据并对其数据进行了修改、提交。此时事务 A 再次读取数据时会发现第一次读取的数据可能与第二次读取的数据是不一样的。即同一个事务内两次读取同一数据其结果却不一样，这样的情况称为不可重复度。常发生于 update 操作之上。 幻读（Phantom read）：幻读与不可重复读相似，其区别在于幻读发生于 insert 操作之上。即事务 A 读取了数据还未进行提交操作时，事务 B 也读取了该数据并对其数据进行了插入、提交操作。导致事务 A 再次读取该数据时发现多出了一些不存在的记录，因此称为幻读。 事务隔离级别的出现就是为了解决如上四个问题的发生，常用事务隔离级别作用如下： 读未提交（Read uncommitted）：一个事务可以读取另一个未提交事务的数据。没有解决上述任何问题。 读已提交（Read committed）：一个事务要等另一个事务提交后才能读取数据。解决了脏读的问题。 可重复读（Repeatable read）：在事务开始读取数据时不再允许修改操作。解决了丢失修改、不可重复读和脏读的问题。 序列化（Serializable）：序列化是最高的事务隔离级别，在该级别下事务串行化顺序执行。解决了上述所有问题。 Spring 事务管理接口 PlatformTransactionManager（平台事务管理器）：Spring 必须使用事务管理器才能管理事务。 常用的事务管理器DataSourceTransactionManager：Jdbc 或 Mybatis 开发使用，采用 JdbcTemplate 或 整合 Mybatis。HibernateTransactionManager：Hibernate 开发使用，整合 Hibernate。 TransactionDefinition（事务属性）：Spring 用于确定事务具体详情。例如事务隔离级别、传播行为、超时、只读、回滚规则等。当进行事务配置时必须配置详情，Spring 会将配置项封装到该对象实例。 传播行为事务的传播行为规定了事务方法和事务方法发生嵌套调用时事务是如何进行传播，Spring 为其定义了七种类型的事务传播行为： PROPAGATION_REQUIRES（传播行为默认值）：如果当前有事务则加入该事务（即支持当前事务）;如果当前没事务则新建一个事务。 PROPAGATION_SUPPORTS：支持当前事务，如果当前没事务则以非事务方式执行。 PROPAGATION_MANDATORY：支持当前事务，如果当前没事务则抛出异常。 PROPAGATION_REQUIRES_NEW：无论有无事务都新建一个事务且如果当前有事务则挂起该事务（即不支持当前事务）。 PROPAGATION_NOT_SUPPORTED：无论有无事务都以非事务方式执行且不支持当前事务。 PROPAGATION_NEVER：如果当前有事务则抛出异常；如果当前没事务则以非事务方式执行。 PROPAGATION_NESTED：如果当前有事务则在该事务内嵌套一个事务执行；如果当前没事务则新建一个事务。 TransactionStatus（事务运行状态）：Spring 用于记录当前事务运行状态。例如事务是否有保存点、是否回滚、是否完成等。Spring 底层会根据状态进行相应的操作。 案例说明 通过事务模板 TransactionTemplate 进行操作（手动管理事务）。 Spring 配置 TransactionTemplate，并注入给 Service。 配置事务管理器（注入 TransactionTemplate，即注入 DataSource）。 工厂 bean 生成代理（半自动）。Spring 提供管理事务的代理工厂 bean：TransactionProxyFactoryBean。 获取代理对象。 Spring 配置代理。 AOP 配置基于 xml在 Spring XML 中配置 AOP 自动生成代理，并进行事务的管理。 配置事务管理器。 配置事务属性。 配置 AOP。 AOP 配置基于注解 配置事务管理器并交予 Spring。 在目标类或目标方法添加注解（@Transactional）。 使用到的部分 Jar 包 spring-tx.jar spring-jdbc.jar spring-orm.jar：Spring 提供对部分 ORM（对象关系映射将关系数据库中表的数据映射成为对象）框架的支持。 代码演示/** * @Author 喵粮都输光了 * @Date 2019/9/7 15:26 * @Description 账户持久层接口 */ public interface AccountDao { /** * 支出 * @param outer 支出者 * @param money 支出金额 */ void expense(String outer, Integer money); /** * 收入 * @param inner 收入者 * @param money 收入金额 */ void income(String inner, Integer money); } /** * @Author 喵粮都输光了 * @Date 2019/9/7 15:22 * @Description 账户持久层实现类 */ public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao { @Override public void expense(String outer, Integer money) { Objects.requireNonNull(this.getJdbcTemplate()).update(\"UPDATE account SET money = money - ? WHERE username = ?\", money, outer); } @Override public void income(String inner, Integer money) { Objects.requireNonNull(this.getJdbcTemplate()).update(\"UPDATE account SET money = money + ? WHERE username = ?\", money, inner); } } jdbc.driverClass=com.mysql.cj.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql://localhost:3306/所使用的库名 jdbc.user=账号 jdbc.password=密码 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- dao --> &lt;bean id=\"accountDao\" class=\"com.kuukokawaii.transaction.account.dao.AccountDaoImpl\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- service --> &lt;bean id=\"accountService\" class=\"com.kuukokawaii.transaction.account.service.AccountServiceImpl\"> &lt;property name=\"accountDao\" ref=\"accountDao\"/> &lt;property name=\"transactionTemplate\" ref=\"transactionTemplate\"/> &lt;/bean> &lt;!-- 创建 TransactionTemplate --> &lt;bean id=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\"> &lt;property name=\"transactionManager\" ref=\"txManager\"/> &lt;/bean> &lt;!-- 配置事务管理器，管理器管理事务，事务存在于 service、dao 等中，它们都可以从 Connection 中获得，而连接从连接池获得，所以需要配置的是连接池。 --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/7 15:34 * @Description Account Service */ public interface AccountService { /** * 转账 * @param outer 支出者 * @param inner 收入者 * @param money 金额 */ void transfer(String outer, String inner, Integer money); } 手动管理事务/** * @Author 喵粮都输光了 * @Date 2019/9/7 15:36 * @Description AccountService实现类 */ public class AccountServiceImpl implements AccountService { private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) { this.transactionTemplate = transactionTemplate; } @Override public void transfer(String outer, String inner, Integer money) { transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus status) { accountDao.expense(outer, money); accountDao.income(inner, money); } }); } } /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ public class AccountServiceImplTest { /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); AccountService accountService = applicationContext.getBean(\"accountService\", AccountService.class); accountService.transfer(\"jack\", \"r\", 1000); } } 半自动&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- dao --> &lt;bean id=\"accountDao\" class=\"com.kuukokawaii.transaction.account.dao.AccountDaoImpl\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- service --> &lt;bean id=\"accountService\" class=\"com.kuukokawaii.transaction.account.service.AccountServiceImpl\"> &lt;property name=\"accountDao\" ref=\"accountDao\"/> &lt;/bean> &lt;!-- service proxy： proxyInterfaces：目标类接口 target：目标类 transactionManager：事务管理器 transactionAttributes：配置 transactionDefinition key：确定哪些方法使用当前事务配置。（一般方法名） value：用于配置事务属性。即 transactionDefinition 格式：PROPAGATION, ISOLATION, readOnly, -Exception, +Exception（其中-Exception为发生这些异常就回滚，+Exception为发生这些异常仍然提交。） --> &lt;bean id=\"proxyAccountService\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"> &lt;property name=\"proxyInterfaces\" value=\"com.kuukokawaii.transaction.account.service.AccountService\"/> &lt;property name=\"target\" ref=\"accountService\"/> &lt;property name=\"transactionManager\" ref=\"txManager\"/> &lt;property name=\"transactionAttributes\"> &lt;props> &lt;prop key=\"transfer\">PROPAGATION_REQUIRED, ISOLATION_DEFAULT&lt;/prop> &lt;/props> &lt;/property> &lt;/bean> &lt;!-- dataSourceTransactionManager --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ public class AccountServiceImplTest { /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); AccountService accountService = applicationContext.getBean(\"proxyAccountService\", AccountService.class); accountService.transfer(\"jack\", \"r\", 1000); } } AOP 配置基于 xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd\"> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- dao --> &lt;bean id=\"accountDao\" class=\"com.kuukokawaii.transaction.account.dao.AccountDaoImpl\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- service --> &lt;bean id=\"accountService\" class=\"com.kuukokawaii.transaction.account.service.AccountServiceImpl\"> &lt;property name=\"accountDao\" ref=\"accountDao\"/> &lt;/bean> &lt;!-- dataSourceTransactionManager --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 事务通知（事务属性）：&lt;tx:method name=\"transfer\" propagation=\"REQUIRES_NEW\" isolation=\"DEFAULT\"/> --> &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"> &lt;tx:attributes> &lt;tx:method name=\"transfer\"/> &lt;/tx:attributes> &lt;/tx:advice> &lt;!-- AOP --> &lt;aop:config> &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.kuukokawaii.transaction.account.service.*.*(..))\"/> &lt;/aop:config> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ public class AccountServiceImplTest { /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); AccountService accountService = applicationContext.getBean(\"accountService\", AccountService.class); accountService.transfer(\"jack\", \"r\", 1000); } } AOP 配置基于注解此处Service层添加了@Service注解。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.transaction.account\"/> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- jdbcTemplate --> &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- dataSourceTransactionManager --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 事务注解开启： transaction-manager：将事务管理器交予 Spring。 proxy-target-class： true：底层强制使用 CGLIB 代理。 false：自动选择。 --> &lt;tx:annotation-driven transaction-manager=\"txManager\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/7 15:22 * @Description 账户持久层实现类 */ @Repository public class AccountDaoImpl implements AccountDao { private final JdbcTemplate jdbcTemplate; @Autowired public AccountDaoImpl(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @Override public void expense(String outer, Integer money) { jdbcTemplate.update(\"UPDATE account SET money = money - ? WHERE username = ?\", money, outer); } @Override public void income(String inner, Integer money) { jdbcTemplate.update(\"UPDATE account SET money = money + ? WHERE username = ?\", money, inner); } } /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class AccountServiceImplTest { @Autowired private AccountService accountService; /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { accountService.transfer(\"jack\", \"r\", 1000); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（六）：JDBCTemplate","date":"2019-09-04T08:49:50.000Z","path":"posts/63918/","text":"什么是 JDBCTemplateSpring 为传统的 JDBC 进行封装,简化持久层操作。通过使用 Spring 的注入功能，可以把 DataSource 注册到 JDBCTemplate 之中。 案例说明 通过 API 对 dbcp 进行操作。 通过 Spring 配置使用 DBCP。 使用 C3P0 连接池。 通过 JdbcDaoSupport 直接获取 JdbcTemplate，并用 properties 文件存储连接池属性。 使用到的部分 Jar 包 spring-tx.jar：负责在 Spring 框架中实现事务管理功能。 c3p0.jar：开源的 JDBC 连接池。 commons-dbcp.jar： 用于管理数据库连接池。依赖于 commons-pool。 commons-pool.jar： 数据库连接池。 mysql-connector-java.jar：Java 通过 JDBC 访问 mysql 数据库时使用。 commons-collections.jar：提供更多的接口。 spring-jdbc.jar：Spring 对 JDBC 数据访问进行封装的包。 代码演示直接使用 DBCP 方式/** * @Author 喵粮都输光了 * @Date 2019/9/4 18:33 * @Description 用户类 */ public class User { /** * 用户 id */ private Integer id; /** * 用户姓名 */ private String username; /** * 用户密码 */ private String password; } /** * @Author 喵粮都输光了 * @Date 09/04/2019 * @Description jdbc test */ public class UserTest { @Test public void test() throws Exception { // 创建数据源（连接池）：此处使用 dbcp BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/所使用的库名\"); dataSource.setUsername(\"账号\"); dataSource.setPassword(\"密码\"); // 创建模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); // 通过 api 操作 jdbcTemplate.update(\"INSERT INTO t_user(username, password) VALUES(?, ?);\", \"tom\", \"998\"); } } 通过 Spring 配置使用 DBCP/** * @Author 喵粮都输光了 * @Date 2019/9/4 19:15 * @Description 用户持久层类 */ public class UserDao { /** * jdbc 模板由 spring 注入。 */ private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public void update(User user) { String sql = \"UPDATE t_user SET username = ?, password = ? WHERE id = ?\"; Object[] args = {user.getUsername(), user.getPassword(), user.getId()}; jdbcTemplate.update(sql, args); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 创建数据源 --> &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"> &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/所使用的库名\"/> &lt;property name=\"username\" value=\"账号\"/> &lt;property name=\"password\" value=\"密码\"/> &lt;/bean> &lt;!-- 创建模板，需要注入数据源 --> &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 配置 dao --> &lt;bean id=\"userDao\" class=\"com.kuukokawaii.jdbctemplate.user.dao.UserDao\"> &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/04/2019 * @Description jdbc test */ public class UserTest { @Test public void test() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); UserDao userDao = applicationContext.getBean(\"userDao\", UserDao.class); User user = new User(); user.setId(1); user.setUsername(\"isolation\"); user.setPassword(\"998\"); userDao.update(user); } } C3P0仅 xml 数据池配置方式不同。 &lt;!-- 创建数据源 --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/所使用的库名\"/> &lt;property name=\"user\" value=\"账号\"/> &lt;property name=\"password\" value=\"密码\"/> &lt;/bean> JdbcDaoSupport如上述所示，那么每一个 dao 中都需要进行setJdbcTemplate的操作，造成代码的重复。而通过使用 JdbcDaoSupport，可以通过 JdbcDaoSupport 直接获取 JdbcTemplate 并对其进行应用。此处通过 properties 配置 jdbc 属性。 /** * @Author 喵粮都输光了 * @Date 2019/9/4 19:15 * @Description 用户持久层类 */ public class UserDao extends JdbcDaoSupport { public void update(User user) { String sql = \"UPDATE t_user SET username = ?, password = ? WHERE id = ?\"; Object[] args = {user.getUsername(), user.getPassword(), user.getId()}; assert this.getJdbcTemplate() != null; this.getJdbcTemplate().update(sql, args); } } jdbc.driverClass=com.mysql.cj.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql://localhost:3306/所使用的库名 jdbc.user=账号 jdbc.password=密码 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 加载配置文件 --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- 创建数据源 --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- 配置 dao，JdbcDaoSupport 通过给定的数据源自动创建模板。 --> &lt;bean id=\"userDao\" class=\"com.kuukokawaii.jdbctemplate.user.dao.UserDao\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;/beans> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（五）：AOP","date":"2019-09-02T05:52:48.000Z","path":"posts/43723/","text":"什么是 AOPAOP 是 OOP（Object Oriented Programming，缩写为OOP）的延续，利用 AOP 可以对业务逻辑的各个部件进行隔离，从而使得业务逻辑之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 假设有一需求如下：为 A 类中的所有方法开启事务且不修改 A 类的代码。为此需要再编写一个 B 类继承 A 类并且 B 类的所有方法都要调用 A 类的方法，且在调用方法的上下对事务进行开启和提交，这样做会发现一直在重复的编写开启提交事务的代码。而 AOP 采取横向抽取机制，取代了传统的纵向继承体系重复性代码，也就是说可以提取上述代码中的重复部分达到重复利用的效果。 手动代理JDK 动态代理JDK 动态代理即对装饰器设计模式的简化。 案例说明： 目标类：需要被代理的类，JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。 切面类：用于存放通知 MyAspect。 工厂类：用于生成代理。 代码演示：/** * @Author 喵粮都输光了 * @Date 2019/9/2 15:44 * @Description UserService 接口类。 */ public interface UserService { /** * 增加用户 */ void addUser(); /** * 更新用户 */ void updateUser(); /** * 删除用户 */ void deleteUser(); } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:46 * @Description UserService 实现类。 */ public class UserServiceImpl implements UserService { @Override public void addUser() { System.out.println(\"增加用户\"); } @Override public void updateUser() { System.out.println(\"更新用户\"); } @Override public void deleteUser() { System.out.println(\"删除用户\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ public class MyAspect { /** * 代理目标方法前运行。 */ public void before() { System.out.println(\"方法运行前\"); } /** * 代理目标方法后运行。 */ public void after() { System.out.println(\"方法运行后\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:49 * @Description 工厂类，用于生成代理类。 */ class MyBeanFactory { /** * 生成代理过的 UserService 对象。 * * @return 返回代理生成的 UserService 对象。 */ static UserService createProxy() { // 目标类 UserService userService = new UserServiceImpl(); // 切面类 MyAspect myAspect = new MyAspect(); /* * 代理类 = 目标类 + 切面类 * newProxyInstance参数： * 1.loader：类加载器，动态代理类运行时创建，任何类都需要类加载器将其加载到内存。一般情况使用→当前类.class.getClassLoader()。 * 2.Class[] interfaces：代理类需要实现的所有接口。 * 方式1：目标类实例.getClass().getInterfaces。该方法只能获得自己的接口，无法获得父元素的接口。 * 方式2：new Class[]{UserService.class}。该方法可以获得自己和父元素的接口。 * 3.InvocationHandler：处理类，是一个接口，必须进行实现，一般采用匿名内部类（推荐使用 lambda)。其中代理类的每一个方法执行时，都将调用一次 invoke。 * invoke参数:1.proxy： 代理对象。 * 2.method： 代理对象当前执行的方法的描述对象（反射）。 * 执行方法名：method.getName()； * 执行方法：method.invoke(对象，实际参数）； * 3.Object[] args： 方法实际参数。 */ return (UserService) Proxy.newProxyInstance(MyBeanFactory.class.getClassLoader(), userService.getClass().getInterfaces(), (proxy, method, args) -> { // 前执行 myAspect.before(); // 执行目标类的方法 Object obj = method.invoke(userService, args); // 后执行 myAspect.after(); return obj; }); } } /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { @Test public void test() throws Exception { UserService userService = MyBeanFactory.createProxy(); userService.addUser(); userService.updateUser(); userService.deleteUser(); } } 输出结果如下： CGLIB 字节码增强CGLIB 代理主要通过对字节码进行操作以控制对象的访问。CGLIB 在运行时创建目标类的子类，从而对目标类进行增强，因此无需接口便可以实现代理。 案例说明： 目标类：需要被代理的类，而 JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。 切面类：用于存放通知 MyAspect。 工厂类：用于生成代理。 使用到的 Jar 包： cglib.jar 或 spring-core.jar（Spring 核心包中整合了 cglib）。 代码演示：/** * @Author 喵粮都输光了 * @Date 2019/9/2 15:46 * @Description UserService 类。 */ class UserService { void addUser() { System.out.println(\"增加用户\"); } void updateUser() { System.out.println(\"更新用户\"); } void deleteUser() { System.out.println(\"删除用户\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:49 * @Description 工厂类，用于生成代理类。 */ class MyBeanFactory { /** * 生成代理后的 UserService 对象。 * * @return 返回代理生成的 UserService 对象。 */ static UserService createProxy() { // 目标类 UserService userService = new UserService(); // 切面类 MyAspect myAspect = new MyAspect(); /* * 代理类 = 目标类 + 切面类 * 1.创建核心类 Enhancer。 * 2.设置 Enhancer 需要代理的目标类。 * 3.设置 Enhancer 的回调函数。MethodInterceptor等效 InvocationHandler。 * o:代理对象。 * method:代理对象当前执行的方法的描述对象（反射）。 * objects:方法实际参数。 * methodProxy:方法的代理。 * 4.创建代理。 */ Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(userService.getClass()); enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -> { // 前执行 myAspect.before(); // 执行目标类的方法。该句等效于 methodProxy.invokeSuper(o, objects)。执行代理类的父类，执行目标类（目标类和代理类父子关系）。 Object obj = method.invoke(userService, objects); // 后执行 myAspect.after(); return obj; }); return (UserService) enhancer.create(); } } Spring AOP 代理Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强代码。半自动需要手动再 Spring 配置文件中配置代理。 案例说明： 目标类：需要被代理的类，JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。（此处代码与JDK 动态代理代码同） 切面类：用于存放通知 MyAspect。 工厂类：工厂类由 Spring 容器管理（配置文件配置）。 使用到的部分 Jar 包： spring-aop.jar（AOP 的实现） aopalliance.jar（AOP 联盟的规范） 代码演示：/** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ public class MyAspect implements MethodInterceptor { @Override public Object invoke(MethodInvocation invocation) throws Throwable { // 代理目标方法前运行 System.out.println(\"方法运行前\"); // 手动执行目标方法 Object obj = invocation.proceed(); // 代理目标方法后运行。 System.out.println(\"方法运行后\"); return obj; } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 目标类 --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.aop.UserServiceImpl\"/> &lt;!-- 切面类 --> &lt;bean id=\"myAspect\" class=\"com.kuukokawaii.aop.MyAspect\"/> &lt;!-- 代理类：使用工厂 bean，底层调用 getObject()，返回特殊 bean。 ProxyFactoryBean：用于创建代理工厂 bean，生成特殊代理对象。 interfaces：确定接口类。 通过&lt;array>可以设置多个值，单值可以仅使用&lt;value>。 target：确定目标类。 interceptorNames：通知切面类的名称，类型 String[]。 optimize：boolean true 意思为强制使用 cglib（无论有无接口）。（如果有接口默认使用 jdk 动态代理，没有则使用 cglib 字节码增强） --> &lt;bean id=\"proxyUserService\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"> &lt;property name=\"interfaces\" value=\"com.kuukokawaii.aop.UserService\"/> &lt;property name=\"target\" ref=\"userService\"/> &lt;property name=\"interceptorNames\" value=\"myAspect\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { /** * Method: addUser() */ @Test public void test() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); // 获取代理类 UserService userService = applicationContext.getBean(\"proxyUserService\", UserService.class); userService.addUser(); userService.updateUser(); userService.deleteUser(); } } 全自动在配置文件中标识所使用到的类，Spring 自动配置代理。 案例说明： 目标类：需要被代理的类，JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。（此处代码与半自动代码同） 切面类：用于存放通知 MyAspect。（此处代码与半自动代码同） 工厂类：工厂类又 Spring 容器管理（配置文件配置）。 使用到的部分 Jar 包： spring-aop.jar（AOP 的实现） aopalliance.jar（AOP 联盟的规范） aspectjweaver.jar（Spring 切入点表达式的实现） 代码演示：&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 目标类 --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.aop.UserServiceImpl\"/> &lt;!-- 切面类 --> &lt;bean id=\"myAspect\" class=\"com.kuukokawaii.aop.MyAspect\"/> &lt;!-- AOP编程： 1.导入命名空间。 2.使用&lt;aop:config>进行配置。proxy-target-class=\"true\"，true：cglib；false：jdk动态代理 &lt;aop:pointcut>：切入点，从目标对象获得具体方法。 切入点表达式：execution(* com.kuukokawaii.aop.*.*(..))：修饰符(可省略) 返回值 包(可省略).类(可省略).方法(参数) throws(可省略)；expression=\"execution()||execution()\" 可匹配多个。 within：匹配包或子包中的方法。 this：匹配实现接口的代理对象中的方法。 target：匹配实现接口的目标对象中的方法。 args：匹配参数格式符合标准的方法。 bean：匹配指定 bean 中的方法。 &lt;aop:advisor>：特殊切面，包含一个通知和切入点。 advice-ref：通知引用， pointcut-ref：切入点引用。 --> &lt;aop:config> &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.kuukokawaii.aop.*.*(..))\"/> &lt;aop:advisor advice-ref=\"myAspect\" pointcut-ref=\"myPointcut\"/> &lt;/aop:config> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { /** * Method: addUser() */ @Test public void test() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); // 获取目标类 UserService userService = applicationContext.getBean(\"userService\", UserService.class); userService.addUser(); userService.updateUser(); userService.deleteUser(); } } AspectJAspectJ 是一个基于 Java 语言的 AOP 框架，它扩展了 Java 语言并提供了一个专门的编译器，在编译时提供横向代码的植入。Spring AOP 引入了对 AspectJ 的支持。 案例说明： 目标类：采用接口 + 实现类的方法。（此处代码与全自动代码同） 切面类：编写多个通知，采用 AspectJ 通知名称任意（方法名任意）。 使用到的部分 Jar 包： spring-aop.jar（AOP 的实现） aopalliance.jar（AOP 联盟的规范） aspectjweaver.jar（Spring 切入点表达式的实现） spring-aspects.jar（提供对 AspectJ 的支持） 代码演示： 基于 XML 配置/** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ public class MyAspect { /** * 前置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ void myBefore(JoinPoint joinPoint) { System.out.println(\"前置通知。\" + joinPoint.getSignature().getName()); } /** * 后置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 * @param returning 用于获取返回值。 */ void myAfterReturning(JoinPoint joinPoint, Object returning) { System.out.println(\"后置通知。\" + joinPoint.getSignature().getName() + \"，返回值：\" + returning); } /** * 环绕通知。 * * @param proceedingJoinPoint 连接点 * @return 返回目标方法。 * @throws Throwable 方法执行异常。 */ Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // 前 System.out.println(\"环绕前\"); // 手动执行目标方法。 Object obj = proceedingJoinPoint.proceed(); // 后 System.out.println(\"环绕后\"); return obj; } /** * 抛出异常通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ void myAfterThrowing(JoinPoint joinPoint, Throwable throwable) { System.out.println(\"抛出异常通知。\" + throwable.getMessage()); } /** * 最终通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ void myAfter(JoinPoint joinPoint) { System.out.println(\"最终通知。\" + joinPoint.getSignature().getName()); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 目标类 --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.aop.UserServiceImpl\"/> &lt;!-- 切面类 --> &lt;bean id=\"myAspect\" class=\"com.kuukokawaii.aop.MyAspect\"/> &lt;!-- aop编程： &lt;aop:aspect>：将切面类声明成“切面”，从而获得通知（方法）。 ref：引用切面类。 &lt;aop:pointcut>：声明一个切入点，所有的通知都可以使用。 expression：切入点表达式。 id：用于其他通知使用。 &lt;aop:before>: 前置通知，目标方法前执行。 method：通知及方法名。 pointcut：切入点表达式，此表达式只能当前通知使用。 pointcut-ref：切入点的引用，可以与其他通知共享切入点。 &lt;aop:after-returning>：后置通知，目标方法后执行，可获得返回值。 returning：类型 Object, 用于获取返回值，需要与方法中的参数名相对应。类型 Object。 &lt;aop:around>：环绕通知。前置通知优先环绕通知执行。 &lt;aop:after-throwing>：抛出异常通知。抛出异常之后的语句不再执行。 throwing：用于获取异常信息，需要与方法中的参数名相对应。类型 Throwable。 &lt;aop:after>：最终通知。相当于 try/catch 中的 finally，抛出异常也会执行。方法执行后执行，优先级高于环绕（后）通知 --> &lt;aop:config> &lt;aop:aspect ref=\"myAspect\"> &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.kuukokawaii.aop.*.*(..))\"/> &lt;aop:before method=\"myBefore\" pointcut-ref=\"myPointcut\"/> &lt;aop:after-returning method=\"myAfterReturning\" pointcut-ref=\"myPointcut\" returning=\"returning\"/> &lt;aop:around method=\"myAround\" pointcut-ref=\"myPointcut\"/> &lt;aop:after-throwing method=\"myAfterThrowing\" pointcut-ref=\"myPointcut\" throwing=\"throwable\"/> &lt;aop:after method=\"myAfter\" pointcut-ref=\"myPointcut\"/> &lt;/aop:aspect> &lt;/aop:config> &lt;/beans> 基于注解配置UserServiceImpl 类需要加上 @Service 注解。@Aspect 用于声明切面类。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.aop\"/> &lt;!-- aop 注解扫描，自动代理 --> &lt;aop:aspectj-autoproxy/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ @Component @Aspect public class MyAspect { /** * 声明公共切入点 */ @Pointcut(\"execution(* com.kuukokawaii.aop.UserServiceImpl.*(..))\") private void myPointcut() { } /** * 前置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ @Before(\"myPointcut()\") void myBefore(JoinPoint joinPoint) { System.out.println(\"前置通知。\" + joinPoint.getSignature().getName()); } /** * 后置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 * @param returning 用于获取返回值。 */ @AfterReturning(value = \"myPointcut()\", returning = \"returning\") void myAfterReturning(JoinPoint joinPoint, Object returning) { System.out.println(\"后置通知。\" + joinPoint.getSignature().getName() + \"，返回值：\" + returning); } /** * 环绕通知。 * * @param proceedingJoinPoint 连接点 * @return 返回目标方法。 * @throws Throwable 方法执行异常。 */ @Around(\"myPointcut()\") Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // 前 System.out.println(\"环绕前\"); // 手动执行目标方法。 Object obj = proceedingJoinPoint.proceed(); // 后 System.out.println(\"环绕后\"); return obj; } /** * 抛出异常通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ @AfterThrowing(value = \"myPointcut()\", throwing = \"throwable\") void myAfterThrowing(JoinPoint joinPoint, Throwable throwable) { System.out.println(\"抛出异常通知。\" + throwable.getMessage()); } /** * 最终通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ @After(\"myPointcut()\") void myAfter(JoinPoint joinPoint) { System.out.println(\"最终通知。\" + joinPoint.getSignature().getName()); } } /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class UserServiceImplTest { @Autowired private UserService userService; /** * Method: addUser() */ @Test public void test() throws Exception { userService.addUser(); userService.updateUser(); userService.deleteUser(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（四）：bean 装配","date":"2019-09-01T05:36:41.000Z","path":"posts/4364/","text":"实例化方式bean 有3种实例化的方式：默认构造、静态工厂和实例化工厂。 默认构造通过&lt;bean id=\"\" class=\"要装配的实现类全限定类名\" /&gt;的方式装配 bean 便是自动使用了默认构造。 静态工厂静态工厂用于生成实例对象，且所有的方法必须是静态的。常用于 Spring 整合其他框架（工具）。通过&lt;bean id=\"\" class=\"要整合的工厂实现类全限定类名\" factory-method=\"静态方法名\" /&gt;进行 bean 的装配。代码演示如下： /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:07 * @Description StaticFactoryService 接口类 */ public interface StaticFactoryService { /** * 测试输出语句 */ void test(); } /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:07 * @Description StaticFactoryService 实现类 */ public class StaticFactoryServiceImpl implements StaticFactoryService { @Override public void test() { System.out.println(\"静态工厂输出成功。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:08 * @Description 自定义 bean 静态工厂 */ public class MyStaticBeanFactory { /** * 创建 StaticFactoryService 实例。 * @return 返回 StaticFactoryService 实例对象。 */ public static StaticFactoryService createService(){ return new StaticFactoryServiceImpl(); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 将静态工厂创建的实例交予 Spring 管理。 class：输入静态工厂的全限定类名。 factory-method：输入需要获取的静态工厂中所存在的静态方法名。 --> &lt;bean id=\"staticFactoryService\" class=\"com.kuukokawaii.di.MyStaticBeanFactory\" factory-method=\"createService\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/01/2019 * @Description StaticFactoryServiceImpl test */ public class StaticFactoryServiceImplTest { /** * Method: test() */ @Test public void testTest() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 StaticFactoryService staticFactoryService = applicationContext.getBean(\"staticFactoryService\", StaticFactoryService.class); staticFactoryService.test(); } } 实例化工厂实例化工厂通过工厂实例对象创建对象，且所有的方法都是非静态的。代码演示如下： 此处代码与上述静态工厂共用 StaticFactoryService 、 StaticFactoryServiceImpl 和 测试类。 /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:08 * @Description 自定义 bean 实例工厂 */ public class MyBeanFactory { /** * 创建 StaticFactoryService 实例。 * @return 返回 StaticFactoryService 实例对象。 */ public StaticFactoryService createService(){ return new StaticFactoryServiceImpl(); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 1.将自定义实例工厂交予 Spring 管理。 class：输入实例工厂的全限定类名。 2.通过实例工厂配置 bean。 factory-bean：配置好的实例工厂的 bean 的 id。 factory-method：输入需要获取的实例工厂中所存在的方法名。 --> &lt;bean id=\"myBeanFactory\" class=\"com.kuukokawaii.di.MyBeanFactory\"/> &lt;bean id=\"staticFactoryService\" factory-bean=\"myBeanFactory\" factory-method=\"createService\"/> &lt;/beans> 作用域Spring 的作用域用于确定创建的 bean 的实例个数。通过 XML 配置 bean 时，添加scope属性进行配置（如&lt;bean id=\"\" class=\"\" scope=\"\" /&gt;）。常用的scope属性有singleton（单例）和prototype（多例）。 生命周期可以将 bean 的生命周期划分为11个部分，具体如下图所示：图中各部分效用如下： Instantiate：初始化 bean，调用构造函数创建实例。 Populate properties：封装属性，即进行 DI 操作。 BeanNameAware's setBeanName()：调用 BeanNameAware 接口的 setBeanName 方法获取 BeanName。 BeanFactoryAware's setBeanFactory()：调用 BeanFactoryAware 接口的 setBeanFactory 方法获取 BeanFactory。 Pre-initialization BeanPostProcessors：如果存在类实现 BeanPostProcessor,则执行 postProcessBeforeInitialization 方法进行预处理。 InitializingBean's afterPropertiesSet()：如果 bean 实现 InitializingBean，则执行 afterPropertiesSet 方法。 Call custom init-method：调用自定义的 init-method 方法。 Post-initialization BeanPostProcessors：如果存在类实现 BeanPostProcessor,执行 postProcessAfterInitialization 方法进行后处理。 Bean is ready to use / Container is Shutdown：执行业务处理。 DisposableBean's destroy()：如果 bean 实现 DisposableBean，则执行 destroy 方法。 Call custom destroy-method：调用自定义的 destroy-method。 bean 生命周期常用操作： 初始化和摧毁如果需要进行初始化或摧毁的操作，可以通过使用init-method和destroy-method属性进行设置，其中destroy-method 只有在 scope=singleton 的时候才会生效。（如&lt;bean id=\"\" class=\"\" init-method=\"\" destory-method=\"\"/&gt;）。 1.在 beans 标签下的default-init-method可以设置所有默认的属性。2.优先级：InitializationBean 和 DisposableBean &gt; init-method 和 destroy-method &gt; default。 后处理在 Spring 中实现 BeanPostProcessor 接口，并将实现类提供给 Spring 容器，Spring 容器就会自动的执行该实现类。在初始化方法前执行 before()，在初始化方法后执行 after()。代码演示如下：/** * @Author 喵粮都输光了 * @Date 2019/9/1 16:13 * @Description 后处理 bean 实现类 */ public class MyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"初始化前\"); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"初始化后\"); return bean; } } /** * @Author 喵粮都输光了 * @Date 2019/9/1 16:16 * @Description BeanPostProcessorService 接口类 */ public interface BeanPostProcessorService { /** * 测试输出语句 */ void test(); } /** * @Author 喵粮都输光了 * @Date 2019/9/1 16:16 * @Description BeanPostProcessorService 实现类 */ public class BeanPostProcessorServiceImpl implements BeanPostProcessorService { @Override public void test() { System.out.println(\"测试方法内容。\"); } public void init() { System.out.println(\"初始化\"); } public void destroy(){ System.out.println(\"摧毁\"); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"beanPostProcessorService\" class=\"com.kuukokawaii.di.BeanPostProcessorServiceImpl\" init-method=\"init\" destroy-method=\"destroy\"/> &lt;bean class=\"com.kuukokawaii.di.MyBeanPostProcessor\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/01/2019 * @Description BeanPostProcessorServiceImpl test */ public class BeanPostProcessorServiceImplTest { /** * Method: test() */ @Test public void testTest() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 BeanPostProcessorService beanPostProcessorService = applicationContext.getBean(\"beanPostProcessorService\", BeanPostProcessorService.class); beanPostProcessorService.test(); applicationContext.close(); } } 输出结果如下： 属性依赖注入setter 方法关键代码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- setter 方法注入： &lt;bean id=\"\" class=\"\"> // 普通数据： &lt;property name=\"\" value=\"值\"/> // 引用数据： &lt;property name=\"\" ref=\"另一个 bean\"/> &lt;/bean> --> &lt;bean id=\"person\" class=\"com.kuukokawaii.setter.Person\"> &lt;property name=\"name\" value=\"老大\"/> &lt;property name=\"address\" ref=\"address\"/> &lt;/bean> &lt;bean id=\"address\" class=\"com.kuukokawaii.setter.Address\"> &lt;property name=\"companyAddress\" value=\"学校地址\"/> &lt;property name=\"homeAddress\" value=\"家庭地址\"/> &lt;/bean> &lt;/beans> P 命名空间对 setter 方法注入进行简化，替换&lt;property name=\"属性名\"/&gt;为&lt;bean p:属性名=\"值\" p:属性名-ref=\"引用值\"。P 命名空间需要在 xml 头部增加xmlns:p=\"http://www.springframework.org/schema/p\"。关键代码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"person\" class=\"com.kuukokawaii.setter.Person\" p:name=\"老大\" p:address-ref=\"address\"/> &lt;bean id=\"address\" class=\"com.kuukokawaii.setter.Address\" p:companyAddress=\"学校地址\" p:homeAddress=\"家庭地址\"/> &lt;/beans> SpEL对&lt;property&gt;进行统一编程，所有内容都使用value（如`&lt;property name=”” value=”#{表达式}”。表达式详情参考：Spring Expression Language 集合注入集合的注入就是给&lt;property&gt;添加子标签。数组使用&lt;array&gt;、List 使用&lt;list&gt;、Set 使用&lt;set&gt;、Map 使用&lt;map&gt;、Properties使用&lt;props&gt;。其中 Map 和 Properties 存放键值对时分别需要使用&lt;entry&gt;和&lt;prop&gt;描述。关键代码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"collData\" class=\"com.kuukokawaii.setter.CollData\"> &lt;property name=\"arrayData\"> &lt;array> &lt;value>array1&lt;/value> &lt;value>array2&lt;/value> &lt;/array> &lt;/property> &lt;property name=\"listData\"> &lt;list> &lt;value>list1&lt;/value> &lt;value>list2&lt;/value> &lt;/list> &lt;/property> &lt;property name=\"setData\"> &lt;set> &lt;value>set1&lt;/value> &lt;value>set2&lt;/value> &lt;/set> &lt;/property> &lt;property name=\"mapData\"> &lt;map> &lt;entry key=\"mk1\" value=\"mv1\"/> &lt;entry key=\"mk2\" value=\"mv2\"/> &lt;/map> &lt;/property> &lt;property name=\"propsData\"> &lt;props> &lt;prop key=\"pk1\">pv1&lt;/prop> &lt;prop key=\"pk2\">pv2&lt;/prop> &lt;/props> &lt;/property> &lt;/bean> &lt;/beans> 基于注解配置 注解就是一个使用了@注解名称的类，比 XML 使用起来更方便。使用注解前需要配置 Spring 包扫描，扫描含有注解的类。 在 web 开发中，常用3个 @Component 注解衍生注解 @Repository：用于 Dao 层。 @Service：用于 Service 层。 @Controller：用于 Web 层。 依赖注入（可以给私有字段设置，也可以给 setter 方法设置。） 普通值：@Value(“需要设置的值”) 引用值： 按照类型注入：@Autowired。 按照名称注入1：@Autowired 和 @Qualifier(“名称”)联合使用。 按照名称注入2：@Resource(“名称”)。 生命周期初始化：@PostConstruct销毁：@PreDestroy 作用域：@Scope(“属性”) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（三）：DI","date":"2019-08-30T13:07:35.000Z","path":"posts/639/","text":"什么是 DI在依赖注入中，如果对象 A 中使用到对象 B，则称对象 A 依赖于对象 B；而当你创建对象 A 时，由于对象 A 依赖于对象 B 需要额外创建一个对象 B，并调用对象 A 的 set 方法进行对象 B 的实例设置，这便称为注入。 案例说明 创建 BookService 接口和实现类。 创建 BookDao 接口和实现类。 通过依赖注入获得 dao 和 service。 通过 xml 配置的方式。 通过注解的方式。 使用到的 Jar 包 spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar commons-logging.jar junit.jar spring-test.jar 代码演示/** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookDao 接口类 */ public interface BookDao { /** * 增加书本 */ void insertBook(); } /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:21 * @Description BookDao 实现类 */ public class BookDaoImpl implements BookDao { @Override public void insertBook() { System.out.println(\"书本添加成功。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookService 接口类 */ public interface BookService { /** * 增加书本 */ void addBook(); } /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookService 实现类 */ public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDaoImpl bookDao) { this.bookDao = bookDao; } @Override public void addBook() { bookDao.insertBook(); } } XML 文件配置方式从 Spring 容器中获得实例对象。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 以下配置其实就执行了三个步骤： 1.BookService bookService = new BookServiceImpl(); 2.BookDao bookDao = new BookDaoImpl(); 3.bookService.setBookDao(bookDao); 其中&lt;property name=\"\" ref=\"\"/>就相当于上述的 set 方法。 --> &lt;bean id=\"bookService\" class=\"com.kuukokawaii.di.BookServiceImpl\"> &lt;property name=\"bookDao\" ref=\"bookDao\"/> &lt;/bean> &lt;bean id=\"bookDao\" class=\"com.kuukokawaii.di.BookDaoImpl\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 08/30/2019 * @Description BookServiceImpl test */ public class BookServiceImplTest { /** * Method: addBook() */ @Test public void testAddBook() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 BookService bookService = (BookService) applicationContext.getBean(\"bookService\"); bookService.addBook(); } } 注解方式从 Spring 容器中获得实例对象。（需要在 BookServiceImpl 类加上 @Service 注解以及 BookDaoImpl 类加上 @Repository 注解，让包扫描能够扫描到。） 此处修改了 BookServiceImpl 类 和 XML 配置。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;context:component-scan base-package=\"com.kuukokawaii\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookService 实现类 */ @Service public class BookServiceImpl implements BookService { private final BookDao bookDao; @Autowired public BookServiceImpl(BookDao bookDao) { this.bookDao = bookDao; } @Override public void addBook() { bookDao.insertBook(); } } /** * @Author 喵粮都输光了 * @Date 08/30/2019 * @Description BookServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class BookServiceImplTest { @Autowired private BookService bookService; /** * Method: addBook() */ @Test public void testAddBook() throws Exception { bookService.addBook(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（二）：IoC","date":"2019-08-29T04:48:33.000Z","path":"posts/6802/","text":"什么是 IoCIoC 可以理解为借助于“第三方”实现对象之间的解耦。Spring IoC 通过使用 IoC 容器调控系统内所有的对象，使得对象之间没有了耦合关系，而 IoC 容器成为了整个项目的核心部分，当 IoC 容器失效时，所有对象彼此之间都会失去联系。 案例说明 创建 UserService 接口和实现类。 获得 UserService 实现类的实例。 通过 XML 文件配置的方式，从 Spring 容器中获得实例对象。 通过注解的方式从 Spring 容器中获得实例对象。 使用到的 Jar 包 spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar commons-logging.jar junit.jar spring-test.jar 代码演示/** * @Author 喵粮都输光了 * @Date 2019/8/29 18:05 * @Description UserService 接口类 */ public interface UserService { /** * 增加用户 */ void addUser(); } /** * @Author 喵粮都输光了 * @Date 2019/8/29 18:06 * @Description UserService 实现类 */ public class UserServiceImpl implements UserService { @Override public void addUser() { System.out.println(\"增加用户。\"); } } XML 文件配置方式从 Spring 容器中获得实例对象。（Spring配置文件常用 ApplicationContext 命名。） &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 需要配置的 bean --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.ioc.UserServiceImpl\" /> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 08/29/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { @Test public void testAddUser() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 UserService userService = (UserService) applicationContext.getBean(\"userService\"); userService.addUser(); } } 注解方式通过注解从 Spring 容器中获得实例对象。（需要在 UserServiceImpl 类加上 @Service 注解，让包扫描能够扫描到。） 需要注意的是用 spring 进行 Junit 测试时，需要引入 spring-test.jar，并在测试类上加入 @RunWith 和 @ContextConfiguration 的注解配置。如果还有错误可以尝试更新 Junit.jar 的版本。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 配置包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 08/29/2019 * @Description UserServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class UserServiceImplTest { @Autowired private UserService userService; /** * Method: addUser() */ @Test public void testAddUser() throws Exception { userService.addUser(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（一）：简介","date":"2019-08-28T07:07:50.000Z","path":"posts/14546/","text":"Spring 优点 方便解耦，简化开发可以将所有对象的创建和依赖关系的维护交给 Spring 管理。 AOP 编程的支持Spring 提供面向切面的编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 声明式事务的支持无需手动编程，只需要通过配置就可以完成对事物的管理。 方便程序的测试Spring 支持 Junit，可以通过注解方便的测试 Spring 程序。 方便集成各种优秀框架Spring 内部提供了对各种优秀框架（Struts、Hibernate、MyBatis、Quartz……）的直接支持。 降低 JavaEE API 的使用难度Spring 封装了 JavaEE 开发中一些非常难用的 API(JDBC、JavaMail、远程调用……)，降低了这些 API 的应用难度。 Spring 体系结构Spring 框架是一个分层架构，它将一系列的功能要素分为 Data Access/Integration，Web，AOP，Core Container，Instrumentation 和 Test 等几大模块。 Core Container Beans：用于管理 Bean。 Core：Spring 的核心，主要用于实现反向控制 IoC（Inversion of Control）与依赖注入 DI（Dependency Injection）、Bean 配置以及加载。 Context：上下文，相当于配置文件。 Expression Language：即 SpEL，是 Spring 的一种表达式，用来动态的获取值、对象等。 AOP AOP：切面编程（Aspect Oriented Programming）。 Aspects：一个切面编程的框架。 Data Access/Integration JDBC：用于链接数据库，向数据库发送 sql 语句。 ORM：对象关系映射，用于整合持久层框架（Mybatis，Hibernate……）。 OXM：即 O/X 映射器，用于将 Java 对象和 XML 文档之间进行互相转换。 JMS：即 Java消息服务，用于两个应用程序之间传送消息，进行异步通信。 Transactions：事务管理。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]}]