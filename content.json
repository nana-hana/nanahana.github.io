[{"title":"Java 容器","date":"2020-03-30T02:22:38.000Z","path":"posts/f431e3b/","text":"Collectionjava.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。当多个线程对同一个集合的内容进行操作时，可能会产生 Fail-Fast 异常，即在迭代过程中如果集合对象的结构发生变化例如添加或删除了一个元素或调整了集合的大小就会改变 modCount(用于记录结构发生变化的次数) 的值，此时会抛 ConcurrentModificationException 异常，此时使用线程安全的集合即可解决问题。 ListList 称为有序集合，允许包含重复元素。 ArrayList：基于动态数组实现，查找快，增删慢，线程不安全。如果要使用线程安全的 ArrayList 可以考虑使用 CopyOnWriteArrayList 类，该类的写操作在复制的数组中进行(需要加锁)，读操作则在原始数组中进行，当写操作完成时把原始数组指向新的数组，因为其实现了读写分离，所以很适合读多写少的应用场景，但是复制的数组多占用了一倍的存储空间，读操作也不能读取实时性的数据，因此不适合内存敏感以及实时性要求高的场景。 Vector：和 ArrayList 类似，尾音它是线程安全的，所以效率比 ArrayList 低。Stack 类继承拓展了 Vector 的操作。 LinkedList：基于双向链表实现，查找慢，增删快，线程不安全。而且可以用作栈、队列和双向队列。 查找多增删少用 ArrayList，反过来用 LinkedList，如果是多线程使用则使用 Vector。 Queue LinkedList：如果 Queue 使用 LinkedList 实现，可以使用它实现双向队列。 PriorityQueue：基于堆结构实现，可以用它实现优先队列(队头是最小元素)，不允许使用 null，其容量会自动增大减少始终保持和队列中拥有的元素一样大，但是它的线程是不安全的。 ConcurrentLinkedQueue：线程安全的队列，队头保存最长元素，队尾是最短元素，不允许使用 null。 SetSet 称为无序集合，不允许包含重复元素，最多只能拥有一个空元素。 TreeSet：基于红黑树实现，且实现了 SortedSet 接口，因此支持有序性操作(排序)，但线程是不安全的，其查找时间复杂度为O(logn)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作，不允许有相同值存在(会自动覆盖)，其线程是不安全的，查找时间复杂度为O(1)。 LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序即插入顺序是可预测的，但是线程是不安全的。 需要排序用 TreeSet， 否则 HashSet，如果不需要排序但是需要保持插入顺序则使用 LinkedHashSet。 MapMap 是一个接口，它是以键值对的形式进行存储的，且不能包含重复的键，每个键只能对应一个值。 TreeMap：基于红黑树实现，其线程是不安全的。 HashMap：基于采用了拉链法解决碰撞冲突的哈希表(数组+链表，链表超过一定值改用数组+红黑树，减少链表查询时间)实现，其线程是不安全的，允许使用 null 键值。 LinkedHashMap：使用双向链表来维护元素的插入顺序即插入顺序是可预测的，顺序为插入顺序或者最少使用(LRU)顺序，其线程是不安全的。 Hashtable 与 ConcurrentHashMap：和 HashMap 类似，但是它是线程安全的且不允许使用 null 键值。但是 Hashtable 是 Java 的一个遗留类，所以不应该去使用它，可以通过使用 ConcurrentHashMap 来支持线程安全，且 ConcurrentHashMap 引入了分段锁，因此效率很高，但同样不允许使用 null 键值。 WeakHashMap：和 HashMap 类似，其线程也是不安全的。WeakHashMap 具有弱键，当 WeakHashMap 中的键值对不再普通使用时会在下一次垃圾回收时自动被回收。常用于实现缓存，通过 WeakHashMap 来引用缓存对象，而 JVM 对这部分缓存进行回收。Tomcat 中的 ConcurrentCache 就使用了 WeakHashMap 来实现缓存，常用对象放入 eden 中不会被回收，不常用的对象放入 longterm(使用 WeakHashMap 实现) 中，longterm 中不用的对象会被回收，put 方法会优先添加 eden，若 eden 存储容量超过了将 eden 的所有对象存储在 longterm 中，而 get 方法会先从 eden 中读取若没找到则在 longterm 中寻找并将其放入 eden。 需要排序使用 TreeMap，否则 HashMap，如果不需要排序但是需要保持插入顺序则使用 LinkedHashMap。如果是多线程使用则使用 ConcurrentHashMap，不要使用 Hashtable。 utilArraysjava.util.Arrays 是一个工具类，主要包含了操纵数组的各种方法。常用的方法有如下： 常用方法 作用 Arrays.sort(Object[] array) 对数组进行升序排序。 Arrays.sort(Object[] array, int from, int to) 对数组元素指定范围进行排序，包头不包尾。 Arrays.fill(Object[] array, Object object) 为数组元素填充相同的值。 Arrays.fill(Object[] array, int from,int to, Object object) 对数组元素指定范围填充相同的值，包头不包尾。 Arrays.toString(Object[] array) 返回数组的字符串形式。 Arrays.deepToString(Object[][] arrays) 返回多维数组的字符串形式。 Collectionsjava.util.Collections 是一个工具类。它包含有各种有关集合操作的静态多态方法。常用的方法有如下： 常用方法 作用 shuffle(Collection) 洗牌即将当前集合内的数据进行随机排序。 reverse(Collection) 逆序排序即对当前集合的元素按照相反的顺序进行排序。 sort(Collection) 对当前集合进行升序排序。 binarySearch(Collection, Object o) 二分查找指定集合中的元素，返回所查找元素的索引。 replaceAll(List list, Object old, Object new) 替换指定元素为其它元素，若要替换的值存在则返回 true，否则返回 false。 copy(List m, List n) 将集合n中的元素全部复制到m中,并且覆盖相应索引的元素。 swap(List list, int i, int j) 交换集合中指定的元素。 fill(List list, Object o) 为数组元素填充相同的值。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://blog.kuukokawaii.com/tags/java/"}]},{"title":"Java 基础","date":"2020-03-29T02:37:16.000Z","path":"posts/a019e08c/","text":"数据类型基本数据类型 数据类型 位数 默认值 包装类 byte 8 0 Byte short 16 0 Short int 32 0 Integer long 64 0L Long float 32 0.0f Float double 64 0.0d Double char 16 ‘\\u0000’ Character boolean 8 false Boolean 包装类基本类型都有包装类型，对应的包装类型表参照上表，基本类型与其对应的包装类型之间的赋值使用自动装箱(Integer.valueof(num))与拆箱完成(x.intValue())。包装类都被声明为 final，所以都不能被继承。 缓存池Integer.valueOf() 方法会优先使用缓冲池中的对象，而 new Integer() 方法每次都会新建一个对象。但是也并不是说当Integer a = Integer.valueOf(num);Integer b = Integer.valueOf(num);时两者就一定相等。这里的缓冲池还有大小之分，若 num 在缓冲池大小内则会优先使用缓冲池中的 num 对象，否则会新建一个对象。例如 Integer 的缓冲池大小为 -128~127，所以当num超过这个大小时，a 不会等于 b。这里有一点特殊的是 Integer 的上界可以在启动 JVM 时通过输入参数-XX:AutoBoxCacheMax=&lt;size&gt;手动更改。 基本类型对应的缓冲池大小如下： boolean 为 true 或 false。 int、short 和 byte 在 -128~127 之间。 char 在 \\u0000 到 \\u007F 之间。 String不可变String 类被声明为 final，因此 String 类同样不可被继承。在 Java8 中 String 类通过private final char value[]存储数据，但是在 Java9 中 String 类的实现改用private final byte[] value存储数据，同时使用private final byte coder来标识使用了哪种编码。因为 String 类中的 value 数组都被声明为了 final，且内部没有改变 value 数组的方法，保证了 String 是不可变的。 String 不可变带来的好处： String 的 hash 值也不会改变，因此 String 只需计算一次 hash 值。 若有内容相等的的 String 可以从字符串常量池中直接获取(相当于缓冲区了)。 当多个线程调用 String 时也不会产生问题，是线程安全的。 String 作为参数传递时也可以保证参数不会被改变，安全性高。例如一个类使用了值为 “A” 的 String，该 String 的值被改变成 “B” 时，使用 String 的那个类仍然将这个 String 当作 “A”，但是改变 String 以及后来使用 String 的类都会将 String 当作 “B” 看待，会产生一系列的问题。 String、StringBuilder 和 StringBufferString 是不可变的；StringBuilder 和 StringBuffer 是可变的。 String 是线程安全的；StringBuilder 是线程不安全的；StringBuffer 通过使用 synchronized 进行同步，因此线程是安全的。 在 Java 中字符串的拼接默认使用的其实是 StringBuffer。 String Pool字符串常量池(String Pool)保存着所有字符串字面量(literal strings)，这些字面量在编译时期就确定。使用 String Pool 有两种方法： 直接使用双引号声明出来的 String 对象会直接存储在常量池中。 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串存入常量池中。 在 Java7 之前，String Pool 被放在运行时常量池中，属于永久代，但是因为其存储空间有限，在大量使用字符串的情况下会导致内存溢出错误，所以在 Java7 中，String Pool 被移到堆中。 new String()String s = new String(\"xxx\")的方法会在编译时创建”xxx”字符串字面量并将其保存在字符串常量池中(如果”xxx”不存在于常量池中的话)，然后 new String(“xxx”)会在堆中创建一个 String s 的对象，并赋值为”xxx”(从常量池中引用)。 运算隐式类型转换Java 不能隐式执行向下转型，因为这会造成精度降低。例如float f = 1.1，其中1.1是 double 型，占用64位，而 float 占用32位，将64位转换成32位会导致精度降低。但是如果使用算术运算符例如f += 1或f++之类的，Java 会自动执行隐式类型转换，相当于f = (short) (f + 1)，整体进行向下转型。 关键字final 数据：声明数据为常量，可以是编译时常量，也可以是运行时初始化后不能被改变的常量。对于基本类型，final 使数值不能改变；对于引用类型，final 使引用不能改变，但是被引用的对象本身可以修改。 方法：声明方法则该方法无法被子类重写。(private 方法隐式地被指定为 final) 类：声明类则该类无法被继承。 static 静态变量：又称为类变量，可以通过类名调用。与实例变量不同在于，实例变量每创建一个实例就会产生一个实例变量，实例摧毁则实例变量摧毁。 静态方法：类加载时静态方法就存在了，不需要依赖任何实例。静态方法不能是抽象方法，同样的不能使用 this 和 super 关键字。 静态语句块：类加载时静态语句块会执行一次。 静态内部类：非静态内部类依赖于外部类的实例，需要先创建外部类的实例才能用这个实例去创建非静态内部类，而静态内部类可以直接调用不用这么复杂。静态内部类不能访问外部类的非静态变量和方法。 静态导包：例如import java.lang.Math.*;调用方法为Math.sqrt(1);，使用静态导包import static java.lang.Math.*;调用方法为sqrt(1);。 初始化顺序：先静态(静态变量、静态语句块)，后普通(实例变量、普通语句块)，最后构造函数。例如父类(静态)→子类(静态)→父类(普通)→父类(构造函数)→子类(普通)→子类(构造函数)。 transient该关键字标记的成员变量不参与序列化过程。 Object 通用方法euqals()equals()即判断两个引用对象是否等价，其实现为： 如果传入对象为 null，返回 false； 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型(getClass())，如果不是，直接返回 false； 将 Object 对象进行转型，判断每个关键域是否相等。 hashCode()两个等价的对象其散列值一定相同，但是散列值相同的两个对象不一定等价，所以再覆写 equals() 方法时应当总是 hashCode() 方法。 理想的哈希函数应当具有均匀性即将不相等的对象均匀分布到所有可能的哈希值上。这就要求哈希函数对所有域的值都进行考虑，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。 R 一般取奇数，如果是偶数，当乘法溢出时最高位会丢失(乘2等于向左移动1位)。由于 Java 地址值的位数关系，R 一般取31。当31乘以 x 时编译器会自动优化为(x&lt;&lt;5) - x提升效率。 继承访问权限 作用域 当前类 同一包 子孙类 其他包 public √ √ √ √ protected √ √ √ × friendly(不加访问修饰符即默认) √ √ × × private √ × × × 需要注意的是默认权限和保护权限：默认权限同包不同类可以访问，不同包不同类不可以访问；保护权限同包不同类可以访问，不同包情况下子类可以访问。 子类如果要重写父类的方法，则子类中该方法的访问级别不能低于父类中该方法的访问级别，这是为了确保使用父类实例的时候可以用子类实例去代替，确保满足里氏替换原则。 抽象类抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类不能被实例化，只能被继承。 接口类接口类是抽象类的延申，解决了 Java 不能多继承的问题。接口类在 Java8 之前只能看成是一个完全抽象的类，它不能有任何的方法实现，但是从 Java8 开始，接口类通过关键字 default 也可以拥有默认的方法实现。 接口的字段必须是 static 和 final 类型的，且访问权限必须是 public。 super、重写和重载super 可以让子类访问父类的构造函数，或者调用父类的方法。 重写指子类实现了与父类在方法声明上完全相同的一个方法。需要注意如下三点： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 重载指同一个类中方法名相同，但是参数类型、参数个数或者参数顺序至少有一个不同的方法。若只有返回值不同，方法名、参数类型、参数个数和参数顺序都相同的方法不算重载。 反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载，通过Class c = 类名.class或Class = Class.forName(\"类名\")进行加载。 反射主要提供了如下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法 简单说就是反射可以动态地获取创建实例的类信息。通过反射获取所需实例的类信息可以极大程度地降低程序的耦合性。反射常用于调试器或测试工具获取私有成员等。虽然反射非常强大，但是其性能开销也大，反射涉及动态类型的解析，所以 JVM 无法对反射代码进行优化，因此反射操作的效率比非反射操作低很多。而且反射只能在一个没有安全限制的环境中运行。反射能够操作私有属性及方法，因此使用反射可能会导致意料之外的问题发生。通过以上种种可知，当一个功能可以不使用反射完成时最好就不使用。 Class 和 java.lang.reflect 都对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field：操作类的属性。 Method：操作类的方法。 Constructor：提供了一个类的单个构造函数的信息和访问权限。 异常所有异常类型都是内置类 Throwable 的子类，Throwable 有两个不同的分支，一个分支是 Error，它表示不希望被程序捕获或是程序无法处理的错误，例如 JVM 运行错误的栈溢出异常和内存溢出异常等；另一个分支是 Exception，而 Exception 又可以细分为不受检查异常(Unchecked Exception)和检查异常(Checked Exception)： 不受检查异常：运行时异常(Runtime Exception)是不受检查异常，在程序中可以选择捕获处理或者不处理，通常这些异常都是逻辑错误引起的，程序应该从逻辑角度尽量避免这类异常的发生，例如空指针异常，数组下标越界等。 受检查异常：Runtime Exception 以外的异常统称为非运行时异常，例如 I/O 异常、 SQL 异常以及用户自定义的异常(一般步自定义受检查异常)，这类异常必须进行处理，否则程序无法通过编译。 用户可以通过继承 Exception 或者其子类创建自定义异常类。 泛型在集合中存储对象并在使用前进行类型转换是非常的不方便的，所以 Java 提供了泛型防止了那种情况的发生。泛型提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出 ClassCastException。 泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List&lt;String&gt;在运行时仅用一个 List 来表示，这样做是为了和旧版本的 Java 进行兼容。 限定通配符和非限定通配符：限定通配符对类型进行了限制，限定通配符有两种，一种是&lt;? extends T&gt;它通过确保类型必须是 T 的子类来设定类型的上界，另一种是&lt;? super T&gt;它通过确保类型必须是 T 的父类来设定类型的下界；非限定通配符&lt;?&gt;表示可以用任意类型来替代。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。 注解Java 注解(Annotation)是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明和配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。注解和修饰符有些类似，应用于包、类型、构造方法、方法、成员变量、参数以及本地变量的声明语句中。例如@param、@override等，前者用于文档生成，后者用于编译时检测是否是覆盖了超类方法。 注解本质是一个继承了Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。通过反射获取注解可以获得动态代理对象，利用代理对象调用自定义注解(接口)的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法。该方法会从 memberValues 这个 map 中索引出对应的值。而 memberValues 的来源是Java 常量池。 java.lang.annotation 提供了四种元注解，专门注解其他的注解(在自定义注解的时候，需要使用到元注解)： @Documented – 注解是否将包含在 JavaDoc 中。 @Retention – 什么时候使用该注解。 RetentionPolicy.SOURCE : 在编译阶段丢弃，例如检测类注解@override等。 RetentionPolicy.CLASS : 在类加载的时候丢弃，在字节码文件的处理中有用，注解默认使用这种方式。 RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式。 @Target – 注解用于什么地方。 ElementType.CONSTRUCTOR: 用于描述构造器。 ElementType.FIELD: 成员变量、对象、属性(包括 enum 实例)。 ElementType.LOCAL_VARIABLE: 用于描述局部变量。 ElementType.METHOD: 用于描述方法。 ElementType.PACKAGE: 用于描述包。 ElementType.PARAMETER: 用于描述参数。 ElementType.TYPE: 用于描述类、接口(包括注解类型)或 enum 声明。 @Inherited – 是否允许子类继承该注解。 自定义注解： Annotation 型定义为@interface, 所有的 Annotation 会自动继承 java.lang.Annotation 这一接口,并且不能再去继承别的类或是接口。 参数成员只能用 public 或默认(friendly) 这两个访问权限修饰。 参数成员只能用基本类型 byte、short、char、int、long、float、double、boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组。 要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象。 注解也可以没有定义成员，不过这样注解就没啥用了。 例如： /** * @Author 喵粮都输光了 * @Date 2020/3/29 19:33 * @Description 动物注解 */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Animal { enum Color { /** * 动物颜色 */ DEFAULT(\"白色\"), RED(\"红色\"), BLACK(\"黑色\"); /** * 颜色 */ private String color; Color(String color) { this.color = color; } public String getColor() { return color; } } /** * 动物名称 * @return 动物名称 */ String name() default \"动物\"; Color color() default Color.DEFAULT; } /** * @Author 喵粮都输光了 * @Date 2020/3/29 19:52 * @Description 动物信息注解 */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface AnimalInfor { /** * 国家 * @return 国家 */ String country() default \"国家\"; /** * 价格 * @return 价格 */ double price() default 0.0; } /** * @Author 喵粮都输光了 * @Date 2020/3/29 20:11 * @Description 自定义注解测试 */ public class Main { public static void main(String[] args) throws Exception { Class&lt;?> dogClass = Dog.class; Dog dog = (Dog) dogClass.newInstance(); Field[] fields = dogClass.getDeclaredFields(); for (Field field : fields) { if (field.isAnnotationPresent(Animal.class)) { Animal animal = field.getAnnotation(Animal.class); dog.setName(animal.name()); dog.setColor(animal.color().getColor()); } else if (field.isAnnotationPresent(AnimalInfor.class)) { AnimalInfor animalInfor = field.getAnnotation(AnimalInfor.class); dog.setInfo(animalInfor.country() + animalInfor.price()); } } dog.print(); } } Java 特点 Java 是存粹的面向对象的语言。 Java 通过虚拟机从而实现跨平台特性。 Java 没有指针，它的引用可以理解为安全指针。 Java 支持自动垃圾回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的。 Java 不支持操作符重载(把已经定义的、有一定功能的操作符进行重新定义，来完成更为细致具体的运算等功能)。 Java 的 goto 是保留字，但是不可用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://blog.kuukokawaii.com/tags/java/"}]},{"title":"算法之字符串","date":"2020-03-28T02:17:33.000Z","path":"posts/45407bae/","text":"字符串排序键索引计数法假设将一个班级的学生分5组，按组进行排序。 /** * 学生数组长度，共多少人 */ int n = a.length; /** * 学生分成的组数 */ int r = 5; /** * 辅助数组，用于排序 */ String[] aux = new String[n]; /** * 索引表，例如第一组3人，第二组5人，则第一组从0开始索引，第二组从3开始索引 */ int[] count = new int[r + 1]; /** * 计算出现频率，即每组多少人，方法key()为获得学生的组号 */ for (int i = 0; i &lt; n; i++) { count[a[i].key() + 1]++; } /** * 将频率转化成索引，即第一组从下标哪开始到哪，第二组从下标哪开始到哪等 */ for (int i = 0; i &lt; r; i++) { count[r + 1] += count[r]; } /** * 将学生按组分类，例如第二组学生第一个从下标3开始存，存了之后索引表第二组索引自增一，下一个第二组学生就从下标4开始存等 */ for (int i = 0; i &lt; n; i++) { aux[count[a[i].key()]++] = a[i]; } /** * 将数据从辅助数组复制回原数组 */ for (int i = 0; i &lt; n; i++) { a[i] = aux[i]; } 低位优先字符串排序低位优先(Least Significant Digit first, LSD)的字符串排序算法能够稳定地将定长字符串排序。若字符串的长度为 n，那么从右向左以每个位置的字符作为键，用键索引计数法将字符串排序 n 遍即可获得有序字符串。只能适用于字符串长度相同的情况。可以用于基数排序。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 11:31 * @Description 低位优先字符串排序 */ public class Lsd { /** * 低位优先排序字符串 * @param a 等长字符串数组 * @param w 字符串长度 */ public static void sort(String[] a, int w) { int n = a.length; int r = 256; String[] aux = new String[n]; // 从右往左每个字符当键 for (int i = w - 1; i >= 0; i--) { // 索引表 int[] count = new int[r + 1]; // 计算出现频率 for (String s : a) { // 遍历所有字符串，计算第i位键频率 count[s.charAt(i) + 1]++; } // 将频率转换为索引 for (int j = 0; j &lt; r; j++) { count[j + 1] += count[j]; } // 将元素分类 for (String s : a) { aux[count[s.charAt(i)]++] = s; } // 回写 for (int j = 0; j &lt; n; j++) { a[j] = aux[j]; } } } public static void main(String[] args) { String[] s = {\"345\", \"678\", \"123\"}; Lsd.sort(s, 3); for (String s1 : s) { System.out.println(s1); } } } 高位优先字符串排序高位优先(Most Significant Digit First，MSD)的字符串排序算法与低位优先字符串相反，高位优先算法从左向右遍历所有字符，首先使用索引计数法将所有字符串按照首字母排序，然后再递归的将每个首字母(忽略首字母)所对应的子数组排序。高位优先算法支持不同长度的字符串排序，为了防止字符串越界，规定索引表频率为0时表示字符串的结尾，为1时表示第一个字符等等。可以用于基数排序。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 12:25 * @Description 高位优先字符串排序 */ public class Msd { /** * ASCII 基数 */ private static final int R = 256; /** * 小数组的切换阈值 */ private static final int M = 125; /** * 辅助数组，用于排序 */ private static String[] aux; /** * 获取字符串第index个字符 * @param s 字符串s * @param index 下标 * @return 存在返回字符，不存在返回-1 */ private static int charAt(String s, int index) { if (index &lt; s.length()) { return s.charAt(index); } else { return -1; } } /** * 高位优先排序 * @param a 字符串数组a */ public static void sort(String[] a) { int n = a.length; aux = new String[n]; sort(a, 0, n - 1, 0); } /** * 排序所给字符串数组中从lo下标到hi下标的字符串，字符串根据index排序 * @param a 字符串数组a * @param lo 字符串数组开始下标 * @param hi 字符串数组结束下标 * @param index 字符下标 */ private static void sort(String[] a, int lo, int hi, int index) { // 从左往右每个字符当键 if (hi &lt;= lo + M) { insertion(a, lo, hi, index); return; } // 索引表 int[] count = new int[R + 2]; // 计算出现频率 for (int i = lo; i &lt;= hi; i++) { count[charAt(a[i], index) + 2]++; } // 将频率转换为索引 for (int i = 0; i &lt; R + 1; i++) { count[i + 1] += count[i]; } // 将元素分类 for (int i = lo; i &lt;= hi; i++) { aux[count[charAt(a[i], index) + 1]++] = a[i]; } // 回写 for (int i = lo; i &lt;= hi; i++) { a[i] = aux[i - lo]; } // 递归的以每个字符为键进行排序 for (int i = 0; i &lt; R; i++) { sort(a, lo + count[i], lo + count[i + 1] - 1, index + 1); } } /** * 从第d个字符开始进行插入排序 * @param a 字符串数组a * @param lo 开始下标 * @param hi 结束下标 * @param d 第几个字符 */ private static void insertion(String[] a, int lo, int hi, int d) { for (int i = lo; i &lt;= hi; i++) { for (int j = i; j > lo &amp;&amp; less(a[j], a[j - 1], d); j--) { swap(a, j, j - 1); } } } /** * 交换两字符串在数组中的位置 * @param a 字符串数组a * @param i 字符串i * @param j 字符串j */ private static void swap(String[] a, int i, int j) { String temp = a[i]; a[i] = a[j]; a[j] = temp; } /** * 判断字符串v的第d个字符是否比字符串w的小 * @param v 字符串v * @param w 字符串w * @param d 第d个字符 * @return true or false */ private static boolean less(String v, String w, int d) { for (int i = d; i &lt; Math.min(v.length(), w.length()); i++) { if (v.charAt(i) &lt; w.charAt(i)) { // 字符串v的第i个字符比字符串w的第i个字符小 return true; } if (v.charAt(i) > w.charAt(i)) { // 字符串v的第i个字符比字符串w的第i个字符大 return false; } } // 两串d个字符相同，根据长短判断 return v.length() &lt; w.length(); } public static void main(String[] args) { String[] s = {\"345465456\", \"678\", \"1239\"}; Msd.sort(s); for (String s1 : s) { System.out.println(s1); } } } 三向字符串快速排序三项字符串快速排序和三向快速排序类似，将字符串分成三部分进行排序。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 13:36 * @Description 三向字符串快速排序 */ public class Quick3String { /** * 获取字符串第index个字符 * @param s 字符串s * @param index 下标 * @return 存在返回字符，不存在返回-1 */ private static int charAt(String s, int index) { if (index &lt; s.length()) { return s.charAt(index); } else { return -1; } } /** * 三向字符串快速排序 * @param a 字符串数组a */ public static void sort(String[] a) { sort(a, 0, a.length - 1, 0); } /** * 排序所给字符串数组中从lo下标到hi下标的字符串，字符串根据index排序 * @param a 字符串数组a * @param lo 字符串数组开始下标 * @param hi 字符串数组结束下标 * @param index 字符下标 */ private static void sort(String[] a, int lo, int hi, int index) { if (hi &lt;= lo) { return; } int lt = lo, gt = hi; int letter = charAt(a[lo], index); int i = lo + 1; while (i &lt;= gt) { int t = charAt(a[i], index); if (t &lt; letter) { swap(a, lt++, i++); } else if (t > letter) { swap(a, i, gt--); } else { i++; } } // 首字母小于切分字符 sort(a, lo, lt - 1, index); if (letter >= 0) { // 等于 sort(a, lt, gt, index + 1); } // 大于 sort(a, gt + 1, hi, index); } /** * 交换两字符串在数组中的位置 * @param a 字符串数组a * @param i 字符串i * @param j 字符串j */ private static void swap(String[] a, int i, int j) { String temp = a[i]; a[i] = a[j]; a[j] = temp; } } 单词查找R 向单词查找树树的结点由字符串键中的所有字符构成，允许使用被查找键中的字符进行查找。根结点不包含任何字符，单词查找树查找可能终止于一个内部节点，即不一定总是到叶子结点。适用于较短的键和较小的字母表。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 14:00 * @Description 单词查找树 */ public class TrieSt&lt;Value> { /** * ASCII 基数 */ private static int R = 256; /** * 根结点 */ private Node root; private static class Node { /** * 该结点包含的字符 */ private Object val; /** * 该结点的子结点们 */ private Node[] nexts = new Node[R]; } /** * 根据单词(键)获得该单词对应结点种保存的值。 * @param key 键 * @return 值 */ public Value get(String key) { Node node = get(root, key, 0); if (node == null) { return null; } return (Value) node.val; } /** * 查找第d个字符对应的子单词查找树 * @param root 根结点 * @param key 单词(键) * @param d 第d个字符 * @return 子单词查找树的结点 */ private Node get(Node root, String key, int d) { if (root == null) { return null; } // 如果第d个字符和单词长度一样长，返回该结点 if (d == key.length()) { return root; } char letter = key.charAt(d); // 找到第d个字符对应的子树，并使d+1查找单词的下一个字符 return get(root.nexts[letter], key, d + 1); } /** * 向单词树中存单词 * @param key 单词(键) * @param value 值 */ public void put(String key, Value value) { // 确保根结点为空 root = put(root, key, value, 0); } /** * 根据所给键、值和当前字符存单词 * @param root 当前结点 * @param key 键 * @param value 值 * @param d 第d个字符 * @return 返回根结点 */ private Node put(Node root, String key, Value value, int d) { if (root == null) { root = new Node(); } // 如果第d个字符和单词长度一样长，该结点存value并返回该结点 if (d == key.length()) { root.val = value; return root; } char letter = key.charAt(d); root.nexts[letter] = put(root.nexts[letter], key, value, d + 1); return root; } public static void main(String[] args) { TrieSt&lt;Integer> st = new TrieSt&lt;>(); st.put(\"apple\", 1); st.put(\"app\", 2); System.out.println(st.get(\"app\") + \":\" + st.get(\"apple\")); } /** * 删除单词 * @param key 键 */ public void delete(String key) { root = delete(root, key, 0); } /** * 根据所给结点，键和当前字符删除单词 * @param root 当前结点 * @param key 键 * @param d 第d个字符 * @return 返回根结点 */ private Node delete(Node root, String key, int d) { if (root == null) { return null; } if (d == key.length()) { // 如果找到最后一个字符将其值置为空 root.val = null; } else { // 否则一直寻找该单词最后一个字符 char letter = key.charAt(d); root.nexts[letter] = delete(root.nexts[letter], key, d + 1); } // 如过当前结点的值不为空，直接返回该结点 if (root.val != null) { return root; } // 遍历当前结点的所有连接，如果连接都为空，返回null即删除该结点，否则直接返回当前结点 for (char letter = 0; letter &lt; R; letter++) { if (root.nexts[letter] != null) { return root; } } return null; } } 三向单词查找树单词查找树每个结点包含 r 个子结点，为了避免 r 过度的浪费空间，可以使用三向单词查找树。三向单词查找树每个结点含有一个字符，三条链接和一个值，着三条连接分别对应着当前字符小于、等于和大于结点字符的所有键。适用于非随机的键。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 15:12 * @Description 三向单词查找树 */ public class Tst&lt;Value> { /** * 根结点 */ private Node root; private class Node { /** * 字符 */ char letter; /** * 左中右连接 */ Node left, mid, right; /** * 值 */ Value val; } /** * 根据单词(键)获得该单词对应结点种保存的值。 * @param key 键 * @return 值 */ public Value get(String key) { Node node = get(root, key, 0); if (node == null) { return null; } return node.val; } /** * 查找第d个字符对应的子单词查找树 * @param root 根结点 * @param key 单词(键) * @param d 第d个字符 * @return 子单词查找树的结点 */ private Node get(Node root, String key, int d) { if (root == null) { return null; } char letter = key.charAt(d); if (letter &lt; root.letter) { // 当前字符小于结点字符 return get(root.left, key, d); } else if (letter > root.letter) { // 当前字符大于结点字符 return get(root.right, key, d); } else if (d &lt; key.length() - 1) { // 未达到查找单词最后一个字符，不大于不小于那就是等于了 return get(root.mid, key, d + 1); } else { // 达到查找单词最后一个字符，直接返回当前结点 return root; } } /** * 向单词树中存单词 * @param key 单词(键) * @param value 值 */ public void put(String key, Value value) { // 不需要确保根结点为空 root = put(root, key, value, 0); } /** * 根据所给键、值和当前字符存单词 * @param root 当前结点 * @param key 键 * @param value 值 * @param d 第d个字符 * @return 返回根结点 */ private Node put(Node root, String key, Value value, int d) { char letter = key.charAt(d); if (root == null) { // 如果根结点为空，直接向根结点存入第一个字符 root = new Node(); root.letter = letter; } if (letter &lt; root.letter) { // 当前字符小于结点字符 root.left = put(root.left, key, value, d); } else if (letter > root.letter) { // 当前字符大于结点字符 root.right = put(root.right, key, value, d); } else if (d &lt; key.length() - 1) { // 未达到查找单词最后一个字符，不大于不小于那就是等于了 root.mid = put(root.mid, key, value, d + 1); } else { // 达到查找单词最后一个字符，直接存储字符 root.val = value; } return root; } } 子串查找Brute-Force 字符串查找算法暴力子字符串查找算法，子串与主串一一匹配。 实现代码1(逐一匹配)： public static int search (String pat, String txt) { int n = txt.length(); int m = pat.length(); for (int i = 0; i &lt;= n - m; i++) { int j; for (j = 0; i &lt; m; j++) { // 主串与子串进行匹配 if (txt.charAt(i + j) != pat.charAt(j)) { break; } } // 找到匹配，返回匹配的初始位置 if (j == n) { return i; } } // 未找到匹配，返回主串的长度 return n; } 实现代码2(显示回退)： public static int search (String pat, String txt) { int i, n = txt.length(); int j, m = pat.length(); for (i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; i++) { if (txt.charAt(i) == pat.charAt(j)) { // 若匹配，则子串向后挪动1位 j++; } else { // 若不匹配，主串指针i回退子串完成匹配的j个位置，子串匹配指针j从0开始 i -= j; j = 0; } } if (j == m) { // 若子串指针匹配长度等于子串的长度匹配成功 return i - m; } else { // 未找到匹配，返回主串的长度 return n; } } Knuth-Morris-Pratt 字符串查找算法Knuth-Morris-Pratt 字符串查找算法即 KMP 算法，KMP 算法在匹配失败时不需要回退到最开始的位置重新进行匹配，可以有两种方法记录信息。 前缀表：计算前缀表，例如模式串为 ababc，将其拆分成 a，ab，aba，abab 四子串，a 的公共部分为 0(前缀后缀不能为本身)，ab 的最大前缀为 a、最大后缀为 b，因此公共部分为 0； aba 的最大前缀为 ab， 最大后缀为 ba，不匹配则减少一位只进行一位匹配前缀 a 和 后缀 a 匹配，则公共部分为 1；abab 为 2。因此模式串 ababc 的状态就是 -1，0，0，1，2。为模式串标上 0，1，2，3，4的下标分别对应上其状态 -1，0，0，1，2。当匹配失败时，将匹配失败位置的模式串状态值当作下标在模式串中寻找其相应的位置，使用这个位置的字符与主串匹配失败位置的字符进行匹配。若匹配位置的状态值为-1则表示子串向右挪一位进行匹配。 DFA：通过使用确定有限状态自动机(DFA)记录模式匹配状态，状态匹配方法如下：设模式串为 ABABAC，字母表 r 为 ABC。(DFA 根据文本中的字符改变而改变自身的状态，还有一种非确定有限状态自动机 NFA 在抽象方面比 DFA 更强，他可以根据或操作判断模式是否存在，即可以根据不确定的字符判断模式是否存在，常用于正则表达式) 第一步：将输入的A记为1，其它都记为0。(i=0，j=0) A B A B A C A 1 B 0 C 0 第二步：把第一个字符的状态值复制到第二个状态值，然后修改匹配成功的字符的状态值，也就是说本来从上到下是110，因为B是输入的所以是匹配成功的，变成了120，i记得要赋值成修改之前的 B 的值，也就是匹配不成功时 B 的值。(i=0，j=1) A B A B A C A 1 1 B 0 2 C 0 0 第三步：不断重复，例如第三列为300(i=1，j=2)，最后表的样子为 A B A B A C A 1 1 3 1 5 1 B 0 2 0 4 0 4 C 0 0 0 0 0 6 /** * @Author 喵粮都输光了 * @Date 2020/3/28 16:57 * @Description KMP 模式匹配算法 */ public class Kmp { /** * 模式串 */ private String pat; /** * 确定有限状态自动机，行表匹配串字符，列表匹配串索引，值为状态 * 状态的意思是例如dfa[r][j]，在已匹配j个字符时，若当前字符串字母为r，已匹配数量会变为多少 */ private int[][] dfa; /** * 构造模式串的DFA * @param pat 模式串 */ public Kmp(String pat) { // 使用模式串构造dfa this.pat = pat; int m = pat.length(); // ASCII 基数 int r = 256; // 一共可能有256个字符，表示输入下标为多少的某个字符其状态为什么 dfa = new int[r][m]; // 将模式串第一个字符的状态值置为 1，第一个字符和自己匹配不管怎么样都是匹配的，也就是已匹配1个 dfa[pat.charAt(0)][0] = 1; // 计算dfa[][j]即模式串第二到最后一个字符的状态值，j是第几个字符 for (int i = 0, j = 1; j &lt; m; j++) { // 遍历所有可能的字符， for (int k = 0; k &lt; r; k++) { dfa[k][j] = dfa[k][i]; } // 一开始全部都是设定成不匹配的，此时要修改匹配成功情况下的值，也就是模式串第j个位置的字符就是输入字符，他匹配数量一定增1，其他情况都是匹配失败 dfa[pat.charAt(j)][j] = j + 1; // i 是记录这个当前第j次循环开始时匹配不成功情况下的值，也就是上面那个循环结束时pat.charAt(j)的值。 i = dfa[pat.charAt(j)][i]; } } /** * 和暴力查找算法的显示回退思路一样，只是回退时使用的是DFA而已 * @param txt 需要查找子串的主串 * @return 查找到的子串下标开始位置 */ public int search(String txt) { int i, n = txt.length(); int j, m = pat.length(); for (i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; i++) { // 匹配不成功时候回退到第j个字符，匹配成功也会有相应状态，所以不需要加判断了 j = dfa[txt.charAt(i)][j]; } if (j == m) { // 若子串指针匹配长度等于子串的长度匹配成功 return i - m; } else { // 未找到匹配，返回主串的长度 return n; } } public static void main(String[] args) { String txt = \"ABCDEFT\"; String pat = \"DEF\"; Kmp kmp = new Kmp(pat); System.out.println(kmp.search(txt)); } } Boyer-Moore 字符串查找算法用一个数组记录字母表中的每个字符在模式串中出现的最右位置，当匹配失败时通过该数组查找与主串匹配失败的字符在模式串中的最右位置来进行重新匹配。 /** * @Author 喵粮都输光了 * @Date 2020/3/28 20:25 * @Description Boyer-Moore 子串查找算法 */ public class BoyerMoore { /** * 记录字母表中的每个字符在模式串中出现的最靠右的位置 * 例如ABBA，则A是3，B是2 */ private int[] right; /** * 模式串 */ private String pat; public BoyerMoore(String pat) { this.pat = pat; int m = pat.length(); int r = 256; right = new int[r]; // 将right的所有值设置成-1 for (int i = 0; i &lt; r; i++) { right[i] = -1; } // 将包含于模式串中的值设置成该字符在模式串中出现的最右边的位置 for (int i = 0; i &lt; m; i++) { right[pat.charAt(i)] = i; } } /** * Boyer-Moore查找 * @param txt 需要查找子串的主串 * @return 查找到的子串下标开始位置 */ public int search(String txt) { int n = txt.length(); int m = pat.length(); // 匹配失败时模式串移动的的幅度 int skip; for (int i = 0; i &lt;= n - m; i += skip) { skip = 0; // right中记录的是最右的位置，因此从right的最右向左遍历 for (int j = m - 1; j >= 0; j--) { // 如果出现了不相等则修改移动幅度skip if (pat.charAt(j) != txt.charAt(i + j)) { /* * 若模式串的j下标字符与主串的i+j下标字符不匹配， * 查找right表主串不匹配字符不在其中直接右挪一位，在其中则j减去该字符在模式串中最右的位置的下标 * 也就是说将与主串那个字符匹配的模式串中最右的该字符移动上去与之匹配 */ skip = j - right[txt.charAt(i + j)]; // 若j减去模式串最右的位置的字符出现了负数，不需要将模式串左右，直接将模式串右移一位即可 if (skip &lt; 1) { skip = 1; } break; } } // 当skip为0时，匹配成功返回主串与模式串匹配的初始位置 if (skip == 0) { return i; } } //匹配失败返回主串长度。 return n; } public static void main(String[] args) { String txt = \"ABCDEFT\"; String pat = \"DEF\"; BoyerMoore boyerMoore = new BoyerMoore(pat); System.out.println(boyerMoore.search(txt)); } } Rabin-Karp 指纹字符串查找算法通过计算模式字符串的散列函数，然后用相同的散列函数计算文本中所有可能的 m 个字符的子字符串散列值并寻找匹配，当寻找到一个散列值与模式字符串相同的子字符串还要继续验证两者是否真的匹配。Rabin-Karp 算法能在常数时间内计算 m 个字符的子字符串散列值，否则直接计算每个字符串的散列值将导致该算法比暴力查询还要慢。 此处使用的 horner 方法即如果在每次算术操作之后都将结果模以 Q 等价于在完成所有算术操作之后将最终的结果模以 Q，可以在常数时间内高效的移动子串。 总结 字符串排序 算法 稳定性 时间复杂度 空间复杂度 优势 低位优先排序 是 O(nw) O(n) 较短的定长字符串 高位优先排序 是 O(n)~O(nw) O(n+wr) 随机字符串 三向快速排序 否 O(n)~O(nw) O(w+logn) 含有较长公共前缀的字符串 字符串查找 暴力查找实现简单且在一般情况下性能良好，但是其所需时间可能和 MN 成正比，JAVA 中的 indexOf() 采用的是暴力查找； KMP 算法能够保证线性级别的性能且不需要再正文中回退，但是需要额外内存空间； Boyer-Moore 算法在一般情况下性能是亚线性级别(可能是线性级别的 M 倍)，但是需要额外内存空间； Rabin-Karp 算法性能是线性级别的，但是其内循环很长。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://blog.kuukokawaii.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法之图","date":"2020-03-26T13:47:14.000Z","path":"posts/d01e83b2/","text":"背包类下面算法会用到背包类： /** * @Author 喵粮都输光了 * @Date 2020/3/27 10:33 * @Description 背包(存取不能删) */ public class Bag&lt;Item> implements Iterable&lt;Item> { /** * 头结点 */ private Node&lt;Item> first; /** * 结点个数 */ private int n; private static class Node&lt;Item> { private Item item; private Node&lt;Item> next; } /** * 初始化背包 */ public Bag() { first = null; n = 0; } /** * 背包是否位空 * @return true or false */ public boolean isEmpty() { return first == null; } /** * 背包存储的数据个数 * @return 背包存储的数据个数 */ public int size() { return n; } /** * 添加 * @param item 元素 */ public void add(Item item) { Node&lt;Item> oldFirst = first; first = new Node&lt;>(); first.item = item; first.next = oldFirst; n++; } @Override public Iterator&lt;Item> iterator() { return new LinkedIterator(first); } /** * 背包迭代器 */ private class LinkedIterator implements Iterator&lt;Item> { /** * 当前结点 */ private Node&lt;Item> current; public LinkedIterator(Node&lt;Item> first) { current = first; } @Override public boolean hasNext() { return current != null; } @Override public void remove() { // 背包无删除方法 throw new UnsupportedOperationException(); } @Override public Item next() { if (!hasNext()) { throw new NoSuchElementException(); } Item item = current.item; current = current.next; return item; } } } 并查集并查集用于解决动态连通性问题，能动态连接两个顶点，并且判断两个顶点是否连通。 Quick Find可以快速的判断两个结点是否相通，因为同一连通分量的所有结点 id 相等，所以通过判断 id 是否相等就可以判断两个结点是否连通。 union 操作代价很高，需要将其中一个连通分量的所有 id 改成另一个连通分量的 id。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 20:48 * @Description quick find */ public class QuickFindUf { /** * 连通分量编号 */ private int[] id; public QuickFindUf(int n) { id = new int[n]; // 初始化，一个结点一个连通分量，刚开始无连接结点 for (int i = 0; i &lt; n; i++) { id[i] = i; } } /** * 查找p所在连通分量的编号 * @param p 结点p * @return 编号 */ public int find(int p) { return id[p]; } /** * 连接结点p和结点q * @param p 结点p * @param q 结点q */ public void union(int p, int q) { int pId = find(p); int qId = find(q); // 若两个结点id相等返回 if (pId == qId) { return; } // 否则把所有id等于p的都改成id等于q for (int i = 0; i &lt; id.length; i++) { if (id[i] == pId) { id[i] = qId; } } } } Quick Union可以快速的进行 union 操作，只需要修改一个结点的id即可，但是 find 操作代价很高，因为同一个连通分量的结点 id 值均不同，一个结点的 id 只是指向另一个结点，查找需要找到最顶层的结点 id。 quick union 会导致树高度可能为结点的数目，查找非常耗时。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 20:54 * @Description quick union */ public class QuickUnionUf { /** * 连通分量编号 */ private int[] id; public QuickUnionUf(int n) { id = new int[n]; // 初始化，一个结点一个连通分量，刚开始无连接结点 for (int i = 0; i &lt; n; i++) { id[i] = i; } } /** * 查找p所在连通分量的编号 * @param p 结点p * @return 编号 */ public int find(int p) { // 若结点p的值不等于结点p的下标，说明结点p的值是另一个结点的下标，将修改p的下标为p的值，继续查找根结点 while (p != id[p]) { p = id[p]; } return p; } /** * 连接结点p和结点q * @param p 结点p * @param q 结点q */ public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); // 将p的根结点下标改成q的根结点下标即可 if (pRoot != qRoot) { id[pRoot] = qRoot; } } } 加权 Quick Union通过将较小的树连接到较大的树上解决了 quick union 树高的问题。加权 quick union 的树高最多不超过 logn。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 21:02 * @Description 加权 quick union */ public class WeightedQuickUnionUf { /** * 连通分量编号 */ private int[] id; /** * 保存结点的数量信息 */ private int[] size; public WeightedQuickUnionUf(int n) { id = new int[n]; // 初始化，一个结点一个连通分量，刚开始无连接结点 for (int i = 0; i &lt; n; i++) { id[i] = i; } size = new int[n]; // 初始化，刚开始每个结点树高都为1 for (int i = 0; i &lt; n; i++) { size[i] = 1; } } /** * 查找p所在连通分量的编号 * @param p 结点p * @return 编号 */ public int find(int p) { // 若结点p的值不等于结点p的下标，说明结点p的值是另一个结点的下标，将修改p的下标为p的值，继续查找根结点 while (p != id[p]) { p = id[p]; } return p; } /** * 连接结点p和结点q * @param p 结点p * @param q 结点q */ public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); // 若结点p和结点q处于同一分量直接返回 if (pRoot == qRoot) { return; } // 如果结点p分量树小于结点q分量树 if (size[pRoot] &lt; size[qRoot]) { // 将结点p分量树挂到结点q分量树上 id[pRoot] = qRoot; // 结点q分量树需要加上结点p分量树的个数 size[qRoot] += size[pRoot]; } else { // 与上面相反 id[qRoot] = pRoot; size[pRoot] += size[qRoot]; } } } 路径压缩的加权 Quick Union将每一个连通分量的指向都指向根结点，修改 find 方法即可。 public int find(int p) { int temp = p; while (p != id[p]) { p = id[p]; } id[temp] = id[p]; return p; } 拓扑排序给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素称为拓扑排序。而且拓扑排序只能在有向无环图中才能进行。 拓扑排序实现只需要稍微修改深度优先搜索的代码即可完成。深度优先搜索时保存路径的数据结构的性质以及在递归调用前保存还是递归调用后保存，拓扑排序能分成三种排列顺序：前序(递归调用前入队)；后序(递归调用后入队)；逆后序(递归调用后压栈)； 实现代码： /** * @Author 喵粮都输光了 * @Date 2020/3/27 10:30 * @Description 有向图数据类型 */ public class Digraph { /** * 顶点数目 */ private int v; /** * 边数目 */ private int e; /** * 邻接表，包数组，每一个包代表一个而顶点的所有邻接顶点 */ private Bag&lt;Integer>[] adj; public Digraph(int v) { this.v = v; this.e = 0; adj = (Bag&lt;Integer>[]) new Bag[v]; for (int i = 0; i &lt; v; i++) { adj[i] = new Bag&lt;>(); } } /** * 顶点个数 * @return 顶点个数 */ public int v() { return v; } /** * 边个数 * @return 边个数 */ public int e() { return e; } /** * 添加边 * @param v 顶点v * @param w 顶点w */ public void addEdge(int v, int w) { adj[v].add(w); e++; } /** * 遍历顶点v的所有邻接顶点 * @param v 顶点v * @return 顶点v的所有邻接顶点 */ public Iterable&lt;Integer> adj(int v) { return adj[v]; } /** * 有向图反转，即入度变出度，出度变入度 * @return 反转的有向图 */ public Digraph reverse() { Digraph digraph = new Digraph(v); for (int i = 0; i &lt; v; i++) { for (int w : adj(v)) { digraph.addEdge(w, v); } } return digraph; } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 13:58 * @Description 基于深度优先搜索的顶点排序 */ public class DepthFirstOrder { /** * 存储顶点是否被遍历过的信息 */ private boolean[] marked; /** * 前序排序 */ private Queue&lt;Integer> pre; /** * 后序排序 */ private Queue&lt;Integer> post; /** * 逆后序排序 */ private Stack&lt;Integer> reversePost; /** * 初始化图，遍历所有顶点 * @param g 图g */ public DepthFirstOrder(Digraph g) { pre = new LinkedList&lt;>(); post = new LinkedList&lt;>(); reversePost = new Stack&lt;>(); marked = new boolean[g.v()]; // 若图非连通，遍历所有非连通子图 for (int i = 0; i &lt; g.v(); i++) { if (!marked[i]) { dfs(g, i); } } } /** * 深度优先搜索 * @param g 图g * @param v 顶点v */ private void dfs(Digraph g, int v) { pre.offer(v); marked[v] = true; for (int w : g.adj(v)) { if (!marked[w]) { dfs(g, w); } } post.offer(v); reversePost.push(v); } /** * 前序遍历顶点 * @return 前序顶点集 */ public Iterable&lt;Integer> pre() { return pre; } /** * 后序遍历顶点 * @return 后序顶点集 */ public Iterable&lt;Integer> post() { return post; } /** * 逆后序遍历顶点 * @return 逆后序顶点集 */ public Iterable&lt;Integer> reversePost() { return reversePost; } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 14:11 * @Description 有向图环检测 */ public class DirectedCycle { /** * 存储顶点是否被遍历过的信息 */ private boolean[] marked; /** * 从起点到一个顶点的已知路径上的最后一个顶点。 */ private int[] edgeTo; /** * 有向环中的所有顶点，若存在环 */ private Stack&lt;Integer> cycle; /** * 一次深度优先搜索中(一张子图中)遍历过的顶点 * true表遍历过，false表没遍历过 * 与marked区别为，marked标记整个图，onStack表一个子图即正在递归中的顶点 */ private boolean[] onStack; /** * 初始化图，深度优先搜索查找环 * @param g 图g */ public DirectedCycle(Digraph g) { onStack = new boolean[g.v()]; edgeTo = new int[g.v()]; marked = new boolean[g.v()]; for (int i = 0; i &lt; g.v(); i++) { if (!marked[i]) { dfs(g, i); } } } /** * 深度优先搜索，若搜索的顶点的邻接顶点在栈中则有环 * @param g 图g * @param i 顶点i */ private void dfs(Digraph g, int i) { // 将该顶点置为true因为遍历过 onStack[i] = true; marked[i] = true; for (int w : g.adj(i)) { if (hasCycle()) { // 有环直接返回 return; } else if (!marked[w]) { // 无环且邻接顶点没有被遍历过，就遍历 edgeTo[w] = i; dfs(g, w); } else if (onStack[w]) { // 如果当前顶点的邻接顶点在子图中遍历过则有环 cycle = new Stack&lt;>(); // cycle记录edgeTo中走过的路径。从当前顶点开始，到产生环的邻接顶点(不包含) for (int j = i; j != w; j = edgeTo[j]) { // 例0-1-2-3-0， i是3，edgeTo回退到0，不将0加入 cycle.push(j); } // 将产生环的邻接顶点加入路径，将0加入 cycle.push(w); // 将当前顶点加入，即变成了 3-2-1-0-3 的循环 cycle.push(i); } } // 递归回退将顶点置为false onStack[i] = false; } /** * 是否有环 * @return true or false */ public boolean hasCycle() { return cycle != null; } /** * 遍历环，若环存在 * @return 环中顶点集 */ public Iterable&lt;Integer> cycle() { return cycle; } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 13:35 * @Description 拓扑排序 */ public class Topological { /** * 顶点的拓扑排序 */ private Iterable&lt;Integer> order; /** * 初始化图，若有向图无环进行拓扑排序 * @param g 图g */ public Topological(Digraph g) { DirectedCycle cycleFinder = new DirectedCycle(g); if (!cycleFinder.hasCycle()) { DepthFirstOrder dfs = new DepthFirstOrder(g); order = dfs.reversePost(); } } /** * 顶点拓扑排序集 * @return 顶点拓扑排序集 */ public Iterable&lt;Integer> order() { return order; } /** * 是不是有向无环图 * @return true or false */ public boolean isDag() { return order != null; } } Kosaraju 算法计算有向图的强连通分量分两步： 在给定的有向图 g 中，使用 DepthFirstOrder 来计算 g 的反向图 ~g，并获得其逆后序排列。 对获得的反向图 ~g 的逆后序排列进行深度优先搜索即可获得强连通分量的数量。 所有在同一个dfs()递归中被访问的顶点都属于同一个强连通分量，通过强连通分量的标识符进行识别。 关键代码： // 已访问过的顶点 boolean[] marked; // 强连通分量的数量 int count = 0; // 强连通分量的标识符，若顶点v是第i个连通分量则id[v]=i int[] id; public KosarajuSCC(Digraph g) { id = new int[g.v()]; DepthFirstOrder order = new DepthFirstOrder(g.reverse()); for (int s : order.reversePost()) { // 可能是非连通图 if (!marked[s]) { dfs(g, s); count++; } } } public void dfs(Digraph g, int v) { marked[v] = true; // 顶点v是第count个连通分量，id[v]=count id[v] = count; for (int w : g.adj(v)) { if (!marked[w]) { dfs(g, w); } } } public boolean stronglyConnected() { // 顶点 v 和顶点 w 是否强连通 return id[v] == id[w]; } 最小生成树给定一副加权无向图，找到它的一颗最小生成树(MST)即一颗树中所有边的权值之和最小的生成树。图的生成树是它的一颗含有其所有顶点的无环连通子图。 最小生成树通用类： /** * @Author 喵粮都输光了 * @Date 2020/3/27 15:37 * @Description 带权重的边基础数据类型 */ public class Edge implements Comparable&lt;Edge> { /** * 顶点v */ private int v; /** * 顶点w */ private int w; /** * 权重 */ private double weight; public Edge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } /** * 获得顶点v * @return 顶点v */ public int either() { return v; } /** * 获取另一个顶点 * @param vertex v或w * @return 返回w或v */ public int other(int vertex) { if (vertex == v) { return w; } else if (vertex == w) { return v; } else { throw new RuntimeException(\"参数有问题\"); } } /** * 该边权重 * @return 返回权重 */ public double weight() { return weight; } @Override public int compareTo(Edge that) { if (this.weight() &lt; that.weight()) { return -1; } else if (this.weight() > that.weight()) { return 1; } else { return 0; } } @Override public String toString() { return String.format(\"%d--%d %.2f\", v, w, weight); } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 15:44 * @Description 加权无向图数据类型 */ public class EdgeWeightedGraph { /** * 顶点数目 */ private int v; /** * 边数目 */ private int e; /** * 邻接表 */ private Bag&lt;Edge>[] adj; public EdgeWeightedGraph(int v) { this.v = v; this.e = 0; adj = (Bag&lt;Edge>[]) new Bag[v]; for (int i = 0; i &lt; v; i++) { adj[i] = new Bag&lt;>(); } } /** * 顶点个数 * @return 顶点个数 */ public int v() { return v; } /** * 边个数 * @return 边个数 */ public int e() { return e; } /** * 添加边 * @param edge 边 */ public void addEdge(Edge edge) { int v = edge.either(); int w = edge.other(v); adj[v].add(edge); adj[w].add(edge); e++; } /** * 遍历顶点v的所有邻接顶点 * @param v 顶点v * @return 顶点v的所有邻接顶点 */ public Iterable&lt;Edge> adj(int v) { return adj[v]; } /** * 返回所有边 * @return 边集 */ public Iterable&lt;Edge> edges() { Bag&lt;Edge> bag = new Bag&lt;>(); for (int i = 0; i &lt; v; i++) { for (Edge e : adj[i]) { // 因为每个顶点会在边中出现两次，所以这里只取一个 if (e.other(i) > i) { bag.add(e); } } } return bag; } } Prim 算法选择一个结点作为树的根结点，将这个根结点的所有边存入优先队列。从优先队列中取出一条权值最小的边并将它添加到树中(如果未失效)，再将这个边的另一个顶点添加到树中。然后将新顶点的所有边加入优先队列，选择一条权值最小的边重复之前的操作，直至队列中无边。 算法实现： /** * @Author 喵粮都输光了 * @Date 2020/3/27 16:15 * @Description 最小生成树的Prim算法 */ public class PrimMst { /** * 顶点集是否被遍历过 */ private boolean[] marked; /** * 最小生成树的边 */ private Queue&lt;Edge> mst; /** * 优先队列存储待选择的边 */ private PriorityQueue&lt;Edge> pq; /** * 初始化生成树，并生成最小生成树 * @param g 图g */ public PrimMst(EdgeWeightedGraph g) { pq = new PriorityQueue&lt;>(); marked = new boolean[g.v()]; mst = new LinkedList&lt;>(); visit(g, 0); while (!pq.isEmpty()) { Edge e = pq.poll(); int v = e.either(); int w = e.other(v); // 如果边的两个顶点都遍历过了跳过 if (marked[v] &amp;&amp; marked[w]) { continue; } mst.offer(e); // 如果顶点v没被遍历过，遍历 if (!marked[v]) { visit(g, v); } // 如果顶点w没被遍历过，遍历 if (!marked[w]) { visit(g, w); } } } /** * 遍历顶点v的所有边，将边的另一头未被标记的顶点加入优先队列 * @param g 图g * @param v 顶点v */ private void visit(EdgeWeightedGraph g, int v) { marked[v] = true; for (Edge e : g.adj(v)) { if (!marked[e.other(v)]) { pq.offer(e); } } } /** * 最小生成树的所有边 * @return 最小生成树所有边 */ public Iterable&lt;Edge> edges() { return mst; } /** * 最小生成树的权值 * @return 树的权值 */ public double weight() { int weight = 0; for (Edge e : mst) { weight += e.weight(); } return weight; } } Kruskal 算法Prim 算法是随便选一个结点然后选择该节点权值最小的边扩展成最小生成树，而 Kruskal 算法是选择权值最小的边，然后选择权值第二小的边(如果加入的边会构成循环则舍弃)，直到构成一颗最小生成树为止。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 17:07 * @Description 最小生成树的Kruskal算法 */ public class Kruskal { /** * 最小生成树的边 */ private Queue&lt;Edge> mst; /** * 初始化生成树，并生成最小生成树 * @param g 图g */ public Kruskal(EdgeWeightedGraph g) { mst = new LinkedList&lt;>(); PriorityQueue&lt;Edge> pq = new PriorityQueue&lt;>(); for (Edge e : g.edges()) { pq.offer(e); } // 并查集 Uf uf = new Uf(g.v()); while (!pq.isEmpty() &amp;&amp; mst.size() &lt; g.v() - 1) { Edge e = pq.poll(); int v = e.either(); int w = e.other(v); if (uf.connected(v, w)) { // 并查集判断顶点v和顶点w是否相连 continue; } // 顶点v和顶点w不相连则将其连接 uf.union(v, w); mst.offer(e); } } /** * 最小生成树的所有边 * @return 最小生成树所有边 */ public Iterable&lt;Edge> edges() { return mst; } /** * 最小生成树的权值 * @return 树的权值 */ public double weight() { int weight = 0; for (Edge e : mst) { weight += e.weight(); } return weight; } } 最短路径单点路径最短：给定一幅加权有向图和一个起点 s，找到顶点 s 到顶点 v 的最短(总权重最小)路径(如果可达)。 最短路径树(Shortest Path Tree，SPT)：给定一副加权有向图和一个起点 s，以 s 为起点的一颗最短路径树包含从 s 起可达的所有顶点。 Dijkstra 算法和 Prim 算法构造方法类似，Dijkstra 算法通过将最小权值的非树顶点放松加入树中，不断重复直至所有顶点都在树中或所有的非树顶点的权值都是无穷大为止。也就是说该算法每次都会为最短路径树添加一条边，该边由一个树中的顶点指向一个非树顶点 w 且它是到 s 最近的顶点。 Dijkstra 算法能够解决边权值非负的加权有向图的单起点最短路径问题。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 17:39 * @Description 加权有向边数据类型 */ public class DirectedEdge { /** * 边的起点 */ private int v; /** * 边的终点 */ private int w; /** * 边的权重 */ private double weight; public DirectedEdge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } /** * 获得起点 * @return 顶点v */ public int from() { return v; } /** * 获取终点 * @return 返回w */ public int to() { return w; } /** * 获取权值 * @return 权值 */ public double weight() { return weight; } @Override public String toString() { return String.format(\"%d->%d %.2f\", v, w, weight); } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 17:45 * @Description 加权无向图数据类型 */ public class EdgeWeightedGraph { /** * 顶点数目 */ private int v; /** * 边数目 */ private int e; /** * 邻接表 */ private Bag&lt;DirectedEdge>[] adj; public EdgeWeightedGraph(int v) { this.v = v; this.e = 0; adj = (Bag&lt;DirectedEdge>[]) new Bag[v]; for (int i = 0; i &lt; v; i++) { adj[i] = new Bag&lt;>(); } } /** * 顶点个数 * @return 顶点个数 */ public int v() { return v; } /** * 边个数 * @return 边个数 */ public int e() { return e; } /** * 添加边 * @param edge 边 */ public void addEdge(DirectedEdge edge) { adj[edge.from()].add(edge); e++; } /** * 遍历顶点v的所有邻接顶点 * @param v 顶点v * @return 顶点v的所有邻接顶点 */ public Iterable&lt;DirectedEdge> adj(int v) { return adj[v]; } /** * 返回所有边 * @return 边集 */ public Iterable&lt;DirectedEdge> edges() { Bag&lt;DirectedEdge> bag = new Bag&lt;>(); for (int i = 0; i &lt; v; i++) { for (DirectedEdge e : adj[i]) { bag.add(e); } } return bag; } } /** * @Author 喵粮都输光了 * @Date 2020/3/27 18:13 * @Description 最短路径Dijkstra算法 */ public class DijkstraSp { /** * 存储顶点是否被遍历过的信息 */ private boolean[] marked; /** * 从起点到一个顶点的已知路径上的最后一个顶点。 */ private DirectedEdge[] edgeTo; /** * 最短路径的长度 */ private double[] distTo; /** * 优先队列存储待选择的边 */ private PriorityQueue&lt;DirectedEdge> pq; public DijkstraSp(EdgeWeightedGraph g, int s) { // 权值不能为负 for (DirectedEdge e : g.edges()) { if (e.weight() &lt; 0) { throw new IllegalArgumentException(\"权值不能为负\"); } } edgeTo = new DirectedEdge[g.v()]; distTo = new double[g.v()]; marked = new boolean[g.v()]; pq = new PriorityQueue&lt;>(g.v(), (e1, e2) -> { // 比较返回路径长度最小的 double dist1 = distTo[e1.from()] + e1.weight(); double dist2 = distTo[e2.from()] + e2.weight(); return Double.compare(dist1, dist2); }); // 将所有顶点的路径权值初始化为达不到 for (int i = 0; i &lt; g.v(); i++) { distTo[i] = Double.POSITIVE_INFINITY; } // 选择一个顶点作为开始顶点 distTo[s] = 0; // 松弛边 relax(g, s); while (!pq.isEmpty()) { DirectedEdge e = pq.poll(); int w = e.to(); if (!marked[w]) { relax(g, w); } } } /** * 松弛边操作：放松边v->w意味着检查v到w的最短路径是否是从s到v，然后由v到w。 * 由v到w的最短路径为distTo[v]+e.weight，如果这个值小于distTo[w]就更新数据，否则忽略。 * @param g 图g * @param v 顶点v */ private void relax(EdgeWeightedGraph g, int v) { marked[v] = true; for (DirectedEdge edge : g.adj(v)) { int w = edge.to(); if (distTo[v] + edge.weight() &lt; distTo[w]) { distTo[w] = distTo[v] + edge.weight(); edgeTo[w] = edge; pq.offer(edge); } } } /** * 顶点v的权值 * @param v 顶点v * @return 顶点v的权值 */ public double distTo(int v) { return distTo[v]; } /** * 起点到顶点v是否有路径 * @param v 顶点v * @return true or false */ public boolean hasPathTo(int v) { return marked[v]; } /** * 返回起点到顶点v的最短路径 * @param v 顶点v * @return 路径 */ public Iterable&lt;DirectedEdge> pathTo(int v) { if (!hasPathTo(v)) { return null; } List&lt;DirectedEdge> path = new ArrayList&lt;>(); for (DirectedEdge edge = edgeTo[v]; edge != null; edge = edgeTo[edge.from()]) { path.add(edge); } Collections.reverse(path); return path; } } 顶点松弛+拓扑排序结合求解按照拓扑结构放松顶点，该方法求情节最短路径能够处理负权重的边，且比 Dijkstra 算法快。 如果要求最长路径可以将 distTo 初始化为 Double.NEGATIVE_INFINITY，并且将 relax 方法中的不等式方法更改即可。 /** * @Author 喵粮都输光了 * @Date 2020/3/27 20:03 * @Description 边松弛+拓扑排序求解最短路径 */ public class AcyclicSp { /** * 从起点到一个顶点的已知路径上的最后一个顶点。 */ private DirectedEdge[] edgeTo; /** * 最短路径的长度 */ private double[] distTo; public AcyclicSp(EdgeWeightedGraph g, int s) { edgeTo = new DirectedEdge[g.v()]; distTo = new double[g.v()]; for (int i = 0; i &lt; g.v(); i++) { distTo[i] = Double.POSITIVE_INFINITY; } distTo[s] = 0; Topological topological = new Topological(g); for (int v : topological.order()){ relax(g, v); } } // 其它方法同 Dijkstra 算法。 } 关键路径如果将一系列任务的长度定义为完成所有任务的最早可能时间，那么最长的任务序列就是问题的关键路径。所以使用顶点松弛+拓扑排序结合求解最长路径即可得到关键路径。 Floyd算法利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法。Dijkstra 算法是单源最短路径算法。 Bellman-Ford 算法在任意含有 v 个顶点的加权有向图中给定起点 s，从 s 无法到达任何负权重环，而通过 Bellman-Ford 算法能解决其中的单点最短路径问题。通过将 distTo[s] 初始化为0，其它 distTo[] 元素初始化为无穷大，并以任意顺序放松有向图的所有边，重复 v 轮。 总结 并查集 算法 find union Quick Find O(n) 1 Quick Union 树高 树高 加权 Quick Union O(logn) O(logn) 路劲压缩加权 Quick Union 接近1 接近1 最小生成树 算法 空间 时间 图类型 Prime 算法 O(E) O(ElogE) 无向图 Kruskal 算法 O(E) O(ElogE) 无向图 最短路径 算法 局限 最坏情况 一般情况 所需空间 优势 Dijkstra 算法 边的权重必须为正 O(ElogV) O(ElogV) V 最坏情况下仍有较好的性能 拓扑排序 只适用于无环加权有向图 O(E+V) O(E+V) V 是无环图中的最优算法 Bellman-Ford 算法 不能存在负权重环 O(E+V) O(VE) V 适用领域广泛 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://blog.kuukokawaii.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法之查找","date":"2020-03-25T13:01:43.000Z","path":"posts/4cc1103c/","text":"符号表模板抽象了符号表所需的基本操作。 无序符号表模板/** * @Author 喵粮都输光了 * @Date 2020/3/25 21:22 * @Description 无序符号表模板 */ public interface UnorderedSt&lt;Key, Value> { /** * 存储的键值对个数 * @return 当前个数 */ int size(); /** * 根据key获得其value * @param key 键 * @return 值 */ Value get(Key key); /** * 根据键值存入键值对 * @param key 键 * @param value 值 */ void put(Key key, Value value); /** * 根据键删除键值对 * @param key 键 */ void delete(Key key); } 有序符号表模板/** * @Author 喵粮都输光了 * @Date 2020/3/25 21:26 * @Description 有序符号表模板 */ public interface OrderedSt&lt;Key extends Comparable&lt;Key>, Value> { /** * 存储的键值对个数 * @return 当前个数 */ int size(); /** * 根据key获得其value * @param key 键 * @return 值 */ Value get(Key key); /** * 根据键值存入键值对 * @param key 键 * @param value 值 */ void put(Key key, Value value); /** * 获得最小的键 * @return 最小的键 */ Key min(); /** * 获得最大的键 * @return 最大的键 */ Key max(); /** * 小于key的键的数量 * @param key 键 * @return 符合要求的键的个数 */ int rank(Key key); /** * 表中[lo...hi]之间的所有键，已排序 * @param lo 起始键 * @param hi 终点键 * @return 返回[lo...hi]之间的所有键的集合 */ List&lt;Key> keys(Key lo, Key hi); } 符号表符号表(Symbol Table)主要用于将一个键与一个值联系起来即存储键值对，它支持高效地插入和查找。符号表分为无序符号表和有序符号表，有序符号表通常通过比较键的大小保持键的有序。 无序符号表实现无序符号表常用链表来实现，方便插入和顺序查找。 时间复杂度：插入和查找的时间复杂度均为O(n)。 /** * @Author 喵粮都输光了 * @Date 2020/3/25 21:39 * @Description 顺序查找(基于无序链表) */ public class SequentialSearchSt&lt;Key, Value> implements UnorderedSt&lt;Key, Value> { private class Node { Key key; Value value; Node next; Node(Key key, Value value, Node next) { this.key = key; this.value = value; this.next = next; } } /** * 根结点 */ private Node first; /** * 符号表大小 */ private int size = 0; @Override public int size() { return size; } @Override public Value get(Key key) { for (Node current = first; current != null; current = current.next) { if (key.equals(current.key)) { return current.value; } } return null; } @Override public void put(Key key, Value value) { for (Node current = first; current != null; current = current.next) { if (key.equals(current.key)) { current.value = value; return; } } first = new Node(key, value, first); size++; } @Override public void delete(Key key) { for (Node current = first, pre = first; current != null; pre = current, current = current.next) { if (key.equals(current.key)) { if (key.equals(first.key)) { first = current.next; } else { pre.next = current.next; } size--; return; } } } public static void main(String[] args) { SequentialSearchSt&lt;String, Integer> st = new SequentialSearchSt&lt;>(); st.put(\"1\", 1); st.put(\"2\", 2); st.put(\"3\", 3); st.put(\"3\", 4); System.out.println(st.size()); st.delete(\"1\"); st.delete(\"2\"); st.delete(\"3\"); System.out.println(st.size()); } } 有序符号表实现有序符号表通常使用一对平行数组实现，两个数组分别存储键和值。该算法保证了键的有序性，并通过二分查找高效的实现查找操作。其实现核心为rank()方法，该方法能够定位需要查找的键的位置或者是需要插入的键的插入位置。 时间复杂度：再n个键的有序数组中二分查找最多需要(lgn+1)次比较，因此查找的时间复杂度为O(lgn)；在最糟糕的情况下，插入的键在数组首位则整个数组需要后移一位，一共有两个数组需要访问数组约2n次，所以插入的时间复杂度为O(n)。 /** * @Author 喵粮都输光了 * @Date 2020/3/25 22:26 * @Description 二分查找(基于有序数组) */ public class BinarySearchSt&lt;Key extends Comparable&lt;Key>, Value> implements OrderedSt&lt;Key, Value> { /** * 键数组 */ private Key[] keys; /** * 值数组 */ private Value[] values; /** * 当前存储的键值对数量 */ private int size = 0; public BinarySearchSt(int capacity) { keys = (Key[]) new Comparable[capacity]; values = (Value[]) new Object[capacity]; } @Override public int size() { return size; } @Override public Key min() { return keys[0]; } @Override public Key max() { return keys[size - 1]; } @Override public int rank(Key key) { // 返回小于key的键的数量 int lo = 0, hi = size - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; int cmp = key.compareTo(keys[mid]); if (cmp &lt; 0) { hi = mid - 1; } else if (cmp > 0) { lo = mid + 1; } else { return mid; } } return lo; } @Override public Value get(Key key) { int index = rank(key); if (index &lt; size &amp;&amp; keys[index].compareTo(key) == 0) { return values[index]; } return null; } @Override public void put(Key key, Value value) { int index = rank(key); // 如果存在更新值 if (index &lt; size &amp;&amp; keys[index].compareTo(key) == 0) { values[index] = value; return; } // 不存在则将插入位置后面的元素依次后移一位 for (int i = size; i > index; i--) { keys[i] = keys[i - 1]; values[i] = values[i - 1]; } keys[index] = key; values[index] = value; size++; } @Override public List&lt;Key> keys(Key lo, Key hi) { List&lt;Key> list = new ArrayList&lt;>(); for (int index = rank(lo); index &lt; size &amp;&amp; keys[index].compareTo(hi) &lt;= 0; index++) { list.add(keys[index]); } return list; } public static void main(String[] args) { BinarySearchSt&lt;String, Integer> st = new BinarySearchSt&lt;>(5); st.put(\"1\", 1); st.put(\"3\", 3); st.put(\"2\", 2); List&lt;String> list = st.keys(\"1\", \"2\"); for (String s : list) { System.out.println(s); } } } 二叉查找树(B 树)为了支持高效插入操作需要使用链式结构，但是二分查找法不适用于链式结构，因此诞生了二叉查找树，同时拥有高效的插入和查找操作。 一颗二叉查找树(BST)是一颗二叉树，其中每个结点都含有一个键且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。BST的中序遍历结果是递增排序。 时间复杂度：二叉查找树拥有顺序查找(无序链表)和二分查找(有序数组)的优点，所以其查找和插入的时间复杂度均为O(n)。 基本数据结构： /** * @Author 喵粮都输光了 * @Date 2020/3/26 10:07 * @Description 二叉查找树 */ public class Bst&lt;Key extends Comparable&lt;Key>, Value> implements OrderedSt&lt;Key, Value> { /** * 二叉树根节点 */ protected Node root; protected class Node { /** * 键 */ Key key; /** * 值 */ Value value; /** * 左结点 */ Node left; /** * 右结点 */ Node right; /** * 以该结点为根的子树结点个数(包括该结点) */ int size; /** * 红黑树判断 */ boolean color; public Node(Key key, Value value, int size) { this.key = key; this.value = value; this.size = size; } } @Override public int size() { return size(root); } /** * 该结点为根的子树结点个数(包括该结点) * @param node 结点 * @return 结点个数 */ private int size(Node node) { if (node == null) { return 0; } return node.size; } /** * 重新计算结点个数 * @param node 以该结点为根的子树结点个数。 */ public void recalculateSize(Node node) { node.size = size(node.left) + size(node.right) + 1; } } get()： @Override public Value get(Key key) { return get(root, key); } /** * 递归查找键，键比根结点键小左子树查找，键比根结点键大右子树查找。 * @param root 二叉查找树根节点 * @param key 需要查找的键 * @return 返回该键的值 */ private Value get(Node root, Key key) { if (root == null) { return null; } int cmp = key.compareTo(root.key); if (cmp &lt; 0) { return get(root.left, key); } else if (cmp > 0) { return get(root.right, key); } else { return root.value; } } put()： @Override public void put(Key key, Value value) { root = put(root, key, value); } /** * 插入结点，找到同样的键覆盖值，没有找到则需新建结点挂入树种。同时更新挂入结点及其所有双亲结点的大小 * @param root 根结点 * @param key 键 * @param value 值 * @return 返回插入结点的引用 */ private Node put(Node root, Key key, Value value) { if (root == null) { return new Node(key, value, 1); } int cmp = key.compareTo(root.key); if (cmp &lt; 0) { root.left = put(root.left, key, value); } else if (cmp > 0) { root.right = put(root.right, key, value); } else { root.value = value; } recalculateSize(root); return root; } floor()： /** * 从根结点起，返回小于等于传入键的的最大键 * @param key 传入键 * @return 返回满足要求的键 */ public Key floor(Key key) { Node node = floor(root, key); if (node == null) { return null; } return node.key; } /** * 从所给结点起，返回小于等于键传入键的的最大键 * @param root 结点 * @param key 传入键 * @return 返回满足要求的键所在结点 */ private Node floor(Node root, Key key) { if (root == null) { return null; } int cmp = key.compareTo(root.key); if (cmp == 0) { // 若相等返回该结点 return root; } else if (cmp &lt; 0) { // 若所给键小于结点的键，则键一定在左子树种 return floor(root.left, key); } else { // 若所给键大于结点的键，则递归该结点的右结点继续判断，若右结点返回空就把当前结点返回 Node temp = floor(root.right, key); return temp == null ? root : temp; } } rank()： @Override public int rank(Key key) { // 小于key的键的数量 return rank(root, key); } /** * 返回小于所给键的键的个数 * @param root 当前结点 * @param key 所给键 * @return 小于所给键的个数 */ private int rank(Node root, Key key) { if (root == null) { return 0; } int cmp = key.compareTo(root.key); if (cmp &lt; 0) { // 若小于，递归左子树的排名 return rank(root.left, key); } else if (cmp > 0) { // 若大于，递归计算右子树的排名再加上左子树的结点数再加一个根结点。 return size(root.left) + 1 + rank(root.right, key); } else { // 若等于，返回该结点左子树的结点数 return size(root.left); } } min()： @Override public Key min() { if (root == null) { return null; } return min(root).key; } /** * 返回最小的键所在结点 * @param root 结点 * @return 最小键所在结点 */ private Node min(Node root) { if (root.left == null) { return root; } return min(root.left); } deleteMin()： /** * 删除最小键所在结点 */ public void deleteMin() { if (root == null) { return; } root = deleteMin(root); } /** * 递归删除最小键所在结点，同时更新删除结点的所有双亲结点的大小 * @param root 当前结点 * @return 第一次返回需要删除结点的右结点，之后都是返回当前结点 */ private Node deleteMin(Node root) { // 找到一个结点左子树为空，返回右子树 if (root.left == null) { return root.right; } // 将该结点的左子树删除，右子树挂载到其左子树 root.left = deleteMin(root.left); // 重新计算结点大小 recalculateSize(root); return root; } delete()： /** * 删除给出键所在结点 * @param key 需要删除的键 */ public void delete(Key key) { root = delete(root, key); } /** * 递归删除所给键所在结点，同时更新删除结点的所有双亲结点的大小 * 删除方法：找到键所在节点的第一个右子树，遍历这个右子树的左子树找到叶子结点，用这个叶子结点替换删除结点， * 需要删除结点的左子树是这个叶子结点的左子树，需要删除节点的右子树是这个叶子结点的右子树， * 当然叶子结点如果有右子树则要变成需要删除结点右子树的左子树。 * @param root 当前结点 * @param key 键 * @return 第一次返回需要删除结点的右结点，之后都是返回当前结点 */ private Node delete(Node root, Key key) { if (root == null) { return null; } int cmp = key.compareTo(root.key); if (cmp &lt; 0) { root.left = delete(root.left, key); } else if (cmp > 0) { root.right = delete(root.right, key); } else { if (root.right == null) { return root.left; } if (root.left == null) { return root.right; } Node temp = root; root = min(temp.right); root.right = deleteMin(temp.right); root.left = temp.left; } recalculateSize(root); return root; } keys()： @Override public List&lt;Key> keys(Key lo, Key hi) { List&lt;Key> list = new ArrayList&lt;>(); keys(root, list, lo, hi); return list; } /** * 表中[lo...hi]之间的所有键，已排序，相当于中序遍历 * @param root 当前结点 * @param list 满足要求的键集合 * @param lo 起始键 * @param hi 终点键 */ private void keys(Node root, List&lt;Key> list, Key lo, Key hi) { if (root == null) { return; } int cmpLo = lo.compareTo(root.key); int cmpHi = hi.compareTo(root.key); // 查找左结点 if (cmpLo &lt; 0) { keys(root.left, list, lo, hi); } // 判断是否在指定范围之内，lo一定小于等于所选键，hi一定大于等于所选键 if (cmpLo &lt;= 0 &amp;&amp; cmpHi >= 0) { list.add(root.key); } // 查找右结点 if (cmpHi > 0) { keys(root.right, list, lo, hi); } } 平衡查找树如果能够保证二叉查找树的树高为lgn的话，也就是二叉查找树是完全二叉树的话，就不会出现二叉查找树的最坏情况出现，此时时间复杂度由O(n)提升至O(lgn)。 2-3 查找树在动态插入时保证树的完美平衡代价非常高昂，因此通过提升树中一个结点保存键的个数减少平衡的代价。2-3查找树引入2-结点(一个键两条链接，左连接的键小于该键，右链接的键大于该键)和3-结点(两个键三条链接，左连接的键小于左键，中间链接的键大于左键小于又见，右链接的键大于右键)来保证平衡。一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。 红黑树红黑二叉查找树通过标准的二叉查找树(2-结点构成)和颜色信息(替换3-结点)来表示2-3查找树。若指向一个结点的颜色信息为红色则表示这个结点和上层结点表示的是一个3-结点，为黑色则表示是一个普通链接。红黑树既是二叉查找树又是2-3查找树，继承了二叉查找树中高效的查找方法和2-3查找树中高效的平衡插入算法。 红黑二叉树也可以表示为是含有红黑链接并满足下列条件的二叉查找树： 红链接均为左链接； 没有任何一个结点同时和两条红链接相连； 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 颜色表示(此处继承二叉查找树代码构建红黑树)： /** * @Author 喵粮都输光了 * @Date 2020/3/26 14:31 * @Description 红黑树 */ public class RedBlackBst&lt;Key extends Comparable&lt;Key>, Value> extends Bst&lt;Key, Value> { /** * 指向结点的链接颜色为红色 */ private static final boolean RED = true; /** * 指向结点的链接颜色为黑色 */ private static final boolean BLACK = false; /** * 指向结点的链接颜色是不是红色 * @param node 结点 * @return true or false */ private boolean isRed(Node node) { // 默认空连接颜色为黑色 if (node == null) { return BLACK; } return node.color == RED; } } 左旋转： /** * 右链接为红色需要进行左旋转操作，红黑树只允许左连接为红色 * 操作：需要变动四处，将根结点的右结点替换根结点，将根结点的右结点的左结点当作根结点的右结点， * 变换颜色，计算结点个数 * @param root 需要旋转的结点 * @return 返回旋转后的根结点 */ private Node rotateLeft(Node root) { // 根结点的右结点 Node right = root.right; // 根结点的右结点变成右结点的左结点 root.right = right.left; // 右结点替换根结点，根结点变成右结点的左结点 right.left = root; // 变色，右结点继承根结点的颜色，根结点变红 right.color = root.color; root.color = RED; // 修改结点的个数，右结点继承根结点的结点个数，根结点重新计算 right.size = root.size; recalculateSize(root); return right; } 右旋转： /** * 当出现两个连续的红链接时，将其中一个红色的左链接进行右旋转操作，操作与左旋转相反 * @param root 需要旋转的结点 * @return 返回旋转后的根结点 */ private Node rotateRight(Node root) { // 根结点的左结点 Node left = root.left; // 根结点的左结点变成左结点的右结点 root.left = left.right; // 左结点替换根结点，根结点变成左结点的右结点 left.right = root; // 变色，左结点继承根结点的颜色，根结点变红 left.color = root.color; root.color = RED; // 修改结点的个数，左结点继承根结点的结点个数，根结点重新计算 left.size = root.size; recalculateSize(root); return left; } 颜色转换： /** * 颜色转换，若一个结点指向左右结点的颜色都是红色的，这就是一个4-结点。 * 需要进行分裂操作，并将指向子结点的颜色变成黑色，指向父节点的颜色从黑色变成红色。 * @param root 需要变换颜色的结点 */ private void flipColors(Node root) { root.color = RED; root.left.color = BLACK; root.right.color = BLACK; } 插入： @Override public void put(Key key, Value value) { root = put(root, key, value); // 根结点永远是黑色的 root.color = BLACK; } /** * 插入结点， * 1.先按二叉查找树的方法插入到正确位置，插入结点颜色是红色 * 2.若指向右结点的颜色为红色，左结点的颜色为黑色，左旋； * 若指向左结点的颜色为红色，左结点的左结点颜色还是红色，右旋； * 若指向左右节点的颜色均为红色，进行颜色转换。 * 3. 最后的最后要将根结点变成黑色。（此处在调用方法中实现了） * @param root 当前结点 * @param key 键 * @param value 值 * @return 返回插入结点的引用 */ private Node put(Node root, Key key, Value value) { // 没找到键的位置，把键插入到应该在的位置，颜色设置为红色。 if (root == null) { Node node = new Node(key, value, 1); node.color = RED; return node; } // 查找键所在结点位置，若找到了覆盖其值。 int cmp = key.compareTo(root.key); if (cmp == 0) { root.value = value; } else if (cmp &lt; 0) { root.left = put(root.left, key, value); } else { root.right = put(root.right, key, value); } // 右红左黑(左旋)，可能会出现左脸红两个，所以放在第一个判断。 if (isRed(root.right) &amp;&amp; !isRed(root.left)) { root = rotateLeft(root); } // 左连红两个(右旋)，之后可能左右都红，所以放在第二个判断。 if (isRed(root.left) &amp;&amp; isRed(root.left.left)) { root = rotateRight(root); } // 左右都红(变色) if (isRed(root.left) &amp;&amp; isRed(root.right)) { flipColors(root); } // 重新计算根结点的结点个数 recalculateSize(root); return root; } 散列表散列表类似于数组，只是用散列函数将被查找的键转化为数组的一个索引，通过转化后的索引访问数组。访问散列表的速度和访问数组元素一样快速，可以在常数时间内实现查找和插入操作。散列表无法实现有序性操作，散列函数无法表示键的大小关系。 散列函数如果有一个大小为 M 的数组，散列函数可以将任意键转换为 [0, M-1] 内的正整数，该正整数即为哈希值。散列函数可能会让不同的键拥有相同的哈希值，也就是哈希值分布不均匀，此时就发生了碰撞，需要特殊的碰撞解决方法进行处理。若散列值计算很耗时，可以将每个键的散列值缓存起来，这种方法称为软缓存。 正整数：常用除留余数法，选择任意正整数 k % M(数组长度)得到的数可以有效的将键散布在 [0, M-1] 之间。M 的选择最好是素数，否则无法利用键中包含的所有信息而导致散布不均匀。例如 M 取10的 k 次方，那么就只能利用键的后k位进行散布。 浮点数：将键表示为二进制数然后使用除留余数法。 字符串：可以通过如下方式散列，r为进制数，通过 r 乘上哈希值再加上字符的ASCII码模数组长度得到字符串的哈希值。如果是多部分组合的类型也可以使用该方法。 int hash = 0; for (char sign : s.toCharArray()) { hash = (r * hash + sign) % M; } hashCode()：该方法是 java 中的一个实现了哈希函数的方法，它默认使用对象的地址值，地址值32位也就是说可以均匀散列至32位整数中。如果需要一个数组索引而不是一个32位的整数，所以可以结合除留余数法进行如下改造。也可以自己覆写对象中的 hashCode() 方法。 private int hash(Key key) { // 将符号位屏蔽即32位整数变成31位非负整数，然后使用除留余数法。0x7fffffff即01111111...31个1 return (key.hashCode() &amp; 0x7fffffff) % M; } 其它的散列函数 数字分析法：提前知道关键字集合，且每个关键字的位数比散列表的地址码位数多，则可以从关键字中提取数字分布比较均匀的若干位作为散列地址。 平方取中法：直接取得数字的平方，然后取其中几位。 折叠法：将关键字分割成相同位数的几部分，然后取这几部分的叠加和(舍去进位)作为散列地址。 碰撞解决拉链法将一个大小为 M 的数组中的每个元素指向一条链表，当元素发生碰撞时，就会将该元素存储在索引指向的链表中。拉链法进行查询时，首先查找 key 所在的链表，然后从链表中顺序查找。 线性探测线性探测法使用空位来解决冲突，当发生冲突时在冲突位置遍历数组寻找到一个空位来存储冲突的键。 /** * @Author 喵粮都输光了 * @Date 2020/3/26 19:24 * @Description 线性探测 */ public class LinearProbingHashSt&lt;Key, Value> implements UnorderedSt&lt;Key, Value> { /** * 当前大小 */ private int size = 0; /** * 最大容量 */ private int maxSize; /** * 键集合 */ private Key[] keys; /** * 值集合 */ private Value[] values; public LinearProbingHashSt(int maxSize) { this.maxSize = maxSize; init(); } public LinearProbingHashSt() { init(); } /** * 初始化 */ private void init() { keys = (Key[]) new Comparable[maxSize]; values = (Value[]) new Object[maxSize]; } /** * 散列函数 * @param key 键 * @return 哈希值 */ private int hash(Key key) { return (key.hashCode() &amp; 0x7fffffff) % maxSize; } @Override public Value get(Key key) { for (int i = hash(key); keys[i] != null; i = (i + 1) % maxSize) { if (keys[i].equals(key)) { return values[i]; } } return null; } @Override public void put(Key key, Value value) { resize(); putElem(key, value); } /** * 插入元素，不包含调整数组 * @param key 键 * @param value 值 */ public void putElem(Key key, Value value) { int i; for (i = hash(key); keys[i] != null; i = (i + 1) % maxSize) { // 找到相同的键，覆盖其值 if (keys[i].equals(key)) { values[i] = value; return; } } keys[i] = key; values[i] = value; size++; } @Override public void delete(Key key) { int i = hash(key); // 寻找需要删除的键 while (keys[i] != null &amp;&amp; !key.equals(keys[i])) { i = (i + 1) % maxSize; } // 若不存在返回 if (keys[i] == null) { return; } // 删除键值对 keys[i] = null; values[i] = null; // 将删除键之后相同哈希值的键值对重新插入 i = (i + 1) % maxSize; while (keys[i] != null) { Key tempKey = keys[i]; Value tempValue = values[i]; keys[i] = null; values[i] = null; size--; putElem(tempKey, tempValue); i = (i + 1) % maxSize; } size--; resize(); } /** * 调整数组大小，使用率α=size/maxSize，当α小于0.5时，探测性能最好，所以最好保证使用率在0.5。 */ private void resize() { if (size >= maxSize / 2) { // 当前大小大于等于容量的1/2，数组扩容一倍 resize(2 * maxSize); } else if (size > 0 &amp;&amp; size &lt;= maxSize / 8) { // 当前大小小于等于容量的1/8，数字缩小一倍 resize(maxSize / 2); } } /** * 根据容量重新调整数组大小 * @param capacity 最大容量 */ private void resize(int capacity) { LinearProbingHashSt&lt;Key, Value> linearProbingHashSt = new LinearProbingHashSt&lt;>(capacity); for (int i = 0; i &lt; maxSize; i++) { if (keys[i] != null) { linearProbingHashSt.putElem(keys[i], values[i]); } } keys = linearProbingHashSt.keys; values = linearProbingHashSt.values; maxSize = linearProbingHashSt.maxSize; } @Override public int size() { return size; } } 查询算法对比 算法 查找 插入 使用 顺序查找(无序链表) O(n) O(n) 操作大型符号表很慢。 二分查找(有序数组) O(lgn) O(n) 查找很快插入很慢，有序操作，空间占用少。 二叉树查找(二叉查找树) O(n) O(n) 性能没有保障，有序操作，链接需要额外空间。 2-3树查找(红黑树) O(2lgn) O(2lgn) 查找插入很快，有序操作，连接需要额外空间。 拉链法(链表数组) 小于O(lgn) 小于O(lgn) 查找插入很快，需要额外计算和大量空间。 线性探测法(并行数组) O(clgn) O(clgn) 查找插入很快，需要额外计算和大量空间。 散列表都是无序的，如果需要优先考虑散列表速度快，如果需要有序性操作则考虑红黑树。考虑存储空间的话散列表占用的存储空间较大，其次红黑树和二叉查找树，再然后顺序查找，最后二分查找。 java 中 java.util.TreeMap 通过红黑树实现；java.util.HashMap 通过拉链法的散列表实现。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://blog.kuukokawaii.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法之排序","date":"2020-03-24T06:59:26.000Z","path":"posts/db4eb545/","text":"排序模板通过 java 的 Comparable 接口的 compareTo() 方法判断两个元素大小关系，使用 less() 和 swap() 来进行比较和交换操作。排序算法的成本模型是比较和交换的次数。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 18:40 * @Description 排序模板 */ public abstract class BaseSort&lt;T extends Comparable&lt;T>> { /** * 排序 * @param nums 排序的数组 */ public abstract void sort(T[] nums); /** * 传入的第一个参数是否比第二个参数小 * @param v 第一个参数 * @param w 第二个参数 * @return true or false */ protected boolean less(T v, T w) { return v.compareTo(w) &lt; 0; } /** * 交换数组中两个元素 * @param nums 需要交换的数组 * @param i 下标i * @param j 下标j */ protected void swap(T[] nums, int i, int j) { T temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } 选择排序从数组中选择一个最小的元素与数组第一个位置的元素交换，再从剩余数组中选择一个最小的元素与数组第二个位置的元素交换，不断重复直至完成排序。 时间复杂度：需要约n(n-1)/2次的比较和n-1次的交换，因此时间复杂度为O(n²)。时间复杂度与数组初始顺序无关。 空间复杂度：交换两个元素只需要一个辅助空间，空间复杂度为O(1)。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 18:10 * @Description 选择排序 */ public class SelectionSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int length = nums.length; for (int i = 0; i &lt; length - 1; i++) { int min = i; for (int j = i + 1; j &lt; length; j++) { if (less(nums[j], nums[min])) { min = j; } } swap(nums, i, min); } } public static void main(String[] args) { SelectionSort&lt;Integer> sort = new SelectionSort&lt;>(); Integer[] nums = {5, 4, 2, 3, 1}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 冒泡排序数组中相邻元素两两比较，遇到右侧元素小于左侧元素则交换，每过一轮循环，就可以让未排序的最大元素上浮至右侧。 时间复杂度：需要约n(n-1)/2次的比较和n(n-1)/2次的交换，因此时间复杂度为O(n²)。若在一轮循环中没有发生元素交换，则说明数组有序。 空间复杂度：交换两个元素只需要一个辅助空间，空间复杂度为O(1)。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 19:08 * @Description 冒泡排序 */ public class BubbleSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int length = nums.length; boolean isSorted = false; for (int i = length - 1; i > 0 &amp;&amp; !isSorted; i--) { isSorted = true; for (int j = 0; j &lt; i; j++) { if (less(nums[j + 1], nums[j])) { isSorted = false; swap(nums, j, j + 1); } } } } public static void main(String[] args) { BubbleSort&lt;Integer> sort = new BubbleSort&lt;>(); Integer[] nums = {2, 6, 3, 4, 9}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 插入排序将当前元素插入到左侧已经排序的数组中，使得插入后的左侧数组仍是井井有条的。 时间复杂度：需要约n(n-1)/2次的比较和n(n-1)/2次的交换，因此时间复杂度为O(n²)。时间复杂度取决于数组的初始顺序，若数组已经部分有序，则逆序较少，需要交换的次数也就较少，时间复杂度较低，最低为O(n)。 空间复杂度：交换两个元素只需要一个辅助空间，空间复杂度为O(1)。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 20:26 * @Description 插入排序 */ public class BubbleSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int length = nums.length; for (int i = 1; i &lt; length; i++) { for (int j = i; j > 0 &amp;&amp; less(nums[j], nums[j - 1]); j--) { swap(nums, j, j - 1); } } } public static void main(String[] args) { BubbleSort&lt;Integer> sort = new BubbleSort&lt;>(); Integer[] nums = {2, 6, 3, 4, 9}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 希尔排序对于大规模数组，插入排序速度就不是很理想，插入排序由于每次只能将逆序数量减1，因此只适合规模不大的数组排序。希尔排序的出现就是为了解决这种问题，希尔排序每次减少的逆序数量大于插入排序，它通过使用插入排序对间隔h的序列进行排序，然后不断的减少h的值直至另h=1时，整个数组就是有序的。 时间复杂度：希尔排序的运行时间小于平方级别(大约为n的1点几次方)。 空间复杂度：交换两个元素只需要一个辅助空间，空间复杂度为O(1)。 /** * @Author 喵粮都输光了 * @Date 2020/3/24 22:27 * @Description 希尔排序 */ public class ShellSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int length = nums.length; int h = 1; while (h &lt; length / 3) { h = 3 * h + 1; } while (h >= 1) { for (int i = h; i &lt; length; i++) { for (int j = i; j >= h &amp;&amp; less(nums[j], nums[j - h]); j -= h) { swap(nums, j, j - h); } } h = h / 3; } } public static void main(String[] args) { ShellSort&lt;Integer> sort = new ShellSort&lt;>(); Integer[] nums = {2, 6, 3, 4, 9}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 归并排序归并排序通过将一个数组分成两部分，分别对其进行排序然后归并起来，其时间复杂度为O(nlogn)。归并排序常用于大规模数组，在小规模数组上可能不如插入排序快。 归并方法将两个已排序数组归并称一个。 /** * 排序用复制数组 */ private T[] temp; /** * 归并 * @param nums 数组 * @param lo 开始下标 * @param mid 中点下标 * @param hi 结束下标 */ private void merge(T[] nums, int lo, int mid, int hi) { int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) { temp[k] = nums[k]; } for (int k = lo; k &lt;= hi; k++) { if (i > mid) { nums[k] = temp[j++]; } else if (j > hi) { nums[k] = temp[i++]; } else if (less(temp[j], temp[i])) { nums[k] = temp[j++]; } else { nums[k] = temp[i++]; } } } 自顶向下归并排序将大数组对半分求解，即不断的对半分将数组分成两两一组然后通过merge方法排序合并。 @Override public void sort(T[] nums) { temp = (T[]) new Comparable[nums.length]; sort(nums, 0, nums.length - 1); } /** * 递归排序各部分数组 * @param nums 数组 * @param lo 开始下标 * @param hi 结束下标 */ private void sort(T[] nums, int lo, int hi) { if (hi &lt;= lo) { return; } int mid = lo + (hi - lo) / 2; sort(nums, lo, mid); sort(nums, mid + 1, hi); merge(nums, lo, mid, hi); } 自底向上归并排序将微型数组进行归并，然后成对归并得到的微型数组。 @Override public void sort(T[] nums) { int length = nums.length; temp = (T[]) new Comparable[length]; for (int size = 1; size &lt; length; size += size) { for (int lo = 0; lo &lt; length - size; lo += 2 * size) { merge(nums, lo, lo + size - 1, Math.min(lo + 2 * size - 1, length - 1)); } } } 快速排序快速排序(Quick Sort)和归并排序有点儿类似，只不过归并排序是对半分求解而快速排序是通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，完成这两个子数组排序就完成了整个数组的排序。 时间复杂度：快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的，其时间复杂度为 O(nlogn)。最坏的情况下切分元素选择的是最小元素，此时时间复杂度为 O(n²)。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。 快速排序算法@Override public void sort(T[] nums) { shuffle(nums); sort(nums, 0, nums.length - 1); } /** * 递归排序各部分数组 * * @param nums 数组 * @param lo 开始下标 * @param hi 结束下标 */ private void sort(T[] nums, int lo, int hi) { if (hi &lt;= lo) { return; } int partition = partition(nums, lo, hi); sort(nums, lo, partition - 1); sort(nums, partition + 1, hi); } /** * 打乱重组数组，消除对输入的依赖 * @param nums 数组洗牌 */ private void shuffle(T[] nums) { List&lt;Comparable&lt;T>> list = Arrays.asList(nums); Collections.shuffle(list); list.toArray(nums); } 切分元素选择 直接取第一位作为切分元素。 /** * 取数组第一个元素作为切分元素 * @param nums 数组 * @param lo 开始下标 * @param hi 结束下表 * @return 切分元素下标 */ private int partition(T[] nums, int lo, int hi) { int i = lo, j = hi + 1; T partition = nums[lo]; while (true) { while (less(nums[++i], partition) &amp;&amp; i != hi) { } while (less(partition, nums[--j]) &amp;&amp; j != lo) { } if (i >= j) { break; } swap(nums, i, j); } swap(nums, lo, j); return j; } 三数取中 切分元素最好的情况就是取数组的中位数，但是计算中位数的代价很高。因此通常随机取3个元素，然后将大小其中的元素作为切分元素。 三向切分 对于有大量重复元素的数组，可以将数组切分为三部分，分别对应于小于、等于和大于切分元素。三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。 /** * 三向切分递归排序各部分数组 * @param nums 数组 * @param lo 开始下标 * @param hi 结束下标 */ private void sort(T[] nums, int lo, int hi) { if (hi &lt;= lo) { return; } int lt = lo, i = lo + 1, gt = hi; T partition = nums[lo]; while (i &lt;= gt) { int cmp = nums[i].compareTo(partition); if (cmp &lt; 0) { swap(nums, lt++, i++); } else if (cmp > 0) { swap(nums, i, gt--); } else { i++; } } sort(nums, lo, lt - 1); sort(nums, gt + 1, hi); } 堆排序堆在堆的完全二叉树中，每个结点的值都小于等于它的父结点的值。因为堆是完全二叉树，所以可以通过数组来表示。位置k的结点的父节点位置为 k/2，其两个子结点位置分别为 2k 和 2k+1。数组索引从1开始，方便描述结点位置关系。 /** * @Author 喵粮都输光了 * @Date 2020/3/25 12:05 * @Description 堆 */ public class Heap&lt;T extends Comparable&lt;T>> { /** * 堆主体 */ private T[] heap; /** * 当前元素个数 */ private int num; public Heap(int maxNum) { heap = (T[]) new Comparable[maxNum + 1]; num = 0; } /** * 是否为空 * @return true or false */ public boolean isEmpty() { return num == 0; } /** * 当前栈所包含的元素个数 * @return 元素个数 */ public int length() { return num; } /** * 传入的第一个元素是否比第二个元素小 * @param i 第一个元素下标 * @param j 第二个元素下标 * @return true or false */ private boolean less(int i, int j) { return heap[i].compareTo(heap[j]) &lt; 0; } /** * 交换数组中两个元素 * @param i 下标i * @param j 下标j */ private void swap(int i, int j) { T temp = heap[i]; heap[i] = heap[j]; heap[j] = temp; } /** * 一个元素插入可能会破坏堆的有序状态，上浮操作将大的元素上浮 * @param k 插入的结点 */ private void swim(int k) { while (k > 1 &amp;&amp; less(k / 2, k)) { swap(k / 2, k); k = k / 2; } } /** * 一个元素插入可能会破坏堆的有序状态，下沉操作将小的元素下沉 * @param k 插入的结点 */ private void sink(int k) { while (2 * k &lt;= num) { int j = 2 * k; if (j &lt; num &amp;&amp; less(j, j + 1)) { j++; } if (!less(k, j)) { break; } swap(k, j); k = j; } } /** * 插入元素 * @param elem 需要插入的元素 */ public void insert(T elem) { heap[++num] = elem; swim(num); } /** * 删除最大元素 * @return 返回删除的元素 */ public T delMax() { T max = heap[1]; swap(1, num--); heap[num + 1] = null; sink(1); return max; } public static void main(String[] args) { Heap&lt;Integer> sort = new Heap&lt;>(5); sort.insert(3); sort.insert(2); sort.insert(4); sort.insert(1); sort.insert(5); for (int i = 0; i &lt; 5; i++) { System.out.println(sort.delMax()); } } } 排序无序数组建立堆最简单的方法就是从左至右遍历数组进行上浮操作。稍微复杂一点但是更高效的方法是从右至左遍历进行下沉操作，叶子节点不需要进行下沉操作，所以只需要遍历一般元素即可，比上浮建立的方法快一倍呢。 /** * @Author 喵粮都输光了 * @Date 2020/3/25 13:25 * @Description 堆排序 */ public class HeapSort&lt;T extends Comparable&lt;T>> extends BaseSort&lt;T> { @Override public void sort(T[] nums) { int num = nums.length - 1; // 构造堆有序 for (int k = num / 2; k >= 1; k--) { sink(nums, k, num); } // 最大元素与最后一个元素交换之后进行下沉操作重新变成堆有序 while (num > 1) { swap(nums, 1, num--); sink(nums, 1, num); } } /** * 一个元素插入可能会破坏堆的有序状态，下沉操作将小的元素下沉 * @param k 插入的结点 */ private void sink(T[] nums, int k, int num) { while (k * 2 &lt;= num) { int j = k * 2; if (j + 1 &lt;= num &amp;&amp; less(nums[j], nums[j + 1])) { j++; } if (!less(nums[k], nums[j])) { break; } swap(nums, k, j); k = j; } } public static void main(String[] args) { HeapSort&lt;Integer> sort = new HeapSort&lt;>(); Integer[] nums = {0, 2, 6, 3, 4, 9}; sort.sort(nums); for (int num : nums) { System.out.println(num); } } } 排序算法对比 算法 稳定性 时间复杂度 空间复杂度 备注 选择排序 × O(n²) O(1) 冒泡排序 √ O(n²) O(1) 插入排序 √ O(n)~O(n²) O(1) 时间复杂度与输入元素排列情况有关。 希尔排序 × O(n的一点几次方) O(1) 插入排序改良版，依次减少大于一个逆序组。 归并排序 √ O(nlogn) O(n) 需要额外数组复制原数组元素。 快速排序 × O(nlogn) O(lgn) 空间复杂度与递归深度有关。 三向快速排序 × O(n)~O(nlogn) O(lgn) 专门用于处理数组中含大量重复元素的情况。 堆排序 × O(nlogn) O(1) 通常使用快速排序，其时间复杂度 O(cnlogn) 的常数 c 通常比其他排序小；当出现大量重复元素时使用三向快速排序，因为它的时间复杂度可能达到O(n)。 JAVA 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向快速排序，对于引用类型使用归并排序。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://blog.kuukokawaii.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构之图","date":"2020-03-22T04:49:06.000Z","path":"posts/f932ba85/","text":"图$($Graph$)$由顶点$($V, vertex$)$和表示顶点之间关系的边$($E, edge, 弧$)$所组成。$V(G)$和$E(G)$分别表示图G的顶点集和边集，$E(G)$可为空集。 基本术语设n为图中顶点数目，e为表示边的数目。 子图 一个图的顶点集和边集完全包含另一张图的顶点集和边集。 无向完全图和有向完全图 完全图即顶点集中每两个顶点之间都至少有一条边，若有一条边则称为无向完全图，有两条互相指向对方的边则称为有向完全图。有n个顶点的无向完全图，具有$\\frac{n(n-1)}{2}$条边，有向完全图的边数是其两倍，为$n(n-1)$。 稀疏图和稠密图 边数很少$(e\\lt nlog_2n)$的图称为稀疏图，反之称为稠密图。 邻接点 无向图中，若两顶点之间有边则称这两个点相邻接。 度、入度和出度 无向图一个顶点有几条边，其度就是几，记作TD$($v$)$。有向图分为入度和出度，入度即其他顶点指向该顶点的边数，记作ID$($v$)$；出度即该顶点指向其他顶点的边数，记作OD$($v$)$；有向图的度等于入度加出度。 路径和路径长度 路径即一个顶点到另一个顶点经过的顶点的集合。路径长度是一条路径上经过的边的数目。有向图其路径也是有向的。 回路或环 第一个顶点和最后一个顶点相同的路径。 简单路径、简单回路或简单环 简单路径即序列中顶点不重复出现的路径。除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路或简单环。 连通、连通图和连通分量 若顶点v到顶点v’有路径，则称v和v’是连通的。若一张图任意两个顶点之间都是连通的，则该图是连通图。连通分量即无向图中的极大连通子图。 强连通图和强连通分量 在一张有向图中，对于任意两个顶点v和v’，存在v到v’和v’到v都存在路径，则该有向图是强连通图。有向图中的极大强连通子图就是有向图的强连通分量$($有向图不一定要是强连通图$)$。 连通图的生成树 一个包含了图中全部顶点的极小连通子图，且仅拥有足以构成一棵树的n-1条边，该连通子图就称为连通图的生成树。 有向树和生成森林 有向树即有一个顶点入度为0，其余顶点入度为1的有向图。一个有向图的生成树即由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的边。 图的存储结构邻接矩阵 邻接矩阵$($Adjacency Matrix$)$是表示顶点之间相邻关系的矩阵。可以看作是一个矩阵，其行依次代表顶点$v_1, \\dots, v_n$，其列也分别代表顶点$v_1, \\dots, v_n$。因此可以用一个二维数组来存储边相关信息，一个一维数组存储顶点信息。 优点 缺点 邻接矩阵 1.便于计算两个顶点之间是否有边；2.便于计算各个顶点之间的度，例如行和就是该顶点的入度，列和就是该顶点的出度。 1.不利于增删顶点；不便统计边的条数，每次统计需要扫描整个表，时间复杂度为$O(n^2)$；2.空间复杂度为$O(n^2)$；适合表示稠密图。 具体代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/23 10:27 * @Description 有向图邻接矩阵 */ public class AdjacencyMatrix { /** * 邻接矩阵主体 */ private int[][] arcs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 顶点表 */ private List&lt;Object> vexs; /** * 初始化一个空邻接矩阵 * @param vexMaxNum 图总顶点数 */ public AdjacencyMatrix(int vexMaxNum) { this.vexMaxNum = vexMaxNum; arcNum = 0; arcs = new int[vexMaxNum][vexMaxNum]; vexs = new ArrayList&lt;>(vexMaxNum); } /** * 返回顶点在图中所在位置(下标) * @param vex 顶点 * @return 下标，-1为空 */ public int locateVex(Object vex) { if (vexs.contains(vex)) { return vexs.indexOf(vex); } else { return -1; } } /** * 根据下标获取顶点 * * @param index 顶点下标 * @return 顶点 */ public Object getVex(int index) { if (index >= vexs.size()) { throw new ArrayIndexOutOfBoundsException(\"没有该顶点\"); } return vexs.get(index); } /** * 将顶点加入顶点表 * @param vex 顶点 */ public void insertVex(Object vex) { // 满了直接返回 if (vexMaxNum == vexs.size()) { throw new ArrayIndexOutOfBoundsException(\"顶点表满了\"); } vexs.add(vex); } /** * 根据顶点下标删除顶点 * @param index 顶点下标 */ public void deleteVex(int index) { if (vexs.size() == 0) { throw new ArrayIndexOutOfBoundsException(\"顶点为空\"); } vexs.remove(index); // 删除边表中该顶点所在行列 int[][] finalArcs = new int[arcs.length][arcs.length]; for (int i = 0, fi = i; i &lt; arcs.length; i++) { if (i != index) { for (int j = 0, fj = j; j &lt; arcs.length; j++) { if (j != index) { finalArcs[fi][fj] = arcs[i][j]; fj++; } } fi++; } } arcs = finalArcs; } /** * 插入顶点1和顶点2的边 * @param v1Index 顶点1 * @param v2Index 顶点2 */ public void insertArc(int v1Index, int v2Index) { // 无向图边最多为顶点数*(顶点数-1)/2，有向图边数是无向图边数*2 if (arcNum == vexs.size() * (vexs.size() - 1)) { throw new ArrayIndexOutOfBoundsException(\"已达顶点所能拥有的最大边数\"); } arcs[v1Index][v2Index]++; arcNum++; } /** * 删除顶点1和顶点2的边 * @param v1Index 顶点1 * @param v2Index 顶点2 */ public void deleteArc(int v1Index, int v2Index) { if (arcNum == 0) { throw new ArrayIndexOutOfBoundsException(\"图中连一条边都没有\"); } if (arcs[v1Index][v2Index] != 0) { arcs[v1Index][v2Index]--; } arcNum--; } /** * 根据顶点下标返回该顶点的第一个邻接顶点下标 * @param index 顶点下标 * @return 邻接顶点下标，-1为空。 */ public int firstAdjVex(int index) { // 列和表示出度 for (int i = 0; i &lt; vexs.size(); i++) { if (arcs[i][index] != 0) { return i; } } return -1; } /** * 返回顶点v1相对于其邻接顶点v2 * @param v1Index 顶点v1 * @param v2Index 顶点v1的一个邻接顶点v2 * @return 下一个邻接顶点下标 */ public int nextAdjVex(int v1Index, int v2Index) { // 列和表示出度 for (int i = v2Index + 1; i &lt; vexs.size(); i++) { if (arcs[i][v1Index] != 0) { return i; } } return -1; } } 邻接表 邻接表$($Adjacency List$)$由表头结点表和边表组成： 表头结点表使用一维数组存储表头结点，而表头结点包含data$($数据域$)$和firstarc$($指向邻接结点$)$。 边表结点包含adjvex$($邻接点域，与表头结点中顶点邻接的顶点的位置$)$、info$($边相关信息，如权值$)$和nextarc$($与表头结点中顶点邻接的下一个邻接结点$)$。 优点 缺点 邻接表 1. 便于增删顶点；2.便于统计边的数目，按定点表顺序扫描所有边表即可获得数目，其时间复杂度为$O(n+e)$；3.空间效率高，有向图的边表结点为e个，无向图边表结点为2e个，其空间复杂度为$O(n+e)$，适合表示稀疏图。 1.不便于判断顶点之间是否有边。2.不便于计算有向图各个顶点的度。在有向图中遍历某个表头结点的边表是该顶点的出度，如果要获得入度则需要遍历全表，可以为邻接表建立逆邻接表获得入度。（逆邻接表就是边表存储该顶点的入度，但是获取出度困难。） 具体代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:31 * @Description 边 */ public class Edge { /** * 弧尾 */ VexNode start; /** * 弧头 */ VexNode end; public Edge(VexNode start, VexNode end) { this.start = start; this.end = end; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:33 * @Description 表头结点 */ public class VexNode { /** * 顶点包含数据 */ Object data; /** * 与该顶点邻接的第一个边 */ ArcNode firstArc; public VexNode(Object data, ArcNode firstArc) { this.data = data; this.firstArc = firstArc; } public VexNode(Object data) { this.data = data; firstArc = null; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:33 * @Description 边表结点 */ public class ArcNode { /** * 边相关信息，如权值 */ int info; /** * 邻接点域，与表头结点中顶点邻接的顶点的位置 */ VexNode adjVex; /** * 与表头结点中顶点邻接的下一个边结点 */ ArcNode nextArc; public ArcNode(int info, VexNode adjVex, ArcNode nextArc) { this.info = info; this.adjVex = adjVex; this.nextArc = nextArc; } public ArcNode(VexNode adjVex, ArcNode nextArc) { info = 1; this.adjVex = adjVex; this.nextArc = nextArc; } public ArcNode(VexNode adjVex) { info = 1; this.adjVex = adjVex; this.nextArc = null; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 12:02 * @Description 邻接表 */ public class AdjacencyList { /** * 顶点结点表 */ private List&lt;VexNode> vexs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 根据顶点集和边集初始化邻接表 * @param vexs 顶点集 * @param edges 边集 */ public AdjacencyList(List&lt;VexNode> vexs, List&lt;Edge> edges) { if (vexs == null || vexs.size() == 0) { return; } vexMaxNum = vexs.size(); // 将顶点集的顶点存入顶点结点表 this.vexs = vexs; // 将边信息存入边结点，并与其邻接点相连 if (edges != null) { for (Edge edge : edges) { VexNode startNode = edge.start; ArcNode arcNode = new ArcNode(edge.end); arcNode.nextArc = startNode.firstArc; startNode.firstArc = arcNode; arcNum++; } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:46 * @Description 测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(1); VexNode v2 = new VexNode(2); VexNode v3 = new VexNode(3); VexNode v4 = new VexNode(4); List&lt;VexNode> vexs = new ArrayList&lt;>(4); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); List&lt;Edge> edges = new ArrayList&lt;>(4); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v3)); edges.add(new Edge(v4, v2)); edges.add(new Edge(v4, v3)); new AdjacencyList(vexs, edges); } } 十字链表 十字链表$($Orthogonal List$)$相当于有向图的邻接表和逆邻接表结合所得到的一种链表。它由顶点结点和边结点组成： 顶点结点包含data$($数据域$)$、firstin$($指向以该顶点为弧头的顶点，即该顶点的入度表$)$和firstout$($指向以该顶点为弧尾的顶点，即该顶点的出度表$)$。 边结点包含tailvex$($尾域，弧尾指向的结点$)$、headvex$($头域，弧头指向的结点$)$、hlink$($头链域，以头域所指顶点为弧头的下一个结点，即头域所指结点的入度表$)$、tlink$($尾链域，以尾域所指顶点为弧尾的下一个结点，即尾域所指结点的出度表$)$和info$($边相关信息，如权值$)$。 优点：时间复杂度和邻接表一样都是$O(n+e)$，且容易求得顶点的出度和入度。 具体代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:31 * @Description 边 */ public class Edge { /** * 弧尾 */ VexNode start; /** * 弧头 */ VexNode end; public Edge(VexNode start, VexNode end) { this.start = start; this.end = end; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:59 * @Description 表头结点 */ public class VexNode { /** * 顶点包含数据 */ Object data; /** * 指向以该顶点为弧头的边，即该顶点的入度表 */ ArcNode firstIn; /** * 指向以该顶点为弧尾的边，即该顶点的出度表 */ ArcNode firstOut; public VexNode(Object data, ArcNode firstIn, ArcNode firstOut) { this.data = data; this.firstIn = firstIn; this.firstOut = firstOut; } public VexNode(Object data) { this.data = data; this.firstIn = null; this.firstOut = null; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 14:00 * @Description 边表结点 */ public class ArcNode { /** * 边相关信息，如权值 */ int info; /** * 尾域，弧尾指向的结点 */ VexNode tailVex; /** * 头域，弧头指向的结点 */ VexNode headVex; /** * 头链域，以头域所指顶点为弧头的下一个结点，即头域所指结点的入度表 */ ArcNode headLink; /** * 尾链域，以尾域所指顶点为弧尾的下一个结点，即尾域所指结点的出度表 */ ArcNode tailLink; public ArcNode(int info, VexNode tailVex, VexNode headVex, ArcNode headLink, ArcNode tailLink) { this.info = info; this.tailVex = tailVex; this.headVex = headVex; this.headLink = headLink; this.tailLink = tailLink; } public ArcNode(VexNode tailVex, VexNode headVex, ArcNode headLink, ArcNode tailLink) { this.info = 1; this.tailVex = tailVex; this.headVex = headVex; this.headLink = headLink; this.tailLink = tailLink; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 14:05 * @Description 十字链表 */ public class OrthogonalList { /** * 顶点结点表 */ private List&lt;VexNode> vexs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 根据顶点集和边集初始化十字链表 * @param vexs 顶点集 * @param edges 边集 */ public OrthogonalList(List&lt;VexNode> vexs, List&lt;Edge> edges) { if (vexs == null || vexs.size() == 0) { return; } vexMaxNum = vexs.size(); // 将顶点集的顶点存入顶点结点表 this.vexs = vexs; // 将边信息存入边结点，并与其邻接点相连 if (edges != null) { for (Edge edge : edges) { // edge.start是弧尾 VexNode startNode = edge.start; // edge.end是弧头 VexNode endNode = edge.end; // 参数分别为尾域、头域、头链域、尾链域， ArcNode arcNode = new ArcNode(startNode, endNode, endNode.firstIn, startNode.firstOut); // 指向下一个出度结点 startNode.firstOut = arcNode; // 指向下一个入度结点 endNode.firstIn = arcNode; arcNum++; } } } /** * 输出 */ public void print() { System.out.println(\"出\"); for (VexNode vexNode : vexs) { System.out.print(vexNode.data + \" -> \"); ArcNode arcNode = vexNode.firstOut; while (arcNode != null) { System.out.print(arcNode.headVex.data + \" -> \"); arcNode = arcNode.tailLink; } System.out.println(\"\\n\"); } System.out.println(\"入\"); for (VexNode vexNode : vexs) { System.out.print(vexNode.data + \" &lt;- \"); ArcNode arcNode = vexNode.firstIn; while (arcNode != null) { System.out.print(arcNode.tailVex.data + \" &lt;- \"); arcNode = arcNode.headLink; } System.out.println(\"\\n\"); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/19 10:37 * @Description 算法测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(\"v1\"); VexNode v2 = new VexNode(\"v2\"); VexNode v3 = new VexNode(\"v3\"); VexNode v4 = new VexNode(\"v4\"); List&lt;VexNode> vexs = new ArrayList&lt;>(4); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); List&lt;Edge> edges = new ArrayList&lt;>(4); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v3)); edges.add(new Edge(v4, v2)); edges.add(new Edge(v4, v3)); OrthogonalList s = new OrthogonalList(vexs, edges); s.print(); } } 邻接多重表 邻接多重表$($Adjacency Multilist$)$是无向图的另一种链式存储结构。在邻接表中同一条边所对应的两个顶点分别在两个不相同的边表中，当有需求寻找一条边的两个顶点时，采用邻接多重表操作图比较方便。邻接多重表和十字链表一样由顶点结点和边结点组成： 顶点结点包含firstedge$($指向第一条依附该顶点的边$)$和data$($数据域$)$。 边结点包含mark$($标记域，标记该边是否被搜索过$)$、ivex$($该边依附的顶点i$)$、ilink$($指向依附于顶点i的另一条边$)$、jvex$($该边依附的顶点j$)$、jlink$($指向依附于顶点j的另一条边$)$和info$($边相关信息，如权值$)$。 优点：邻接多重表除了每个边结点比邻接表多边结点一个标记域，其所需存储量和邻接表相同。 具体代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/23 13:31 * @Description 边 */ public class Edge { /** * 弧尾 */ VexNode start; /** * 弧头 */ VexNode end; public Edge(VexNode start, VexNode end) { this.start = start; this.end = end; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 17:24 * @Description 表头结点 */ public class VexNode { /** * 顶点包含数据 */ Object data; /** * 指向第一条依附该顶点的边 */ ArcNode firstEdge; public VexNode(Object data, ArcNode firstEdge) { this.data = data; this.firstEdge = firstEdge; } public VexNode(Object data) { this.data = data; this.firstEdge = null; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 17:24 * @Description 边表结点 */ public class ArcNode { /** * 边相关信息，如权值 */ int info; /** * 标记域，是否被搜索过 */ boolean isSearched; /** * 该边依附的顶点i */ VexNode iVex; /** * 指向依附于顶点i的另一条边 */ ArcNode iLink; /** * 该边依附的顶点j */ VexNode jVex; /** * 指向依附于顶点j的另一条边 */ ArcNode jLink; public ArcNode(int info, VexNode iVex, ArcNode iLink, VexNode jVex, ArcNode jLink) { this.info = info; this.iVex = iVex; this.iLink = iLink; this.jVex = jVex; this.jLink = jLink; this.isSearched = false; } public ArcNode(VexNode iVex, ArcNode iLink, VexNode jVex, ArcNode jLink) { this.info = 1; this.iVex = iVex; this.iLink = iLink; this.jVex = jVex; this.jLink = jLink; this.isSearched = false; } } /** * @Author 喵粮都输光了 * @Date 2020/3/23 17:26 * @Description 邻接多重表 */ public class AdjacencyMultiList { /** * 顶点结点表 */ private List&lt;VexNode> vexs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 根据顶点集和边集初始化邻接多重表 * @param vexs 顶点集 * @param edges 边集 */ public AdjacencyMultiList(List&lt;VexNode> vexs, List&lt;Edge> edges) { if (vexs == null || vexs.size() == 0) { return; } vexMaxNum = vexs.size(); // 将顶点集的顶点存入顶点结点表 this.vexs = vexs; // 将边信息存入边结点，并与其邻接点相连 if (edges != null) { for (Edge edge : edges) { // edge.start是弧尾 VexNode startNode = edge.start; // edge.end是弧头 VexNode endNode = edge.end; // 创建这两个结点的边结点，两个顶点共用一条边 ArcNode arcNode = new ArcNode(startNode, startNode.firstEdge, endNode, endNode.firstEdge); // 弧头的另一个边 startNode.firstEdge = arcNode; // 弧尾的另一个边 endNode.firstEdge = arcNode; arcNum++; } } } /** * 输出 */ public void print() { for (VexNode vex : vexs) { System.out.print(vex.data + \" -> \"); ArcNode arcNode = vex.firstEdge; while (arcNode != null) { System.out.print(\" | \" + arcNode.iVex.data + \"-\" + arcNode.jVex.data + \" | -> \"); // 需要输出某个顶点的所有边，需要判断当前边的iVex还是jVex等于需要输出的结点来决定下一个访问iLink还是JLink。 if (vex == arcNode.iVex) { arcNode = arcNode.iLink; } else { arcNode = arcNode.jLink; } } System.out.println(\"\\n\"); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/19 10:37 * @Description 算法测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(\"v1\"); VexNode v2 = new VexNode(\"v2\"); VexNode v3 = new VexNode(\"v3\"); VexNode v4 = new VexNode(\"v4\"); VexNode v5 = new VexNode(\"v5\"); List&lt;VexNode> vexs = new ArrayList&lt;>(5); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); vexs.add(v5); List&lt;Edge> edges = new ArrayList&lt;>(5); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v4)); edges.add(new Edge(v2, v3)); edges.add(new Edge(v2, v5)); edges.add(new Edge(v3, v5)); edges.add(new Edge(v3, v4)); AdjacencyMultiList adjacencyMultiList = new AdjacencyMultiList(vexs, edges); adjacencyMultiList.print(); } } 图的遍历深度优先搜索 深度优先搜索$($Depth First Search, DFS$)$遍历思路$($类似树的先序遍历$)$：从图中某个顶点开始遍历，将遍历过的顶点标上已遍历的标记，随意选择一个邻接顶点遍历它并选择这个顶点的邻接顶点遍历，不断重复，当遍历到某个顶点发现这个顶点没有未标记的邻接顶点时就往回退返回上一个邻接顶点，从上一个邻接顶点选择其他未标记的邻接顶点遍历，以此类推直到图中所有邻接顶点都标记过了遍历就完成了。通过深度优先搜索遍历路径构成的树称为深度优先生成树。 时间复杂度：当使用邻接矩阵存储时，每个顶点都要遍历n次寻找邻接顶点，其时间复杂度为$O(n^2)$；当用邻接表存储时，每个顶点只需要查找其相连的边即可，即查找邻接顶点时间复杂度为$O(e)$，所以整体遍历时间复杂度为$O(n+e)$。 算法实现：通常使用递归实现，此处实现遍历非连通的邻接表结构的图。 /** * @Author 喵粮都输光了 * @Date 2020/3/23 12:02 * @Description 邻接表 */ public class AdjacencyList { /** * 顶点结点表 */ private List&lt;VexNode> vexs; /** * 图最大顶点数和当前的边数 */ private int vexMaxNum, arcNum; /** * 存储顶点是否被遍历过的信息 */ private boolean[] state; /** * 根据顶点集和边集初始化邻接表 * @param vexs 顶点集 * @param edges 边集 */ public AdjacencyList(List&lt;VexNode> vexs, List&lt;Edge> edges) { if (vexs == null || vexs.size() == 0) { return; } vexMaxNum = vexs.size(); // 将顶点集的顶点存入顶点结点表 this.vexs = vexs; // 将边信息存入边结点，并与其邻接点相连 if (edges != null) { for (Edge edge : edges) { VexNode startNode = edge.start; ArcNode arcNode = new ArcNode(edge.end); arcNode.nextArc = startNode.firstArc; startNode.firstArc = arcNode; arcNum++; } } } /** * 查找顶点所在位置 * @param vexNode 需要查找的顶点 * @return 顶点下标 */ public int getVexIndex(VexNode vexNode) { return vexs.indexOf(vexNode); } /** * 顶点是否被遍历 * @param vexNode 顶点 * @return true or false */ private boolean isVisited(VexNode vexNode) { return state[getVexIndex(vexNode)]; } /** * 深度优先遍历 */ public void dfsTraverse() { state = new boolean[vexMaxNum]; // 若图非连通，遍历所有子连通图 for (VexNode vexNode : vexs) { if (!isVisited(vexNode)) { dfs(vexNode); } } } /** * 深度优先遍历子图 * @param vexNode 需要遍历的结点 */ private void dfs(VexNode vexNode) { // 将遍历顶点设置称true state[getVexIndex(vexNode)] = true; System.out.println(vexNode.data); // 寻找下一条边的另一个顶点，判断是否遍历过，若未遍历过则递归遍历，遍历过就寻找下一个邻接点 for (ArcNode arcNode = vexNode.firstArc; arcNode != null; arcNode = arcNode.nextArc) { vexNode = arcNode.adjVex; if (!isVisited(vexNode)) { dfs(vexNode); } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/24 10:18 * @Description 测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(\"v1\"); VexNode v2 = new VexNode(\"v2\"); VexNode v3 = new VexNode(\"v3\"); VexNode v4 = new VexNode(\"v4\"); VexNode v5 = new VexNode(\"v5\"); List&lt;VexNode> vexs = new ArrayList&lt;>(4); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); vexs.add(v5); List&lt;Edge> edges = new ArrayList&lt;>(4); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v3)); edges.add(new Edge(v4, v2)); edges.add(new Edge(v4, v3)); AdjacencyList adjacencyList = new AdjacencyList(vexs, edges); System.out.println(\"深度\"); adjacencyList.dfsTraverse(); } } 广度优先搜索 广度优先搜索$($Breadth Firsh Search, BFS$)$遍历思路$($类似树的层序遍历$)$：从图中某个顶点开始遍历，将遍历过的顶点标上已遍历的标记，遍历所有该顶点的邻接顶点，然后分别从刚访问过的邻接顶点出发依次访问它们的邻接顶点，直到图中所有邻接顶点都标记过了遍历就完成了。通过广度优先搜索遍历路径构成的树称为广度优先生成树。 时间复杂度：时间复杂度和深度优先搜索相同，使用邻接矩阵时时间复杂度为$O(n^2)$，使用连接表时时间复杂度为$O(n+e)$。因此两者的区别仅仅是遍历顺序不同而已。 算法实现：通常使用队列实现，此处实现遍历非连通的邻接表结构的图。 /** * 广度优先遍历 */ public void bfsTraverse() { state = new boolean[vexMaxNum]; // 若图非连通，遍历所有子连通图 for (VexNode vexNode : vexs) { if (!isVisited(vexNode)) { bfs(vexNode); } } } /** * 广度优先遍历子图 * @param rootNode 需要遍历的结点 */ private void bfs(VexNode rootNode) { Queue&lt;VexNode> queue = new LinkedList&lt;>(); queue.offer(rootNode); while (!queue.isEmpty()) { rootNode = queue.poll(); state[getVexIndex(rootNode)] = true; System.out.println(rootNode.data); for (ArcNode arcNode = rootNode.firstArc; arcNode != null; arcNode = arcNode.nextArc) { rootNode = arcNode.adjVex; if (!isVisited(rootNode)) { queue.offer(rootNode); } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/24 10:18 * @Description 测试 */ public class Main { public static void main(String[] args) { VexNode v1 = new VexNode(\"v1\"); VexNode v2 = new VexNode(\"v2\"); VexNode v3 = new VexNode(\"v3\"); VexNode v4 = new VexNode(\"v4\"); VexNode v5 = new VexNode(\"v5\"); List&lt;VexNode> vexs = new ArrayList&lt;>(4); vexs.add(v1); vexs.add(v2); vexs.add(v3); vexs.add(v4); vexs.add(v5); List&lt;Edge> edges = new ArrayList&lt;>(4); edges.add(new Edge(v1, v2)); edges.add(new Edge(v1, v3)); edges.add(new Edge(v4, v2)); edges.add(new Edge(v4, v3)); AdjacencyList adjacencyList = new AdjacencyList(vexs, edges); System.out.println(\"广度\"); adjacencyList.dfsTraverse(); } } 常用图算法 最小生成树：又称为最小代价生成树$($Minimum Cost Spanning Tree$)$，是在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树。其常用算法有 Prim 算法和 Kruskal 算法。 最短路径：从一个顶点到另一个顶点之间各边代价之和最小的那条路径。在带权有向网中，第一个顶点称为源点$($Source$)$，最后一个顶点称为终点$($Destination$)$。其常用算法有 Dijkstra 算法和 Floyd 算法。 拓扑排序： 有向无环图$($Directed Acycline Graph, DAG$)$：一个无环的有向图。 AOV网$($Activity On Vertex Network$)$：用顶点表示活动，用弧表示活动之间的优先关系的有向无环图称为顶点表示活动的网。例如游戏中做某个任务，但是这个任务有多个前置任务，需要先做了前置任务才能进行该任务。 拓扑排序：将AOV网中所有顶点排成一个线性序列，该序列满足：若AOV网中由顶点$V_i$到顶点$V_j$有一条路径，则在该线性序列中的顶点$V_i$必定在顶点$V_j$之前。排序方法为：删除图中一个无前驱的顶点$($包括和该顶点有关的边$)$并输出顶点，重复直至图中无顶点为止。 关键路径： AOE网$($Activity On Edge Network$)$：用顶点表示事件，用弧表示活动，权表示活动持续的事件的带权有向无环图称为以边表示活动的网。 源点和汇点：网中有一个入度为零的点称为源点，也仅有一个出度为零的点称为汇点。 带权路径长度：一条路径各弧上的权值之和。 关键路径$($Critical Path$)$：从源点到汇点的带权路径长度最长的路径。 关键活动：在关键路径上的活动都称为关键活动。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之树","date":"2020-03-21T00:48:15.000Z","path":"posts/6c17d6bd/","text":"树树的定义树是n个结点的有限集，它可以是空树或非空树。对于非空树T： 最多一个根结点。 根结点的每一个孩子都是一颗子树。 基本术语 结点的度 结点拥有的子树个数。 树的度 树中各结点度的最大值。 祖先 从根到该结点所经分支上的所有结点。 子孙 以某节点为根的子树中的任一结点都是该结点的子孙。 层次 结点的高度（从一开始）。 堂兄弟 双亲在同一层的结点互为堂兄弟。 树的深度 树的高度（从一开始）。 有序树和无序树 无序树即忽略节点的信息，只考虑其拓扑结构的树，也就是说兄弟之间没有顺序关系，而有序树与之相法。 森林 树的集合（树的个数可为零）。 树的存储结构 双亲表示法：用一组连续的存储单元存储树的结点，每个结点都拥有数据域和双亲域（指向该结点的双亲）。很容易求得树的根和结点的双亲，但是求结点的孩子时需要遍历整个结构。 孩子表示法： 第一种方法：每个结点由数据域和多个指针域构成，每个指针域指向一颗子树的根结点，指针域的个数就是该树的度，但是树中不是每个结点的度都等于树的度，因此会造成很多指针域的浪费。一颗n个结点度为k的树必有$n(k-1)+1$个空链域。 第二种方法：每个结点由数据域、degree域（存储该结点的度）和多个指针域构成，这样不会造成空间的浪费，但是操作起来不是太方便。 第三种方法：用一组连续的存储单元存储树的结点，每个结点都有数据域和存储该结点孩子的单链表表头，这样很容易获得结点的所有孩子。可以对该结构进行扩展，每个结点都增加一个双亲域，很容易就能获得该结点的孩子和双亲。 孩子兄弟表示法：使用二叉链表做树的存储结构，结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，也就是说结点由数据域、指向第一个孩子结点的指针域和指向下一个兄弟结点的指针域构成。该结构非常容易寻找孩子结点，如果添加双亲域的话寻找双亲也非常便捷。 二叉树二叉树的定义二叉树与树类似，区别主要有如下两点： 二叉树每个结点最多只有两个子树，即结点的度小于等于二。 二叉树的子树有左右之分，其次序不能颠倒。 二叉树的性质 二叉树第i层上最多有$2^{i-1}$个结点。 推导：第一层有1个，第二层有2个，第三层有4个，到第n层有$a_n=a_1*q^(n-1)$（等比数列）。 深度为k的二叉树最多有$2^k-1$个结点。 推导：根据等比数列求和公式$S_n=a_1\\frac{1-q^n}{1-q}$，其中$q=2, a_1=1$，计算得$S_n=2^n-1$。 二叉树叶子结点个数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。 推导：设$n_1$是度为1的结点个数，n为总结点个数，则可得$n=n_0+n_1+n_2$。由于树的总分支条数加一等于树的总结点个数，以及度为1的结点有1条分支，度为2的结点有两条分支，可以得知$n=n1+2n_2+1$，两式相减可得度1和度2结点个数之间的关系公式。 满二叉树即深度为k且含有$2^k-1$个结点的二叉树。 完全二叉树即深度为k的二叉树，其1至k-1层是满二叉树，而在第k层上，所有叶子结点都连续集中在左侧（也就是说不可以存在只有右结点没有左节点的结点）。 具有n个结点的完全二叉树的深度为$\\lfloor log_2n \\rfloor+1$或$\\lceil log_2(n+1) \\rceil$。 推导：设深度为k的完全二叉树结点有n个，则n肯定大于等于k行结点的个数以及小于等于满二叉树总结点个数，也就是说$2^{k-1}≤n$和$n≤2^k-1$。对左式的两边加$log_2$计算得$k-1≤log_2n$，由于k是整数，$log_2n$可能是小数，因为是小于等于所以$log_2n$取下限得$\\lfloor log_2n \\rfloor+1$；对右式进行同样的方法计算得$log_2(n+1)≤k$，k是整数，k大于等于可能是小数的$log_2n$，所以对其取上限得$\\lceil log_2(n+1) \\rceil$。 按层序给一颗有n个结点的完全二叉树的结点编号，则对任一结点i有： 若$i=1$，则i是二叉树的根节点；若$i&gt;1$，则其双亲结点为$\\lfloor \\frac{i}{2} \\rfloor$。 若$2i&gt;n$，则i是叶子节点，否则其左孩子结点是$2i$。 若$2i+1&gt;n$，则i无右孩子，否则右孩子结点是$2i+1$。 二叉树的存储结构 顺序存储：对于完全二叉树来说即将所有结点按照层次顺序存储到连续的存储单元中；对于一般二叉树来说需要将其每个结点与完全二叉树上的结点一一对应进行存储，比如根结点有右孩子没有左孩子，则存储时数组下标1需要空出，0存储根节点而2存储右孩子。由此看来，顺序存储仅适合完全二叉树，一般二叉树会造成空间的极大浪费。 链式存储：二叉树链式存储分为二叉链表和三叉链表。 二叉链表：结点包含左孩子和右孩子指针域以及数据域。拥有n个结点的二叉链表中有n+1个空链域。 推导：二叉链表中每个叶子结点有两个空链域，度为零的结点有一个空链域，则空链域个数为$2n_0+n1$，通过公式$n=n_0+n_1+n_2$和$n_0=n_2+1$可以得到$2n_0+n1=n+1$。 三叉链表：结点比二叉链表的结点多一个双亲指针域。 二叉树的遍历二叉树的遍历即通过遍历得到二叉树中结点访问的线性序列，实现了非线性结构的线性化。根据访问结点的次序不同可得三种遍历：先序遍历、中序遍历、后序遍历，此外还有层序遍历，时间复杂度均为O(n)。先序遍历和中序遍历或后序遍历和中序遍历可以唯一确定一颗二叉树。 先序遍历：1.访问根节点；2.先序遍历左子树；3.先序遍历右子树。也就是中左右的顺序。 先序遍历递归算法： /** * 先序遍历递归实现 * @param root 根节点 */ public void preOrderTraverse(TreeNode root) { if (root != null) { // 访问根节点 System.out.println(root.data); // 先序遍历左子树 preOrderTraverse(root.left); // 先序遍历右子树 preOrderTraverse(root.right); } } 先序遍历非递归算法： /** * 先序遍历非递归实现 * @param root 根节点 */ public void preOrderTraverseStack(TreeNode root) { Stack&lt;TreeNode> stack = new Stack&lt;>(); TreeNode current = root; // 当前结点不为空就处理结点入栈，当前结点为空处理出栈为结点赋值，当前结点和栈都空处理完毕。 while (current != null || !stack.isEmpty()) { if (current != null) { // 先序打印根结点并将根结点入栈，当前节点赋值根结点的左结点。 System.out.println(current.data); stack.push(current); current = current.left; } else { // 左结点处理完毕，弹栈出来的是根节点，因为根节点处理过了此时将根节点的右结点压栈处理。 TreeNode temp = stack.pop(); current = temp.right; } } } 中序遍历：1.中序遍历左子树；2.访问根节点；3.中序遍历右子树。也就是左中右的顺序。 中序遍历递归算法： /** * 中序遍历递归实现 * @param root 根节点 */ public void inOrderTraverse(TreeNode root) { if (root != null) { // 中序遍历左子树 inOrderTraverse(root.left); // 访问根节点 System.out.println(root.data); // 中序遍历右子树 inOrderTraverse(root.right); } } 中序遍历非递归算法： /** * 中序遍历非递归实现 * @param root 根节点 */ public void inOrderTraverseStack(TreeNode root) { Stack&lt;TreeNode> stack = new Stack&lt;>(); TreeNode current = root; while (current != null || !stack.isEmpty()) { if (current != null) { // 压入根节点不打印，当前结点赋值左结点。 stack.push(current); current = current.left; } else { // 弹栈出来的是根结点，打印并给当前结点赋值该根结点的右结点。 TreeNode temp = stack.pop(); System.out.print(temp.data); current = temp.right; } } } 后序遍历：1.后序遍历左子树；2.后序遍历右子树；3.访问根节点。也就是左右中的顺序。 后序遍历递归算法： /** * 后序遍历递归实现 * @param root 根节点 */ public void postOrderTraverse(TreeNode root) { if (root != null) { // 后序遍历左子树 postOrderTraverse(root.left); // 后序遍历右子树 postOrderTraverse(root.right); // 访问根节点 System.out.println(root.data); } } 后序遍历非递归算法： /** * 后序遍历非递归实现 * @param root 根节点 */ public void postOrderTraverseStack(TreeNode root) { Stack&lt;TreeNode> stack = new Stack&lt;>(); TreeNode current, previous = null; stack.push(root); while (!stack.isEmpty()) { current = stack.peek(); /* * 判断两种情况： * 1.当前节点的左右结点是否为空，空就打印该结点并弹栈。 * 2.当前结点的左右结点有一个不为空时，判断上一个结点是否为空并且是不是该结点的孩子，如果是打印并弹栈。 */ if ((current.left == null &amp;&amp; current.right == null) || (previous != null &amp;&amp; (previous == current.left || previous == current.right))) { System.out.println(current.data); stack.pop(); previous = current; } else { // 如果当前结点有孩子结点，先处理左结点再处理右结点。因为栈后入先出，所以先压栈右再压栈左。 if (current.right != null) stack.push(current.right); if (current.left != null) stack.push(current.left); } } } 层序遍历：从上往下，从左往右进行遍历。 层序遍历实现： /** * 层序遍历 * @param root 根节点 */ public void levelOrderTraverse(TreeNode root) { // 排除根节点为空的情况 if (root == null) { return; } // 先进的结点先出，使用队列实现 Queue&lt;TreeNode> queue = new LinkedList&lt;TreeNode>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); System.out.println(node.data); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } 线索二叉树 n个结点的二叉链表就会有n+1个指针域被浪费，线索二叉树为了将浪费的指针域利用起来，将空指针域用来存储其该结点的直接前驱和直接后继（就是遍历的上一个结点和下一个结点），其中指向结点前驱和后继的指针称为线索。 线索二叉树的结点由左孩子（left）、右孩子（right）、数据域、左标记（leftIsThread）和右标记（rightIsThread）组成。以左标记为例，$leftIsThread=\\begin{cases}false&amp;left指向结点的左孩子\\\\true&amp;left指向结点的前驱 \\end{cases}$ 按照不同的遍历顺序进行线索化（即遍历二叉树将其变成线索二叉树的过程）可分为先序线索二叉树、中序线索二叉树和后序线索二叉树。中序线索二叉树具体代码如下： /** * @Author 喵粮都输光了 * @Date 2020/3/21 16:19 * @Description 线索二叉树 */ public class ThreadTree { private static class Node { /** * 左孩子 */ private Node left; /** * 左结点是否线索化，默认不是 */ private boolean leftIsThread; /** * 数据 */ private Object data; /** * 右结点是否线索化，默认不是 */ private boolean rightIsThread; /** * 右孩子 */ private Node right; public Node(Object data) { left = null; leftIsThread = false; this.data = data; rightIsThread = false; right = null; } } /** * 根节点 */ private Node root; /** * 上一个遍历到的结点 */ private Node pre; /** * 总结点数 */ private int length; public ThreadTree() { root = null; pre = null; length = 0; } /** * 初始化线索二叉树 * @param data 需要存储的数据 */ public ThreadTree(Object[] data) { // 此处传入下标1是为了方便二叉树创建时使用递归 root = createTree(data, 1); // 中序线索化 inOrderThread(root); pre = null; length = data.length; } /** * 创建二叉树 * @param data 数据 * @param index 数组开始下标加一 * @return 根结点 */ private Node createTree(Object[] data, int index) { // index 默认多了1，所以此处可以等于数组长度 if (index > data.length) { return null; } Node node = new Node(data[index - 1]); Node left = createTree(data, 2 * index); Node right = createTree(data, 2 * index + 1); node.left = left; node.right = right; return node; } /** * 中序线索二叉树（最左结点前驱是线索，最右结点后继不是线索） * @param root 需要线索化的二叉树根节点 */ private void inOrderThread(Node root) { if (root != null) { // 中序遍历线索化左子树 inOrderThread(root.left); // 左孩子为空设置其前驱。 if (root.left == null) { root.leftIsThread = true; root.left = pre; } // 若上一个结点不为空（特殊处理根结点的上一个结点）并且上一个结点的右孩子为空，设置上一个结点的后继为当前结点。 if (pre != null &amp;&amp; pre.right == null) { pre.rightIsThread = true; pre.right = root; } pre = root; // 中序遍历线索化右子树 inOrderThread(root.right); } } /** * 中序遍历线索二叉树，按照后继方式遍历。（找最左子结点开始） * @param root 需要遍历的二叉树根节点 */ private void inOrderTraversePost(Node root) { // 查找最左子结点，最左结点前驱是线索 while (root != null &amp;&amp; !root.leftIsThread) { root = root.left; } while (root != null) { System.out.println(root.data); if (root.rightIsThread) { // 如果是线索直接找后继 root = root.right; } else { // 如果右指针不是线索，找从右子树开始的最左结点 root = root.right; while (root != null &amp;&amp; !root.leftIsThread) { root = root.left; } } } } /** * 中序后继方式遍历线索化二叉树 */ public void inOrderTraversePost() { inOrderTraversePost(root); } /** * 中序遍历线索二叉树，按照前驱方式遍历。（找到最右结点开始倒序遍历） * @param root 需要遍历的二叉树根节点 */ private void inOrderTraversePre(Node root) { // 查找最右结点，最右结点后继不是线索 while (root.right != null &amp;&amp; !root.rightIsThread) { root = root.right; } while (root != null) { System.out.println(root.data); if (root.leftIsThread) { // 如果是线索直接找前驱 root = root.left; } else { // 如果左指针不是线索，找从左子树开始的最右结点 root = root.left; while (root.right != null &amp;&amp; !root.rightIsThread) { root = root.right; } } } } /** * 中序前驱方式遍历线索化二叉树 */ public void inOrderTraversePre() { inOrderTraversePre(root); } } 森林森林与二叉树的转换森林是树的集合，通过左结点取第一个孩子结点，右结点取第一个兄弟结点可以将森林转化成二叉树。反过来也可以将二叉树转化成森林。 树和森林的遍历 树的遍历：先根遍历树即先访问树的根结点再依次先根遍历根的每颗子树；后根遍历即先依次后跟遍历每颗子树再访问根结点。将树转化成二叉树（和森林转化二叉树方法一样），则对树的先根和后根遍历等同于二叉树的先序和中序遍历。 森林的遍历：先序遍历即从第一颗树开始依次先序遍历所有树；中序遍历即从第一棵树开始依次后跟遍历所有树。森林的先序和中序遍历等同于将该森林转化成的二叉树的先序和中序遍历。 哈夫曼树基本概念哈夫曼（Huffman）树又称为最优二叉树，是一类带权路径长度最短的树。其基本术语如下： 路径：一个结点到另一个结点之间的分支构成这两个结点之间的路径。 路径长度：一个结点到另一个结点之间经过的线（边或分支）的条数就是路径长度。 树的路径长度：从树根到每一个结点的路径长度之和。 权：赋予某个实体一个量，是对实体的某个或某些属性的数值化描述，分为结点权和边权。 结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。 树的带权路径长度：树中所有叶子结点的带权路径长度。 哈夫曼树：由带权叶子节点构造的带权路径长度WPL最小的二叉树。 构造算法 构造过程：用所有带权根节点构成一个森林，从森林中挑选两个权最小的作为新构造的二叉树的两个孩子结点，两个孩子结点的双亲结点为这两个孩子结点权的和。此时从森林中删除这两个孩子结点，并将新构造的二叉树放入森林，重复之前的操作知道森林构成一颗二叉树为止。 算法实现：哈夫曼树中只有度为2和0的结点，因此n个叶子结点的哈夫曼树共有2n-1个结点，可以将其存储在大小为2n-1的一维数组中。数组中每个单元存储一个树结点，树结点由weight（权重）、left（左孩子）和right（右孩子）构成。且为了实现方便，下标零一般不存储数据，并将叶子节点集中存储在下标1至n上。哈夫曼树构造具体代码如下： /** * @Author 喵粮都输光了 * @Date 2020/3/21 22:21 * @Description 哈夫曼树 */ public class HuffmanTree { public static class Node implements Comparable&lt;Node> { /** * 权重 */ private double weight; /** * 左孩子、右孩子 */ private Node left, right; public Node(double weight) { this.weight = weight; } @Override public int compareTo(Node o) { if (this.weight &lt; o.weight) { return -1; } else if (this.weight > o.weight) { return 1; } return 0; } @Override public String toString() { return \"weight:\" + this.weight + \"; \"; } } /** * 哈夫曼树根节点 */ private Node root; public HuffmanTree(List&lt;Node> nodes) { root = createTree(nodes); } /** * 构造哈夫曼树 * @param nodes 带权结点集合 * @return 哈夫曼树根结点 */ private Node createTree(List&lt;Node> nodes) { // 最后留下构成的二叉树根节点 while (nodes.size() > 1) { Collections.sort(nodes); Node left = nodes.get(0); Node right = nodes.get(1); Node parent = new Node(left.weight + right.weight); parent.left = left; parent.right = right; nodes.remove(left); nodes.remove(right); nodes.add(parent); } return nodes.get(0); } } 哈夫曼编码哈夫曼编码是一种可变长编码方式，常用于数据压缩。将字符出现频率作为该字符的权并构造其哈夫曼树，因此出现频率最高的结点离根结点最近，也就是说其编码位数越短，以此达到压缩数据的目的。哈夫曼编码具体代码如下： /** * @Author 喵粮都输光了 * @Date 2020/3/22 0:55 * @Description 哈夫曼编码 */ public class Huffman { private static class Node implements Comparable&lt;Node> { /** * 数据（字符） */ private char ch; /** * 出现频率 */ private int freq; /** * 左右孩子 */ private Node left, right; public Node(char ch, int freq, Node left, Node right) { this.ch = ch; this.freq = freq; this.left = left; this.right = right; } /** * 判断该结点是否是叶子结点 * @return true or false */ private boolean isLeaf() { return (left == null) &amp;&amp; (right == null); } @Override public int compareTo(Node o) { if (this.freq > o.freq) { return 1; } else if (this.freq &lt; o.freq) { return -1; } return 0; } } /** * 哈夫曼树根结点 */ private Node root; /** * 编码表 */ private Map&lt;Character, String> encodeTable = new Hashtable&lt;>(256); public Huffman(String s) { root = createHuffmanTree(s); encodeTable(root, \"\", encodeTable); } /** * 通过给定的字符串构建哈夫曼树 * @param s 给定字符串 * @return 哈夫曼树根结点 */ private Node createHuffmanTree(String s) { // 字符串为空直接返回 if (s == null || \"\".equals(s)) { return null; } // 统计单词出现频率 HashMap&lt;Character, Integer> maps = new HashMap&lt;>(256); for (char letter : s.toCharArray()) { maps.put(letter, maps.getOrDefault(letter, 0) + 1); } // 单词和其出现频率封装在Node中，并用list储存node List&lt;Node> nodes = new ArrayList&lt;>(); for (Map.Entry&lt;Character, Integer> map : maps.entrySet()) { nodes.add(new Node(map.getKey(), map.getValue(), null, null)); } // 构造哈夫曼树 while (nodes.size() > 1) { Collections.sort(nodes); Node left = nodes.get(0); Node right = nodes.get(1); Node parent = new Node('\\0', left.freq + right.freq, left, right); parent.left = left; parent.right = right; nodes.remove(left); nodes.remove(right); nodes.add(parent); } return nodes.get(0); } /** * 哈夫曼解码 * @param encodeString 需要解码的字符串 * @return 解码后的字符串 */ public String decode(String encodeString) { StringBuilder decodeString = new StringBuilder(); // 遍历字符串 for (int i = 0, start = i; i &lt; encodeString.length(); i++) { String nowString = encodeString.substring(start, i + 1); // 在编码表中查找子串是否存在 if (encodeTable.containsValue(nowString)) { for (Map.Entry&lt;Character, String> decode : encodeTable.entrySet()) { if (decode.getValue().equals(nowString)) { decodeString.append(decode.getKey()); } } start = i + 1; } } return decodeString.toString(); } /** * 哈夫曼编码 * @param s 需要编码的字符串 * @return 编码后的字符串 */ public String encode(String s) { StringBuilder encodedString = new StringBuilder(); // 获得编码表 for (char letter : s.toCharArray()) { encodedString.append(encodeTable.get(letter)); } return encodedString.toString(); } /** * 将字符编码存入编码表 * @param root 哈夫曼树根节点 * @param encoding 字符编码 * @param map 编码表 */ private void encodeTable(Node root, String encoding, Map&lt;Character, String> map) { if (root == null) { return; } // 是叶子结点就存储 if (root.isLeaf()) { map.put(root.ch, encoding); return; } // 递归左右结点 encodeTable(root.left, encoding + '0', map); encodeTable(root.right, encoding + '1', map); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之串、数组与广义表","date":"2020-03-20T14:41:27.000Z","path":"posts/2844cbbf/","text":"串 串（string或字符串）是内容受限的线性表，限定了表中的元素为字符。 串的两种基本存储结构为顺序存储和链式存储。通常采用顺序存储结构。 数组 数组是由类型相同的数据元素构成的有序集合，数组中存储的数据可以是带有结构的同一数据类型的数据。数组一般采用顺序存储结构，其存储方式也可分为按行存储(较多)和按列存储。 多维数组实质上是 n 个线性表的组合，其每一维都是一个线性表，因此多维数组可以看成是线性表的推广。 特殊矩阵压缩存储，可以将多个值相同的元只分配一个存储空间，对零元不分配空间。常见的有对称矩阵，三角矩阵和对角矩阵： 对称矩阵：一维数组array[k]与矩阵$a_{ij}$之间的对应关系：$$k=\\begin{cases}\\frac{i(i-1)}{2}+j-1&amp;当i≥j，\\\\ \\frac{j(j-1)}{2}+i-1&amp;当i\\lt j。 \\end{cases}$$对称矩阵只需要存储包含对角线及以上或者以下元素，因此存储空间可以从$n^2$减小到$\\frac{n(n+1)}{2}$。假设当作下三角来看，第一行1个元素，第二行2个元素，直到第n行n个元素。可以知道$a_{ij}$就是第1行到第i-1行的元素个数加上第i行的元素个数再减去一（一维数组下标从0开始），即$\\frac{i(i-1)}{2}+j-1$。由于对称矩阵是对称的，将刚得出的公式中的i和j互换即可获得一样的下标。 三角矩阵： 下三角矩阵：矩阵下三角(不含对角线)的元素均为某一常数或零。一维数组array[k]与矩阵$a_{ij}$之间的对应关系：$$k=\\begin{cases}\\frac{i(i-1)}{2}+j-1&amp;当i≥j，\\\\ \\frac{n(n+1)}{2}&amp;当i\\lt j。 \\end{cases}$$矩阵下三角第一行1个元素，第二行2个元素，直到n行n个元素。元素总和为$\\frac{n(n+1)}{2}$。因此当需要计算$a_{ij}$时，首先需要计算1至i-1行有多少个元素在加上第i行的j个元素，还要减一（一维数组下标从0开始）。均为某一常数或零就存储在最后一个位置上。 上三角矩阵：与下三角矩阵相反。一维数组array[k]与矩阵$a_{ij}$之间的对应关系：$$k=\\begin{cases}\\frac{(i-1)(2n-i+2)}{2}+(j-i) &amp;当i≤j，\\\\ \\frac{n(n+1)}{2} &amp;当i\\gt j。 \\end{cases}$$矩阵上三角第一行n个元素，第二行n-1个元素，直到第n行1个元素。由此可知这是一个等差数列，i行的元素个数为$n-i+1$个，再根据公式$S_n=\\frac{n(a_1+a_n)}{2}$可得1至i-1行有$\\frac{(i-1)(n+n-(i-1)+1)}{2}=\\frac{(i-1)(2n-i+2)}{2}$个元素，加上第i行的(j-i+1)个元素（看$a_{11}，j-i为0，还要加上1才能表示有一个元素$），还要减一（一维数组下标从0开始）。均为某一常数或零就存储在最后一个位置上。 对角矩阵：对角矩阵所有的非零元都集中在以主对角线为中心的带状区域中，即除了对角线上和在对角线上、下方若干条对角线上的数据外，其他数据都为零。可以通过以行或列为主，或以对角线顺序将其压缩到一维数组上。 广义表 广义表是另外一种线性表的推广形式，表中的元素可以是称为原子的单个元素，也可以是一个子表，所以线性表可以看成广义表的特例。 广义表的常用操作有取表头和取表尾。 取表头：取出的表头为非空广义表的第一个元素，可以是单原子也可以是子表。 取表尾：取出的表尾为去表头之外其余元素所构成的表，尾表一定是一个广义表。 广义表通常采用链式存储结构：头尾链表的存储结构和扩展线性链表的存储结构。 头尾链表的存储结构：表结点由标志域(1表子表，0表原子)、指示表头的指针域和指示表尾的指针域构成。原子结点由标志域和值域构成。 扩展线性链表的存储结构：无论表结点还是原子结点均由三个域组成，即标志域、指示表头的指针域(表结点或原子结点)和指示表尾的指针域。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之栈与队列","date":"2020-03-20T07:09:59.000Z","path":"posts/2442d660/","text":"栈栈是限定仅在表尾进行插入或删除操作的线性表(表尾为栈顶，表头为栈底)，简单说就是后存入的元素在取的时候反而会先取出，因此也称为后进先出(LIFO)的线性表。栈可分为顺序栈和链栈。 顺序栈顺序栈的基本操作实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/20 16:29 * @Description 顺序栈 */ public class ArrayStack { /** * 栈主体 */ private Object[] stack; /** * 已存储的元素个数 */ private int length; /** * 初始化顺序栈 * @param maxLength 最大长度 */ public ArrayStack(int maxLength) { stack = new Object[maxLength]; length = 0; } /** * 顺序栈是否为空 * @return 为空true，不空false */ public boolean empty() { return length == 0; } /** * 清空顺序栈 */ public void clear() { length = 0; } /** * 顺序栈中数据元素个数。 * @return 元素个数 */ public int length() { return length; } /** * 压栈 * @param elem 需要存储的元素 */ public void push(Object elem) { if (length == stack.length) { throw new ArrayIndexOutOfBoundsException(\"栈满了\"); } stack[length] = elem; length++; } /** * 弹栈 * @return 删除的元素 */ public Object pop() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"栈式空的\"); } Object data = stack[length - 1]; length--; return data; } /** * 获取栈顶元素 * @return 栈顶元素 */ public Object getTop() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"栈空\"); } return stack[length - 1]; } } 链栈链栈的基本操作实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/20 16:29 * @Description 链栈 */ public class LinkedStack&lt;T> { /** * 栈顶 */ private Node top; /** * 已存储的元素个数 */ private int length; private class Node { /** * 数据 */ private T data; /** * 下一个结点 */ private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } } /** * 初始化链栈 */ public LinkedStack() { clear(); } /** * 链栈是否为空 * @return 为空true，不空false */ public boolean empty() { return length == 0; } /** * 清空链栈 */ public void clear() { top = null; length = 0; } /** * 链栈中数据元素个数。 * @return 元素个数 */ public int length() { return length; } /** * 压栈 * @param elem 需要存储的元素 */ public void push(T elem) { top = new Node(elem, top); length++; } /** * 弹栈 * @return 删除的元素 */ public T pop() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"栈空\"); } T data = top.data; top = top.next; length--; return data; } /** * 获取栈顶元素 * @return 栈顶元素 */ public T getTop() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"栈空\"); } return top.data; } } 队列 队列是限定在表尾(队尾)进行插入，在表头(队头)进行删除的线性表，换句话说就是先进先出(FIFO)的线性表。队列可分为顺序队列(常用循环队列)和链式队列。 循环队列循环队列的基本操作实现，需要注意的有四点： 队列入队出队首尾指针：(rear + 1) % maxLength 和 (front + 1) % maxLength。 队长及队列判空判满条件： 方法一：为了区分队满和队空，入队时少用一个队列单元，即当rear的下一个为front时表示队满。 队满：(rear + 1) % maxLength == front。 队空：front == rear。 队长：(rear - front + maxLength) % maxLength。 方法二：通过变量length记录实际在队列中的元素个数。 队满：length == maxLength。 队空：length == 0。 队长：length。 /** * @Author 喵粮都输光了 * @Date 2020/3/20 18:30 * @Description 循环队列(牺牲一个队列单元判空判满) */ public class CircleQueue { /** * 循环队列主体 */ private Object[] queue; /** * 队头 */ private int front; /** * 队尾 */ private int rear; /** * 队列最大长度 */ private int maxLength; /** * 初始化链式队列 */ public CircleQueue(int maxLength) { this.maxLength = maxLength + 1; queue = new Object[maxLength + 1]; front = 0; rear = 0; } /** * 链式队列是否为空 * @return 为空true，不空false */ public boolean empty() { return rear == front; } /** * 清空链栈 */ public void clear() { front = 0; rear = 0; } /** * 链式队列中数据元素个数。 * @return 元素个数 */ public int length() { return (rear + maxLength - front) % maxLength; } /** * 入队 * @param elem 需要存储的元素 */ public void enqueue(Object elem) { if ((rear + 1) % maxLength == front) { throw new ArrayIndexOutOfBoundsException(\"队列满\"); } queue[rear] = elem; rear = (rear + 1) % maxLength; } /** * 出队 * @return 删除的元素 */ public Object dequeue() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"队列空\"); } Object data = queue[front]; front = (front + 1) % maxLength; return data; } /** * 队头元素 * @return 队头元素 */ public Object getHead() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"队列空\"); } return queue[front]; } } 链式队列链式队列的基本操作实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/20 18:30 * @Description 链式队列 */ public class LinkedQueue&lt;T> { /** * 队头 */ private Node&lt;T> front; /** * 队尾 */ private Node&lt;T> rear; /** * 已存储的元素个数 */ private int length; private static class Node&lt;T> { /** * 数据 */ private T data; /** * 下一个结点 */ private Node&lt;T> next; public Node(T data, Node&lt;T> next) { this.data = data; this.next = next; } } /** * 初始化链式队列 */ public LinkedQueue() { clear(); } /** * 链式队列是否为空 * @return 为空true，不空false */ public boolean empty() { return length == 0; } /** * 清空链栈 */ public void clear() { front = null; rear = null; length = 0; } /** * 链式队列中数据元素个数。 * @return 元素个数 */ public int length() { return length; } /** * 入队 * @param elem 需要存储的元素 */ public void enqueue(T elem) { Node&lt;T> oldRear = rear; rear = new Node&lt;>(elem, null); if (empty()) { front = rear; } else { oldRear.next = rear; } length++; } /** * 出队 * @return 删除的元素 */ public T dequeue() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"队列空\"); } T data = front.data; front = front.next; length--; if (empty()) { rear = null; } return data; } /** * 队头元素 * @return 队头元素 */ public T getHead() { if (empty()) { throw new ArrayIndexOutOfBoundsException(\"队列空\"); } return front.data; } } 栈和队列的比较 栈 队列 逻辑结构 和线性表相同，元素一一对应。 和线性表相同，元素一一对应。 顺序存储(存储结构) 空间预先分配，容易导致空间溢出或闲置。 常设计为循环队列。空间预先分配，容易导致空间溢出或闲置。 链式存储(存储结构) 动态分配，不会造成空间浪费或溢出。 动态分配，不会造成空间浪费或溢出。 运算规则 后进先出，插入删除在表的一端(栈顶)完成。 先进先出，插入在队尾进行，删除在队头进行。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之线性表","date":"2020-03-19T12:26:13.000Z","path":"posts/91054329/","text":"线性表特点 线性表第一个元素无前驱，最后一个元素无后继，其他每个数据元素都有一个前驱和后继。 对线性表的数据元素可以进行增删改查等操作。 顺序表 顺序表(ArrayList)即线性表的顺序存储表示，通过使用一组地址连续的存储单元依次存储线性表的数据元素。简单说就是逻辑上相邻的数据元素，在物理地址上也是相邻的。 顺序表的基本操作实现(使用数组)： /** * @Author 喵粮都输光了 * @Date 2020/3/19 21:12 * @Description 顺序表，下标从0开始。 */ public class ArrayList { /** * 顺序表主题 */ private Object[] list; /** * 已存储的元素个数 */ private int length; /** * 初始化顺序表 * @param maxLength 最大长度 */ public ArrayList(int maxLength) { list = new Object[maxLength]; length = 0; } /** * 清空顺序表 */ public void clearList() { length = 0; } /** * 顺序表是否为空 * @return 为空true，不空false */ public boolean listEmpty() { return length == 0; } /** * 顺序表中数据元素个数。 * @return 元素个数 */ public int listLength() { return length; } /** * 获取顺序表指定位置元素 * @param index 下标 * @return 指定元素 */ public Object getElem(int index) { // 下标不合法 if (index &lt; 0 || index > length - 1) { return null; } return list[index]; } /** * 返回顺序表中第一个值与object相同的元素位置，没找到返回-1 * @param elem 需要查找的元素 * @return 返回查找到的第一个与之相同的元素位置，否则返回-1 */ public int locateElem(Object elem) { for (int i = 0; i &lt; length; i++) { if (list[i].equals(elem)) { return i; } } return -1; } /** * 在所给index位置之前插入新的元素。index位置之后元素后移 * @param elem 需要插入的元素 * @param index 需要插入的位置 */ public void listInsert(Object elem, int index) { // 下标不合法或数组满了 if (index &lt; 0 || index > list.length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } if (length == list.length) { throw new ArrayIndexOutOfBoundsException(\"数组满了\"); } if (index != length) { for (int i = length; i > index; i--) { list[i] = list[i - 1]; } } list[index] = elem; length++; } /** * 删除所给index位置的元素，index位置之后元素前移 * @param index 需要删除的位置 * @return 返回删除的元素 */ public Object listDelete(int index) { // 下标不合法或数组为空 if (index &lt; 0 || index > length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } Object removeElem = list[index]; if (index != length - 1) { for (int i = index; i &lt; length - 1; i++) { list[index] = list[index + 1]; } } length--; return removeElem; } /** * 遍历顺序表 * @return 返回遍历结果 */ public String traverseList() { if (length == 0) { return \"[]\"; } StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"[\"); for (int i = 0; i &lt; length; i++) { stringBuilder.append(list[i]).append(\", \"); } stringBuilder.delete(stringBuilder.length() - 2, stringBuilder.length()); stringBuilder.append(\"]\"); return String.valueOf(stringBuilder); } } 链表链表(LinkedList)即线性表的链式存储表示，用一组任意的存储单元存储线性表的数据元素，由于物理地址可能非连续，因此需要存储一个指示其直接后继的信息。也就是说逻辑上相邻的数据元素，在物理地址上可能相邻也可能不相邻。(链表示例动画) 单链表 单链表如下图所示只能从头访问至尾。 单链表的基本操作实现： /** * @Author 喵粮都输光了 * @Date 2020/3/19 21:12 * @Description 单链表。 */ public class SinglyLinkedList&lt;T> { /** * 头结点 */ private Node head; /** * 单链表长度 */ private int length; private class Node { /** * 数据 */ private T data; /** * 下一个结点 */ private Node next; /** * 初始化一个结点 * @param data 存储的数据 * @param next 下一个结点 */ public Node(T data, Node next) { this.data = data; this.next = next; } /** * 尾结点，未传入下一个结点，则初始化下一个结点为空 * @param data 存储的数据 */ public Node(T data) { this(data, null); } } /** * 初始化单链表 */ public SinglyLinkedList() { head = null; length = 0; } /** * 在表头插入数据元素 * @param elem 数据元素 */ public void listInsertHead(T elem) { head = new Node(elem, head); length++; } /** * 在表尾插入数据元素 * @param elem 数据元素 */ public void listInsertTail(T elem) { listInsert(elem, length); } /** * 在指定位置插入数据元素 * @param elem 数据元素 * @param index 需要插入的位置 */ public void listInsert(T elem, int index) { // 下标不合法 if (index &lt; 0 || index > length) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listInsertHead(elem); return; } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } preNode.next = new Node(elem, preNode.next); length++; } /** * 删除头结点元素 * @return 返回删除的元素 */ public T listDeleteHead() { if (length == 0) { throw new ArrayIndexOutOfBoundsException(\"数组为空\"); } T removeElem = head.data; head = head.next; length--; return removeElem; } /** * 删除尾结点元素 * @return 返回删除的元素 */ public T listDeleteTail() { return listDelete(length - 1); } /** * 删除指定结点元素 * @param index 需要删除的元素位置 * @return 返回删除的元素 */ public T listDelete(int index) { // 下标不合法或数组为空 if (index &lt; 0 || index > length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listDeleteHead(); } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } T removeElem = preNode.next.data; preNode.next = preNode.next.next; return removeElem; } /** * 返回链表中d第一个值与elem相同的元素位置，没找到返回-1 * @param elem 需要查找的元素 * @return 返回查找到的第一个与之相同的元素位置，否则返回-1 */ public int locateElem(T elem) { if (length == 0) { return -1; } Node temp = head; int index = 0; // 必须用equals，类型不同 if (temp.data.equals(elem)) { return index; } while (temp.next != null) { temp = temp.next; index++; if (temp.data.equals(elem)) { return index; } } return -1; } /** * 遍历链表 * @return 返回遍历结果 */ public String traverseList() { if (length == 0) { return \"[]\"; } Node temp = head; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"[\"); stringBuilder.append(temp.data).append(\", \"); while (temp.next != null) { temp = temp.next; stringBuilder.append(temp.data).append(\", \"); } stringBuilder.delete(stringBuilder.length() - 2, stringBuilder.length()); stringBuilder.append(\"]\"); return String.valueOf(stringBuilder); } } 循环链表 循环链表的最后一个结点指向头结点。与单链表基本一致，唯一差别仅在判断当前指针是否指向表尾结点的终止条件不同。循环链表示意图如下。 循环链表的基本操作实现：直接通过如下方式修改单链表。 添加尾结点。 /** * 尾结点 */ private Node tail; 为尾结点初始化。 /** * 初始化循环链表 */ public CircularLinkedList() { head = null; tail = null; length = 0; } 修改插入删除方法。 /** * 在表头插入数据元素 * @param elem 数据元素 */ public void listInsertHead(T elem) { head = new Node(elem, head); if (length == 0) { tail = head; tail.next = head; } length++; } /** * 在指定位置插入数据元素 * @param elem 数据元素 * @param index 需要插入的位置 */ public void listInsert(T elem, int index) { // 下标不合法 if (index &lt; 0 || index > length) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listInsertHead(elem); return; } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } preNode.next = new Node(elem, preNode.next); if (index == length) { tail = preNode.next; tail.next = head; } length++; } /** * 删除头结点元素 * @return 返回删除的元素 */ public T listDeleteHead() { if (length == 0) { throw new ArrayIndexOutOfBoundsException(\"数组为空\"); } T removeElem = head.data; head = head.next; tail.next = head; length--; return removeElem; } /** * 删除指定结点元素 * @param index 需要删除的元素位置 * @return 返回删除的元素 */ public T listDelete(int index) { // 下标不合法或数组为空 if (index &lt; 0 || index > length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listDeleteHead(); } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } T removeElem = preNode.next.data; preNode.next = preNode.next.next; if (index == length - 1) { tail = preNode; tail.next = head; } return removeElem; } 修改locateElem和traverseList方法的判断是否到链尾的方法为如下。 while (temp.next != head) { // 方法 } 双向链表 双向链表的结点比单链表和循环链表的结点多一个指向其直接前驱的信息，双向链表也可以有双向循环链表的实现方式，其示意图如下。 双向循环链表的基本操作实现：直接通过如下方式修改双链表(可以去掉尾结点，留着没有意义)。 删除尾结点并修改class Node增加前驱信息保存。 private class Node { /** * 数据 */ private T data; /** * 下一个结点 */ private Node next; /** * 上一个结点 */ private Node pre; /** * 初始化一个结点 * @param data 存储的数据 * @param next 下一个结点 */ public Node(T data, Node pre, Node next) { this.data = data; this.next = next; this.pre = pre; } } 修改插入删除方法。 /** * 在表头插入数据元素 * @param elem 数据元素 */ public void listInsertHead(T elem) { if (length == 0) { head = new Node(elem, head, head); head.pre = head; head.next = head; } else { head = new Node(elem, head.pre, head); head.pre.next = head; head.next.pre = head; } length++; } /** * 在指定位置插入数据元素 * @param elem 数据元素 * @param index 需要插入的位置 */ public void listInsert(T elem, int index) { // 下标不合法 if (index &lt; 0 || index > length) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listInsertHead(elem); return; } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } preNode.next = new Node(elem, preNode, preNode.next); preNode.next.next.pre = preNode.next; if (index == length) { preNode.next.next = head; } length++; } /** * 删除头结点元素 * @return 返回删除的元素 */ public T listDeleteHead() { if (length == 0) { throw new ArrayIndexOutOfBoundsException(\"数组为空\"); } T removeElem = head.data; head.pre.next = head.next; head.next.pre = head.pre; head = head.next; length--; return removeElem; } /** * 删除指定结点元素 * @param index 需要删除的元素位置 * @return 返回删除的元素 */ public T listDelete(int index) { // 下标不合法或数组为空 if (index &lt; 0 || index > length - 1) { throw new IllegalArgumentException(\"下标不合法\"); } if (index == 0) { listDeleteHead(); } Node preNode = head; for (int i = 0; i &lt; index - 1; i++) { preNode = preNode.next; } T removeElem = preNode.next.data; preNode.next = preNode.next.next; preNode.next.pre = preNode; if (index == length - 1) { preNode.next = head; head.pre = preNode; } return removeElem; } 顺序表与链表的比较存储密度：指的是数据元素本身所占用的存储量和整个结点结构所占用的存储量之比。存储密度越大，存储空间的利用率越高。 顺序表 链表 存储空间(空间) 预先分配，容易导致空间溢出或闲置。 动态分配，不会造成空间浪费或溢出。 存储密度(空间) 不用存储结点间的逻辑关系，存储密度等于1。 需要存储结点间逻辑关系，存储密度小于1。 存取元素(时间) 随机存取，复杂度O(1)。 顺序存取，复杂度O(n)。 插入删除(时间) 平均需移动一半元素，复杂度O(n)。 不需要移动元素，复杂度O(1)。 使用情况 1.表长变化不大，事先能知道大概大小。2.多查少增删。 1.表厂变化大。2.多增删少查。 各链表的时间复杂度比较 查找头结点 查找尾结点 查找结点p的前驱 带头结点的单链表 直接获取，复杂度O(1)。 需要遍历表，复杂度为O(n)。 无法获得前驱。 带头结点的循环单链表(无尾指针) O(1) O(n) 需要遍历表，复杂度为O(n)。 带头结点的循环单链表(无头指针) O(1) 通过尾指针直接获取，复杂度为O(1)。 O(n) 带头结点的双向循环链表 O(1) 直接获取头结点的前驱就是尾结点，复杂度为O(1)。 直接通过p结点的前驱获取，复杂度为O(1)。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构简介","date":"2020-03-19T11:14:55.000Z","path":"posts/b8928e0e/","text":"基本概念及术语 数据：能输入到计算机中并能被计算机处理的符号。例如文本字符串、数学实数、图形图像和声音等通过特殊编码后获得的数据。 数据元素：是数据的基本单位，通常作为整体考虑。例如学生记录$($包含姓名、年龄、学号等$)$。 数据项：是组成数据元素的最小单位。例如姓名、年龄、学号等，也就是说数据元素是由数据项构成的。 数据对象：可以看作是一个包含了相同性质的数据元素的集合。例如学生表，包含了相同性质的数据元素学生记录。 数据结构数据结构就是数据元素之间存在关系的集合，数据结构包含逻辑结构和存储结构。 逻辑结构：逻辑上存在关系，与数据存储无关的结构。如果数据元素之间存在一对一关系称为线性结构，否则称为非线性结构$($集合结构、树形结构和图状结构$)$。几种常用的逻辑结构层次图如下： 存储结构：数据在计算机中存储表示的方式，又称为物理结构。顺序存储结构和链式存储结构是两种常用的基本存储结构。 顺序存储结构：所有元素依次存放在一片连续的存储空间中。 链式存储结构：无需占用一整块存储空间，但是作为代价为了表示结点之间的关系，需要让每个结点都拥有指向其他结点的指针字段。也就是说链式存储结构中结点拥有数据和其他结点的存储地址。 算法分析 内循环：执行最频繁的指令决定了程序执行的总时间，把这些指令称为程序的内循环。 成本模型：使用成本模型来评估算法，例如数组的访问次数就是一种成本模型。 常见的增长数量级函数： 描述 函数 常数级别 1 对数级别 logN 线性级别 N 线性对数级别 NlogN 平方级别 $N^2$ 立方级别 $N^3$ 指数级别 $2^N$ 倍率定理：若$T(N)\\sim aN^blgN$，那么$\\frac{T(2N)}{N}\\sim 2^b$。 大常数：在求近似时，如果低级项的常数系数很大，那么近似的结果是错误的。 均摊分析：通过记录所有操作的总成本除以操作总数来将成本均摊。例如由数组实现的栈，当进行压栈操作时操作所访问数组的次数为常数次，但是如果栈满还要压栈时需要对数组扩容，为了将数据后移此时需要访问次数为数组大小次，均摊后访问数组的平均次数为常数$($也就是将写入数组时访问的次数与扩容时访问数组的次数平摊$)$。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"设计模式之复合模式","date":"2020-03-18T02:42:34.000Z","path":"posts/198c6c0a/","text":"复合模式 复合模式在一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题。 下面代码展现了模式之间合作的例子，其UML类图如下： 原型 需求：设计一个鸭子模拟器，具体鸭子实现各自的叫声接口。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:54 * @Description 叫声接口 */ public interface Quackable { /** * 叫声 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:58 * @Description 橡皮鸭 */ public class RubberDuck implements Quackable { @Override public void quack() { System.out.println(\"吱吱叫\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:57 * @Description 红头鸭 */ public class RedheadDuck implements Quackable { @Override public void quack() { System.out.println(\"呱呱叫\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:00 * @Description 鸭子模拟器 */ public class DuckSimulator { public static void main(String[] args) { DuckSimulator duckSimulator = new DuckSimulator(); duckSimulator.simulate(); } /** * 模拟鸭子 */ void simulate() { Quackable redheadDuck = new RedheadDuck(); Quackable rubberDuck = new RubberDuck(); simulate(redheadDuck); simulate(rubberDuck); } /** * 模拟鸭子叫重载 * @param duck 鸭子 */ void simulate(Quackable duck) { duck.quack(); } } 适配器模式 需求：现在需要添加一个鹅类，鹅会咯咯叫，将鹅包装成鸭子类使用同一个接口进行叫声调用。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:03 * @Description 鹅 */ public class Goose { /** * 鹅叫 */ void honk() { System.out.println(\"咯咯叫\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:06 * @Description 鹅叫声适配器，适配器模式 */ public class GooseAdapter implements Quackable { private Goose goose; public GooseAdapter(Goose goose) { this.goose = goose; } @Override public void quack() { goose.honk(); } } 修改DuckSimulator中的simulate()方法如下： /** * 模拟鸭子 */ void simulate() { Quackable redheadDuck = new RedheadDuck(); Quackable rubberDuck = new RubberDuck(); Quackable gooseDuck = new GooseAdapter(new Goose()); simulate(redheadDuck); simulate(rubberDuck); simulate(gooseDuck); } 装饰器模式 需求：现在需要一个叫声计数器，在不改变鸭子的代码的情况下统计鸭子叫声的次数。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:17 * @Description 叫声计数器，装饰器模式 */ public class QuackCounter implements Quackable { private Quackable duck; /** * 叫声次数，要记录所有传入对象的叫声次数，使用静态 */ private static int numberOfQuacks; public QuackCounter(Quackable duck) { this.duck = duck; } @Override public void quack() { duck.quack(); numberOfQuacks++; } /** * 获得叫声次数 * @return 叫声次数 */ public static int getQuacks() { return numberOfQuacks; } } 修改DuckSimulator中的simulate()方法如下： /** * 模拟鸭子 */ void simulate() { Quackable redheadDuck = new QuackCounter(new RedheadDuck()); Quackable rubberDuck = new QuackCounter(new RubberDuck()); simulate(redheadDuck); simulate(rubberDuck); System.out.println(\"叫声次数：\" + QuackCounter.getQuacks()); } 抽象工厂模式 需求：因为所有鸭子的叫声都需要统计，为了防止拥有叫声的鸭子对象创建时没有进行装饰，因此将鸭子对象的创建以及叫声的统计包装起来。通过一个工厂生产装饰过的鸭子，该工厂还要能够生产不同类型的鸭子(不包括鹅，此处相当于是鸭子产品家族，当然也可以创建鹅抽象工厂接口并建立鹅家族)。 代码演示： 鸭子抽象工厂接口。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:42 * @Description 鸭子抽象工厂接口 */ public abstract class BaseDuckFactory { /** * 创建红头鸭 * @return 红头鸭对象 */ abstract Quackable createRedheadDuck(); /** * 创建橡皮鸭 * @return 橡皮鸭对象 */ abstract Quackable createRubberDuck(); } 普通鸭子抽象工厂。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:48 * @Description 未装饰的鸭子抽象工厂 */ public class DuckFactory extends BaseDuckFactory { @Override Quackable createRedheadDuck() { return new RedheadDuck(); } @Override Quackable createRubberDuck() { return new RubberDuck(); } } 装饰叫声统计功能的鸭子抽象工厂。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:49 * @Description 装饰叫声统计功能的鸭子抽象工厂 */ public class CountingDuckFactory extends BaseDuckFactory { @Override Quackable createRedheadDuck() { return new QuackCounter(new RedheadDuck()); } @Override Quackable createRubberDuck() { return new QuackCounter(new RubberDuck()); } } 鸭子模拟器测试类。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:00 * @Description 鸭子模拟器 */ public class DuckSimulator { public static void main(String[] args) { DuckSimulator duckSimulator = new DuckSimulator(); BaseDuckFactory countingDuckFactory = new CountingDuckFactory(); duckSimulator.simulate(countingDuckFactory); } /** * 模拟鸭子 * @param duckFactory 鸭子工厂 */ void simulate(BaseDuckFactory duckFactory) { Quackable redheadDuck = duckFactory.createRedheadDuck(); Quackable rubberDuck = duckFactory.createRubberDuck(); simulate(redheadDuck); simulate(rubberDuck); System.out.println(\"叫声次数：\" + QuackCounter.getQuacks()); } /** * 模拟鸭子叫重载 * @param duck 鸭子 */ void simulate(Quackable duck) { duck.quack(); } } 组合模式和迭代器模式 需求：分别管理不同的鸭子非常的繁琐，因此需要将所有鸭子视为一个集合，通过少数命令让整个集合的鸭子听令行动。 代码演示： 会叫对象管理类。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 12:11 * @Description 所有拥有叫声的对象群(对象集合) */ public class Flock implements Quackable { /** * 会叫对象集合 */ private ArrayList&lt;Quackable> quackers = new ArrayList&lt;>(); /** * 向集合中添加会叫的对象 * @param quacker 会叫的对象 */ public void add(Quackable quacker) { quackers.add(quacker); } @Override public void quack() { // 此处使用了内置的迭代器。超级循环封装使用了集合和数组的迭代器。 for (Quackable quacker : quackers) { quacker.quack(); } } } 修改DuckSimulator中的simulate(BaseDuckFactory duckFactory)方法如下： /** * 模拟鸭子 * @param duckFactory 鸭子工厂 */ void simulate(BaseDuckFactory duckFactory) { Quackable redheadDuck = duckFactory.createRedheadDuck(); Quackable rubberDuck = duckFactory.createRubberDuck(); Quackable gooseDuck = new QuackCounter(new GooseAdapter(new Goose())); Flock flockOfDucks = new Flock(); flockOfDucks.add(redheadDuck); flockOfDucks.add(rubberDuck); flockOfDucks.add(gooseDuck); simulate(flockOfDucks); System.out.println(\"叫声次数：\" + QuackCounter.getQuacks()); } 观察者模式 需求：现在需要追踪个别的鸭子实时的观察其呱呱叫的行为。订阅需要观察的鸭子，当鸭子调用了叫声功能就通知订阅者。 代码演示： 叫声观察主题。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 12:27 * @Description 叫声观察主题 */ public interface QuackObservable { /** * 注册为观察者 * @param observer 需要注册的对象 */ void registerObserver(Observer observer); /** * 通知所有观察者方法 */ void notifyObservers(); } 观察者接口。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 13:28 * @Description 观察者接口 */ public interface Observer { /** * 更新 * @param duck 需要更新的对象 */ void update(QuackObservable duck); } 让叫声接口继承该主题，并对所有实现叫声接口的类实现叫声观察主题的方法，此处所有叫声对象方法都相同，可以通过一个类实现QuackObservable，在叫声对象中调用即可。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:54 * @Description 叫声接口 */ public interface Quackable extends QuackObservable { /** * 叫声 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2020/3/18 13:38 * @Description QuackObservable的一个具体实现 */ public class Observable implements QuackObservable { private ArrayList&lt;Observer> observers = new ArrayList&lt;>(); private QuackObservable duck; public Observable(QuackObservable duck) { this.duck = duck; } @Override public void registerObserver(Observer observer) { observers.add(observer); } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(duck); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:06 * @Description 鹅叫声适配器，适配器模式 */ public class GooseAdapter implements Quackable { private Observable observable; private Goose goose; public GooseAdapter(Goose goose) { observable = new Observable(this); this.goose = goose; } @Override public void quack() { goose.honk(); notifyObservers(); } @Override public void registerObserver(Observer observer) { observable.registerObserver(observer); } @Override public void notifyObservers() { observable.notifyObservers(); } @Override public String toString() { return \"伪装成鸭的鹅\"; } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:57 * @Description 红头鸭 */ public class RedheadDuck implements Quackable { private Observable observable; public RedheadDuck() { observable = new Observable(this); } @Override public void quack() { System.out.println(\"呱呱叫\"); notifyObservers(); } @Override public void registerObserver(Observer observer) { observable.registerObserver(observer); } @Override public void notifyObservers() { observable.notifyObservers(); } @Override public String toString() { return \"红头鸭\"; } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 10:58 * @Description 橡皮鸭 */ public class RubberDuck implements Quackable { private Observable observable; public RubberDuck() { observable = new Observable(this); } @Override public void quack() { System.out.println(\"吱吱叫\"); notifyObservers(); } @Override public void registerObserver(Observer observer) { observable.registerObserver(observer); } @Override public void notifyObservers() { observable.notifyObservers(); } @Override public String toString() { return \"橡皮鸭\"; } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 11:17 * @Description 叫声计数器，装饰器模式 */ public class QuackCounter implements Quackable { private Quackable duck; private Observable observable; /** * 叫声次数，要记录所有传入对象的叫声次数，使用静态 */ private static int numberOfQuacks; public QuackCounter(Quackable duck) { observable = new Observable(this); this.duck = duck; } @Override public void quack() { duck.quack(); numberOfQuacks++; notifyObservers(); } /** * 获得叫声次数 * @return 叫声次数 */ public static int getQuacks() { return numberOfQuacks; } @Override public void registerObserver(Observer observer) { observable.registerObserver(observer); } @Override public void notifyObservers() { observable.notifyObservers(); } @Override public String toString() { return duck.toString(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/18 12:11 * @Description 所有拥有叫声的对象群(对象集合) */ public class Flock implements Quackable { /** * 会叫对象集合 */ private ArrayList&lt;Quackable> quackers = new ArrayList&lt;>(); /** * 向集合中添加会叫的对象 * @param quacker 会叫的对象 */ public void add(Quackable quacker) { quackers.add(quacker); } @Override public void quack() { // 此处使用了内置的迭代器。超级循环封装使用了集合和数组的迭代器。 for (Quackable quacker : quackers) { quacker.quack(); } } @Override public void registerObserver(Observer observer) { for (QuackObservable quacker : quackers) { quacker.registerObserver(observer); } } @Override public void notifyObservers() { for (QuackObservable quacker : quackers) { quacker.notifyObservers(); } } } 观察者具体实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/18 13:48 * @Description 观察者 */ public class Quackologist implements Observer { @Override public void update(QuackObservable duck) { System.out.println(\"正在呱呱叫的对象：\" + duck); } } 修改DuckSimulator中的simulate(BaseDuckFactory duckFactory)方法如下： /** * 模拟鸭子 * @param duckFactory 鸭子工厂 */ void simulate(BaseDuckFactory duckFactory) { Quackable redheadDuck = duckFactory.createRedheadDuck(); Quackable rubberDuck = duckFactory.createRubberDuck(); Quackable gooseDuck = new QuackCounter(new GooseAdapter(new Goose())); Flock flockOfDucks = new Flock(); flockOfDucks.add(redheadDuck); flockOfDucks.add(rubberDuck); flockOfDucks.add(gooseDuck); Quackologist quackologist = new Quackologist(); flockOfDucks.registerObserver(quackologist); simulate(flockOfDucks); System.out.println(\"叫声次数：\" + QuackCounter.getQuacks()); } MVC MVC即“模型-视图-控制器”(Model-View-Controller)是由数个模式结合起来而形成的新模式，三者关系如下： 视图：用来呈现模型。视图通常直接从模型中取得它需要显示的状态与数据。 控制器：取得用户的输入并解读其对模型的意思。 模型：模型持有所有的数据、状态和程序逻辑。模型没有注意到视图和控制器，虽然它提供了操纵和检索状态的接口，并发送状态改变通知给观察者。 应用到的设计模式：策略模式、观察者模式和组合模式。(此处将视图想象为GUI组件比较容易理解) 策略模式：视图可以视为一个显示信息的窗口，上面有很多模块，每个模块可能对应一个控制器。当按下某一个模块上的某个按钮时，便请求该模块对应的控制器调用相应的方法或模型处理。视图可以组合各种控制器。 观察者模式：模型实现了观察者模式，当模型状态改变时，相关对象将持续更新。也就是说当模型数据更新时，一个模型所使用到的多个视图(或是控制器)都会自动更新。 组合模式：显示包括了窗口、按钮、文本标签等。每个显示组件不是组合节点(窗口)，就是叶节点(按)。当控制器返回用户请求结果信息时，只需通知最顶层窗口即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之代理模式","date":"2020-03-17T01:49:06.000Z","path":"posts/907a70d0/","text":"代理模式 代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。 代理模式UML类图：Proxy持有RealSubject的引用。客户和RealSubject的交互都必须通过Proxy。因为Proxy和RealSubject实现相同的接口，所以任何用到RealSubject的地方都可以用Proxy取代。Proxy也控制了对RealSubject的访问。 远程代理 远程代理控制访问远程对象。 远程代理可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。JAVA中常用RMI进行远程方法调用。RMI生成stub充当代理，其运行流程为客户对象→stub→skeleton→服务对象，然后从服务对象依次返回到客户对象。 代码演示： Subject和RealSubject。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 15:49 * @Description 商店接口 */ public interface Store extends Remote { /** * 列出商店书籍 * * @return 书籍 * @throws RemoteException rmi异常 */ String bookList() throws RemoteException; } /** * @Author 喵粮都输光了 * @Date 2020/3/17 15:50 * @Description 商店实现类(实际工作的类) */ public class StoreImpl extends UnicastRemoteObject implements Store { public StoreImpl() throws RemoteException { // UnicastRemoteObject提供了一些远程功能 // 超类UnicastRemoteObject调用I/O，网络可能产生RemoteException异常，子类需要将其抛出 } @Override public String bookList() { return \"《西游记》、《三国演义》\"; } } 注册服务对象至rmi。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 15:55 * @Description 将StoreImpl服务注册入rmi的registry */ public class ServiceTestDrive { public static void main(String[] args) { try { Store store = new StoreImpl(); // 通过Naming的rebind方法将对象注册入rmi的registry中。 Naming.rebind(\"store\", store); } catch (Exception e) { e.printStackTrace(); } } } 客户对象。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 15:57 * @Description 客户端测试 */ public class Main { public static void main(String[] args) { try { // 通过Naming的lookup方法在rmi的registry中查找注册在其中的对象并返回。 Store store = (Store) Naming.lookup(\"rmi://127.0.0.1/store\"); // 调用该对象的方法，rmi会请求真实的StoreImpl并将结果打包返回。 String books = store.bookList(); System.out.println(books); } catch (Exception e) { e.printStackTrace(); } } } 运行时，需要命令行进入java的class文件生成目录下运行rmiregistry，打开注册服务。否则rebind方法会失败，然后将需要调用的对象注册入registry中，在运行客户端。 保护代理 保护代理基于权限控制对资源的访问。 利用JAVA动态代理创建保护代理。设计一个person，拥有姓名、性别和评分。创建两代理：1.类拥有者能设置自己的姓名、性别等，但不能给自己打分。2.非类拥有者能进行打分，但是不能设置别人的其他属性。 代码演示： 接口类及其具体实现类 /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:05 * @Description 人接口 */ public interface PersonBean { /** * 获得姓名 * @return 姓名 */ String getName(); /** * 获得性别 * @return 性别 */ String getGender(); /** * 获得评分 * @return 评分 */ int getHotOrNotRating(); /** * 设置姓名 * @param name 姓名 */ void setName(String name); /** * 设置性别 * @param gender 性别 */ void setGender(String gender); /** * 设置评分 * @param rating 评分 */ void setHotOrNotRating(int rating); } /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:09 * @Description 人实体实现 */ public class PersonBeanImpl implements PersonBean { /** * 姓名 */ private String name; /** * 性别 */ private String gender; /** * 评分 */ private int rating; /** * 评价人数 */ private int ratingCount = 0; @Override public String getName() { return name; } @Override public String getGender() { return gender; } @Override public int getHotOrNotRating() { if (ratingCount == 0) { return 0; } return rating / ratingCount; } @Override public void setName(String name) { this.name = name; } @Override public void setGender(String gender) { this.gender = gender; } @Override public void setHotOrNotRating(int rating) { this.rating += rating; ratingCount++; } } 代理行为。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:20 * @Description 拥有者代理，自己不能设置自己的评分 */ public class OwnerInvocationHandler implements InvocationHandler { private PersonBean personBean; private final static String SET_RATING = \"setHotOrNotRating\"; public OwnerInvocationHandler(PersonBean personBean) { this.personBean = personBean; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (SET_RATING.equals(method.getName())) { // 如果是自己评价自己不允许 throw new IllegalAccessException(); } else { // 否则都允许 return method.invoke(personBean, args); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:20 * @Description 非拥有者代理，只能打分不能修改其他的 */ public class NonOwnerInvocationHandler implements InvocationHandler { private PersonBean personBean; private final static String SET = \"set\"; private final static String SET_RATING = \"setHotOrNotRating\"; public NonOwnerInvocationHandler(PersonBean personBean) { this.personBean = personBean; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName().startsWith(SET)) { if (SET_RATING.equals(method.getName())) { // 如果是打分允许 return method.invoke(personBean, args); } else { // 其他修改不允许 throw new IllegalAccessException(); } } else { return method.invoke(personBean, args); } } } 测试。 /** * @Author 喵粮都输光了 * @Date 2020/3/17 17:04 * @Description 测试 */ public class Main { public static void main(String[] args) { PersonBean personBean = new PersonBeanImpl(); PersonBean owner = getOwnerProxy(personBean); PersonBean nonOwner = getNonOwnerProxy(personBean); owner.setHotOrNotRating(1); nonOwner.setGender(\"男\"); } /** * 获取拥有者代理 * @param personBean 代理对象 * @return 拥有者代理 */ public static PersonBean getOwnerProxy(PersonBean personBean) { return (PersonBean) Proxy.newProxyInstance(personBean.getClass().getClassLoader(), personBean.getClass().getInterfaces(), new OwnerInvocationHandler(personBean)); } /** * 获取非拥有者代理 * @param personBean 代理对象 * @return 非拥有者代理 */ public static PersonBean getNonOwnerProxy(PersonBean personBean) { return (PersonBean) Proxy.newProxyInstance(personBean.getClass().getClassLoader(), personBean.getClass().getInterfaces(), new NonOwnerInvocationHandler(personBean)); } } 虚拟代理 虚拟代理控制访问创建开销大的资源。 虚拟代理作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来边沿对象的替身。对象创建后，代理就会将请求直接委托给对象。 使用场景：需求GUI加载图片，图片未被加载时候显示文字图片加载中，图片加载完成时替换文字图片加载中为实际的图片。此时可以设计一个代理类，传入图片加载类，首先为程序显示文字图片加载中，然后创建线程调用图片加载方法(防止程序等待图片加载返回被挂起)，等图片加载方法返回了图片时，将显示的文字图片加载中替换成真正的图片即可。 其他变种代理 防火墙代理(Firewall Proxy)：控制网络资源的访问，保护主题免于“坏客户”的侵害。常用于公司的防火墙系统。 智能引用代理(Smart Reference Proxy)：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。 缓存代理(Caching Proxy)：为开销大的运算结果提供暂时存储，它也允许多个客户共享结果，以减少计算或网络延迟。常用于Web服务器代理，以及内容管理与出版系统。 同步代理(Synchronization Proxy)：在多线程的情况下为主题提供安全的访问。常用于为分散式环境内的潜在对象集合提供同步访问控制，例如JavaSpaces。 复杂隐藏代理(Complexity Hiding Proxy)：用来隐藏一个类的复杂集合的复杂度，并进行访问控制。也被称为外观代理。 写入时复制代理(Copy-On-Write Proxy)：用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。这是虚拟代理的变体。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之状态模式","date":"2020-03-16T01:38:00.000Z","path":"posts/61e067b6/","text":"状态模式 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 状态模式UML类图： 原型 需求：设计一个状态机具有如下功能并测试。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/16 10:24 * @Description 糖果机（状态机） */ public class GumballMachine { /** * 售空状态 */ private final static int SOLD_OUT = 0; /** * 未投入钱状态，有库存 */ private final static int NO_QUARTER = 1; /** * 已投入钱状态 */ private final static int HAS_QUARTER = 2; /** * 出售状态 */ private final static int SOLD = 3; /** * 当前状态，默认售空 */ private int state = SOLD_OUT; /** * 糖果库存 */ private int count; public GumballMachine(int count) { this.count = count; if (count > 0) { // 糖果库存大于0，设置为未投入钱状态 state = NO_QUARTER; } } /** * 投钱。 */ public void insertQuarter() { if (state == HAS_QUARTER) { System.out.println(\"投钱失败，已存在投入的钱。\"); } else if (state == NO_QUARTER) { state = HAS_QUARTER; System.out.println(\"投钱成功。\"); } else if (state == SOLD_OUT) { System.out.println(\"投钱失败，没有库存了。\"); } else if (state == SOLD) { System.out.println(\"投钱失败，正在出售请稍等。\"); } } /** * 退钱。 */ public void ejectQuarter() { if (state == HAS_QUARTER) { state = NO_QUARTER; System.out.println(\"退钱成功。\"); } else if (state == NO_QUARTER) { System.out.println(\"退钱失败，未投入钱。\"); } else if (state == SOLD_OUT) { System.out.println(\"退钱失败，未投入钱。\"); } else if (state == SOLD) { System.out.println(\"退钱失败，正在出售请稍等。\"); } } /** * 转动曲柄购买糖果。 */ public void turnCrank() { if (state == HAS_QUARTER) { state = SOLD; System.out.println(\"转动曲柄成功。\"); dispense(); } else if (state == NO_QUARTER) { System.out.println(\"转动曲柄失败，未投入钱。\"); } else if (state == SOLD_OUT) { System.out.println(\"转动曲柄失败，没有库存了。\"); } else if (state == SOLD) { System.out.println(\"转动曲柄失败，正在出售请稍等。\"); } } /** * 发放糖果。 */ private void dispense() { if (state == SOLD) { System.out.println(\"发放糖果成功。\"); count--; if (count == 0) { state = SOLD_OUT; System.out.println(\"糖果售空了。\"); } else { state = NO_QUARTER; } } else if (state == NO_QUARTER) { System.out.println(\"发放糖果失败，请先投钱。\"); } else if (state == SOLD_OUT) { System.out.println(\"发放糖果失败。\"); } else if (state == HAS_QUARTER) { System.out.println(\"发放糖果失败。\"); } } @Override public String toString() { return \"目前糖果库存\" + count; } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 10:55 * @Description 测试 */ public class Main { public static void main(String[] args) { GumballMachine gumballMachine = new GumballMachine(5); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.ejectQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.ejectQuarter(); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); } } 增加新状态 问题：当需要增加新状态时，上面的程序需要修改所有包含状态的方法并且新增状态，极难维护。 解决：对变化的状态进行封装，使一个状态对应一个类，再使用组合的方法再当前状态中组合所需状态即可。其UML图如下： 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:24 * @Description 状态接口 */ public interface State { /** * 投钱。 */ void insertQuarter(); /** * 退钱。 */ void ejectQuarter(); /** * 转动曲柄购买糖果。 */ void turnCrank(); /** * 发放糖果。 */ void dispense(); } import java.util.Random; /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:27 * @Description 已投入钱状态 */ public class HasQuarterState implements State { private GumballMachine gumballMachine; private Random randomWinner = new Random(System.currentTimeMillis()); public HasQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\"投钱失败，已存在投入的钱。\"); } @Override public void ejectQuarter() { gumballMachine.setState(gumballMachine.getNoQuarterState()); System.out.println(\"退钱成功。\"); } @Override public void turnCrank() { int winner = randomWinner.nextInt(10); if ((winner == 0) &amp;&amp; (gumballMachine.getCount() > 1)) { gumballMachine.setState(gumballMachine.getWinnerState()); } else { gumballMachine.setState(gumballMachine.getSoldState()); } System.out.println(\"转动曲柄成功。\"); } @Override public void dispense() { System.out.println(\"发放糖果失败。\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:27 * @Description 未投入钱状态 */ public class NoQuarterState implements State { private GumballMachine gumballMachine; public NoQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { gumballMachine.setState(gumballMachine.getHasQuarterState()); System.out.println(\"投钱成功。\"); } @Override public void ejectQuarter() { System.out.println(\"退钱失败，未投入钱。\"); } @Override public void turnCrank() { System.out.println(\"转动曲柄失败，未投入钱。\"); } @Override public void dispense() { System.out.println(\"发放糖果失败，请先投钱。\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:27 * @Description 售空状态 */ public class SoldOutState implements State { private GumballMachine gumballMachine; public SoldOutState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\"投钱失败，没有库存了。\"); } @Override public void ejectQuarter() { System.out.println(\"退钱失败，未投入钱。\"); } @Override public void turnCrank() { System.out.println(\"转动曲柄失败，没有库存了。\"); } @Override public void dispense() { System.out.println(\"发放糖果失败。\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:27 * @Description 出售状态 */ public class SoldState implements State { private GumballMachine gumballMachine; public SoldState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\"投钱失败，正在出售请稍等。\"); } @Override public void ejectQuarter() { System.out.println(\"退钱失败，正在出售请稍等。\"); } @Override public void turnCrank() { System.out.println(\"转动曲柄失败，正在出售请稍等。\"); } @Override public void dispense() { gumballMachine.releaseBall(); if (gumballMachine.getCount() > 0) { gumballMachine.setState(gumballMachine.getNoQuarterState()); } else { gumballMachine.setState(gumballMachine.getSoldOutState()); System.out.println(\"糖果售空了。\"); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 13:25 * @Description 中奖状态 */ public class WinnerState implements State { private GumballMachine gumballMachine; public WinnerState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\"投钱失败，正在出售请稍等。\"); } @Override public void ejectQuarter() { System.out.println(\"退钱失败，正在出售请稍等。\"); } @Override public void turnCrank() { System.out.println(\"转动曲柄失败，正在出售请稍等。\"); } @Override public void dispense() { System.out.println(\"恭喜中奖，你将多获得一颗糖。\"); gumballMachine.releaseBall(); if (gumballMachine.getCount() == 0) { gumballMachine.setState(gumballMachine.getSoldOutState()); } else { gumballMachine.releaseBall(); if (gumballMachine.getCount() > 0) { gumballMachine.setState(gumballMachine.getNoQuarterState()); } else { gumballMachine.setState(gumballMachine.getSoldOutState()); System.out.println(\"糖果售空了。\"); } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 11:48 * @Description 糖果机（状态机） */ public class GumballMachine { /** * 售空状态 */ private State soldOutState; /** * 出售状态 */ private State soldState; /** * 未投入钱状态 */ private State noQuarterState; /** * 已投入钱状态 */ private State hasQuarterState; /** * 中奖状态 */ private State winnerState; /** * 当前状态，默认售空 */ private State state; /** * 糖果库存 */ private int count; public GumballMachine(int count) { soldOutState = new SoldOutState(this); soldState = new SoldState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); winnerState = new WinnerState(this); state = soldOutState; this.count = count; if (count > 0) { state = noQuarterState; } } /** * 投钱。 */ public void insertQuarter() { state.insertQuarter(); } /** * 退钱。 */ public void ejectQuarter() { state.ejectQuarter(); } /** * 转动曲柄购买糖果。 */ public void turnCrank() { state.turnCrank(); state.dispense(); } /** * 发放糖果。 */ void releaseBall() { System.out.println(\"发放糖果成功。\"); if (count != 0) { count--; } } /** * 填充糖果库存。 */ void refill(int count) { this.count = count; state = noQuarterState; } public State getSoldOutState() { return soldOutState; } public State getSoldState() { return soldState; } public State getNoQuarterState() { return noQuarterState; } public State getHasQuarterState() { return hasQuarterState; } public State getWinnerState() { return winnerState; } public int getCount() { return count; } void setState(State state) { this.state = state; } public State getState() { return state; } @Override public String toString() { return \"目前糖果库存\" + count; } } /** * @Author 喵粮都输光了 * @Date 2020/3/16 10:55 * @Description 测试 */ public class Main { public static void main(String[] args) { GumballMachine gumballMachine = new GumballMachine(5); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之迭代器模式与组合模式","date":"2020-03-15T02:16:31.000Z","path":"posts/f8e48b7d/","text":"迭代器模式 迭代器模式提供一种方法顺序访问一个聚合(集合)对象中的各个元素，而又不暴露其内部的表示。 设计原则：一个类应该只有一个引起变化的原因，即单一责任。 迭代器模式UML类图： 迭代器模式原型 当不同类型的集合在遍历时需要使用不同的循环进行遍历，迭代器模式便是抽取遍历的部分进行封装，因此只需一个循环即可多态的处理任何集合项。 案例：两个菜单项，一个返回数组一个返回ArrayList，此时需要两个循环进行遍历，通过iterator进行封装使用一个循环遍历两个不同集合。其UML图如下： 代码演示：此处使用java自带的iterator（也可以自己设计一个iterator接口包含hasNext()和next()方法即可。） 1.菜单项。 /** * @Author 喵粮都输光了 * @Date 2020/3/15 14:45 * @Description 菜单项 */ public class MenuItem { /** * 菜名 */ private String name; /** * 是否是素菜 */ private boolean vegetarian; /** * 菜价 */ private double price; public MenuItem(String name, boolean vegetarian, double price) { this.name = name; this.vegetarian = vegetarian; this.price = price; } public String getName() { return name; } public boolean isVegetarian() { return vegetarian; } public double getPrice() { return price; } } 2.早餐(ArrayList)和晚餐(数组)，因为ArrayList JAVA实现过iterator可以不用管，数组没有实现iterator，需要继承JAVA的iterator接口自己实现。 /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:20 * @Description 创建菜单迭代器接口 */ public interface Menu { /** * 创建菜单迭代器 * @return 菜单迭代器 */ Iterator&lt;MenuItem> createIterator(); } /** * @Author 喵粮都输光了 * @Date 2020/3/15 14:48 * @Description 早餐菜单，ArrayList方式 */ public class BreakfastMenu implements Menu { private ArrayList&lt;MenuItem> menuItems; public BreakfastMenu() { menuItems = new ArrayList&lt;>(); addItem(\"鸡蛋\", true, 1); addItem(\"牛奶\", false, 3); addItem(\"皮蛋瘦肉粥\", false, 10); } /** * 增加菜单项 * @param name 菜名 * @param vegetarian 是否素菜 * @param price 价格 */ public void addItem(String name, boolean vegetarian, double price) { MenuItem menuItem = new MenuItem(name, vegetarian, price); menuItems.add(menuItem); } @Override public Iterator&lt;MenuItem> createIterator() { return menuItems.iterator(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 14:49 * @Description 晚餐菜单，数组方式 */ public class DinnerMenu implements Menu { /** * 菜单最大存储菜单项 */ private static final int MAX_ITEMS = 6; /** * 已存储菜单项 */ private int numberOfItems = 0; private MenuItem[] menuItems; public DinnerMenu() { menuItems = new MenuItem[MAX_ITEMS]; addItem(\"小炒肉\", false, 8); addItem(\"大鸡腿\", false, 7); addItem(\"青菜\", true, 3); } /** * 增加菜单项 * @param name 菜名 * @param vegetarian 是否素菜 * @param price 价格 */ public void addItem(String name, boolean vegetarian, double price) { MenuItem menuItem = new MenuItem(name, vegetarian, price); if (numberOfItems >= MAX_ITEMS) { System.err.println(\"菜单满了，不能再添加菜单项了。\"); } else { menuItems[numberOfItems] = menuItem; numberOfItems++; } } @Override public Iterator&lt;MenuItem> createIterator() { return new DinnerMenuIterator(menuItems); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:29 * @Description 晚餐菜单迭代器 */ public class DinnerMenuIterator implements Iterator&lt;MenuItem> { private int position = 0; private MenuItem[] menuItems; public DinnerMenuIterator(MenuItem[] menuItems) { this.menuItems = menuItems; } @Override public boolean hasNext() { return position &lt; menuItems.length &amp;&amp; menuItems[position] != null; } @Override public MenuItem next() { return menuItems[position++]; } @Override public void remove() { throw new UnsupportedOperationException(\"不支持删除操作。\"); } } 3.对两个菜单进行打印。 /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:14 * @Description 女招待，用于打印菜单 */ public class Waitress { private ArrayList&lt;Iterator&lt;MenuItem>> menus; public Waitress(ArrayList&lt;Iterator&lt;MenuItem>> menus) { this.menus = menus; } /** * 打印菜单 */ public void printMenu() { Iterator&lt;Iterator&lt;MenuItem>> menuIterator = menus.iterator(); while (menuIterator.hasNext()) { Iterator&lt;MenuItem> menu = menuIterator.next(); printMenu(menu); } /* 可用将上面的代码替换成如下： * 超级for可用在一个集合或者一个数组中遍历，无需显示创建迭代器。 * for (Iterator&lt;MenuItem> menu : menus) { printMenu(menu); } */ } /** * 根据传入的iterator打印菜单 * @param menuIterator 菜单iterator */ private void printMenu(Iterator&lt;MenuItem> menuIterator) { while (menuIterator.hasNext()) { MenuItem menuItem = menuIterator.next(); System.out.println(menuItem.getName() + \", \" + menuItem.getPrice()); } } } 4.测试。 /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:07 * @Description 测试 */ public class Main { public static void main(String[] args) { BreakfastMenu breakfastMenu = new BreakfastMenu(); DinnerMenu dinnerMenu = new DinnerMenu(); ArrayList&lt;Iterator&lt;MenuItem>> menus = new ArrayList&lt;>(); menus.add(breakfastMenu.createIterator()); menus.add(dinnerMenu.createIterator()); Waitress waitress = new Waitress(menus); waitress.printMenu(); } } 组合模式 组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。说白了组合模式就是对树形结构的一种遍历。 组合模式UML类图： 组合模式原型 需求：此时需要为晚餐菜单增加子菜单甜点，也就是说打印方法还需要打印菜单中的菜单。可用通过组合模式的方法，将菜单和菜单项视作同一个整体进行遍历。其UML图如下： 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/15 16:40 * @Description 菜单组件提供了菜单项和菜单所需的操作。 */ public abstract class BaseMenuComponent { /** * 新增菜单组件 * @param menuComponent 菜单组件 */ public void add(BaseMenuComponent menuComponent) { throw new UnsupportedOperationException(); } /** * 删除菜单组件 * @param menuComponent 菜单组件 */ public void remove(BaseMenuComponent menuComponent) { throw new UnsupportedOperationException(); } /** * 获取菜单组件 * @param i 下标 * @return 菜单组件 */ public BaseMenuComponent getChild(int i) { throw new UnsupportedOperationException(); } /** * 获取菜单或菜名字 * @return 菜名或菜单名 */ public String getName() { throw new UnsupportedOperationException(); } /** * 获取菜单或菜介绍 * @return 菜介绍或者菜单介绍 */ public String getDescription() { throw new UnsupportedOperationException(); } /** * 获取菜价 * @return 菜价 */ public double getPrice() { throw new UnsupportedOperationException(); } /** * 菜是否是素菜 * @return true or false */ public boolean isVegetarian() { throw new UnsupportedOperationException(); } /** * 打印菜单或者菜 */ public void print() { throw new UnsupportedOperationException(); } /** * 创建迭代器 * @return 迭代器 */ public Iterator&lt;BaseMenuComponent> createIterator() { throw new UnsupportedOperationException(); } /** * 返回list * @return list */ public List&lt;BaseMenuComponent> getMenuComponentList() { throw new UnsupportedOperationException(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 17:23 * @Description 菜单迭代器 */ public class CompositeIterator implements Iterator&lt;BaseMenuComponent> { private Stack&lt;Iterator&lt;BaseMenuComponent>> stack = new Stack&lt;>(); public CompositeIterator(Iterator&lt;BaseMenuComponent> iterator) { stack.push(iterator); } @Override public boolean hasNext() { if (stack.empty()) { return false; } else { Iterator&lt;BaseMenuComponent> iterator = stack.peek(); if (!iterator.hasNext()) { stack.pop(); return hasNext(); } else { return true; } } } @Override public BaseMenuComponent next() { if (hasNext()) { Iterator&lt;BaseMenuComponent> iterator = stack.peek(); BaseMenuComponent component = iterator.next(); if (component instanceof Menu) { stack.push(component.getMenuComponentList().iterator()); } return component; } else { return null; } } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 16:56 * @Description 菜单（组合） */ public class Menu extends BaseMenuComponent { private ArrayList&lt;BaseMenuComponent> menuComponents = new ArrayList&lt;>(); private String name; private String description; public Menu(String name, String description) { this.name = name; this.description = description; } @Override public void add(BaseMenuComponent menuComponent) { menuComponents.add(menuComponent); } @Override public void remove(BaseMenuComponent menuComponent) { menuComponents.remove(menuComponent); } @Override public BaseMenuComponent getChild(int i) { return menuComponents.get(i); } @Override public String getName() { return name; } @Override public String getDescription() { return description; } @Override public void print() { System.out.println(\"------------------------\\n\" + getName() + \", \" + getDescription()); // 还需要打印该子菜单中的菜或者是子子菜单。 for (BaseMenuComponent menuComponent : menuComponents) { menuComponent.print(); } } @Override public Iterator&lt;BaseMenuComponent> createIterator() { return new CompositeIterator(menuComponents.iterator()); } @Override public List&lt;BaseMenuComponent> getMenuComponentList() { return menuComponents; } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 14:45 * @Description 菜单项（叶子） */ public class MenuItem extends BaseMenuComponent { /** * 菜名 */ private String name; /** * 是否是素菜 */ private boolean vegetarian; /** * 菜价 */ private double price; /** * 菜介绍 */ private String description; public MenuItem(String name, boolean vegetarian, double price, String description) { this.name = name; this.vegetarian = vegetarian; this.price = price; this.description = description; } @Override public String getDescription() { return description; } @Override public String getName() { return name; } @Override public double getPrice() { return price; } @Override public boolean isVegetarian() { return vegetarian; } @Override public void print() { System.out.println(getName() + \", 是素菜吗？\" + isVegetarian() + \", \" + getPrice()); } @Override public Iterator&lt;BaseMenuComponent> createIterator() { // 菜单项是叶子不需要再遍历了 return new NullIterator(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:54 * @Description 空迭代器 */ public class NullIterator implements Iterator&lt;BaseMenuComponent> { @Override public boolean hasNext() { return false; } @Override public Object next() { return null; } @Override public void remove() { throw new UnsupportedOperationException(\"不支持删除操作。\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:14 * @Description 女招待，用于打印菜单 */ public class Waitress { private BaseMenuComponent allMenus; public Waitress(BaseMenuComponent allMenus) { this.allMenus = allMenus; } /** * 打印所有菜单项 */ public void printMenu() { allMenus.print(); } /** * 输出所有素菜菜单项 */ public void printVegetarianMenu() { Iterator&lt;BaseMenuComponent> iterator = allMenus.createIterator(); while (iterator.hasNext()) { BaseMenuComponent menuComponent = iterator.next(); try { if (menuComponent.isVegetarian()) { menuComponent.print(); } } catch (UnsupportedOperationException ignored) { } } } } /** * @Author 喵粮都输光了 * @Date 2020/3/15 15:07 * @Description 测试 */ public class Main { public static void main(String[] args) { BaseMenuComponent allMenus = new Menu(\"总菜单\", \"总菜单介绍\"); BaseMenuComponent breakfastMenu = new Menu(\"早餐\", \"早餐介绍\"); BaseMenuComponent dinnerMenu = new Menu(\"晚餐\", \"晚餐介绍\"); BaseMenuComponent dessertMenu = new Menu(\"晚餐后甜点\", \"晚餐后甜点介绍\"); breakfastMenu.add(new MenuItem(\"鸡蛋\", true, 1, \"鸡蛋早餐\")); breakfastMenu.add(new MenuItem(\"牛奶\", false, 3, \"牛奶早餐\")); dinnerMenu.add(new MenuItem(\"小炒肉\", false, 8, \"小炒肉晚餐\")); dinnerMenu.add(new MenuItem(\"大鸡腿\", false, 7, \"大鸡腿晚餐\")); dessertMenu.add(new MenuItem(\"大西瓜\", true, 20, \"西瓜甜点\")); dinnerMenu.add(dessertMenu); allMenus.add(breakfastMenu); allMenus.add(dinnerMenu); Waitress waitress = new Waitress(allMenus); waitress.printMenu(); waitress.printVegetarianMenu(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之模板方法模式","date":"2020-03-14T05:07:55.000Z","path":"posts/6948162f/","text":"模板方法模式 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 设计原则：别调用我们，我们会调用你，即好莱坞原则。也就是说高层组件控制何时以及如何使用底层组件，底层组件可以参与计算但不能直接调用高层组件（不绝对），防止低层组件依赖高层组件，高层组件又依赖底层组件的情况发生。 模板方法模式UML类图： 原型 需求：设计一个咖啡类，其中有一个方法可以进行咖啡的冲泡（1.煮沸水；2.冲泡咖啡；3.倒入杯子；4.加糖和牛奶）；设计一个茶类，其中有一个方法可以进行茶的冲泡（1.煮沸水；2.浸泡茶叶；3.倒入杯子；4.加柠檬）。这两个类都有相同的步骤1和3，对步骤2和4进行更高层抽象可以笼统为步骤2冲泡和步骤4加调料。再在抽象类中增加对饮料制作步骤的控制方法就是模板方法的原形了。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:11 * @Description 咖啡因饮料 */ public abstract class BaseCaffeineBeverage { /** * 进行饮料冲泡，固定步骤防止被子类覆盖 */ final void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } /** * 煮沸水，固定方法防止被子类覆盖 */ protected final void boilWater() { System.out.println(\"煮沸水\"); } /** * 冲泡 */ protected abstract void brew(); /** * 倒入杯子，固定方法防止被子类覆盖 */ protected final void pourInCup() { System.out.println(\"倒入杯子\"); } /** * 增加佐料 */ protected abstract void addCondiments(); } /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 咖啡类 */ public class Coffee extends BaseCaffeineBeverage { @Override protected void brew() { System.out.println(\"冲泡咖啡\"); } @Override protected void addCondiments() { System.out.println(\"添加糖和牛奶\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 茶叶类 */ public class Tea extends BaseCaffeineBeverage { @Override protected void brew() { System.out.println(\"浸泡茶叶\"); } @Override protected void addCondiments() { System.out.println(\"加柠檬\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 测试 */ public class Main { public static void main(String[] args) { Coffee coffee = new Coffee(); coffee.prepareRecipe(); Tea tea = new Tea(); tea.prepareRecipe(); } } 增加钩子 需求：饮料中的调料需要根据客户的需求选择添加或不添加。 解决：使用钩子，钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩，是否需要挂钩则由子类自行决定。 代码演示： 修改BaseCaffeineBeverage类，因为添加调料方法是可选的，将其更改为钩子。 /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:11 * @Description 咖啡因饮料 */ public abstract class BaseCaffeineBeverage { /** * 进行饮料冲泡，固定步骤防止被子类覆盖 */ final void prepareRecipe() { boilWater(); brew(); pourInCup(); if (customerWantsCondiments()) { addCondiments(); } } /** * 煮沸水，固定方法防止被子类覆盖 */ protected final void boilWater() { System.out.println(\"煮沸水\"); } /** * 冲泡 */ protected abstract void brew(); /** * 倒入杯子，固定方法防止被子类覆盖 */ protected final void pourInCup() { System.out.println(\"倒入杯子\"); } /** * 增加佐料 */ protected abstract void addCondiments(); /** * 客户是否需要添加调料，默认添加 * @return true */ protected boolean customerWantsCondiments() { return true; } } 以咖啡类为例，修改方法。 import java.util.Scanner; /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 咖啡类 */ public class Coffee extends BaseCaffeineBeverage { /** * 用户输入首字母判断是否为y */ private final static String YES = \"y\"; @Override protected void brew() { System.out.println(\"冲泡咖啡\"); } @Override protected void addCondiments() { System.out.println(\"添加糖和牛奶\"); } /** * 根据客户对调料的需求覆写该方法，则可以不覆盖默认客户需要调料。 * @return true or false */ @Override protected boolean customerWantsCondiments() { String answer = getUserInput(); return answer.toLowerCase().startsWith(YES); } /** * 获取用户输入 * @return 用户输入 */ private String getUserInput() { System.out.println(\"是否需要添加牛奶和糖？(y/n)\"); Scanner scanner = new Scanner(System.in); String answer = scanner.next(); scanner.close(); return answer; } } 进行测试。 /** * @Author 喵粮都输光了 * @Date 2020/3/14 14:16 * @Description 测试 */ public class Main { public static void main(String[] args) { Coffee coffee = new Coffee(); coffee.prepareRecipe(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之适配器模式与外观模式","date":"2020-03-13T06:12:37.000Z","path":"posts/aa979c82/","text":"适配器模式 适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 使用场景：当需要使用一个现有的类而其接口并不符合你的需求时，就使用适配器。 对象适配器模式 对象适配器模式通过组合的方式实现适配器模式，比类适配器模式更灵活。其UML类图如下： 代码演示： 有一个鸭子类。 /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:55 * @Description 鸭子接口 */ public interface Duck { /** * 鸭子呱呱叫 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:57 * @Description 绿头鸭 */ public class MallardDuck implements Duck { @Override public void quack() { System.out.println(\"呱呱叫\"); } } 有一个火鸡类。 /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:55 * @Description 火鸡接口 */ public interface Turkey { /** * 火鸡咯咯叫 */ void gobble(); } /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:58 * @Description 野生火鸡 */ public class WildTurkey implements Turkey { @Override public void gobble() { System.out.println(\"咯咯叫\"); } } 将火鸡包装成鸭子并测试。 /** * @Author 喵粮都输光了 * @Date 2020/3/13 15:00 * @Description 火鸡适配器，火鸡→鸭子 */ public class TurkeyAdapter implements Duck { private Turkey turkey; TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } @Override public void quack() { turkey.gobble(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/13 14:59 * @Description 测试 */ public class Main { public static void main(String[] args) { // 鸭子 Duck duck = new MallardDuck(); duck.quack(); // 火鸡 Turkey turkey = new WildTurkey(); turkey.gobble(); // 将需要转换的火鸡变成鸭子 Duck turkeyAdapter = new TurkeyAdapter(turkey); turkeyAdapter.quack(); } } 类适配器模式 类适配器模式：通过继承的方式实现适配器模式。其UML类图如下： 代码演示（JAVA不支持多继承此处使用python）： class Duck: @staticmethod def quack(): print(\"呱呱叫\") class Turkey: @staticmethod def gobble(): print(\"咯咯叫\") class TurkeyAdapter(Duck, Turkey): def quack(self): self.gobble() if __name__ == '__main__': duck = Duck() duck.quack() turkey = Turkey() turkey.gobble() turkeyAdapter = TurkeyAdapter() turkeyAdapter.quack() 外观模式 外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 使用场景：当需要简化并统一一个很大的接口或者一群复杂的接口时，就使用外观模式。 设计原则：只和你的密友谈话，即最少知识原则。也就是说在对象的方法内调用属于一下范围的方法： 该对象本身。 被当作方法的参数而传递进来的对象。 此方法所创建或实例化的任何对象。 对象的任何组件，也就是构造方法传入的参数或对象。 最好不要使用对象的方法的方法所返回的值。当然不需要完全遵守，因为实现最少知识原则虽然减少了对象之间的依赖方便维护，但是导致系统复杂度和开发时间的增加并降低了运行时的性能。 外观模式可以这么来看。当有一批操作经常需要一起进行时，也就是说我想完成一个操作，而这个操作需要调用类A的a方法，类B的bc方法，类C…等等。这时候可以创建一个外观（类），在构造参数中传入每一个使用到的组件并把它们赋值给相应的实例变量，然后创建方法，在方法中执行之前所需执行的一系列操作。这样就使用上了外观模式，外观模式将客户从复杂的子系统中解耦。 外观模式UML类图： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之命令模式","date":"2020-03-12T05:30:23.000Z","path":"posts/933830c7/","text":"命令模式 命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。常用于队列请求（命令对象排队进行处理）和日志请求（所有操作记录于日志中，系统死机时可以按照日志恢复）。 命令模式UML类图： 原型设计一个遥控器，当按下遥控器上的按钮时，就会执行一个命令，例如打开风扇或关闭电灯。遥控器无需知道如何执行命令，只需要知道按下按钮即可完成命令。其实说白了就是将原来控制器直接调用具体方法变成了控制器调用命令对象，命令对象调用具体方法，有一个特别大的好处，就是控制器调用命令对象可以对一系列的方法进行操控，而不是像原来一个一个去new调用。代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 命令接口 */ public interface Command { /** * 命令执行 */ void execute(); } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:28 * @Description 开关门命令 */ public class DoorCommand implements Command { private Door door; DoorCommand(Door door) { this.door = door; } @Override public void execute() { if (door.getStatus() == 1) { door.off(); } else { door.on(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:22 * @Description 大门实体 */ public class Door { /** * 门关着 */ private static final int OFF = 0; /** * 门开着 */ private static final int ON = 1; /** * 门状态 */ private int status; Door() { status = OFF; } void off() { status = OFF; System.out.println(\"门关上了\"); } void on() { status = ON; System.out.println(\"门打开了\"); } int getStatus() { return status; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:15 * @Description 关灯命令 */ public class LightOffCommand implements Command { private Light light; LightOffCommand(Light light) { this.light = light; } @Override public void execute() { light.off(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启强光灯命令 */ public class LightOnStrongCommand implements Command { private Light light; LightOnStrongCommand(Light light) { this.light = light; } @Override public void execute() { light.strong(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启弱光灯命令 */ public class LightOnWeekCommand implements Command { private Light light; LightOnWeekCommand(Light light) { this.light = light; } @Override public void execute() { light.week(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:16 * @Description 灯实体 */ public class Light { /** * 强光 */ private static final int STRONG = 2; /** * 弱光 */ private static final int WEEK = 1; /** * 关闭 */ private static final int OFF = 0; /** * 灯光亮度 */ private int luminance; Light() { luminance = OFF; } void strong() { luminance = STRONG; System.out.println(\"开启了强光灯\"); } void week() { luminance = WEEK; System.out.println(\"开启了弱光灯\"); } void off() { luminance = OFF; System.out.println(\"灯关了\"); } int getLuminance() { return luminance; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:32 * @Description 控制器实体，相当于invoker */ public class RemoteControl { /** * 控制器按钮多个 */ private Command[] button; RemoteControl() { // 按钮5个 button = new Command[5]; } /** * 将具体按钮与需要执行的命令绑定 * @param location 按钮位置 * @param command 命令 */ void setCommand(int location, Command command) { button[location] = command; } /** * 按下按钮执行命令 */ void buttonWasPressed(int location) { button[location].execute(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 测试 */ public class Main { public static void main(String[] args) { // 控制器 RemoteControl remoteControl = new RemoteControl(); // 需要操控的对象 Door door = new Door(); Light light = new Light(); // 命令需要有执行的对象 Command doorCommand = new DoorCommand(door); Command lightOnWeekCommand = new LightOnWeekCommand(light); Command lightOnStrongCommand = new LightOnStrongCommand(light); Command lightOffCommand = new LightOffCommand(light); // 控制器按钮绑定需要执行的命令 remoteControl.setCommand(0, doorCommand); remoteControl.setCommand(1, lightOnWeekCommand); remoteControl.setCommand(2, lightOnStrongCommand); remoteControl.setCommand(3, lightOffCommand); // 操作控制器 remoteControl.buttonWasPressed(0); remoteControl.buttonWasPressed(0); remoteControl.buttonWasPressed(1); remoteControl.buttonWasPressed(2); remoteControl.buttonWasPressed(3); } } 增加undo方法为命令模式实现撤销方法。代码演示：修改Command和其实现类，对于门只有开关两种状态，检测一下当前状态将其向反方向执行就是撤销了。对于有多种状态的对象例如灯有强光、弱光和关闭，则需要变量先对其进行记录才能进行撤销。 /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 命令接口 */ public interface Command { /** * 命令执行 */ void execute(); /** * 撤销上一条执行的命令 */ void undo(); } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:28 * @Description 开关门命令 */ public class DoorCommand implements Command { private Door door; DoorCommand(Door door) { this.door = door; } @Override public void execute() { if (door.getStatus() == 1) { door.off(); } else { door.on(); } } @Override public void undo() { execute(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 18:52 * @Description 灯光命令 */ public class LightCommand implements Command { private Light light; /** * 记录灯光亮度 */ private int luminance; LightCommand(Light light) { this.light = light; } @Override public void execute() { } @Override public void undo() { if (luminance == Light.OFF) { light.off(); } else if (luminance == Light.WEEK) { light.week(); } else if (luminance == Light.STRONG) { light.strong(); } } public Light getLight() { return light; } public void setLuminance(int luminance) { this.luminance = luminance; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启弱光灯命令 */ public class LightOnWeekCommand extends LightCommand { LightOnWeekCommand(Light light) { super(light); } @Override public void execute() { setLuminance(getLight().getLuminance()); getLight().week(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:31 * @Description 开启强光灯命令 */ public class LightOnStrongCommand extends LightCommand { LightOnStrongCommand(Light light) { super(light); } @Override public void execute() { setLuminance(getLight().getLuminance()); getLight().strong(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:15 * @Description 关灯命令 */ public class LightOffCommand extends LightCommand { LightOffCommand(Light light) { super(light); } @Override public void execute() { setLuminance(getLight().getLuminance()); getLight().off(); } } 修改RemoteControl类，在控制器中新增变量用于记录上一条执行的命令就可以实现撤销功能了。 /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:32 * @Description 控制器实体，相当于invoker */ public class RemoteControl { /** * 控制器按钮多个 */ private Command[] button; /** * 记录上一个执行的命令 */ private Command undoCommand; RemoteControl() { button = new Command[5]; } /** * 将具体按钮与需要执行的命令绑定 * @param location 按钮位置 * @param command 命令 */ void setCommand(int location, Command command) { button[location] = command; } /** * 按下按钮执行命令 */ void buttonWasPressed(int location) { button[location].execute(); undoCommand = button[location]; } /** * 撤销按钮 */ void undoButtonWasPushed() { if (undoCommand != null) { undoCommand.undo(); } } } 修改测试类（带结果）。 // 操作控制器 //门打开了 remoteControl.buttonWasPressed(0); //门关上了 remoteControl.undoButtonWasPushed(); //开启了弱光灯 remoteControl.buttonWasPressed(1); //灯关了 remoteControl.undoButtonWasPushed(); //开启了强光灯 remoteControl.buttonWasPressed(2); //灯关了 remoteControl.buttonWasPressed(3); 使用宏命令同时执行多个命令，例如同时打开灯和门。以及撤销宏命令。 /** * @Author 喵粮都输光了 * @Date 2020/3/12 19:06 * @Description 宏命令 */ public class MacroCommand implements Command { private Command[] commands; MacroCommand(Command[] commands) { this.commands = commands; } @Override public void execute() { for (Command command : commands) { command.execute(); } } @Override public void undo() { for (Command command : commands) { command.undo(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 17:13 * @Description 测试 */ public class Main { public static void main(String[] args) { RemoteControl remoteControl = new RemoteControl(); Door door = new Door(); Light light = new Light(); Command doorCommand = new DoorCommand(door); Command lightOnStrongCommand = new LightOnStrongCommand(light); Command[] commands = {doorCommand, lightOnStrongCommand}; MacroCommand macroCommand = new MacroCommand(commands); remoteControl.setCommand(0, macroCommand); remoteControl.buttonWasPressed(0); remoteControl.undoButtonWasPushed(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之单件模式","date":"2020-03-12T03:30:49.000Z","path":"posts/9b1fa808/","text":"单件模式 单件模式确保一个类只有一个实例，并提供一个全局访问点。 应用场景：有些对象其实只需要一个而不是多个，例如线程池、缓存、注册表、全局设置等。因此当需要确保程序中的某个类只有一个实例时，就可以采用单件模式。 原型该单件模式是延迟实例化模式。代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:27 * @Description 单件模式 */ public class Singleton { /** * getInstance静态方法中使用了该变量因此需要在变量上加static，确保唯一性。 */ private static Singleton uniqueInstance; /** * 禁止new创建 */ private Singleton() { } /** * 当实例未被创建时，uniqueInstance为空，创建一个实例返回，否则返回已创建的实例。 * 此处static是因为无法通过new创建实例则无法调用实例的方法。通过static关键字可以直接使用类名调用方法。 * @return Singleton */ public static Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:29 * @Description 测试 */ public class Main { public static void main(String[] args) { Singleton singleton = Singleton.getInstance(); System.out.println(singleton); } } 处理多线程 问题：原型的单例模式在多线程情况下可能会创建多个不同的实例。 解决1：为getInstance()增加关键字synchronized，但是会造成性能非常低的问题。如果getInstance()的性能对应用程序不是很关键这个方法足够使用了。 代码演示1： 修改原型的getInstance()如下即可。 public static synchronized Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } 解决2：使用急切实例化的方法，而不是使用延迟实例化的做法。如果程序在创建和运行时方面的负担不太繁重，这样会让JVM在加载这个类时马上创建出此唯一的单件实例，就不存在线程安全问题啦。 代码演示2： /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:27 * @Description 急切实例化的单件模式 */ public class Singleton { private static Singleton uniqueInstance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return uniqueInstance; } } 解决3：用“双重检查加锁”，在getInstance()中减少使用同步。这样做会先检查实例是否创建了，未创建才进行同步，这样保证只有第一次调用方法实例化时才会同步。 代码演示3： /** * @Author 喵粮都输光了 * @Date 2020/3/12 12:27 * @Description 双重检查加锁的单件模式 */ public class Singleton { /** * volatile关键词确保当uniqueInstance变量被初始化成Singleton实例时，多个线程能正确地处理uniqueInstance变量。 */ private volatile static Singleton uniqueInstance = new Singleton(); private Singleton() { } /** * 此处判断两次是为了防止当多个线程通过了第一次判断之后，其中一个线程加锁进行了实例化之后解锁， * 另一个线程加锁进来又一次实例化之后解锁，导致实例化对象不同的情况。因此在锁内还需要判断一次。 * @return Singleton */ public static Singleton getInstance() { if (uniqueInstance == null) { synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之工厂模式","date":"2020-03-11T07:23:40.000Z","path":"posts/bf53f1b3/","text":"工厂模式 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。 抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 设计原则：要依赖抽象，不要依赖具体类，即依赖倒置原则。 应用场景： 简单工厂：将实例化具体类的代码进行了封装，实现了解耦操作。缺点也很明显，不利于扩展，需要创建对象数量众多时，工厂会比较臃肿。且每次修改都需要对源代码进行修改，违反了关闭修改的设计原则。 工厂方法：拥有简单工厂的优点，并且便于扩展（新增不同的子类即可），适用于实现具体工厂。在编写新的具体产品类时，还要提供与之相对的具体工厂类，类的个数成对增长，在一定程度上增加了系统的复杂度。其UML类图如下： 抽象工厂：如果需要创建一系列同分类的产品时，使用抽象工厂是一个很好的选择，可以将相关产品都聚合起来。需要注意的是如果要新增一个产品需要对接口进行修改！所以常用于事先规划好且不会进行变更的产品。具体工厂实现经常使用工厂方式进行搭配。其UML类图如下： 原型设计一个比萨商店系统，出售各种类型的比萨（比萨商店类，比萨抽象类，具体比萨子类）。 简单工厂 问题：当通过比萨商店出售比萨时，需要按照所需比萨类型去实例化具体的比萨子类。当比萨商店新增不同的比萨时，需要修改商店的实例化部分代码，也就是说需要不断的修改源代码。 解决：将实例化部分代码提取出来设计成一个简单工厂，专门用该工厂实例化不同类型的比萨。此时，新增比萨则无需变动比萨商店类，只需修改简单工厂即可。 简单工厂UML类图： 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:06 * @Description 比萨抽象类 */ public abstract class BasePizza { /** * 比萨名字 */ private String name; /** * 面团种类 */ private String dough; /** * 准备材料过程 */ void prepare() { System.out.println(\"材料准备\"); } /** * 打包过程 */ void box() { System.out.println(\"打包\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDough() { return dough; } public void setDough(String dough) { this.dough = dough; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 芝士比萨子类 */ public class CheesePizza extends BasePizza { CheesePizza() { setName(\"芝士比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 素食比萨子类 */ public class VeggiePizza extends BasePizza { VeggiePizza() { setName(\"素食比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:21 * @Description 披萨简单工厂 */ public class SimplePizzaFactory { /** * 芝士比萨 */ public final static String CHEESE = \"cheese\"; /** * 素食比萨 */ public final static String VEGGIE = \"veggie\"; /** * 创建具体类型比萨 * @param type 比萨类型 * @return 具体类型比萨 */ BasePizza createPizza(String type) { BasePizza pizza = null; if (type.equals(CHEESE)) { pizza = new CheesePizza(); } else if (type.equals(VEGGIE)) { pizza = new VeggiePizza(); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:18 * @Description 披萨商店 */ public class PizzaStore { private SimplePizzaFactory factory; PizzaStore(SimplePizzaFactory factory) { this.factory = factory; } /** * 比萨订单 * @param type 比萨类型 * @return 具体类型比萨 */ BasePizza orderPizza(String type) { BasePizza pizza; pizza = factory.createPizza(type); pizza.prepare(); pizza.box(); return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:14 * @Description 测试 */ public class Main { public static void main(String[] args) { SimplePizzaFactory simplePizzaFactory = new SimplePizzaFactory(); PizzaStore pizzaStore = new PizzaStore(simplePizzaFactory); BasePizza cheesePizza = pizzaStore.orderPizza(SimplePizzaFactory.CHEESE); System.out.println(cheesePizza.getName() + \"完成\"); BasePizza veggiePizza = pizzaStore.orderPizza(SimplePizzaFactory.VEGGIE); System.out.println(veggiePizza.getName() + \"完成\"); } } 工厂方法模式 问题：此时如果要新增比萨商店，例如中国比萨商店、日本比萨商店，可以通过增加各地区简单工厂来实现。但是通过简单工厂的方式实现无法变更正在创建的产品，也就是说当需要增加新产品时就需要更改工厂类，违反了对修改关闭的原则。 解决：将简单工厂实现为继承PizzaStore的具体子类，PizzaStore中新增create的抽象方法。使用工厂方式模式一定程度可以克服以上问题。 工厂方法模式例子UML类图： 代码演示： 将PizzaStore类改变成BasePizzaStore抽象类。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:18 * @Description 披萨商店 */ public abstract class BasePizzaStore { /** * 芝士比萨 */ public final static String CHEESE = \"cheese\"; /** * 素食比萨 */ public final static String VEGGIE = \"veggie\"; /** * 比萨订单 * @param type 比萨类型 * @return 具体类型比萨 */ BasePizza orderPizza(String type) { BasePizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.box(); return pizza; } /** * 实例化具体的比萨 * @param type 比萨类型 * @return 具体类型比萨 */ abstract BasePizza createPizza(String type); } 新建中国比萨商店和日本比萨商店以及两商店所能产出的比萨。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 中国素食比萨子类 */ public class ChinaVeggiePizza extends BasePizza { ChinaVeggiePizza() { setName(\"中国素食比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 中国芝士比萨子类 */ public class ChinaCheesePizza extends BasePizza { ChinaCheesePizza() { setName(\"中国芝士比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 中国比萨商店子类 */ public class ChinaPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; if (type.equals(CHEESE)) { pizza = new ChinaCheesePizza(); } else if (type.equals(VEGGIE)) { pizza = new ChinaVeggiePizza(); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 日本素食比萨子类 */ public class JapanVeggiePizza extends BasePizza { JapanVeggiePizza() { setName(\"日本素食比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 日本芝士比萨子类 */ public class JapanCheesePizza extends BasePizza { JapanCheesePizza() { setName(\"日本芝士比萨\"); setDough(\"普通面团\"); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 日本比萨商店子类 */ public class JapanPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; if (type.equals(CHEESE)) { pizza = new JapanCheesePizza(); } else if (type.equals(VEGGIE)) { pizza = new JapanVeggiePizza(); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:14 * @Description 测试 */ public class Main { public static void main(String[] args) { BasePizzaStore chinaPizzaStore = new ChinaPizzaStore(); BasePizza chinaPizza = chinaPizzaStore.orderPizza(BasePizzaStore.CHEESE); System.out.println(chinaPizza.getName() + \"完成\"); BasePizzaStore japanPizzaStore = new JapanPizzaStore(); BasePizza japanPizza = japanPizzaStore.orderPizza(BasePizzaStore.VEGGIE); System.out.println(japanPizza.getName() + \"完成\"); } } 抽象工厂模式 问题：每个地区生产的比萨制作方法不同，原料也不尽相同，这时就需要一个原料工厂了。以面团为例，面团假设有厚面团和薄面团，通过使用工厂方式模式就需要建立一个父类面团，子类厚面团和薄面团。原料不可能只有面团，有无数个都需要如此建立父类子类，这是非常劳累的事情，而且他们都属于一个类别，通过工厂方式模式无法将这些原料归类在一起。 解决：使用抽象工厂模式，设计一个原料工厂接口用于创建所有所需原料，然后按地区划分创建原料工厂实现类，直接实例化具体的原料，例如厚面团。这样做的好处是可以聚集所有同类别的代码，相当于分类一样。 抽象工厂模式例子UML类图： 代码演示： 新增原料工厂接口，并实现具体地区的原料工厂。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:25 * @Description 比萨原料工厂接口 */ public interface PizzaIngredientFactory { /** * 生产面团 * @return 面团 */ Dough createDough(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:48 * @Description 中国比萨原料工厂 */ public class ChinaIngredientFactory implements PizzaIngredientFactory { @Override public Dough createDough() { // 使用厚皮 return new ThickCrustDough(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:49 * @Description 日本比萨原料工厂 */ public class JapanIngredientFactory implements PizzaIngredientFactory { @Override public Dough createDough() { // 使用薄皮 return new ThinCrustDough(); } } 新增面团原料接口，并实现具体的面团。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:26 * @Description 面团 */ public interface Dough { /** * 面团类型 * @return 面团类型 */ String doughType(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:46 * @Description 厚皮面粉实现类 */ public class ThickCrustDough implements Dough { @Override public String doughType() { return \"厚皮面粉\"; } @Override public String toString() { return doughType(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 21:46 * @Description 薄皮面粉实现类 */ public class ThinCrustDough implements Dough { @Override public String doughType() { return \"薄皮面粉\"; } @Override public String toString() { return doughType(); } } 修改pizza抽象类，将原料准备方法设置成抽象方法，修改dough的类型为Dough。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:06 * @Description 比萨抽象类 */ public abstract class BasePizza { /** * 比萨名字 */ private String name; /** * 面团种类 */ private Dough dough; /** * 准备材料过程 */ abstract void prepare(); /** * 打包过程 */ void box() { System.out.println(\"打包\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public Dough getDough() { return dough; } public void setDough(Dough dough) { this.dough = dough; } } 修改每一个具体的pizza实现类。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 中国素食比萨子类 */ public class ChinaVeggiePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; ChinaVeggiePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"中国素食比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:23 * @Description 日本素食比萨子类 */ public class JapanVeggiePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; JapanVeggiePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"日本素食比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 中国芝士比萨子类 */ public class ChinaCheesePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; ChinaCheesePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"中国芝士比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:11 * @Description 日本芝士比萨子类 */ public class JapanCheesePizza extends BasePizza { private PizzaIngredientFactory ingredientFactory; JapanCheesePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; setName(\"日本芝士比萨\"); } @Override void prepare() { setDough(ingredientFactory.createDough()); } } 修改每一个商店类，在实例化具体pizza时添加对应地区原料。 /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 中国比萨商店子类 */ public class ChinaPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; PizzaIngredientFactory ingredientFactory = new ChinaIngredientFactory(); if (type.equals(CHEESE)) { pizza = new ChinaCheesePizza(ingredientFactory); } else if (type.equals(VEGGIE)) { pizza = new ChinaVeggiePizza(ingredientFactory); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 20:20 * @Description 日本比萨商店子类 */ public class JapanPizzaStore extends BasePizzaStore { @Override BasePizza createPizza(String type) { BasePizza pizza = null; JapanIngredientFactory ingredientFactory = new JapanIngredientFactory(); if (type.equals(CHEESE)) { pizza = new JapanCheesePizza(ingredientFactory); } else if (type.equals(VEGGIE)) { pizza = new JapanVeggiePizza(ingredientFactory); } return pizza; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 19:14 * @Description 测试 */ public class Main { public static void main(String[] args) { BasePizzaStore chinaPizzaStore = new ChinaPizzaStore(); BasePizza chinaPizza = chinaPizzaStore.orderPizza(BasePizzaStore.CHEESE); System.out.println(chinaPizza.getDough() + \"\\n\" + chinaPizza.getName() + \"完成\"); BasePizzaStore japanPizzaStore = new JapanPizzaStore(); BasePizza japanPizza = japanPizzaStore.orderPizza(BasePizzaStore.VEGGIE); System.out.println(japanPizza.getDough() + \"\\n\" + japanPizza.getName() + \"完成\"); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之装饰者模式","date":"2020-03-11T04:12:09.000Z","path":"posts/2ba79d9e/","text":"装饰者模式 装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 设计原则：类应该对扩展开放，对修改关闭。 特性： 1.装饰者和被装饰对象有相同的超类型。 2.可以用一个或多个装饰者包装一个对象。 3.在任何需要被包装的场合，可以用装饰过的对象代替它。 4.装饰者可以在所委托被装饰者的行为前后增加自己的行为达到特定目的。 5.对象可以在任何时候不限量被装饰（比如运行时）。 装饰者模式UML类图： 原型设计一个饮品订单系统，抽象一个饮品类，让所有的饮品都继承该超类。 为饮品增加调料 问题：饮品中大多都会增加调料，例如咖啡加奶加糖等等。按照原型的设计思路需要新设计一个类（类名为饮品+调料）输出饮品增加了调料后的价格及介绍。这将导致类的数量爆炸式增长。 解决：在饮品抽象类中增加所有出现的调料变量（布尔型），并通过hasX和setX的方式获取和设置调料变量的布尔值。在其子类中需要修改cost方法，调用父类cost方法得知调料价格，再加上子类饮品的价格输出。这样做只需要保留所需的饮品子类即可。 以装饰的方式对饮品增加调料 问题：上述解决方法没有封装变化的部分（出现新的调料就需要不断修改抽象类），而且可能会出现一些饮品不能增加的调料（例如茶+奶泡）或是需要双倍份的调料。 解决：以饮品为主体，在运行时以调料来装饰饮品。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/11 12:20 * @Description 饮品抽象类 */ public abstract class BaseBeverage { /** * 饮品描述 */ String description = \"未知饮品\"; /** * 获取饮品描述 * @return 饮品描述 */ public String getDescription() { return description; } /** * 饮品价格 * @return 饮品价格 */ abstract double cost(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:18 * @Description 调料装饰者抽象类 */ public abstract class BaseCondimentDecorator extends BaseBeverage { /** * 重新实现获取描述的方法 * @return 描述 */ @Override public abstract String getDescription(); } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:00 * @Description 深焙咖啡饮品实现类 */ public class DarkRoast extends BaseBeverage { DarkRoast() { description = \"深焙咖啡\"; } @Override double cost() { return 0.99; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:03 * @Description 蒸馏咖啡饮品实现类 */ public class Espresso extends BaseBeverage { Espresso() { description = \"浓缩咖啡\"; } @Override double cost() { return 1.99; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:23 * @Description 摩卡调料装饰器实现类 */ public class Mocha extends BaseCondimentDecorator { private BaseBeverage beverage; Mocha(BaseBeverage beverage) { this.beverage = beverage; } @Override public String getDescription() { return beverage.getDescription() + \"+摩卡\"; } @Override double cost() { return beverage.cost() + 0.2; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:26 * @Description 奶泡调料装饰器实现类 */ public class Whip extends BaseCondimentDecorator { private BaseBeverage beverage; Whip(BaseBeverage beverage) { this.beverage = beverage; } @Override public String getDescription() { return beverage.getDescription() + \"+奶泡\"; } @Override double cost() { return beverage.cost() + 0.1; } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { BaseBeverage beverage1 = new DarkRoast(); beverage1 = new Mocha(beverage1); System.out.println(\"描述：\" + beverage1.getDescription()); System.out.println(\"价格：\" + beverage1.cost()); BaseBeverage beverage2 = new Espresso(); beverage2 = new Mocha(beverage2); beverage2 = new Whip(beverage2); System.out.println(\"描述：\" + beverage2.getDescription()); System.out.println(\"价格：\" + beverage2.cost()); } } 自定义JAVA I/O装饰者 需求：装饰Reader类，将从控制台读入的所有大写字母转换成小写。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/11 15:17 * @Description Reader组件装饰器：大写转小写 */ public class LowerCaseInputStream extends Reader { private final StreamDecoder sd; public LowerCaseInputStream(InputStream in) { super(in); try { sd = StreamDecoder.forInputStreamReader(in, this, (String) null); } catch (UnsupportedEncodingException e) { throw new Error(e); } } @Override public int read() throws IOException { // 针对字节 int result = super.read(); return result == -1 ? result : Character.toLowerCase(result); } @Override public int read(char[] cbuf, int off, int len) throws IOException { // 针对字节数组 int result = sd.read(cbuf, off, len); for (int i = off; i &lt; off + result; i++) { cbuf[i] = Character.toLowerCase(cbuf[i]); } return result; } @Override public void close() throws IOException { sd.close(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/11 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(new LowerCaseInputStream(System.in)); String s = scanner.next(); System.out.println(s); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之观察者模式","date":"2020-03-09T10:08:00.000Z","path":"posts/168b5985/","text":"观察者模式 观察者模式定义了对象之间的一(subject)对多(observer)依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。类似关注up主，up主更新视频时就会推送视频给关注该up主的用户。 设计原则：为了交互对象之间的松耦合设计而努力。（松耦合：当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。） 观察者模式UML图： 原型 需求：设计一个气象站发布栏，要求气象站数据更新时，推送最新的数据至订阅了该气象站的用户手中，用户可以自定义数据的显示样式。 代码演示： /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:00 * @Description 主题接口 */ public interface Subject { /** * 注册观察者 * @param observer 观察者接口 */ void registerObserver(Observer observer); /** * 删除观察者 * @param observer 观察者接口 */ void removeObserver(Observer observer); /** * 状态更新，通知观察者 */ void notifyObservers(); } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:00 * @Description 观察者接口 */ public interface Observer { /** * 通知观察者状态更新的接口 * @param args 更新数据 */ void update(Object[] args); } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:05 * @Description 信息显示样式接口 */ public interface DisplayElement { /** * 数据展示样式 */ void display(); } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:12 * @Description 主题具体实现类 */ public class WeatherData implements Subject { private ArrayList&lt;Observer> observers; private Object[] args; public WeatherData() { observers = new ArrayList&lt;>(); } @Override public void registerObserver(Observer observer) { int index = observers.indexOf(observer); if (index &lt; 0) { observers.add(observer); } } @Override public void removeObserver(Observer observer) { int index = observers.indexOf(observer); if (index >= 0) { observers.remove(index); } } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(args); } } /** * 通知观察者。 */ public void measurementsChanged() { notifyObservers(); } /** * 设气象数据并通知观察者。 * @param args 更新数据 */ public void setMeasurements(Object[] args) { this.args = args; measurementsChanged(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:21 * @Description 信息显示样式具体实现：目前状况样式 */ public class CurrentConditionsDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private float pressure; @Override public void display() { System.out.println(\"当前状态：\\n温度：\" + temperature + \"\\n湿度：\" + humidity + \"\\n气压：\" + pressure + \"\\n\"); } @Override public void update(Object[] args) { this.temperature = (float) args[0]; this.humidity = (float) args[1]; this.pressure = (float) args[2]; display(); } } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(); weatherData.registerObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{10f, 20f, 30f}); weatherData.setMeasurements(new Float[]{40f, 50f, 60f}); weatherData.removeObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{70f, 80f, 90f}); } } 新增pull功能 问题：上面设计的观察者模式只能通过主题推送数据至观察者，不能由观察者从主题上拉取自己所需数据，当观察者所需数据很小时，这就是个很头疼的问题了，获取了一堆没用的数据。 解决：新增pull功能，当主题更新了数据时通知观察者但不发送数据，观察者从主题处拉取自己所需数据。 代码演示： 修改Observer接口中的update方法。 /** * 通知观察者状态更新的接口 * @param subject 订阅的主题 * @param args 主题参数 */ void update(Subject subject, Object[] args); 修改Subject接口中的notifyObservers方法。 /** * 状态更新，通知观察者 * @param args 参数 */ void notifyObservers(Object[] args); 修改WeatherData类notifyObservers方法和measurementsChanged方法。 @Override public void notifyObservers(Object[] args) { for (Observer observer : observers) { observer.update(this, args); } } /** * 通知观察者。 */ public void measurementsChanged() { // null不推送数据，否则填需要推送的数据。（此处可以提取成动态运行设置是pull还是push） notifyObservers(null); } 弹性更新 问题：当气象站发生很细微的温度变更时就会通知观察者，这并不是我们想要的结果。 解决：将其改成变动半度以上时才更新，可以通过加入tag来标记状态是否进行更新。 代码演示： 新增Subject接口中的方法。 /** * 设置为允许推送 */ void setChanged(); /** * 设置为不允许推送 */ void clearChanged(); /** * 查看是否可推送 */ boolean hasChanged(); 修改WeatherData类的实现。 @Override public void setChanged() { changed = true; } @Override public void clearChanged() { changed = false; } @Override public boolean hasChanged() { return changed; } /** * 通知观察者。 */ public void measurementsChanged() { setChanged(); // null不推送数据，否则填需要推送的数据。（此处可以提取成动态运行设置是pull还是push） notifyObservers(null); } @Override public void removeObserver(Observer observer) { if (changed) { int index = observers.indexOf(observer); if (index >= 0) { observers.remove(index); } clearChanged(); } } 修改CurrentConditionsDisplay类，当没有获取到信息时，手动获取数据。 @Override public void update(Subject subject, Object[] args) { if (subject instanceof WeatherData) { if (args == null) { args = ((WeatherData) subject).getArgs(); } this.temperature = (float) args[0]; this.humidity = (float) args[1]; this.pressure = (float) args[2]; display(); } } JAVA内置观察者模式支持 需求：通过使用JAVA内置的Observable和Observer实现观察者模式。 代码演示： 只留下CurrentConditionsDisplay、Main、WeatherData类和DisplayElement接口。并修改前面三个类。 import java.util.Observable; /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:12 * @Description 主题具体实现类 */ public class WeatherData extends Observable { private Object[] args; /** * 通知观察者。 */ public void measurementsChanged() { setChanged(); // 无参则不推送数据，否则填需要推送的数据。（此处可以提取成动态运行设置是pull还是push） notifyObservers(); } /** * 设气象数据并通知观察者。 * @param args 更新数据 */ public void setMeasurements(Object[] args) { this.args = args; measurementsChanged(); } /** * 数据访问 getter * @return 数据 */ public Object[] getArgs() { return args; } } import java.util.Observable; import java.util.Observer; /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:21 * @Description 信息显示样式具体实现：目前状况样式 */ public class CurrentConditionsDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private float pressure; @Override public void display() { System.out.println(\"当前状态：\\n温度：\" + temperature + \"\\n湿度：\" + humidity + \"\\n气压：\" + pressure + \"\\n\"); } @Override public void update(Observable o, Object arg) { if (o instanceof WeatherData) { if (arg == null) { WeatherData weatherData = (WeatherData) o; this.temperature = (float) weatherData.getArgs()[0]; this.humidity = (float) weatherData.getArgs()[1]; this.pressure = (float) weatherData.getArgs()[2]; } else { Object[] args = (Object[]) arg; this.temperature = (float) args[0]; this.humidity = (float) args[1]; this.pressure = (float) args[2]; } display(); } } } /** * @Author 喵粮都输光了 * @Date 2020/3/10 14:28 * @Description 测试 */ public class Main { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(); weatherData.addObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{10f, 20f, 30f}); weatherData.setMeasurements(new Float[]{40f, 50f, 60f}); weatherData.deleteObserver(currentConditionsDisplay); weatherData.setMeasurements(new Float[]{70f, 80f, 90f}); } } Observable注意：Observable是一个类不是接口，限制了复用潜力（无法多继承），违反了针对接口编程的原则。而且Observable是乱序通知观察者的，每次的次序是不相同的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"概率论与数理统计","date":"2020-03-07T10:50:02.000Z","path":"posts/28d5cef4/","text":"概率论的基本概念随机试验随机试验：$\\begin{cases} 在相同条件下可重复。\\\\结果不止一个。\\\\无法预测。 \\end{cases}$ 样本空间、随机事件 样本空间：所有基本事件的集合。 样本点：样本空间的元素。 $A\\subset B$：事件B包含事件A。 $A\\bigcup B=\\{x|x∈A 或 x∈B\\}$：事件A与事件B的和事件（也可以记为$A+B$），即A，B中至少一个发生，事件$A\\bigcup B$发生。 $A\\bigcap B=\\{x|x∈A 且 x∈B\\}$：事件A与事件B的积事件（也可以记为$AB$），即仅当A，B同时发生时，事件$A\\bigcup B$发生。 $A-B=\\{x|x∈A 且 x∈B\\}$：事件A与事件B的差事件，即当且仅当A发生、B不发生时，事件$A-B$发生。 $A\\bigcap B=\\emptyset$：事件A与B是互不相容的（或互斥的），即事件A与事件B不能同时发生。 $A\\bigcup B=S$且$A\\bigcap B=\\emptyset$，事件A与事件B互为逆事件（或事件A与事件B互为对立事件），即事件A、B中必有一个发生，且仅有一个发生（A的对立事件记为$\\hat{A}$，$\\hat{A}=S-A$，S为总事件）。 频率与概率 频率：描述了事件发生的频繁程度，即大量实验统计。 概率：在一次试验中发生的可能性大小的数。频率的稳定值即统计概率。 公理化：$\\begin{cases} 非负性，概率不为负\\\\规范性，P(S)=1\\\\可列可加性 \\end{cases}$。 概率性质：$\\begin{cases} p(\\emptyset)=0。\\\\P(A_1+A_2+\\dots+A_n)=P(A_1)+P(A_2)+\\dots+P(A_n)。\\\\若A\\subset B，则P(B-A)=P(B)-P(A)，P(B)≥P(A)。\\\\对于任一事件A，P(A)≤1。\\\\对于任一事件A，P(\\hat{A})=1-P(A)。\\\\P(A\\bigcup B)=P(A)+P(B)-P(AB)=P(A)+P(B-AB)。 \\end{cases}$ 古典概型 古典概型：$\\begin{cases} 样本点个数有限。\\\\每个基本事件发生的概率相同。 \\end{cases}$，也可称为等可能概型。 $P(A)=\\frac{有利样本点}{样本总数}$，例如$\\frac{骰子偶数点数3}{总骰子数6}$。 不重复排列：$\\begin{cases}P_n^m=n(n-1)(n-2)\\dots(n-m+1)=\\frac{n!}{(n-m)!}\\\\P_n^n=n(n-1)×\\dots×3×2×1=n! \\end{cases}$。重复排列：$\\begin{cases}C_n^m=\\frac{P_n^m}{m!}=\\frac{n!}{m!(n-m)!}\\\\C_n^m=C_n^{n-m}\\\\C_n^0=C_n^n=1 \\end{cases}$。 几何概型：$p(A)=\\frac{\\mu(G)}{\\mu(S)}$，$\\mu$表几何区域内的一种度量（如线段中即长度），与古典概型性质唯一不同的在于几何概型拥有完全可加性，古典概型是有限可加性。 条件概率 条件概率：S样本空间，A，B两个事件，其中$P(B)&gt;0$，称$P(A|B)=\\frac{P(AB)}{P(B)}$为在事件A发生的条件下事件B发生的条件概率。 乘法公式：$P(ABC)=P(A)P(B|A)P(C|AB)$，即先发生了A，然后在A发生的条件下发生了B，最后在AB发生的条件下发生了C。n项的话依次类推。 全概率公式：$A_1,A_2\\dots A_n$是E的完备事件组（互不相容，并是S），$P(A_i)&gt;0$，$P(B)=\\sum_{i=1}^nP(A_i)P(B|A_i)$。知原因推结果。 贝叶斯公式：$A_1,A_2\\dots A_n$是E的完备事件组，B是任一事件，$P(A_i)&gt;0$，$P(B)&gt;0$，$P(A_k|B)=\\frac{P(A_k)P(B|A_k)}{\\sum_{i=1}{n}P(A_i)P(B|A_i}=\\frac{P(A_kB)}{P(B)}$。知结果推原因。 独立性 若$P(A)&gt;0$，$P(B)&gt;0$，$P(A|B)=P(A)$或$P(AB)=P(A)P(B)$，即A的概率不受B发生与否的影响称为独立性。 若事件A与B相互独立，则A与$\\hat{B}$，$\\hat{A}$与B，$\\hat{A}$与$\\hat{B}$都相互独立。 A，B，C三个事件，若满足等式：$\\begin{cases} P(AB)=P(A)P(B)\\\\P(AC)=P(A)P(C)\\\\P(BC)=P(B)P(C)\\\\P(ABC)=P(A)P(B)P(C) \\end{cases}$，则事件A，B，C相互独立。 随机变量及其分布随机变量 在样本空间$S={e}$中，$X=X(e)$每一个样本都对应一个实值单值函数，则称$X=X(e)$为随机变量。 离散型：有限个或无限可列个。 连续型（非离散型）：取值一个或多个区间。 离散型随机变量及其分布律 离散型随机变量X所有可能取的值为$x_k(k=1,2,\\dots)$，X取各个可能值的概率，即事件$\\{X=x_k\\}$的概率为$P\\{X=x_k\\}=p_k$。且$p_k≥0$，$\\sum_{k=1}^\\infty p_k=1$。 伯努利试验：试验只有A和$\\hat{A}$两种可能。 n重伯努利试验：将伯努利试验重复n次，试验之间彼此独立。 $(0-1)$分布：随机变量X只能取0与1两个值，其分布律为$P\\{X=k\\}=p^k(1-p)^{1-k}, k=0,1（0&lt;p&lt;1）$。 几何分布：设$P(A)=p$，第k次首次发生，即前$k-1$次未发生，则$P\\{X=k\\}=(1-p)^{k-1}p，k=1,2,3,\\dots$，记为$X\\sim G(p)$。 二项分布：即n重伯努利试验，记为$X\\sim B(n, p)$。$P(A)=p$，n次试验发生了k次，则$P\\{X=k\\}=C_n^kp^k(1-p)^{n-k}，k=0,1,\\dots,n$。当$n=1$时，二项分布化为$(0-1)$分布。二项分布最可能值：$\\begin{cases} (n+1)p不为整数，[(n+1)p]达到最大值。\\\\(n+1)p是整数，(n+1)p和(n+1)p-1都是最大值。 \\end{cases}$ 泊松分布：$P\\{X=k\\}=\\frac{\\lambda^ke^{-\\lambda}}{k!}，k=0,1,\\dots$，其中$\\lambda&gt;0$，记为$X\\sim P(\\lambda)$或$X\\sim \\pi(\\lambda)$。 超几何分布：不放回抽样试验，N个元素，$N_1$属于第一类，$N_2$属于第二类，取n个，X：n个中属于第一类的个数，$P\\{X=k\\}=\\frac{C_{N_1}^kC_{N_2}^{n-k}}{C_N^n}$，$k=0,1,\\dots,min{n,N_1}$。 不放回抽样实验，当N很大，n相对于N很小时，可以当作放回抽样试验。$P=\\frac{M}{N}$改变小，即$\\frac{n}{N}$小（N总数，M样本数），则$P=\\{X=k\\}=\\frac{C_M^kC_{N-M}^{n-k}}{C_N^n}\\approx C_n^kP^k(1-p)^{n-k}$。 随机变量的分布函数 $F(x)=P\\{X≤x\\}(-\\infty＜x＜\\infty)$，称为X的分布函数（对于离散型，连续型都成立）。 $F(x)$是一个不减函数（或增或保持不变）；$0≤F(x)≤1$,即$F(-\\infty)=\\lim \\limits_{x \\to -\\infty} F(x)=0$，$F(\\infty)=\\lim \\limits_{x \\to \\infty} F(x)=1$。 $F(x)$对于离散型是右连续的（即$F(x+0)=F(x)$），$F(X)$对于连续型是连续的。 连续型随机变量及其概率密度 非负可积$f(x)$，$f(x)≥0$,$a≤b$，则$P\\{a&lt;x≤b\\}=\\int_a^bf(x){\\rm d}x$，记为$X\\sim f(x)$。连续型随机变量不注重端点值，且$f(x)≥0$，$\\int_{-\\infty}^\\infty f(x){\\rm d}x=1$。 对于任意$x_1≤x_2$，$P\\{x_1&lt;X≤x_2\\}=F(x_2)-F(x_1)=\\int_{x_1}^{x_2}f(x){\\rm d}x$。 若$f(x)$在点x处连续，则$F\\prime(x)=f(x)$。 连续变量取个别值的概率为零。 均匀分布：$f(x)=\\begin{cases} \\frac{1}{b-a}，&amp;a&lt;x&lt;b，\\\\0，&amp;其他，\\end{cases}$，记为$X\\sim U(a, b)$。 指数分布：$f(x)=\\begin{cases} \\lambda e^{-\\lambda x}，&amp;x&gt;0，\\\\0，&amp;x≤0，\\end{cases}$，其中$\\lambda &gt;0$，记为$X\\sim Exp(\\lambda)$。 正态分布（高斯分布）：$f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$，$-\\infty&lt;x&lt;\\infty$，记为$X\\sim N(\\mu, \\sigma^2)$。当$x=\\mu$时取得最大值。曲线关于$x=\\mu$对称，对于任意$h&gt;0$都有$P\\{\\mu-h&lt;X≤\\mu\\}=P\\{\\mu&lt;X≤\\mu+h\\}$。$\\sigma$固定，$\\mu$变化，图像左右移动；$\\mu$固定，$\\sigma$变化，$\\begin{cases} \\sigma变小，最高点上移，图像变陡。\\\\\\sigma变大，最高点下移，图像变缓。 \\end{cases}$ 标准正态分布$\\phi_o(x)$：当$\\mu=0$，$\\sigma=1$时，$\\phi_o(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}$。$\\Phi_o(-x)=1-\\Phi_o(x)$，$\\phi_o(x)=\\phi_o(-x)$。$\\phi(x)=\\frac{1}{\\sigma}\\phi_o(\\frac{x-\\mu}{\\sigma})$。若$X\\sim N(\\mu, \\sigma^2)$，则$Z=\\frac{X-\\mu}{\\sigma}\\sim N(0, 1)$。 随机变量的函数的分布 离散型：X代入函数，p不变。若X代入函数之后有相同值则合并（p相加）。 连续型：设X的$f_X(x)$，$y=g(x)$，$Y=g(X)$，则求解步骤为： 得出$F_Y(x)$，$F_Y(x)=P\\{Y≤x\\}$，将其化成$F_X(x)$，$F_X(x)=P\\{X≤x\\}$。 对$F_Y(x)=F_X(x)$求导得$f_Y(x)=f_X(x)$，根据$f_X(x)$写出$f_Y(x)$的分段函数。 多维随机变量及其分布二维随机变量 联合分布函数：$F(x, y)$=$P\\{(X≤x)\\bigcap(Y≤y)\\}$=$P\\{X≤x, Y≤y\\}$。 $F(x, y)$是不减h函数，y固定时，$x_1＜x_2$，$F(x_1, y)≤F(x_2, y)$。 $0≤F(x, y)≤1$，当y固定时$F(-\\infty, y)=0$，$当x固定时F(x, -\\infty)=0$，$F(-\\infty, -\\infty)=0$，$F(\\infty, \\infty)=1$。 对于任意$(x_1, y_1)$，$(x_2, y_2)$，$x_1&lt;x_2$，$y_1&lt;y_2$，则$F(x_2, y_2)-F(x_2, y_1)+F(x_1, y_1)-F(x_1, y_2)≥0$。 边缘分布 离散型边缘分布：简单说就是确定$x_i$，将$x_i$所在的%y_j%概率相加，即为该$x_i$的边缘分布。 连续型边缘分布：$F(x, y)$=$P\\{X≤x, Y≤y\\}$=$\\int_{-\\infty}^x \\int_{-\\infty}^y f(s, t){\\rm d}s{\\rm d}t$，其中$F(x, y)$是联合分布，$f(x, y)$是联合密度。G是XY平面上的一个区域，$P\\{(X, Y)∈G\\}$=${\\int \\int}_G f(x, y){\\rm d}x{\\rm d}y$。 联合分布可唯一确认边缘分布；边缘分布不能确定联合分布；当X，Y独立时，边缘分布才能确定联合分布。 边缘密度函数：已知$f(x, y)$，求$f_X(x)=\\int_{-\\infty}^{+\\infty} f(x, y){\\rm d}y$，$f_Y(x)=\\int_{-\\infty}^{+\\infty} f(x, y){\\rm d}x$，且$f(x, y)$=$f_X(x)f_Y(y)$。 二维正态分布的边缘分布也是正态。 两边缘分布是正态的，二维并非一定是二维正态的。 条件分布 条件分布：$P\\{X=x_i|Y=y_j\\}$=$\\frac{P\\{X=x_i, Y=y_j\\}}{P\\{Y=y_j\\}}$=$\\frac{P_{ij}}{P_j}$。 离散型的条件分布即$\\frac{某点概率}{边缘分布概率}$。 连续型的条件分布：$(X, Y)$，$f(x, y)$，$f_X(x)$，$f_Y(y)$，若$f_Y(y)&gt;0$，在$Y=y$的条件下，$F(x|y)=\\int_{-\\infty}^x \\frac{f(x, y)}{f_Y(y)}{\\rm d}y$。 相互独立的随机变量 二维离散型的独立性：$P_{ij}=x_iy_j$。 二维连续型的独立性：$f(x, y)=f_X(x)f_Y(y)$。 变量独立，则变量构造的函数也独立。 两个随机变量的函数的分布 二维离散型的函数分布：X和Y代入函数，求XY相乘所有的可能，p不变，若有重复的则合并（p相加）。 二维连续型的函数分布：$(X, Y)$，$f(x, y)$，$Z=g(X, Y)$，$F(\\xi)=P\\{Z≤\\xi\\}=P\\{g(X, Y)≤\\xi\\}={\\int\\int}_{D_\\xi} f(x, y){\\rm d}x{\\rm d}y$，求出$f_Z(\\xi)$。 卷积公式：$f_X*f_Y=f_{X+Y}(z)=\\int_{-\\infty}^{\\infty}f_X(z-y)f_Y(y){\\rm d}y=\\int_{-\\infty}^{\\infty}f_X(x)f_Y(z-x){\\rm d}x$。 $Z=\\frac{Y}{X}$：$f_{\\frac{Y}{X}}(z)=\\int_{-\\infty}^{\\infty}|x|f_X(x)f_Y(xz){\\rm d}x$。 $Z=XY$：$f_{XY}(z)=\\int_{-\\infty}^{\\infty}\\frac{1}{|x|}f_X(x)f_Y(\\frac{z}{x}){\\rm d}x$。 $M=max\\{X, Y\\}$：$F_{max}(z)=F_X(z)F_Y(z)$。 $N=min\\{X, Y\\}$：$F_{min}(z)=1-[1-F_X(z)][1-F_Y(z)]$。 随机变量的数字特征数学期望 离散型的期望：若分布律为$P\\{X=x_k\\}=P_k$，$EX=\\sum_{k=1}^\\infty x_kP_k$（$EX$或$E(X)$数学期望），离散型的期望即值乘以概率值相加。 连续型的期望：若概率密度为$\\int_{-\\infty}^{\\infty} xf(x){\\rm d}x$，$EX=\\int_{-\\infty}^{\\infty} xf(x){\\rm d}x$。 离散型函数的期望：$Y=g(X)$，则$EY=\\sum_{k=1}^\\infty g(x_k)P_k$。 连续型函数的期望：$Y=g(X)$，则$EY=\\int_{-\\infty}^{\\infty} g(x)f(x){\\rm d}x$。 二维离散型函数的期望：$Z=g(X, Y)$，则$EZ=\\sum_i\\sum_j g(x_i, y_j)P_{ij}$。 二维连续型函数的期望：$Z=g(X, Y)$，则$EZ=\\int_{-\\infty}^\\infty\\int_{-\\infty}^\\infty g(x, y)f(x, y){\\rm d}x{\\rm d}y$。 期望的性质：$\\begin{cases} EC=C\\\\E(X+C)=EX+C\\\\E(CX)=CEX\\\\E(kX+b)=kEX+b\\\\E(X±Y)=EX±EY\\\\若X，Y独立，E(XY)=EX EY \\end{cases}$ 条件期望：一个变量取某值，另一个变量的期望。$\\begin{cases} E(X|Y=y_j)=\\sum x_iP(X=x_i|Y=y_j)&amp;离散型\\\\E(X|Y=y)=\\int_{-\\infty}^\\infty xf(x|y){\\rm d}x&amp;连续型 \\end{cases}$。 方差 方差：即随机变量与期望偏离的程度，记为$DX=E(X-EX)^2=EX^2-(EX)^2$，量纲$\\sqrt{DX}$。 离散型方差：$DX=\\sum_k (x_k-EX)^2P_k$。 连续型方差：$DX=\\int_{-\\infty}^\\infty (x-EX)^2f(x){\\rm d}x$。 方差的性质：$\\begin{cases} DC=0\\\\D(X+C)=DX\\\\D(CX)=C^2DX\\\\D(kX+b)=k^2DX\\\\若X，Y独立，D(X±Y)=DX+DY\\\\DX=0\\Leftrightarrow P(X=EX)=1 \\end{cases}$ 若$X^\\ast=\\frac{X-EX}{\\sqrt{DX}}$，则$EX^\\ast=0$，$DX^\\ast=1$。 $(0-1)$分布的期望与方差：$EX=p$，$DX=p(1-p)$。 二项分布的期望与方差：$EX=np$，$DX=np(1-p)$。 几何分布的期望与方差：$EX=\\frac{1}{p}$，$DX=\\frac{1-p}{p^2}$。 泊松分布的期望与方差：$EX=\\lambda$，$DX=\\lambda$。 均匀分布的期望与方差：$EX=\\frac{a+b}{2}$，$DX=\\frac{(b-a)^2}{12}$。 指数分布的期望与方差：$EX=\\frac{1}{\\lambda}$，$DX=\\frac{1}{\\lambda^2}$。 正态分布的期望与方差：$EX=\\mu$，$DX=\\sigma^2$。 协方差及相关系数 协方差：$Cov(X, Y)=E[(X-EX)(Y-EY)]=E(XY)-EXEY$。 $D(X±Y)=DX+DY±2Cov(X, Y)$。 协方差相关性质：$\\begin{cases} Cov(X, Y)=Cov(Y, X)\\\\Cov(aX, bY)=abCov(X, Y)\\\\Cov(X_1+X_2, Y)=Cov(X_1, Y)+Cov(X_2, Y)\\\\Cov(C, X)=0\\\\若X，Y独立，Cov(X, Y)=0 \\end{cases}$。 标准化：若$X^\\ast=\\frac{X-EX}{\\sqrt{DX}}$，$Y^\\ast=\\frac{Y-EY}{\\sqrt{DY}}$，则$Cov(X^\\ast, Y^\\ast)=\\rho=\\frac{Cov(X, Y)}{\\sqrt{DX}\\sqrt{DY}}$。 相关系数：$\\begin{cases} |\\rho|≤1\\\\ [E(XY)]^2≤EX^2EY^2\\\\|\\rho|=1\\Leftrightarrow P\\{Y=a+bX\\}=1，即XY成线性关系 \\end{cases}$ $\\rho=1$则X，Y完全正相关；$\\rho=-1$则X，Y完全负相关；$|\\rho|$接近0则X，Y线性关系不弱；$\\rho=0$则X，Y不存在线性关系。 X，Y独立则X，Y不相关；X，Y不相关则X，Y不一定独立。独立与不相关是等价的。 矩、协方差矩阵 原点矩：$EX^k$，以原点为中心；中心距：$E(X-EX)^k$，以期望为中心。 离散型原点矩：$\\sum x_i^kP_i$。 离散型中心距：$\\int_{-\\infty}{\\infty}x^kf(x){\\rm d}x$。 连续型原点矩：$\\sum (x_i-EX)^kP_i$。 连续型中心距：$\\int_{-\\infty}{\\infty}(x-EX)^kf(x){\\rm d}x$。 大数定律及中心极限定理大数定律 切比雪夫大数定理：$X_1,\\dots,X_n$不相关的变量，$EX_i$和$DX_i$都存在，方差有界，即$DX_i≤M$，对$\\forall \\epsilon&gt;0$时，有$\\lim \\limits_{n \\to \\infty} P\\{|\\frac{1}{n}\\sum_{i=1}^nX_i-\\frac{1}{n}\\sum_{i=1}^nEX_i|&lt;\\epsilon\\}=1$。 伯努利大数定理：假设n重伯努利试验，事件A发生了m次，P是其发生概率，$\\frac{m_n}{n}$即为其频率，当$n \\to \\infty$时，即$\\lim \\limits_{n \\to \\infty}P\\{|\\frac{m_n}{n}-P|&lt;\\epsilon\\}=1$，其概率依概率收敛于它的概率。也有$\\lim \\limits_{n \\to +\\infty}P\\{|\\frac{m_n}{n}-P|≥\\epsilon\\}=0$。 辛钦大数定理：$X_1,\\dots,X_n$独立同分布，且$EX_i=M$，$DX_i=\\sigma^2$，有$\\forall \\epsilon&gt;0$，则$\\lim \\limits_{n \\to \\infty} P\\{|\\frac{1}{n}\\sum_{i=1}^nX_i-\\mu|&lt;\\epsilon\\}=1$。 中心极限定理 $X_1,\\dots,X_n$独立同分布，$EX_i=\\mu$，$DX_i=\\sigma^2$，$0&lt;\\sigma^2&lt;+\\infty$，$\\lim \\limits_{n \\to \\infty}F_n(x)$=$\\lim \\limits_{n \\to \\infty}P\\{\\frac{\\sum_{k=1}^nX_k-n\\mu}{\\sqrt{n}\\sigma}≤x\\}$=$\\int_{-\\infty}^x\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}{\\rm d}t$=$\\Phi(x)$。当n充分大时，$\\frac{\\sum x_i-n\\mu}{\\sqrt{n}\\sigma}\\sim N(0, 1)$，$\\sum_{i=1}^nX_i\\sim N(n\\mu, n\\sigma^2)$。 $Y_n$，n，p二项分布近似正态分布，$\\Phi_o(x)=\\lim \\limits_{n \\to \\infty}P\\{\\frac{Y_n-np}{\\sqrt{np(1-p)}}≤x\\}$，其中$Y_n=\\sum_{i=1}^nX_i$，$X_i=\\begin{cases} 1&amp;发生\\\\0&amp;未发生 \\end{cases}$，$EX_i=P$，$DX_i=p(1-P)$。 样本及抽样分布随机样本$X:(0-1)分布$：$P(X_1=x_1,\\dots,X_n=x_n)$=$P(X_1=x_1)\\dots P(X_n=x_n)$=$P^{x_1}(1-p)^{1-x_1}\\dots P^{x_n}(1-p)^{1-x_n}$=$P^{x_1+\\dots+x_n}(1-p)^{n-(x_1+\\dots +x_n)}$。 抽样分布 统计量：不含任何未知参数的样本构造的函数。 样本平均值：$\\hat{X}=\\frac{1}{n}\\sum_{i=1}^nX_i$。 未修正样本方差：$S_o^2=\\frac{1}{n}\\sum_{i=1}^n(X_i-\\hat{X})^2$。$S^2=\\frac{n}{n-1}S_o^2$。 样本方差：$S^2=\\frac{1}{n-1}\\sum_{i=1}^n(X_i-\\hat{X})^2$。 样本标准方差：$S=\\sqrt{S^2}$。 样本k阶（原点）矩：$A_k=\\frac{1}{n}\\sum_{i=1}^nX_i^k,(k=1,2,\\dots)$。$A_1=\\hat{X}$。 样本k阶中心距：$B_k=\\frac{1}{n}\\sum_{i=1}^n(X_i-\\hat{X})^k,(k=2,3,\\dots)$。$B_2=S_o^2$。$S^2=\\frac{n}{n-1}B_2$。 协方差：$S_{1,2}=\\frac{1}{n}(X_i-\\hat{X})(Y_i-Y)$。 两样本之间的相关系数：$R=\\frac{S_{1,2}}{S_1S_2}$。 总体X的均值为$EX=\\mu$，方差为$DX=\\sigma^2$，样本（$X_1,X_2,\\dots,X_n$）来自总体X，则$E\\hat{X}=\\mu$，$D\\hat{X}=\\frac{1}{n}\\sigma^2$，$ES^2=\\sigma^2$。 卡方分布： $X_1,\\dots,X_n$独立且是来自$N(0, 1)$的样本，则$\\chi^2=\\sum_{i=1}^nx_i^2\\sim \\chi^2(n)$。 $EX=n$，$DX=2n$。 由中心极限定理得$X\\sim \\chi^2(n)$，$Y\\sim \\chi^2(m)$，X, Y独立，则$X+Y\\sim \\chi^2(m+n)$。 $X_i\\sim \\chi^2(m_i)$，独立，$\\sum_{i=1}^nX_i\\sim \\chi^2(\\sum_{i=1}^nm_i)$。 上$\\alpha$分位数：$P(\\chi^2&gt;\\chi^2_alpha(n))=\\alpha$。$\\chi^2$相当于变量，$\\chi^2_alpha(n)$相当于一个点，$\\alpha$相当于面积。 $\\chi^2(2)$是$\\lambda=\\frac{1}{2}$的指数分布。 $\\chi^2(n)$是单峰曲线，在$n-2$时取得最大值。 当$n=2$时曲线不对称，当n增大图像越接近对称，且在n很大时，可用正态分布近似。 t分布： 若$X\\sim N(0, 1)$，$Y\\sim \\chi^2(n)$，X, Y独立，则$t(n)\\sim\\frac{X}{\\sqrt{\\frac{Y}{n}}}$。 上$\\alpha$分位数：$P(T&gt;t_\\alpha(n))=\\alpha$。 $t_{1-\\alpha}(n)$=$-t_\\alpha(n)$。 n越小，其图像与正态分布差距越大（$n≥30$，与正态分布区别很小）。 F分布： $X\\sim \\chi^2(n_1)$，$Y\\sim \\chi^2(n_2)$，X, Y独立，$F(n_1, n_2)\\sim \\frac{\\frac{X}{n_1}}{\\frac{Y}{n_2}}$。 $\\frac{1}{F}\\sim F(n_2, n_1)$。 上$\\alpha$分位数：$P(F&gt;F_\\alpha(n_1, n_2)=\\alpha$。 $F_{1-\\alpha}(n_1, n_2)=\\frac{1}{F_\\alpha(n_2, n_1)}$。 正态总体下的抽样分布： $X\\sim N(\\mu, \\sigma^2)$，$\\{X_1,\\dots,X_n\\}$样本，则$E\\hat{X}=\\mu$，$D\\hat{X}=\\frac{\\sigma^2}{n}$，$\\frac{\\hat{X}-\\mu}{\\sigma}\\sqrt{n}\\sim N(0, 1)$，即$E(S^2)=\\sigma^2$。 $\\hat{X}\\sim N(\\mu, \\frac{\\sigma^2}{n})$。 $\\frac{(n-1)S^2}{\\sigma^2}\\sim \\chi^2(n-1)$，$\\hat{X}$与$S^2$独立。 $\\frac{1}{\\sigma^2}\\sum_{i=1}^n(X_i-\\mu)^2\\sim \\chi^2(n)$。 $\\frac{\\hat{X}-\\mu}{S}\\sqrt{n}\\sim t(n-1)$。 两个正态总体：$X\\sim N(\\mu_1, \\sigma_1^2)$，$Y\\sim N(\\mu_2, \\sigma_2^2)$，样本$\\{X_1,\\dots,X_{n_1}\\}$，$\\{Y_1,\\dots,Y_{n_2}\\}$，$\\begin{cases} \\frac{(\\hat{X}-\\hat{Y})-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}}\\sim N(0, 1)\\\\\\frac{\\frac{S_1^2}{\\sigma_1^2}}{\\frac{S_2^2}{\\sigma_2^2}}\\sim F(n_1-1, n_2-1)\\\\ \\sigma_1^2=\\sigma_2^2=\\sigma 时，T=\\frac{(\\hat{X}-\\hat{Y})-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}}\\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}}}\\sim t(n_1+n_2-2) \\end{cases}$ 参数估计点估计 点估计：通过一个样本估计总体未知参数。 矩估计法：以样本矩的连续函数作为相应的总体矩的连续函数的估计量。$A_n=\\frac{1}{n}\\sum X_i^2$。 极大似然估计法： 1.写出总体的概率函数或密度函数。 2.写出似然函数$L(\\lambda)=\\prod_{i=1}^2\\frac{\\lambda^{x_i}}{x_i!}e^{-\\lambda}$（此处以泊松分布为例，似然函数即将样本观测值代入1.式并连乘）。 3.需使似然函数取最大值，两边取$ln$。 4.对$\\lambda$求导（此处$\\lambda$根据概率函数或者密度函数改变）。 估计量的评选标准 无偏性： 估计的参数的估计值的期望是其真实的值，即$E\\hat{\\theta}=\\theta$。 总体$X$，$EX=\\mu$，$DX=\\sigma^2$，$(X_1,\\dots,X_n)$，总体与任何分布无关，则$\\begin{cases}\\hat{X}是\\mu的无偏估计，E\\hat{X}=\\mu。\\\\样本方差S^2是\\sigma^2的无偏估计，ES^2=\\sigma^2。\\\\未修正样本方差S_o^2是\\sigma^2的有偏估计。\\\\n \\to \\infty，渐进无偏估计。\\\\ \\hat{\\theta}是\\theta的无偏估计，g(\\hat{\\theta})不一定是g(\\theta)的无偏估计。\\\\DS=\\sigma^2-(ES)^2，ES=\\sqrt{\\sigma^2-DS}≤\\sigma（一般不等于）。 \\end{cases}$ 有效性：$D(\\hat{\\theta}_1)≤D(\\hat{\\theta}_2)$，方差越小越有效。 相合性（一致性）：$\\lim \\limits_{n \\to +\\infty}P(|\\hat{\\theta}-\\theta|&lt;\\epsilon)=1$。 区间估计 置信区间：$[\\hat{\\theta_1},\\hat{\\theta_2}]$能套住$\\theta$的概率，即以区间估计的区域套住$\\theta$的概率。 枢轴变量：即通过先确定两个数来确定未知数。 $I=I(T, \\theta)$，其中$T$已知，$\\theta$未知，枢轴变量I的分布F已知且与$\\theta$无关。 给定$1-\\alpha$，确定F分布的上$$分位数，上$$分位数，即$P\\{V_{1-\\frac{\\alpha}{2}}≤I(T, \\theta)≤V_{\\frac{\\alpha}{2}}\\}=1-\\alpha$。 正态总体均值与方差的区间估计 若给定置信水平$1-\\alpha$，$X_1,\\dots,X_n$为$N(\\mu, \\sigma^2)$的样本，已知$\\hat{X}$，$S^2$。 $\\sigma^2$已知，枢轴变量$\\frac{\\hat{X}-\\mu}{\\frac{\\sigma}{\\sqrt{n}}}$，$1-\\alpha$的置信区间$(\\hat{X}±\\frac{\\sigma}{\\sqrt{n}}z_{\\frac{\\alpha}{2}})$。 $\\sigma^2$未知，枢轴变量$\\frac{\\hat{X}-\\mu}{\\frac{\\sigma}{\\sqrt{n}}}\\sim t(n-1)$，$1-\\alpha$的置信区间$(\\hat{X}±\\frac{S}{\\sqrt{n}}t_{\\frac{\\alpha}{2}}(n-1))$。 单个总体$N(\\mu, \\sigma^2)$情况表 估计表 $\\mu$ $\\sigma^2$已知 $\\frac{\\hat{X}-\\mu}{\\sigma}\\sqrt{n}\\sim N(0, 1)$ $[\\hat{X}-\\frac{\\sigma}{\\sqrt{n}}\\mu_{\\frac{\\alpha}{2}}, \\hat{X}+\\frac{\\sigma}{\\sqrt{n}}\\mu_{\\frac{\\alpha}{2}}]$ $\\mu$ $\\sigma^2$未知 $\\frac{\\hat{X}-\\mu}{S}\\sqrt{n}\\sim t(n-1)$ $[\\hat{X}-\\frac{S}{\\sqrt{n}}t_{\\frac{\\alpha}{2}}(n-1), \\hat{X}+\\frac{S}{\\sqrt{n}}t_{\\frac{\\alpha}{2}}(n-1)]$ $\\sigma^2$ $\\mu$已知 $\\frac{1}{\\sigma^2}\\sum_{i=1}^n(X_i-\\mu)^2\\sim \\chi^2(n)$ $[\\frac{\\sum(X_i-\\mu)^2}{\\chi^2_{\\frac{\\alpha}{2}}(n)}, \\frac{\\sum(X_i-\\mu)^2}{\\chi^2_{1-\\frac{\\alpha}{2}}(n)}]$ $\\sigma^2$ $\\mu$未知 $\\frac{(n-1)S^2}{\\sigma^2}\\sim \\chi^2(n-1)$ $[\\frac{(n-1)S^2}{\\chi^2_{\\frac{\\alpha}{2}}(n-1)}, \\frac{(n-1)S^2}{\\chi^2_{1-\\frac{\\alpha}{2}}(n-1)}]$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"高等数学","date":"2020-03-02T05:00:25.000Z","path":"posts/93e4730e/","text":"函数与极限映射 $D_f$是定义域(domain)，$R_f$是值域(range)。$x∈X$，对应的 y 是唯一的。（$R_f\\subset Y, R_f≠Y$） 满射：$R_f=Y$。 单射：$x_1≠x_2, f(x_1)≠f(x_2)$，即x和f(x)唯一对应。 一一映射：满足单射和满射。 逆映射：设$f:X→Y$且满足单射，每个$y∈R_f$，有唯一的$x∈X, f(x)=y, g:R_f→X$，则$D_{f^{-1}}=R_f, R_{f^{-1}}=X$。 复合映射：$g:X→Y_1, f:Y_2→Z$，且$Y_1 \\subset Y_2, x∈X$，则$f[g(x)]∈Z$。 函数 函数特性：有界性、单调性、奇偶性和周期性。 反函数：若$f:D→f(D)$，且满足单射，则$f^{-1}:f(D)→D$。$f$与$f^{-1}$关于$y=x$对称，所以$f$单调增(减)时，$f^{-1}$也单调增(减)。 复合函数：$y=f(t), t=g(x)$，则$y=f(g(x))$，其中$t=g(x)$的值域必须落在$y=f(t)$的定义域内。 初等函数：由常数和基本初等函数（幂、指数、对数、三角和反三角函数）经过有限次的四则运算和函数复合所构成的函数。 极限 数列极限定义：$\\forall \\epsilon &gt;0$，$\\exists 正整数N$，当$n&gt;N$时，$|x_n-a|&lt;\\epsilon$，其中a就是极限，记作$\\lim \\limits_{n \\to \\infty} x_n=a$或$x_n \\to a(n \\to \\infty)$。也就是说N是数列中的某一项，$n&gt;N$表示该项后面的所有项，$|x_n-a|&lt;\\epsilon$表示该项后面的所有项都落在$\\epsilon$那么大的小区域中。 自变量趋于有限值时函数的极限定义：$\\forall \\epsilon &gt;0$，$\\exists \\delta&gt;0$，当$0&lt;|x-x_0|&lt; \\delta$时，有$|f(x)-A|&lt;\\epsilon$，记作$\\lim \\limits_{x \\to x_0} f(x)=A$或$f(x) \\to A(x \\to x_0)$。也就是说当x趋于$x_0$时，函数f(x)趋于A，f(x)在$x_0$的去心领域内有定义（注在$x_0$处可以没有定义）。 自变量趋于无穷大时函数的极限定义：$\\forall \\epsilon &gt;0$，$\\exists X&gt;0$，当$|x|&gt; X$时，有$|f(x)-A|&lt;\\epsilon$，记作$\\lim \\limits_{x \\to \\infty} f(x)=A$或$f(x) \\to A(x \\to \\infty)$。 单侧极限： 左极限：$\\lim \\limits_{x \\to x_o^-} f(x)=A$，从左边逼近； 右极限：$\\lim \\limits_{x \\to x_o^+} f(x)=A$，从右边逼近； f(x)极限存在。$\\Leftrightarrow$左右极限均存在且相等。 极限性质 类型 性质 数列 1.极限唯一；2.有界性；3.保号性；4.若数列$\\{x_n\\}$收敛于a，那么它的任一子数列也收敛，且极限也是a。 函数 1.极限唯一；2.局部有界性；3.局部保号性；4.海涅定理：若$\\lim \\limits_{x \\to x_o} f(x)=A$，且$\\{x_n\\} \\to x_0$，则$\\lim \\limits_{n \\to \\infty} f(x_n)=\\lim \\limits_{x \\to x_o} f(x)=A$。 无穷小和无穷大 无穷小定义：$x \\to x_0(x \\to \\infty)$，$f(x)$的极限是0。（0是可以作为无穷小的唯一常数。） 无穷大定义：$x \\to x_0(x \\to \\infty)$，$f(x)$的极限是$\\infty$。 $f(x)$是无穷小，则$\\frac{1}{f(x)}$是无穷大；$f(x)$是无穷大，则$\\frac{1}{f(x)}$是无穷小。 极限运算法则 有限个无穷小的和(差)是无穷小。 有界函数与无穷小的乘积是无穷小。 常数与无穷小的乘积是无穷小。 有限个无穷小的乘积是无穷小。 若$\\phi(x)≥\\psi(x)$，则$\\lim \\phi(x)≥\\lim \\psi(x)$。 $\\lim \\limits_{x \\to \\infty} \\frac{a_0x^m+a_1x^{m-1}+\\cdots+a_m}{b_0x^n+b_1x^{n-1}+\\cdots+b_n} = \\begin{cases} 0,&amp;当n&gt;m,\\\\\\frac{a_0}{b_0},&amp;当n=m,\\\\\\infty,&amp;当n&lt;m. \\end{cases}$ 极限存在准则，两个重要极限 夹逼准则：$g(x)≤f(x)≤h(x)$，若$\\lim g(x)=A$,$\\lim h(x)=A$，则$\\lim f(x)=A$。 $\\lim \\limits_{x \\to 0} \\frac{sinx}{x}=A$。 单调有界数列必有极限。 $\\lim \\limits_{x \\to \\infty} (1+\\frac{1}{x})^x=e$或$\\lim \\limits_{x \\to 0} (1+x)^\\frac{1}{x}=e$。即$(1+0)^\\infty$的样子。 柯西极限存在准则：$\\{x_n\\}$收敛$\\Leftrightarrow$$\\forall \\epsilon, \\exists N, m&gt;N, n&gt;N$时，则$|x_n-x_m|&lt;\\epsilon$。即任取某一项N，在该项之后任取两项m和n，他们之间的距离很小。 无穷小的比较无穷小的比较即比较趋向于0的速度快慢。 $\\lim \\frac{\\beta}{\\alpha}=0$，则$\\beta$是比$\\alpha$高阶的无穷小，记作$\\beta=o(\\alpha)$。 $\\lim \\frac{\\beta}{\\alpha}=\\infty$，则$\\beta$是比$\\alpha$低阶的无穷小。 $\\lim \\frac{\\beta}{\\alpha}=c≠0$，则$\\beta$与$\\alpha$是同阶无穷小。 $\\lim \\frac{\\beta}{\\alpha^k}=c≠0$，则$\\beta$是关于$\\alpha$的k阶无穷小 $\\lim \\frac{\\beta}{\\alpha}=1$，则$\\beta$与$\\alpha$是等价无穷小，记作$\\alpha\\sim\\beta$。 $\\beta$与$\\alpha$等价。$\\Leftrightarrow$$\\beta=\\alpha+o(\\alpha)$。 $\\alpha\\sim\\widetilde{\\alpha}$，$\\beta\\sim\\widetilde{\\beta}$，且$\\lim \\frac{\\widetilde{\\beta}}{\\widetilde{\\alpha}}$存在，则$\\lim \\frac{\\beta}{\\alpha}=\\lim \\frac{\\widetilde{\\beta}}{\\widetilde{\\alpha}}$ 当$x \\to 0$时，求两个无穷小比(做乘除运算)的极限时，分子及分母可用等价无穷小来替换。常用等价替换： $sinx\\sim x$ $tanx\\sim x$ $arcsinx\\sim x$ $arctanx\\sim x$ $ln(1+x)\\sim x$ $e^x-1\\sim x$ $a^x\\sim 1+xlna$ $1-cosx\\sim \\frac{1}{2}x^2$ $(1+x)^\\frac{1}{n}-1\\sim \\frac{1}{n}x$ $(1+x)^\\alpha\\sim 1+\\alpha x$ 函数的连续性与间断点 $\\lim \\limits_{\\Delta x \\to 0} \\Delta y=\\lim \\limits_{\\Delta x \\to 0} [f(x_0+\\Delta x)-f(x_0)]=0$。 $\\lim \\limits_{x \\to x_0} f(x)=f(x_0)$。即连续性的条件为$\\begin{cases} 1.在x_0处有极限。\\\\2.在x_0处有定义。\\\\3.极限等于函数值。 \\end{cases}$ 连续。$\\Leftrightarrow$左、右连续。 左连续：$\\lim \\limits_{x \\to x_0^-} f(x)=f(x_0)$。 右连续：$\\lim \\limits_{x \\to x_0^+} f(x)=f(x_0)$。 间断即不满足连续的条件。间断点类型： 第一类间断点(左右极限都存在)：可去间断点、跳跃间断点。 第二类间断点(左右极限至少一个不存在)：无穷间断点、震荡间断点。 连续函数的运算与初等函数的连续性 函数$f(x)$和$g(x)$在点$x_0$连续，则它们的和(差)、积(商)都在点$x_0$处连续。 如果函数$y=f(x)$在区间$I_x$上单调递增(或单调递减)且连续，那么它的反函数$x=f^{-1}(y)$也在对应的区间$I_y$上单调递(或单调递减)增且连续。 $y=f[g(x)]$由$u=g(x)$与$y=f(u)$复合而成，若$\\lim \\limits_{x \\to x_0} g(x)=u_0$，而$y=f(u)$在$u=u_0$连续，则$\\lim \\limits_{x \\to x_0} f[g(x)]=\\lim \\limits_{u \\to u_0} f(u)=f(u_0)$。即$\\lim \\limits_{x \\to x_0} f[g(x)]=f[\\lim \\limits_{x \\to x_0} g(x)]$。 $y=f[g(x)]$由$u=g(x)$与$y=f(u)$复合而成，若$u=g(x)$在$x=x_0$连续，且$g(x_0)=u_0$，而$y=f(u)$在$u=u_0$连续，则$y=f[g(x)]$在$x=x_0$也连续。 基本初等函数在其定义域内都是连续的；一切初等函数在其定义区间内都是连续的。 闭区间上连续函数的性质 在闭区间上连续的函数在该区间上有界且一定能取得它的最大值和最小值。 零点定理：函数$f(x)$在闭区间$[a, b]$上连续，且$f(a)$与$f(b)$异号（即$f(a)*f(b)&lt;0$），则在开区间$(a, b)$内至少有一点$\\xi$，使得$f(\\xi)=0$。 介值定理：函数$f(x)$在闭区间$[a, b]$上连续，且在该区间的端点取不同的函数值$f(a)=A$及$f(b)=B$，则对于A与B之间的任意一个数C，在开区间$(a, b)$内至少有一点$\\xi$，使得$f(\\xi)=C(a&lt;\\xi&lt;b)$。 在闭区间$[a, b]$上连续的函数$f(x)$的值域为闭区间$[m, M]$，其中m与M依次为$f(x)$在$[a, b]$上的最小值与最大值。 导数与微分导数概念 由于自变量x的变化引起函数$y=f(x)$变化的“快慢”问题，即函数的变化率称为导数。 $y=f(x)$在点$x_0$的某个邻域内有定义，当$x$在$x_0$处取得增量$\\Delta x$时，$x_0 \\to x_0+\\Delta x$，$\\Delta y = f(x_0+\\Delta x)-f(x_0)$。若$\\Delta y$与$\\Delta x$之比当$\\Delta x\\to 0$时的极限存在，则称$y=f(x)$在点$x_0$处可导，记为$f^\\prime (x_0)$=$\\lim \\limits_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x}$=$\\lim \\limits_{\\Delta x \\to 0} \\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}$=$\\lim \\limits_{x \\to x_0} \\frac{f(x)-f(x_0)}{x-x_0}$或记为$y^\\prime |_{x=x_0}$=$\\frac{dy}{dx}|_{x=x_0}$=$\\frac{df(x)}{dx}|_{x=x_0}$。其中$\\frac{dy}{dx}$表示y对x求导。 单侧导数： 左导数：$f^\\prime_-$=$\\lim \\limits_{h \\to 0^-} \\frac{f(x_0+h)-f(x_0)}{h}$=$\\lim \\limits_{x \\to x_0^-} \\frac{f(x)-f(x_0)}{x-x_0}$，从左边逼近； 右导数：$f^\\prime_+$=$\\lim \\limits_{h \\to 0^+} \\frac{f(x_0+h)-f(x_0)}{h}$=$\\lim \\limits_{x \\to x_0^+} \\frac{f(x)-f(x_0)}{x-x_0}$，从右边逼近； 可导。$\\Leftrightarrow$左右导数均存在且相等。 导数的几何意义： 在某一点的导数即该点的切线的斜率，$k_切=f^\\prime(x_0)=tan\\alpha$，$k_法=-\\frac{1}{f^\\prime(x_0)}$。 若$y=f(x)$，$f^\\prime(x_0)=\\infty$，表切线垂直于x轴。 可导必连续，连续不一定可导。（$\\lim \\limits_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x}$存在即可导，$\\lim \\limits_{\\Delta x \\to 0} \\Delta y=0$即连续。） 函数的求导法则 常数和基本初等函数的导数公式： $(C)^\\prime=0$ $(x^\\mu)^\\prime=\\mu x^{\\mu-1}$ $(a^x)^\\prime=a^xlna(a&gt;0, a≠1)$ $(e^x)^\\prime=e^x$ $(lnx)^\\prime=\\frac{1}{x}$ $(log_ax)^\\prime=\\frac{1}{xlna}(a&gt;0, a≠1)$ $(sinx)^\\prime=cosx$ $(cosx)^\\prime=-sinx$ $(tanx)^\\prime=sec^2x$ $(cotx)^\\prime=-csc^2x$ $(sec)^\\prime=secxtanx$ $(cscx)^\\prime=-cscxcotx$ $(arcsinx)^\\prime=\\frac{1}{\\sqrt{1-x^2}}$ $(arccosx)^\\prime=-\\frac{1}{\\sqrt{1-x^2}}$ $(arctanx)^\\prime=\\frac{1}{1+x^2}$ $(arccotx)^\\prime=-\\frac{1}{1+x^2}$ $(shx)^\\prime=chx$ $(chx)^\\prime=shx$ $(thx)^\\prime=\\frac{1}{ch^2x}$ $(arshx)^\\prime=\\frac{1}{\\sqrt{1+x^2}}$ $(archx)^\\prime=\\frac{1}{\\sqrt{x^2-1}}$ $(arthx)^\\prime=\\frac{1}{1-x^2}$ 函数的和、差、积、商的求导法则： $(u±v)^\\prime=u^\\prime±v^\\prime$ $(Cu)^\\prime=Cu^\\prime(C是常数)$ $(uv)^\\prime=u^\\prime v+uv^\\prime$ $(\\frac{u}{v})^\\prime=\\frac{u^\\prime v-uv^\\prime}{v^2}$ 反函数求导：$x=f(y)$在$I_y$内单调、可导且$f^\\prime(y)≠0$，则其反函数$y=f^\\prime(x)$在对应区间内也可导，$[f^\\prime(x)]^\\prime=\\frac{1}{f^\\prime(y)}$或$\\frac{dy}{dx}=\\frac{1}{\\frac{dx}{dy}}$。即反函数的导数等于直接函数导数的倒数。 复合函数求导：若$u=g(x)$在点x可导，而$y=f(u)$在点$u=g(x)$可导，则$y=f[g(x)]$在点x可导，$\\frac{dy}{dx}=f^\\prime(u)·g^\\prime(x)$或$\\frac{dy}{dx}=\\frac{dy}{du}·\\frac{du}{dx}$。 高阶导数 对函数做n次求导叫做n阶导数，记作$\\frac{d^ny}{dx^n}$或$y^{(n)}(x)$。 常用高阶导数： $(a^x)^{(n)}=a^x(lna)^n$ $(sinx)^{(n)}=sin(x+\\frac{n\\pi}{2})$ $(cosx)^{(n)}=cos(x+\\frac{n\\pi}{2})$ $(x^n)^{(n)}=n!$ $(x^n)^{(n+k)}=0(k=1, 2, \\dots)$ $(uv)^{(n)}=\\sum_{k=0}^n C_n^ku^{(n-k)}v^{(k)}$ $[ln(1+x)]^{(n)}=(-1)^{(n-1)}\\frac{(n-1)!}{(1+x)^n}$ 隐函数及参数方程求导 $y=sinx$类型是显函数，$x+y^3-1=0$类型是隐函数。此处隐函数同时两边对x求导得到$y^\\prime=\\dots$的型式即可。 参数方程$\\begin{cases} x=\\phi(t)\\\\y=\\Phi(t) \\end{cases}$，$\\frac{dy}{dx}=\\frac{\\frac{dy}{dt}}{\\frac{dx}{dt}}=\\frac{\\Phi^\\prime}{\\phi^\\prime}$。 函数的微分 由于自变量x的微小改变（增量$|\\Delta x|$很小时）引起$y=f(x)$的改变量$\\Delta y$的近似值问题，即微分问题。 $y=f(x)$在某区间内有定义，若$x_0 \\to x_0+\\Delta x$，则$\\Delta y=f(x_0+\\Delta x)-f(x_0)$（精确值）可表示成$\\Delta y=A\\Delta x+o(\\Delta x)$（近似值，$o(\\Delta x)$可忽略不计），A是不依赖$\\Delta x$的常数，称$y=f(x)$可微。其中$A\\Delta x$叫做$y=f(x)$在点$x_0$相应于$\\Delta X$的微分，记作$dy=A\\Delta x$。 可微。$\\Leftrightarrow$可导，$dy=f^\\prime(x)dx$（$\\Delta x=dx$，$A=f^\\prime(x)$）。 函数的微分运算法则微分公式与法则都和导数差不多。 微分的几何意义通过$\\Delta y=f(x_0+\\Delta x)-f(x_0)$与$dy=f^\\prime(x_0)\\Delta x$作图即可得知。（曲线，切线，$x_0$，$x_0+\\Delta x$，$\\Delta y$和$dy$） 微分中值定理与导数的应用微分中值定理 费马引理：$f(x)$在点$x_0$的某邻域$U(x_0)$内有定义，且在$x_0$处可导，若$f(x)≤f(x_0)$（$f(x)≥f(x_0)$），$\\forall x∈U(x_0)$，则$f^\\prime(x_0)=0$。 罗尔定理：$f(x)$满足$\\begin{cases} 1.在[a, b]上连续。\\\\2.在(a, b)内可导。\\\\3.f(a)=f(b)。 \\end{cases}$，则至少有一点$\\xi∈(a, b)$，使得$f^\\prime(\\xi)=0$。 拉格朗日中值定理：$f(x)$满足$\\begin{cases} 1.在[a, b]上连续。\\\\2.在(a, b)内可导。 \\end{cases}$，则至少有一点$\\xi∈(a, b)$，使得$f(b)-f(a)=f^\\prime(\\xi)(b-a)$。即$f^\\prime(\\xi)=\\frac{f(b)-f(a)}{b-a}$，相当于求斜率。 柯西中值定理：$f(x)$及$F(x)$满足$\\begin{cases} 1.在[a, b]上连续。\\\\2.在(a, b)内可导。\\\\3.\\forall x∈(a, b)，F^\\prime(x)≠0。 \\end{cases}$，则至少有一点$\\xi∈(a, b)$，使得$\\frac{f(b)-f(a)}{F(b)-F(a)}=\\frac{f^\\prime(\\xi)}{F^\\prime(\\xi)}$。 $f(x)$在区间I上连续，在I内可导且导数恒为零，则$f(x)=C$（C为常数）。 洛必达法则若$\\begin{cases} 1.当x \\to a时，f(x)和F(x) \\to 0。\\\\2.在点a的某去心邻域内，f^\\prime(x)及F^\\prime(x)都存在且F^\\prime≠0。\\\\3.\\lim \\limits_{x \\to a} \\frac{f^\\prime(x)}{F^\\prime(x)}存在或为无穷大。\\\\ \\end{cases}$，则$\\lim \\limits_{x \\to a} \\frac{f(x)}{F(x)}=\\lim \\limits_{x \\to a} \\frac{f^\\prime(x)}{F^\\prime(x)}$。（将条件$x \\to a$改为$x \\to \\infty$同样适用。） 泰勒公式 泰勒中值定理1：$f(x)$在$x_0$处有n阶导数，$\\exists x_0$的一个邻域，对于该邻域内的任一x，有$f(x)=f(x_0)+f^\\prime(x_0)(x-x_0)+\\frac{f^{\\prime\\prime}(x_0)}{2!}(x-x_0)^2+\\dots+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)$，其中$R_n(x)=o((x-x_0)^n)$。 泰勒中值定理2：$f(x)$在$x_0$的某个邻域$U(x_0)$内具有(n+1)阶导数，$\\forall x∈U(x_0)$，有泰勒中值定理1的公式，其中$R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{n+1}$($\\xi$是$x_0$与$x$之间的某个值)。 当泰勒中值定理2的公式中$n=0$时，就变成了拉格朗日中值公式。 当泰勒中值定理1的公式中$x_0=0$时，就变成了带有佩亚诺余项的麦克劳林公式，$f(x)=f(0)+f^\\prime(0)x+\\frac{f^{\\prime\\prime}(0)}{2!}x^2+\\dots+\\frac{f^{(n)}(0)}{n!}x^n+o(x^n)$。 当泰勒中值定理2的公式中$x_0=0$时，就变成了带有拉格朗日余项的麦克劳林公式，$f(x)=f(0)+f^\\prime(0)x+\\frac{f^{\\prime\\prime}(0)}{2!}x^2+\\dots+\\frac{f^{(n)}(0)}{n!}x^n+\\frac{f^{(n+1)}(\\theta x)}{(n+1)!}x^{n+1}(0&lt;\\theta&lt;1)$。 函数的单调性与曲线的凹凸性 $y=f(x)$在$[a, b]$上连续，在$(a, b)$内可导。则在$(a, b)$内$f^\\prime(x)≥0$($f^\\prime(x)≤0$)，且等号仅在有限多个点处成立，则$y=f(x)$在$[a, b]$上单调增加(减少)。 $y=f(x)$在$[a, b]$上连续，在$(a, b)$内具有一阶和二阶导数。则在$(a, b)$内$f^{\\prime\\prime}(x)&gt;0$($f^{\\prime\\prime}(x)&lt;0$)，$y=f(x)$在$[a, b]$上的图形是凹(凸)的。 导数为零的点称为驻点或临界点；在$f^{\\prime\\prime}(x)=0$或二阶导数不存在的点左右异号则该点就是拐点。 函数的极值与最大值最小值 $f(x)$在$x_0$处可导，且在$x_0$处取得极值，则$f^\\prime(x_0)=0$。 $f(x)$在$x_0$处连续，且在$x_0$的某去心邻域可导。 若$x∈(x_0-\\delta, x_0)$时，$f^\\prime(x)&gt;0$，而$x∈(x_0, x_0+\\delta)$，$f^\\prime(x)&lt;0$，则$f(x)$在$x_0$处取得极大值。 若$x∈(x_0-\\delta, x_0)$时，$f^\\prime(x)&lt;0$，而$x∈(x_0, x_0+\\delta)$，$f^\\prime(x)&gt;0$，则$f(x)$在$x_0$处取得极小值。 若$x∈(x_0-\\delta, x_0)\\bigcup(x_0, x_0+\\delta)$时，$f^\\prime(x)$的符号保持不变，则$f(x)$在$x_0$处没有极值。 $f(x)$在$x_0$处具有二阶导数且$f^\\prime(x_0)=0$，$f^{\\prime\\prime}≠0$，则当$f^{\\prime\\prime}&lt;0$($f^{\\prime\\prime}&gt;0$)时，$f(x)$在$x_0$处取得极大值(极小值)。 将驻点及不可导点带入函数取区间上的最大值和最小值就是函数的最大值和最小值。 函数图形的描绘描绘步骤为： 确定定义域和间断点，判断函数的奇偶性和周期性。 求$f^\\prime(x)$和$f^{\\prime\\prime}$，根据$f^\\prime(x)=0$、$f^{\\prime\\prime}=0$以及间断点分开区间。 确定$y=f(x)$的单调增、减区间，求出极值。 确定$y=f(x)$的凹凸区间和拐点。 取间断点求渐近线方程，共三种： 斜率渐近线：$k=\\lim \\limits{x \\to +\\infty} \\frac{f(x)}{x}$，$b=\\lim \\limits{x \\to +\\infty}[f(x)-kx]$。 垂直渐近线：$x \\to x_0$时，$f(x) \\to \\infty$，则$x=x_0$就是渐近线。 水平渐近线：$k=0$时的渐近线。 作表作图。 不定积分不定积分的概念与性质 $F^\\prime(x)=f(x)$，$F(x)+C$($C$是常数)是原函数，$f(x)$称为导函数。原函数存在的条件为连续函数一定有原函数。 在区间I上，$f(x)$带有任意常数项的原函数称为$f(x)$（或$f(x)dx$）在区间I上的不定积分，记作$\\int f(x){\\rm d}x$，即$\\int f(x){\\rm d}x=F(x)+C$（$C$是常数）。 不定积分的几何含义：即一组平行的曲线簇。 不定积分的性质： $\\int [f(x)+g(x)]{\\rm d}x=\\int f(x){\\rm d}x+\\int g(x){\\rm d}x$ $\\int kf(x){\\rm d}x=k\\int f(x){\\rm d}x$ 基本积分表： $\\int k{\\rm d}x=kx+C$（$k是常数$） $\\int x^\\mu{\\rm d}x=\\frac{x^{\\mu+1}}{\\mu+1}+C$ $\\int \\frac{1}{x}{\\rm d}x=ln|x|+C$ $\\int \\frac{1}{1+x^2}{\\rm d}x=arctanx+C$ $\\int \\frac{1}{\\sqrt{1-x^2}}{\\rm d}x=arcsinx+C$ $\\int cosx{\\rm d}x=sinx+C$ $\\int sinx{\\rm d}x=-cosx+C$ $\\int sec^2x{\\rm d}x=tanx+C$ $\\int csc^2x{\\rm d}x=-cotx+C$ $\\int secxtanx{\\rm d}x=secx+C$ $\\int cscxcotx{\\rm d}x=-cscx+C$ $\\int e^x{\\rm d}x=e^x+C$ $\\int a^x{\\rm d}x=\\frac{a^x}{lna}+C$ $\\int shx{\\rm d}x=chx+C$ $\\int chx{\\rm d}x=shx+C$ $\\int tanx{\\rm d}x=-ln|cosx|+C$ $\\int cotx{\\rm d}x=ln|sinx|+C$ $\\int secx{\\rm d}x=ln|secx+tanx|+C$ $\\int cscx{\\rm d}x=ln|cscx-cotx|+C$ $\\int \\frac{1}{a^2+x^2}{\\rm d}x=\\frac{1}{a}arctan\\frac{x}{a}+C$ $\\int \\frac{1}{x^2-a^2}{\\rm d}x=\\frac{1}{2a}ln|\\frac{x-a}{x+a}|+C$ $\\int \\frac{1}{\\sqrt{a^2-x^2}}{\\rm d}x=arcsin\\frac{x}{a}+C$ $\\int \\frac{1}{\\sqrt{x^2+a^2}}{\\rm d}x=ln(x+\\sqrt{x^2+a^2})+C$ $\\int \\frac{1}{\\sqrt{x^2-a^2}}{\\rm d}x=ln|x+\\sqrt{x^2-a^2}|+C$ $\\int \\sqrt{x^2+a^2}{\\rm d}x=\\frac{a^2}{2}ln(\\sqrt{a^2+x^2}+x)+\\frac{x}{2}\\sqrt{a^2+x^2}+C$ $\\int \\sqrt{x^2-a^2}{\\rm d}x=\\frac{a^2}{2}ln(\\sqrt{x^2-a^2}+x)+\\frac{x}{2}\\sqrt{x^2-a^2}+C$ 换元积分法 第一类换元法：$\\int f(\\phi(x))\\phi^\\prime(x){\\rm d}x=\\int f(\\phi(x)){\\rm d}\\phi(x)=F(\\phi(x))+C$。 第二类换元法：$\\int f(x)dx=\\int f(\\phi(t))\\phi^\\prime(t)dt=g(t)+C$，其中$t=\\phi^{-1}(x)$，因此$g(t)+C$=$g(\\phi^{-1}(x))+C$。做题步骤： 1.设$x=\\phi(t)$，并求积。 2.将t换回x。（此处可画直角三角形辅助，例$sinx=\\frac{x}{a}$，则斜边a、对边x、临边$\\sqrt{a^2-x^2}$，$cosx$就等于$\\frac{\\sqrt{a^2-x^2}}{a}$） 分部积分法 $\\int u {\\rm d}v=uv-\\int v {\\rm d}u$。 选择$\\int u {\\rm d}v$中u的优先级顺序：对数函数、反三角函数、幂函数、三角函数和指数函数（对反幂三指，其中对反可以互换，三指也可以互换）。 有理函数的积分 $R(x)=\\frac{P_m(x)}{Q_n(x)}\\begin{cases} m≥n，&amp;有理假分式。\\\\m&lt;n，&amp;有理真分式。 \\end{cases}$，其中$P(x)$和$Q(x)$是两个多项式，m和n是多项式的最高次幂。有理假分式需要通过长除法变成有理真分式进行求解。 $\\frac{A}{(x-a)^n}$型式化成$\\frac{A_1}{(x-a)^n}+\\frac{A_2}{(x-a)^{n-1}}+\\dots+\\frac{A_n}{x-a}$； $\\frac{Bx+C}{(x^2+px+q)^n}$型式化成$\\frac{B_1x+C_1}{(x^2+px+q)^n}+\\frac{B_2x+C_2}{(x^2+px+q)^{n-1}}+\\dots+\\frac{B_nx+C_n}{x^2+px+q}$。 $\\int \\frac{1}{ax^2+bx+c}{\\rm d}x$ $\\int \\frac{dx+e}{ax^2+bx+c}{\\rm d}x$ b^2-4ac=0 $a(x-x_1)^2$。 $a(x-x_1)^2$，将d凑成和分母类似。 b^2-4ac&gt;0 $a(x-x_1)(x-x_2)$，化成$\\frac{A_1}{x-x_1}+\\frac{A_2}{x-x_2}$型式。 与左边相同。 b^2-4ac&lt;0 先配方，然后将d凑成和分母类似。 与左边相同。 $\\int R(sinx, cosx){\\rm d}x$ 另$t=tan\\frac{x}{2}$。 $\\int R(tanx){\\rm d}x$$\\int R(sin^2x, cos^2 x){\\rm d}x$$\\int R(sin2x, cos2x){\\rm d}x$ 另$t=tanx$。 $\\int R(x, \\sqrt[n]{\\frac{ax+b}{cx+h}}){\\rm d}x$ 另$t=\\sqrt[n]{\\frac{ax+b}{cx+h}}$。 $\\int R(x, \\sqrt{ax^2+bx+c}){\\rm d}x$ 先配方，然后对根式选择适当的三角变换去掉根式，化为三角函数有理式的积分。 定积分定积分的概念与性质 $f(x)$在$[a, b]$上有界，在$[a, b]$上任意插入若干个分点将其分成n个小区间$\\Delta x_1,\\Delta x_2,\\dots,\\Delta x_n$，在每个小区间上任取一点$\\xi_i$，$I=\\lim \\limits_{\\lambda \\to 0} \\sum_{i=1}^n f(\\xi_i)\\Delta x_i$($\\lambda=max\\{\\Delta x_1,\\Delta x_2,\\dots,\\Delta x_n\\}$)，称这个极限I为$f(x)$在$[a, b]$上的定积分，记作$\\int_a^b f(x){\\rm d}x$。就是说若要取一个曲边梯形的面积，则可以用若干个小长方形的面积相加近似的获取其面积。 $f(x)$在$[a, b]$上连续，则$f(x)$在$[a, b]$上可积。 $f(x)$在$[a, b]$上有界，且只有有限个间断点，则$f(x)$在$[a, b]$上可积。 当$b=a$时，则$\\int_a^a f(x){\\rm d}x=0$。 $\\int_a^b f(x){\\rm d}x$=$-\\int_b^a f(x){\\rm d}x$。 $\\int_a^b [\\alpha f(x)+\\beta g(x)]{\\rm d}x$=$\\alpha\\int_a^b f(x){\\rm d}x$+$\\beta\\int_a^b g(x){\\rm d}x$。 当$a&lt;c&lt;b$时，$\\int_a^b f(x){\\rm d}x$=$\\int_a^c f(x){\\rm d}x$+$\\int_c^b f(x){\\rm d}x$。 在$[a, b]$上$f(x)\\equiv 1$，则$\\int_a^b 1{\\rm d}x$=$\\int_a^b {\\rm d}x$=$b-a$。 在$[a, b]$上$f(x)≥0$（$f(x)≤0$），则$\\int_a^b f(x){\\rm d}x≥0$（$\\int_a^b f(x){\\rm d}x≤0$），其中$a&lt;b$。 在$[a, b]$上$f(x)≤g(x)$，则$\\int_a^b f(x){\\rm d}x≤\\int_a^b g(x){\\rm d}x$，其中$a&lt;b$。 $|\\int_a^b f(x){\\rm d}x|≤\\int_a^b |f(x)|{\\rm d}x$，其中$a&lt;b$。 若M及m分别是$f(x)$在$[a, b]$上的最大值和最小值，则$m(b-a)≤\\int_a^b f(x){\\rm d}x≤M(b-a)$，其中$a&lt;b$。 定积分中值定理：若$f(x)$在$[a, b]$上连续，$\\exists \\xi∈[a, b]$，使得$\\int_a^b f(x){\\rm d}x=f(\\xi)(b-a)$。 微积分基本共识 $f(x)$在$[a, b]$上连续，则积分上限的函数在$[a, b]$上可导，其导数为$\\Phi^\\prime(x)=\\frac{d}{dx}\\int_a^xf(t){\\rm d}t=f(x)$，其中($a≤x≤b$)。 $\\int_{\\psi(x)}^{\\phi(x)}[f(t){\\rm d}t]^\\prime=f(\\phi(x))\\phi^\\prime(x)-f(\\psi(x))\\psi^\\prime(x)$。 牛顿-莱布尼茨公式：$F(x)$是连续函数$f(x)$在$[a, b]$上的一个原函数，则$\\int_a^bf(x){\\rm d}x=F(b)-F(a)$。 定积分的换元法和分部积分法 $x=\\phi(t)$，若$\\phi(\\alpha)=a$，$\\phi(\\beta)=b$，则$\\int_a^bf(x){\\rm d}x=\\int_{\\alpha}^{\\beta}f[\\phi(t)]\\phi^\\prime(t){\\rm d}t$。（一定要注意上下限也要替换。） $f(x)$在$[-a, a]$上连续且为偶函数，则$\\int_{-a}^af(x){\\rm d}x=2\\int_0^af(x){\\rm d}x$；$f(x)$在$[-a, a]$上连续且为奇函数，则$\\int_{-a}^af(x){\\rm d}x=0$。 $f(x)$在$[0, 1]$上连续，则$\\int_0^{\\frac{\\pi}{2}}f(sinx){\\rm d}x=\\int_0^{\\frac{\\pi}{2}}f(cosx){\\rm d}x$，$\\int_0^{\\pi}xf(sinx){\\rm d}x=\\frac{\\pi}{2}\\int_0^{\\pi}f(sinx){\\rm d}x$。 $f(x)$是连续的周期函数，则$\\int_a^{a+T}f(x){\\rm d}x=\\int_0^Tf(x){\\rm d}x$，$\\int_a^{a+nT}f(x){\\rm d}x=n\\int_0^Tf(x){\\rm d}x$（$n∈N$）。 $\\int_a^b u {\\rm d}v=[uv]_a^b-\\int_a^b v {\\rm d}u$。 反常积分（广义积分） 无穷限的反常积分： $\\int_a^{+\\infty}f(x)dx=\\lim \\limits_{t \\to +\\infty}\\int_a^tf(x){\\rm d}x$，若极限存在则收敛，否则发散。 $\\int_{-\\infty}^{a}f(x)dx=\\lim \\limits_{t \\to -\\infty}\\int_t^af(x){\\rm d}x$，若极限存在则收敛，否则发散。 $\\int_{-\\infty}^{+\\infty}f(x)dx=\\int_{-\\infty}^{0}f(x)dx+\\int_{0}^{+\\infty}f(x)dx$，若右式均收敛则左式收敛，否则发散。 无界函数的反常积分：（注意函数无定义点。） 若$f(x)$在$(a, b]$上连续，则a就是$f(x)$的瑕点。任取$t&gt;a$，则$\\int_a^bf(x){\\rm d}x=\\lim \\limits_{t \\to a^+}\\int_t^bf(x){\\rm d}x$。 若$f(x)$在$[a, b)$上连续，则b就是$f(x)$的瑕点。任取$t&lt;b$，则$\\int_a^bf(x){\\rm d}x=\\lim \\limits_{t \\to b^-}\\int_a^tf(x){\\rm d}x$。 若$f(x)$在$[a, c)$及$(c, b]$上连续，则c就是$f(x)$的瑕点。$\\int_a^bf(x){\\rm d}x=\\int_a^cf(x){\\rm d}x+\\int_c^bf(x){\\rm d}x$。 $\\Gamma$函数 $\\Gamma(s)$=$\\int_0^{+\\infty}e^{-x}x^{s-1}{\\rm d}x$，其中$s&gt;0$。 $\\Gamma(s+1)$=$s\\Gamma(s)$，其中$s&gt;0$。 $\\Gamma(n+1)=n!$。 定积分的应用定积分在几何学上的应用 平面图形的面积：$A=\\int_a^bf(x){\\rm d}x$。 X型区域：若在x轴的$[a, b]$上$g(x)≤f(x)$，则$S=\\int_a^b[f(x)-g(x)]{\\rm d}x$。 Y型区域：若在y轴的$[c, e]$上$g(y)≤f(y)$，则$S=\\int_c^e[f(y)-g(y)]{\\rm d}y$。 椭圆的面积：$S=\\frac{ab\\pi}{4}$。 根据$sin^2t+cos^2t=1$与$(\\frac{x}{a})^2+(\\frac{y}{b})^2=1$推出$\\begin{cases} x=acost\\\\y=bsint \\end{cases}$，其中$0≤t≤\\frac{\\pi}{2}$。 $S=4\\int_0^ay{\\rm d}x=\\int_0^{\\frac{\\pi}{2}}absin^2t{\\rm d}t=\\frac{\\pi ab}{4}$ 极坐标情形：$A=\\int_\\alpha^\\beta\\frac{1}{2}[p(\\theta)]^2{\\rm d}\\theta$。 旋转体的体积： X型区域：若在x轴的$[a, b]$上，$\\int_a^b\\pi f^2(x){\\rm d}x$=$\\int_a^bA(x){\\rm d}x$。 Y型区域：若在y轴的$[c, e]$上，$\\int_c^e\\pi \\phi^2(y){\\rm d}y$=$\\int_c^eA(y){\\rm d}y$。 旋转体的侧面积：曲线$y=f(x)≥0$，$a≤x≤b$，绕X轴旋转，得到的旋转体侧面积为$S=\\int_a^b2\\pi f(x)\\sqrt{1+f^{\\prime 2}(x)}{\\rm d}x$。 光滑曲线弧是可求长的，求弧长公式为： $\\begin{cases} x=\\phi(t)\\\\y=\\psi(t) \\end{cases}$，其中$\\alpha≤t≤\\beta$，则$s=\\int_\\alpha^\\beta\\sqrt{\\phi^{\\prime 2}(t)+\\psi^{\\prime 2}(t)}{\\rm d}t$。 $\\begin{cases} x=x\\\\y=f(x) \\end{cases}$，其中$a≤x≤b$，则$s=\\int_a^b\\sqrt{1+y^{\\prime 2}}{\\rm d}x$。 $\\rho=\\rho(\\theta)$，($\\alpha≤\\theta≤\\beta$)，$\\begin{cases} x=x(\\theta)=\\rho(\\theta)cos\\theta\\\\y=y(\\theta)=\\rho(\\theta)sin\\theta \\end{cases}$，$s=\\int_\\alpha^\\beta\\sqrt{\\rho^2(\\theta)+\\rho^{\\prime 2}(\\theta)}{\\rm d}\\theta$。 微分方程微分方程的基本概念 通俗说含导数的即微分方程。 任意常数的个数与微分方程的阶数相同，这样的解叫做微分方程的通解。 可分离变量的微分方程$y^\\prime=f(x, y)$化为$g(y){\\rm d}y=f(x){\\rm d}x$，两边同时作积。 齐次方程 齐次方程：$\\frac{dy}{dx}=\\phi(\\frac{y}{x})$，例如：$\\frac{dy}{dx}=\\frac{1+(\\frac{y}{x})^2}{1-2(\\frac{y}{x})^2}$，即$\\frac{y}{x}$是整体出现的。求解步骤： $u=\\frac{y}{x}$。 $y=xu$。 $\\frac{dy}{dx}=u+x\\frac{du}{dx}$。 分离变量。 可化为齐次方程：$\\frac{dy}{dx}=\\frac{ax+by+c}{a_1x+b_1y+c_1}$，当$c=c_1$时是其次的，否则是非齐次的。将非齐次化作齐次方程令$x=X+h$，$y=Y+k$，所以$\\frac{dY}{dX}=\\frac{aX+bY+ah+bk+c}{a_1X+b_1Y+a_1h+b_1k+c_1}$，若方程组$\\begin{cases} ah+bk+c=0,\\\\a_1h+b_1k+c_1=0\\end{cases}$中： 若$\\frac{a_1}{a}≠\\frac{b_1}{b}$，则$\\frac{dY}{dX}=\\frac{aX+bY}{a_1X+b_1Y}$。 若$\\frac{a_1}{a}=\\frac{b_1}{b}$，则令$\\frac{a_1}{a}=\\frac{b_1}{b}=\\lambda$，$\\frac{dy}{dx}=\\frac{ax+by+c}{\\lambda(ax+by)+c_1}$，引入变量$v=ax+by$，则$\\frac{dv}{dx}=a+b\\frac{dy}{dx}$或$\\frac{dy}{dx}=\\frac{1}{b}(\\frac{dv}{dx}-a)$，于是最终方程为$\\frac{1}{b}(\\frac{dv}{dx}-a)=\\frac{v+c}{\\lambda v+c_1}$。 一阶线性微分方程$\\frac{dy}{dx}+P(x)y=Q(x)$称为一阶线性微分方程： 若$Q(x)\\equiv 0$则称为齐次线性微分方程，其通解为$y=Ce^{-\\int P(x){\\rm d}x}$，其中$C=±e^{C_1}$。 若$Q(x)≠0$则称为非齐次线性微分方程，另$y=ue^{-\\int P(x){\\rm d}x}$代入原方程可得到其特解$y=e^{-\\int P(x){\\rm d}x}(\\int Q(x)e^{\\int P(x){\\rm d}x}{\\rm d}x+C)$，其解为通解加上特解为$y=Ce^{-\\int P(x){\\rm d}x}+e^{-\\int P(x){\\rm d}x}\\int Q(x)e^{\\int P(x){\\rm d}x}{\\rm d}x$。 可降阶的高阶微分方程 $y^{(n)}=f(x)$：几阶导就求几次积分。 $y^{\\prime\\prime}=f(x, y^\\prime)$：设$y^\\prime=p$，则$y^{\\prime\\prime}=p^\\prime$，$p^\\prime=f(x, p)$，分离变量求积。 $y^{\\prime\\prime}=f(y, y^\\prime)$：设$y^\\prime=p$，则$y^{\\prime\\prime}=p^\\prime=\\frac{dp}{dx}=\\frac{dp}{dy}\\frac{dy}{dx}=p\\frac{dp}{dy}$，分离变量求积。 高阶线性微分方程 二阶齐次线性方程：$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=0$，其解为$y=C_1y_1(x)+C_2y_2(x)$。 二阶非齐次线性方程：$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=f(x)$，设$y^(x)$是特解，$Y(x)$是通解，则其解为$y=Y(x)+y^(x)$。 常系数齐次线性微分方程将$y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=0$写为$y^{\\prime\\prime}+py^\\prime+qy=0$，求解： $r^2+pr+q=0$ $y^{\\prime\\prime}+P(x)y^\\prime+Q(x)y=0$ $p^2-4q&gt;0$，$r=\\frac{-p±\\sqrt{p^2-4q}}{2}$ $y=C_1e^{r_1x}+C_2e^{r_2x}$ $p^2-4q=0$，$r=-\\frac{p}{2}$ $y=(C_1+C_2x)e^{r_1x}$ $p^2-4q&lt;0$，$r=\\alpha ±\\beta i$，$\\alpha=-\\frac{p}{2}, \\beta=\\frac{\\sqrt{4q-p^2}}{2}$ $e^{\\alpha x}(C_1cos\\beta x+C_2sin\\beta x)$ 常系数非齐次线性微分方程 $f(x)=e^{\\lambda x}P_m(x)$，其特解为：$y*=e^{\\lambda x}Q_m(x)$， $\\lambda=\\begin{cases} 0,&amp;\\lambda与特征方程两个特征根均不相等\\\\1&amp;\\lambda与特征方程其中一个特征根相等\\\\2&amp;\\lambda与特征方程两个特征根均相等 \\end{cases}$。 $Q_m(x)$与$P_m(x)$是同次的多项式，例如$P_m(x)=x^2+3$，则$Q_m(x)=ax^2+bx+c$。 $f(x)=e^{\\lambda x}[P_l(x)cos\\psi x+Q_n(x)sin \\psi x]$，其特解为：$y^*=x^ke^{\\lambda x}[R_m^{(1)}(x)cos\\psi x+R_m^{(2)}(x)sin\\psi x]$， $\\lambda=\\begin{cases} 0,&amp;\\lambda±i\\psi不是特征方程的根 \\\\1,&amp;\\lambda±i\\psi是特征方程的根 \\end{cases}$。 $P_l(x)$和$Q_n(x)$是两个多项式，$R_m(x)$中的$m=Max\\{l, n\\}$。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数","date":"2020-01-18T06:41:20.000Z","path":"posts/c23efd5b/","text":"行列式行列式定义 $\\begin{vmatrix} a&amp;b\\\\ c&amp;d \\end{vmatrix}=ad-bc$ 三阶行列式：展开式共六项，其中三个正项，三个负项。（n 阶行列式展开式共 n! 项。） n 阶行列式：行取自然排列（例123），列取排列所有可能（例123、132、$\\dots$），不同行不同列取 n 个元素相乘，符号由列标排列逆序数的奇偶决定。 下三角、上三角和对角形的行列式为主对角线元素相乘。 山寨下三角、山寨上三角和山寨对角形的行列式为 $(-1)^{\\frac{n(n-1)}{2}}$ 与次对角线元素相乘。 行列式性质 转置：$D^T=D$ 交换两行（列），行列式变号。 两行（列）元素相等，D=0。 某一行（列）有公因子 k，k 外提一次。所有行（列）都有公因子 k，k 外提 n 次。 两行（列）元素成比例，D=0。 某一行（列）元素全为0，D=0。 某一行（列）元素全是两数之和，拆成两个行列式。（只拆该行或列，其余行或列保持不变。） 某一行（列）乘以一个数加到另一行（列），D 不变。 行列式展开 D = 某一行（列）元素与其代数余子式乘积之和。（将$(i, j)$所在的行列划去留下的就是余子式，代数余子式是带符号的余子式，其符号为$(-1)^{i+j}$。） 异乘变零：某行（列）元素与其他行（列）的代数余子式乘积之和为0。 拉普拉斯定理：任取 k 行（列），由这 k 行（列）元素组成的所有 k 阶子式与其代数余子式乘积之和为 D。（常用于解某一块都是0的行列式。） 克拉默法则：n 个方程 n 个未知数的方程组，系数行列式若不等于0则有唯一解：$x_i=\\frac{D_i}{D}$，其中 $D_i$ 为用常数项替代 i 列，而其他列不变的行列式的值。n 个方程 n 个未知数的齐次方程组，系数行列式若不等于0则有零解；若等于0则有非零解。 范德蒙德行列式： $$\\begin{vmatrix} 1&amp;1&amp;\\cdots&amp;1\\\\ x_1&amp;x_2&amp;\\cdots&amp;x_n\\\\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots\\\\ {x_{1}}^{n-1}&amp;{x_{2}}^{n-1}&amp;\\cdots&amp;{x_{n}}^{n-1} \\end{vmatrix}=\\prod_{1≤j&lt;i≤n}(x_i-x_j)$$ 对称行列式主对角线无要求，上下位置对应相等；反对称行列式主对角线全为零，上下位置对应成相反数。 矩阵及其运算矩阵的运算 负矩阵：A，-A；n阶方阵：行数=列数，$A_{n×n}=A_n$；单位阵：方阵对角线都是1，其余为0，记作E。 矩阵加（减）法：同型矩阵，对应元素相加（减）。 矩阵数乘：kA，用 k 乘以 A 的每个元素。 矩阵提公因子：每个元素都有公因子则向外提一次。 AB 相乘条件：A 的列数=B 的行数。 C=AB，结果矩阵形状：C 的行数=A 的行数；C 的列数=B 的列数。 矩阵乘法不满足： AB 一般不等于 BA。 AB=AC，且 A≠0，推不出 B=C。 AB=0，推不出 A=0，或 B=0。 与零矩阵相乘：$A_{4×3}O_{3×2}=O_{4×2}$； 与E相乘：$AE=A$，$EB=B$； 运算规则：$\\begin{cases}(AB)C=A(BC)\\\\(A+B)C=AC+BC\\\\k(A+B)=(kA)B=A(kB)\\end{cases}$。 次幂：$A^k=AA\\cdots A$（k 个 A 相乘）。 $A^m×A^n=A^{m+n}$$(A^m)^n=A^{mn}$$(P^{-1}AP)^n=P^{-1}A^nP$ $(A^T)^T=A$$(kA)^T=kA^T$$(A+B)^T=A^T+B^T$$(AB)^T=B^TA^T$ $diag(1, 2, 3)=\\begin{bmatrix}1&amp;0&amp;0\\\\0&amp;2&amp;0\\\\0&amp;0&amp;3\\end{bmatrix}$。 对称矩阵：$A^T=A$反对称矩阵：$A^T=-A$ $|A^T|=|A|$$|kA|=k^n|A|$$|AB|=|A||B|$ 分块矩阵求转置分两步： 将分块矩阵的块看作普通元素求转置。 对每一个块求转置。 $\\begin{bmatrix} A_1&amp;0&amp;0&amp;0\\\\0&amp;A_2&amp;0&amp;0\\\\0&amp;0&amp;A_3&amp;0\\\\0&amp;0&amp;0&amp;A_4 \\end{bmatrix}$=$\\begin{bmatrix} A_1^{-1}&amp;0&amp;0&amp;0\\\\0&amp;A_2^{-1}&amp;0&amp;0\\\\0&amp;0&amp;A_3^{-1}&amp;0\\\\0&amp;0&amp;0&amp;A_4^{-1} \\end{bmatrix}$；$H=\\begin{bmatrix} A&amp;C\\\\0&amp;B \\end{bmatrix}$，$H^{-1}=\\begin{bmatrix} A^{-1}&amp;A^{-1}CB^{-1}\\\\0&amp;B^{-1} \\end{bmatrix}$。 标准形： 对角线全0或全1。 对角线从上到下是连续的1和连续的0。 可以不是方阵。 逆矩阵 逆矩阵：$AB=BA=E$，逆矩阵一定是方阵。推论：$AB=E$，A, B 均可逆，所以 $A^{-1}=B$, $B^{-1}=A$ 求 $A^{-1}$： 伴随矩阵法：$A^{-1}=\\frac{1}{|A|}A^*$ 初等变换法：$(\\begin{array}{c:c}A&amp;E\\end{array}) \\longrightarrow (\\begin{array}{c:c}E&amp;A^{-1}\\end{array})$ $(A^{-1})^{-1}=A$$(AB)^{-1}=B^{-1}A^{-1}$ $(A^T)^{-1}=(A^{-1})^T$$(kA)^{-1}=\\frac{1}{k}A^{-1}$ $|A^{-1}|=\\frac{1}{|A|}$$(A^{-1})^{\\ast}=(A^*)^{-1}=\\frac{1}{|A|}A$ A 可逆则 $|A|≠0$。 伴随矩阵 按行求代数余子式，按列放，伴随矩阵一定是方阵。 $AA^{\\ast}=A^{\\ast}A=|A|E$ $|A^{\\ast}|=|A|^{n-1}$ $A^{-1}=\\frac{1}{|A|}A^{\\ast} \\longrightarrow A^{\\ast}=|A|A^{-1}$ $R(A^{\\ast})=\\begin{cases} n,&amp;若 R(A)=n\\\\ 1,&amp;若 R(A)=n-1\\\\ 0,&amp;若 R(A)&lt;n-1 \\end{cases}$ 矩阵的初等变换初等矩阵初等变换 三种初等行变换，三种初等列变换： 交换两行（列）。 用一个非0数乘某一行（列）。 某一行（列）的 k 倍加到另一行（列）上去。 等价：AB 是同型矩阵，A 经初等变换得到 B（同型矩阵行列相等）。 等价：AB 是同型矩阵，存在可逆 P, Q，使得 $PAQ=B$。 初等矩阵即对E做y一次初等变换得到的矩阵。 初等矩阵均可逆，其逆矩阵也是初等矩阵，转置矩阵也是初等矩阵。 初等矩阵左乘 A，相当于对 A 做初等行变换。初等矩阵右乘 A，相当于对 A 做初等列变换。 初等矩阵 $E(i, j)$ 表示交换 i, j 行。其中 $|E(i, j)|=-1$，$E^{-1}(i, j)=E(i, j)$。初等矩阵 $E(i(k))$ 表示用 k 乘第 i 行。其中 $|E(i(k))|=k$，$E^{-1}(i(k))=E(i(\\frac{1}{k}))$。初等矩阵 $E(i, j(k))$ 表示用第 j 行的 k 倍加到第 i 行上。其中 $|E(i, j(k))|=1$，$E^{-1}(i, j(k))=E(i, j(-k))$。 矩阵的秩 R(A)：非零子式的最高阶数。 零矩阵的秩为0。 $0≤R(A)≤min\\{行数, 列数\\}$，若$R(A)=min\\{行数, 列数\\}$则称为满秩，若$R(A)＜min\\{行数, 列数\\}$则称为降秩。 若A是方阵且满秩即|A|≠0，则A可逆。 $R(A)=r \\Longleftrightarrow $有一个 r 阶非零子式，所有 r+1 阶子式均为0。 初等变换（行, 列）不改变矩阵的秩。 求 R(A)，将 A 化为阶梯型（初等行列变换均可），数非零行的行数。阶梯型画线横线可跨多个数，竖线只能跨一个数。行简化阶梯型：在阶梯型的基础上，非零行的首非零元是1；首非零元所在列其余元素是0。 $R(A)=R(A^T)$ P, Q 可逆，$R(A)=R(PA)=R(AQ)=R(PAQ)$。 $max\\{R(A), R(B)\\}≤R(A, B)≤R(A)+R(B)$ $R(A+B)≤R(A)+R(B)$ $R(AB)≤min\\{R(A), R(B)\\}$ $A_{m×n}·B_{n×l}=0$，则 $R(A)+R(B)≤n$。 $A·B=0$，若 A 为列满秩矩阵，则 $B=0$。（列满秩矩阵即矩阵的秩等于矩阵的列数。） 向量组的线性相关性向量的线性组合 $kα=0 \\Longleftrightarrow k=0 或 α=0$ 零向量可由任意向量组表示。 向量组中的一个向量可由该向量组表示。 任意向量可由单位向量组表示。 向量组等价：两向量组可相互表示。 线性相关 &amp;&amp; 线性无关 线性相关：存在不全是0的 $k_1, \\cdots, k_n$，使 $kα_1+ \\cdots +kα_n=0$。 线性无关：$kα_1+ \\cdots +kα_n=0$ 成立，$k_1, \\cdots, k_n$ 全取0。 线性相关、无关的性质 向量组中两个向量分量成比例，向量组线性相关。 一个零向量线性相关，一个非零向量线性无关。 含零向量的向量组必线性相关。 部分组线性相关，则整体组线性相关。整体组线性无关，则部分组线性无关。 向量组线性无关，则接长组线性无关。向量组线性相关，则截短组线性相关。 n 个 n 维向量线性无关 $\\Longleftrightarrow D≠0$n 个 n 维向量线性相关 $\\Longleftrightarrow D=0$ 线性相关、无关的定理 向量线性相关 $\\Longleftrightarrow$ 至少一个向量是其余向量的线性组合。 $α_1, \\cdots, α_s$ 线性无关，$α_1, \\cdots, α_s, β$ 线性相关，则 β 可由 $α_1, \\cdots, α_s$ 唯一线性表示。 $α_1, \\cdots, α_s$ 线性无关，可由 $β_1, \\cdots, β_t$ 线性表示，则 $s≤t$。 $α_1, \\cdots, α_s$ 可由 $β_1, \\cdots, β_t$ 线性表示，且 $s&gt;t$，则 $α_1, \\cdots, α_s$ 线性相关。 向量个数 &gt; 向量维数，向量组线性相关。 n+1 个 n 维向量必线性相关。 等价的线性无关的向量组，含相同个数的向量。 极大线性无关组 线性无关组的定义：$α_1, α_2, \\cdots, α_r$ 的部分组如 $α_1, α_2$ 无关且每个向量均可由 $α_1, α_2$ 表示。 线性无关向量组的极大无关组是本身。 向量组与其极大无关组等价。 向量组的不同极大无关组含向量个数相同。 向量组的秩：极大无关组含向量的个数。 $0≤R(α_1, \\cdots, α_s)≤min\\{向量个数, 向量维数\\}$ A 的行秩=A 的列秩= R(A) $R(AB)≤min\\{R(A), R(B)\\}$ 求极大线性无关组： 不管向量是行或列，均按行构成矩阵。 只做初等行变化，化成行最简形矩阵。 首非零元所在列做极大无关组。 其余向量表示系数直接写出即可。 线性方程组AX=B 有解判定 $R(A)=R(Ā)=n$，有唯一解。（$R(Ā)$是带上等式右边的矩阵的秩。） $R(A)=R(Ā)&lt;n$，有无穷解。 $R(A)≠R(Ā)$，无解。 一般解计算方法： 写出Ā。 通过初等行变化转换成阶梯型。 判断解的个数。 化为行简化阶梯型，非零行的首非零元留在等式左边，其余变量留在等式右边得一般解。 AX=0 齐次方程组 齐次方程组一定有解，至少有零解。 齐次方程组仅有零解 $\\Longleftrightarrow R(A)=n$。 齐次方程组有非零解 $\\Longleftrightarrow R(A)&lt;n$。 齐次方程组中，方程个数&lt;未知数个数，有非零解。 齐次方程组中，方程个数=未知数个数，有非零解 $\\Longleftrightarrow$ 系数行列式等于零；仅有零解 $\\Longleftrightarrow$ 系数行列式不等于零。 AX=0 解的结构 $AX=0$ 的两个解相加仍然是解。 η 是 $AX=0$ 的解，则 cη 也是解。 $AX=0$ 的解的线性组合仍然是解。 基础解系：$η_1, \\cdots, η_s$ 是解，满足： $η_1, \\cdots, η_s$ 线性无关。 任意解可有 $η_1, \\cdots, η_s$ 表示。 $AB=0$，则 $R(A)+R(B)≤n$。 AX=B 解的结构 $AX=B \\longrightarrow AX=0$（导出组） $AX=B$ 的两个解相减是 $AX=0$ 的解。 $AX=B$ 的一个解和 $AX=0$ 的一个解相加是 $AX=B$ 的另一个解。 $AX=B$ 的通解：特解 + 基础解系的线性组合。 $AX=B$ 的一个特解。 $AX=0$ 的基础解系。 相似矩阵及其二次型特征值 &amp;&amp; 特征向量 $Aα=λα$，其中$λ$是特征值，$α$是对应于$λ$的特征向量。特征值可以是零，特征向量是非零向量。 $|λE-A|=0$，用于求特征值。$(λE-A)X=0$ 的非零解，用于求特征向量。解法： 1.写出$|λE-A|$。 2.把某行尽可能转化为零后再按行展开。 3.提关于$λ$的公因子。 4.将$λ$代入$|λE-A|$，做初等行变化转换成行简化阶梯型，计算其基础解系。 A 和 $A^T$ 有相同的特征值。 $\\sum λ_i=\\sum a_{ii}$$λ_1, \\cdots, λ_n=|A|$ 矩阵的迹 $tr(A)=\\sum a_{ii}$ 不同特征值对应的特征向量线性无关。（实对称矩阵，不同特征值对应的特征向量一定正交。） k 重特征值的线性无关的特征向量个数小于等于 k 个。 kλ 是 kA 的特征值。 $λ^k$ 是 $A^k$ 的特征值。 求 A 的多项式的特征值：A 替换成 λ，E 替换成 1。 $λ^{-1}$ 是 $A^{-1}$ 的特征值。 $\\frac{1}{λ}|A|$ 是 $A^*$ 的特征值 相似矩阵 A, B 是同阶方阵，存在可逆 P，$P^{-1}AP=B$。 相似矩阵具有反身性，对称性和传递性。 $A\\sim B\\begin{cases} A, B 有相同的特征值。\\\\ |A|=|B|\\\\ tr(A)=tr(B)\\\\ |A|和|B| 同时为零或同时不为零，因此 A, B 同时不可逆或同时可逆。\\\\ A, B 若可逆则 A^{-1}\\sim B^{-1}。\\\\ A^m\\sim B^m \\end{cases}$ 对角化 A 相似于对角行 $\\Longleftrightarrow$ A 有 n 个线性无关的特征向量。 A 有 n 个互异特征值，可对角化。 不管单根，若每个 k 重特征根，都有 k 个特征向量，则可对角化。 特征向量做列构成 P， 特征值做主对角线构成 A，特征值和特征向量位置对应。 内积 $[α, β]=α^Tβ$，若 α, β 是列向量。 内积是一个数。 $[α, α]≥0$, $[α, α]=0$ $\\Longleftrightarrow$ $α=0$ $[α, β]=[β, α]$$[kα, β]=k[β, α]=k[α, β]$$[α+β, γ]=[α, γ]+[β, γ]$ 长度 $||α||=\\sqrt{[α, α]}$$||α||^2=[α, α]$$[α, α]=||α||^2$ $||α||≥0$, $||α||=0$ $\\Longleftrightarrow$ $α=0$ $||kα||=|k|·||α||$$|[α, β]|≤||α||·||β||$ $||α+β||≤||α||+||β||$ $[α, β]=0$，即正交，$α \\bot β$。 正交向量组：不含零向量，两两正交。 标准正交向量组：正交向量组，每个向量都是单位向量。 施密特正交化：$α_1, α_2, α_3$ | $β_1, β_2, β_3$$β_1=α_1$$β_2=α_2-\\frac{[α_2, β_1]}{[β_1, β_1]}β_1$$β_3=α_3-\\frac{[α_3, β_1]}{[β_1, β_1]}β_1-\\frac{[α_3, β_2]}{[β_2, β_2]}β_2$$\\cdots$ 正交 A 是方阵，$A^TA=E$，A 为正交矩阵。 A 正交，$|A|=1 或 -1$，$|A^{-1}|=A^T$。 A 正交，$A^{-1}$ 和 $A^T$ 也正交。A, B 正交，$AB$ 也正交。 A 正交，$[Aα, Aβ]=[α, β]$。 A 正交 $\\Longleftrightarrow$ 列（行）向量组是标准正交向量组。 正交相似 实对称矩阵 A 的不同特征值的特征向量必正交。 正交相似：A, B 是同阶方阵，存在正交 P，$P^{-1}AP=B$。 A 是实对称矩阵，存在正交 Q，$Q^{-1}AQ=\\bigwedge$。 Q：正交单位化后的特征向量做列。$\\bigwedge$：特征值作为主对角线元素。 二次型 二次型 $\\longrightarrow$ 矩阵： 平方项系数做主对角线。 交叉项系数除以二放两对称位置。 矩阵 $\\longrightarrow$ 二次型： 主对角线做平方项系数。 主对角线右上角元素乘以二做交叉项系数。（如矩阵不对称则先将矩阵化为对称矩阵） 二次型的矩阵对称。 $X=CY$，线性替换。 合同 A, B 是 n 阶方阵，存在可逆 C，$C^TAC=B$。 合同矩阵具有反身性，对称性和传递性。 $A\\simeq B\\begin{cases} R(A)=R(B)\\\\ A 对称 \\Longleftrightarrow B 对称\\\\ A, B 可逆，A^{-1}\\simeq B^{-1}\\\\ A^T\\simeq B^T \\end{cases}$ 标准形 标准形：只有平方项，没有交叉项。 标准形不唯一。 化标准形三种方法： 配方法：先处理 $x_1$，使后边的项中不再出现 $x_1$，再依次对 $x_2, x_3, \\cdots, x_n$ 进行配方法处理。 初等变换法：$(\\begin{array}{c:c}A\\\\E\\end{array}) \\longrightarrow (\\begin{array}{c:c}\\bigwedge\\\\C\\end{array})$（对 A, E 做列变换，只对 A 做相应的行变换，$\\bigwedge$是对角矩阵即除了对角线以外都是零。） 正交替换法：正交 Q，$Q^TAQ=\\bigwedge$。， 规范形 规范形：只有平方项，系数只能为1, -1, 0，且变量的下标是连着的。（1, -1, 0 系数不可变换位置） 规范形是唯一的。 正惯性指数：规范形的正项个数。负惯性指数：规范形的负项个数。符号差：正惯性指数-负惯性指数。 $A\\simeq B$ $\\Longleftrightarrow$ 有相同的秩和正惯性指数。 正定 二次型 $X^TAX$，任意 $X≠0$： $X^TAX&gt;0$，正定。 $X^TAX&lt;0$，负定。 $X^TAX≥0$，半正定。 $X^TAX≤0$，半负定。 正定二次型经过非退化替换仍化为正定二次型。 二次型正定 $\\Longleftrightarrow$ 标准形每个变量的系数都大于零。 二次型正定 $\\Longleftrightarrow$ 正惯性指数为 n。 A 正定，$|A|&gt;0$。 A 正定 $\\Longleftrightarrow$ A 的特征值都大于零。 A 正定 $\\Longleftrightarrow$ A 各阶顺序主子式大于零。 A 正定 $\\longrightarrow$ ①$A^{-1}正定$②${A^*正定}$③$A^k正定$④A 主对角线元素都大于零。 A 正定，B（半）正定 $\\longrightarrow$ A+B 正定。 总结外提 k 行列式一行（列）有公因子 k，向外提一次。 矩阵所有元素都有公因子 k，向外提一次。 向量所有分量都有公因子 k，向外提一次。 $|kA|=k^n|A|$ $(kA)^{-1}=\\frac{1}{k}A^{-1}$ $(kA)^=k^{n-1}A^$ $(kA)^T=kA^T$ $[kα, β]=k[α, β]$ $||kα||=|k|·||α||$ 方阵 A 可逆充要条件 $|A|≠0$ A 满秩。（R(A)=行，R(A)=列。） A 的标准形是 E。 $A=E_1E_2 \\cdots E_s$，$E_i$是初等矩阵。 A 的所有特征值不为0。 $R(A)=n$ A 的行秩=A 的列秩=R(A)=n A 的行（列）向量组无关。 A 的非零子式最高阶数为 n。 AX=0 只有零解。AX=B 有唯一解。 等价、相似、正交相似、合同 $\\cong$ 等价：A, B 同型，存在可逆 P, Q，$PAQ=B$。 $\\sim$ 相似：A, B 方阵，存在可逆 P，$P^{-1}AP=B$。 $\\sim$ 正交相似：A, B 方阵，存在正交 P，$P^{-1}AP=B$。 $\\simeq$ 合同：A, B 方阵，存在可逆 P，$P^TAP=B$。 正交相似肯定相似，且一定合同（$P^{-1}=P^T$）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.kuukokawaii.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Django（二）：ORM","date":"2019-12-21T13:15:33.000Z","path":"posts/b179370b/","text":"ORMDjango ORM 默认使用 SQLite 数据库，它是一款轻型的数据库，是遵守ACID的关系型数据库管理系统，它包含在一个相对小的 C 库中。也可以使用其他数据库，例如 MySQL，修改 Django 的默认连接为 MySQL 方式之后，即可通过 Django 的 ORM 操作 MySQL 数据库。 默认数据库连接修改默认数据库连接可以通过修改主目录文件夹下的 settings.py 文件中的 DATABASES 参数。此处以 MySQL 为例，代码如下： DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': '数据库名', 'HOST': '127.0.0.1', 'PORT': '3306', 'USER': '', 'PASSWORD': '', } } 如果是低版本的 pymysql 连接数据库则还需要再主目录文件夹下的 __init__.py 文件夹中输入如下代码： import pymysql pymysql.install_as_MySQLdb() 数据表操作Django 支持在应用的 models.py 中进行数据表的增删改操作，示例代码如下： # models.py from django.db import models # 此处User在数据库中的表名为user.user，因为该models在user应用下，其中类名会自动小写。 class User(models.Model): username = models.CharField(max_length=45, unique=True) password = models.CharField(max_length=45) # 此处department在数据库中的字段名为department_id，Django会自动增加_id为尾缀 department = models.ForeignKey(\"Department\") class Department(models.Model): name = models.CharField(max_length=32) 字段参考 字段名 作用 models.AutoField int 类型=int(11)。如果类中没有 models.AutoField，则默认会创建一个字段名为 id 的自增列，且默认标注为主键。 models.CharField 字符串类型=varchar。必须有 max_length 参数。 models.BooleanField boolean 类型=tinyint(1)。不能为空，Blank=True。 models.ComaSeparatedIntegerField 用逗号分割的数字=varchar。继承CharField，所以必须 max_length 参数。 models.DateField 日期类型=date。对于参数，auto_now=True 则每次更新都会更新这个时间；auto_now_add=True 则只是第一次创建时添加，之后的更新不再改变。 models.DateTimeField 日期类型=datetime。同 DateField 的参数。 models.Decimal 十进制小数类型=decimal。必须指定整数位 max_digits 和小数位 decimal_places。 models.EmailField 字符串类型（正则表达式邮箱）=varchar。对字符串进行邮箱正则表达式验证。 models.FloatField 浮点类型=double。 models.IntegerField 整型=int。 models.BigIntegerField 长整型=bigint。 models.IPAddressField 字符串类型（ip4 正则表达式） models.GenericIPAddressField 字符串类型（ip4 或 ip6 正则表达式）。参数 protocol 可以是：both、ipv4 或 ipv6 models.NullBooleanField 允许为空的布尔类型。 models.PositiveIntegerFile 正 integer。 models.PositiveSmallIntegerField 正 smallInteger。 models.SlugField 减号、下划线、字母和数字。 models.SmallIntegerField 整型，对应数据库中的 tinyint、smallint、int、bigint。 models.TextField 字符串类型=longtext。 models.TimeField 时间。HH:MM[:ss[.uuuuuu]]。 models.URLField 字符串类型（正则表达式地址）。 models.BinaryField 二进制=binary。 models.ImageField 图片。存储图片名，常与 upload_to 参数连用，设置图片路径。 models.FilePathField 文件。存储文件名常与 upload_to 参数连用，设置文件路径。 models.ForeignKey(其他表类名) 多对一，参数 on_delete 必须。例如动物和狗，则在狗中添加 ForeignKey。 models.OneToOneField(其他表类名) 一对一，参数 on_delete 必须。例如主表和从表，则在从表中添加 OneToOneField。 models.ManyToManyField(其他表类名) 多对多。 参数参考 参数（默认值） 作用 null=True 数据库中字段是否可以为空，True 可以。 blank=True django 的 admin 中添加数据时是否可允许空值，True 可以。 primary_key=False 主键，对 AutoField 设置主键后会代替原来的自增 id 列 ，True 作为主键列。 auto_now 自动创建，无论添加或修改都是会修改成当前操作的时间。 auto_now_add 自动创建，时间永远是创建时的时间。 choices 常用于下拉菜单。例如使用M可以获得Male：class Person(models.Model): GENDER_CHOICES = ( (‘M’, ‘Male’), (‘F’, ‘Female’), ) models.CharField(max_length=2, choices=GENDER_CHOICES)Person(gender=”M”) max_length 最大长度。 default 该字段默认值。 verbose_name admin 中字段的显示名称。 name db_column unique=True 是否允许重复，True 不允许。 db_index=True 是否允许数据库索引，True 允许。 editable=True 在 admin 里是否可编辑。 error_messages=None 错误信息提示，True 允许。 auto_created=False 自动创建，True 允许。 help_text 在 admin 中提示帮助信息。 upload_to 常用于设置文件、图片的上传路径。 on_delete 有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值。CASCADE：级联删除，常用。PROTECT：报完整性错误。SET_NULL：把外键设置为 null，前提是允许为 null。SET_DEFAULT：为外键设置默认值。SET()：此调用其他值，可以是一个函数。 数据行操作进行数据库行操作时，首先需要导入该模块的 models。例如导入 user 模块的 models，代码如下： from user import models 增加 自动提交（传对应参数） models.User.objects.create(username='root', password='123456') 自动提交（传字典，字典中 key 与数据库字段名一一对应） user_info = {\"username\": \"root\", \"password\": \"123456\"} models.User.objects.create(**user_info) 手动提交 obj = models.objects(username='root', password='123456') obj.save() 删除models.User.objects.filter(username='root').delete() 修改 自动提交 models.User.objects.filter(username='root').update(password='654321') 手动提交 obj = models.User.objects.get(username='root') obj.password = '654321' obj.save() 查询 根据条件查找单个 # 查找 username 为 root 的用户 models.User.objects.get(username=\"root\") 查找所有 models.User.objects.all() 查找所有，但只取 values 参数中选定的列 # 只取 username 列 models.User.objects.all().values('username') 查找所有，但只取 values_list 参数中选定的列，并返回一个 list（默认 tuple）。 models.User.objects.all().values_list('username', 'password') 获取所查表行数。 # 查 user 表一共有多少条数据 models.User.objects.count() 根据条件查找。 # 查找 id = 1 的 models.User.objects.filter(id=1) # 查找 id > 1 的 models.User.objects.filter(id__gt=1) # 查找 id &lt; 1 的 models.User.objects.filter(id__lt=1) 自定义 SQL 语句操作获取 django.db.connection 后，直接通过 pymysql 进行操作。 from django.db import connection cursor = connection.cursor() # 增加(插入一条数据成功返回主键，失败返回0) def create_one(): sql = \"insert语句\" result = 0 try: cursor.execute(sql) # 获取插入的数据 id result = connection.insert_id() connection.commit() except Exception as ex: print(\"插入异常：\", ex) connection.rollback() return result # 增加(插入多条数据成功返回更新条数，失败返回0) def create_many(): sql = \"insert语句\" info_list = [(\"root\", \"123\"), (\"admin\", \"321\")] result = 0 try: result = cursor.executemany(createmany_sql, info_list) connection.commit() except Exception as ex: print(\"插入异常：\", ex) connection.rollback() return result # 更新一条数据，返回影响条数 def update(): sql = \"update|delete语句\" result = 0 try: cursor.execute(sql) result = cursor.rowcount connection.commit() except Exception as ex: print(\"更新异常：\", ex) connection.rollback() return result # 查询数据，返回查询的数据，失败返回None def get(): sql = \"selete语句\" result = None try: cursor.execute(sql) # 查询单条用fetchone，查询多条用fetchall result = cursor.fetchone() except Exception as ex: print(\"查找异常：\", ex) return result 事务from django.db import transaction with transaction.atomic(): 数据库操作语句 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"django","slug":"django","permalink":"https://blog.kuukokawaii.com/tags/django/"}]},{"title":"Django（一）：简介","date":"2019-12-21T08:43:22.000Z","path":"posts/1e026f1b/","text":"MTV 框架模式Django 是一个遵循 MVC 设计模式的框架，采用了 MTV 的框架模式（T 即 Template），其中控制器接受用户输入的部分由框架自行处理，因此 Django 更关注模板部分。 项目搭建Django 所需命令可以通过django-admin help查看所拥有的命令，使用django-admin help 命令名字可以查看该命令如何使用。 Django 目录结构 templates：存放视图文件。 static：存放静态文件。 django_temp：存放项目相关文件。 settings.py：项目相关配置。 urls.py：路由配置。 user：存放应用模块相关文件。 admin.py：后台管理相关配置。 dao.py：数据库操作相关。 models.py：自定义类，并根据类创建数据库表。 tests.py：单元测试。 views.py：业务处理。 配置静态文件夹在 settings 中配置静态文件夹，代码如下： STATIC_URL = '/static/' STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'), ] 配置模板文件夹在 settings 中配置模板文件夹，修改DIRS中的templates即可修改模板文件夹位置。代码如下： TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 创建一个应用首先通过命令python manage.py startapp 名字创建应用。其次在 settings 中添加新增的应用即可。例如新创建的应用名为user，代码如下： INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'user', ] 配置路由 在 urls.py 中的urlpatterns新增路由即可。path 中第一个参数为 URI 映射位置，后一个参数为需要映射到的服务位置（方法），代码如下： urlpatterns = [ path('admin/', admin.site.urls), path('login/', user_controller.login), path('register/', user_controller.register), ] URL 也可以动态匹配，常用于 Restful 设计风格。函数只需多加变量，即可获得该匹配的 URI 地址，代码如下： urlpatterns = [ # 匹配0和任意整数 path('user/&lt;int:uid>/', user_controller.update), # 匹配除了'/'以外的非空字符串 path('user/&lt;str:username>/', user_controller.update), # 匹配任意由 ASCII 字母或数字以及连字符和下划线组成的短标签 path('user/&lt;slug:username>/', user_controller.update), ] def update(uid): return HttpResponse(uid) 项目主文件夹的 urls.py 还可以通过 include() 函数包含其他子文件夹的路由映射。例如在主文件中包含 user 文件夹下的 urls.py，此时所有 user 文件夹下的路径都会加上user/的前缀： # main.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('user/', include(\"user.urls\")), ] # user文件夹下的 urls.py from django.urls import path from user.views import login, register, index, temp urlpatterns = [ path('login/', login), path('register/', register), path('index/', index), path('temp/&lt;str:slug>/', temp), ] path 可以取别名，此时在前端页面可以通过花括号内% url 名字 [参数] %的形式调用。当目录过深时，会使用别名取代长路径，代码如下： urlpatterns = [ path('temp/&lt;str:slug>/', temp), ] &lt;form action=\"{% url 名字 参数%}\" method=\"POST\"> 花括号内输入% csrf_token % &lt;/form>411 初始化 Django 数据库 Django 拥有自带的数据库，但此处使用 Mysql 数据库为例（需要安装 mysqlclient），在应用的models.py中通过表创建数据库。此处建立一个 User 表，代码如下： from django.db import models class User(models.Model): username = models.CharField(max_length=45, unique=True) password = models.CharField(max_length=45) 通过命令行输入python manage.py makemigrations保存修改在本地。 输入python manage.py migrate提交本地修改至数据库，即可完成建表操作。 注意事项Django CSRF 提交问题Django 中设置防跨站请求伪造功能，当用 POST 提交数据的时候，Django 会去检查是否有一个 CSRF 的随机字符串，如果没有则会报错（Forbidden 403）。 在表单中通过 POST 方法提交出现问题，则需要再表单中输入花括号内包含% csrf_token %即可完成完成操作。代码如下： &lt;form action=\"\" method=\"POST\"> 花括号内输入% csrf_token % &lt;/form> 通过 AJAX 提交 POST 请求，需要在 data 中添加csrfmiddlewaretoken数据即可完成提交。代码如下： $.ajax({ url: \"/\", type: \"POST\", data: { csrfmiddlewaretoken: \"{{ csrf_token }}\" }, success: function (data) { }, error: function (error) { } }); 支持 PUT 和 DELETE支持 PUT 和 DELETE 请求，修改 ajaxSetup 函数即可。代码如下： function csrfSafeMethod(method) { return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method)); } $.ajaxSetup({ beforeSend: function (xhr, settings) { if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) { xhr.setRequestHeader(\"X-CSRFToken\", \"{{ csrf_token }}\"); } } }); 后台获取 DELETE 和 PUT 请求携带的参数代码如下： from django.http import QueryDict QueryDict(request.body).get(\"参数名\") session 存储对象session 存储对象需要对对象进行序列化。Django 中用 session 序列化对象需要在 settings.py 中添加如下代码： SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer' document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"django","slug":"django","permalink":"https://blog.kuukokawaii.com/tags/django/"}]},{"title":"Python：邮件发布","date":"2019-12-17T00:55:21.000Z","path":"posts/1530706b/","text":"发送模板import smtplib from email.mime.text import MIMEText smtp_obj = None # QQ邮箱host host = \"smtp.qq.com\" # QQ邮箱port port = 465 password = \"\" # 邮件内容 content = \"内容\" # MIMIE邮件体 message = MIMEText(content) # 邮件标题 message[\"Subject\"] = \"标题\" message[\"From\"] = \"1398524980@qq.com\" message[\"To\"] = \"1134177664@qq.com\" try: # 基于SSL安全协议和发送邮件 smtp_obj = smtplib.SMTP_SSL(host, port) # 邮件发送人验证 smtp_obj.login(message[\"From\"], password) smtp_obj.sendmail(message[\"From\"], message[\"To\"], message.as_string()) except Exception as e: print(\"发送失败\", e) finally: smtp_obj.close() print(\"发送成功\") document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"python","slug":"python","permalink":"https://blog.kuukokawaii.com/tags/python/"}]},{"title":"SpringBoot（十四）：监控管理","date":"2019-12-06T07:30:31.000Z","path":"posts/81ac1c26/","text":"监控管理SpringBoot 通过引入 actuator 依赖，可以获得应用监控和管理功能。可以通过 HTTP、JMX 和 SSH 协议来进行操作，自动得到审计、健康及指标信息等。监控和管理端点信息如下： 端点名 描述 autoconfig 所有自动配置信息 auditevents 审计事件 beans 所有 Bean 的信息 configprops 所有配置属性(application.yml中的配置) dump 线程状态信息 env 当前环境信息（服务器设置，系统环境变量等） health 应用健康信息 info 当前应用信息（内存大小，剩余用量等） metrics 应用的各项指标 mappings 应用@RequestMapping映射路径 shutdown 关闭当前应用（默认关闭） trace 追踪信息（获取最新的 HTTP 请求） SpringBoot 整合监控管理 引入 actuator 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId> &lt;/dependency> 通过 HTTP 方式访问监控端点，如http://localhost:8080/actuator/获取可访问地址列表。 定制端点信息 定制端点一般通过 endpoints + 原端点名 + 属性名来设置。 修改端点 ID，如endpoints.beans.id=myBean。 开启远程应用关闭功能，如endpoints.shutdown.enabled=true。 关闭端点，如endpoints.beans.enabled=false。 关闭所有端点访问：endpoints.enabled=false。 开启所需端点：endpoints.beans.enabled=true。（如关闭所有端点访问，该开启端点可以进行访问。） 定制端点访问路径，如management.context-path=/manage。 关闭 HTTP 端点，如management.port=-1；也可以修改端口，如management.port=8181。 自定义 healthIndicator实现 healthIndicator 接口，指示器名必须为xxxHealthIndicator。代码如下： /** * @Author 喵粮都输光了 * @Date 2019/12/6 16:31 * @Description 自定义状态监测 */ @Component public class CustomHealthIndicator implements HealthIndicator { @Override public Health health() { /* * 自定义检查方法： * Health.up().build() 表健康。 * Health.down().withDetail(\"message\", \"服务异常\").build() 表关闭，附带关闭信息。 */ return Health.down().withDetail(\"message\", \"服务异常\").build(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十三）：热部署","date":"2019-12-06T06:19:11.000Z","path":"posts/64a44bcd/","text":"热部署在开发中修改一个 Java 文件后想要看到效果不得不重启应用，这将导致花费大量的时间，因此希望在不重启应用的情况下，程序可以自动部署（热部署）。 热部署方式模板引擎 在 Spring Boot 中开发情况下禁用模板引擎的 cache。 页面模板改变时重新编译当前页面生效。 Spring LoadedSpring 官方提供的热部署程序，实现修改类文件的热部署。 下载 Spring Loaded。 添加运行时参数：-javaagent:[热部署程序jar包所在位置] -noverify。 JRebelJRebel 是收费的一个热部署软件，在idea 或 eclipse 安装相应插件即可使用。 Spring Boot Devtools 引入依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;optional>true&lt;/optional> &lt;/dependency> 修改编辑器的运行应用程序更新策略（此处以 IDEA 为例）。 update resources：更新资源（如果引入了依赖则为热部署更新）。 update classes and resources：更新类文件和资源（如果引入了依赖则为热部署更新）。 hot swap classes and uodate trigger file if failed：热部署更新类和目标文件，当热部署更新失败时重启应用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十二）：分布式","date":"2019-12-04T14:29:05.000Z","path":"posts/e0109747/","text":"应用架构单一应用架构当网站流量很小时，只需一个应用将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架（ORM）是关键。 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web 框架（MVC）是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。在分布式系统中，国内常用 Dubbo + Zookeeper 组合，而 SpringBoot 推荐使用全栈的 Spring、SpringBoot + SpringCloud。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等现象逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键。 Zookeeper 和 DubboZookeeperZookeeper 是一个分布式的，开放源码的分布式应用程序协调服务（即注册中心）。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步和组服务等。 DubboDubbo 是 Alibaba 开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象处服务提供方（Provider）和服务消费方（Consumer）两个角色。 Container 在启动时负责加载运行 Provider。 Provider 在运行时将所拥有的服务信息注册至 Registry。 Consumer 在启动时会从 Registry 订阅所需服务，Registry 将 Consumer 所需服务的地址列表返回给 Registry。当 Provider 的服务信息有变更时，Registry 会基于长连接的方式将更新推送给 Consumer。 Consumer 需要调用服务时，可以根据负载均衡机制找到服务提供者位置并调用服务，如调用失败则可从服务地址列表中查找该服务的其他提供者调用服务直至调用成功为止。 Monitor 用于监控调用信息。 SpringBoot 整合 Dubbo、Zookeeper 父类 MAVEN 项目 springboot_dubbo，仅用于控制模块的依赖版本。pom 文件如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>springboot_dubbo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;artifactId>provider-ticket&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>provider-ticket&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-dependencies-zookeeper&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 项目模块 provider-ticket，用于继承父类依赖实现出票功能。 pom 文件继承父类 Dubbo 和 zookeeper 依赖版本。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>springboot_dubbo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;artifactId>provider-ticket&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>provider-ticket&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-dependencies-zookeeper&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置注册中心相关信息以及服务提供者所在位置，并通过@Service注解暴露服务。 application.yml配置包扫描+@Service配置方式（注意此处导入的一定要是import org.apache.dubbo.config.annotation.Service）。 dubbo: application: name: provider-ticket registry: address: zookeeper://localhost:21810 scan: base-packages: com.kuukokawaii.ticket.service import org.apache.dubbo.config.annotation.Service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 10:42 * @Description 出票 service 实现 */ @Service public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"取到票了！！\"; } } @DubboComponentScan或@EnableDubbo注解+@Service的配置方式。@DubboComponentScan和@EnableDubbo注解二选一标注于主程序类上，接口实现类仍需@Service注解（注意导入 dubbo 的注解），而application.yml中则无需配置包扫描。 /** * @Author 喵粮都输光了 * @Date 2019/12/6 10:47 * @Description 主程序 */ @SpringBootApplication //@DubboComponentScan(\"com.kuukokawaii.ticket.service\") @EnableDubbo(scanBasePackages = \"com.kuukokawaii.ticket.service\") public class ProviderTicketApplication { public static void main(String[] args) { SpringApplication.run(ProviderTicketApplication.class, args); } } import org.apache.dubbo.config.annotation.Service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 10:42 * @Description 出票 service 实现 */ @Service public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"取到票了！！\"; } } 项目模块 consumer-user，用于继承父类依赖调用 provider-ticket 模块的出票功能。 pom 文件继承父类 Dubbo 和 zookeeper 依赖版本。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>springboot_dubbo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;artifactId>consumer-user&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>consumer-user&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-dependencies-zookeeper&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置注册中心地址（与 provider-ticket 模块同）。 dubbo: application: name: consumer-user registry: address: zookeeper://localhost:21810 consumer-user 模块通过@Reference注解远程引用 provider-ticket 模块的服务则需要先编写服务接口，必须是与 provider-ticket 模块服务接口相同的全限定名。例如此处的com.kuukokawaii.ticket.service.TicketService;（不需要实现类）。 package com.kuukokawaii.ticket.service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 11:21 * @Description 远程调用出票服务 */ public interface TicketService { /** * 出票服务 * * @return 出票String */ String getTicket(); } 通过 dubbo 的@Reference注解远程引用服务，注意此处导入的@Service注解为org.springframework.stereotype.Service。 import org.apache.dubbo.config.annotation.Reference; import org.springframework.stereotype.Service; /** * @Author 喵粮都输光了 * @Date 2019/12/6 11:22 * @Description 用户 service */ @Service public class UserService { @Reference private TicketService ticketService; public void hello() { System.out.println(ticketService.getTicket()); } } Spring Cloud Spring Cloud 是一个分布式的整体解决方案。Spring Cloud 为开发者提供了在分布式系统中快速构建的工具，使用 Spring Cloud 的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 Spring Cloud 分布式开发五大常用组件： Netflix Eureka：服务发现。 Netflix Ribbon：客户端负载均衡。 Netflix Hystrix：断路器。 Netflix Zuul：服务网关。 Spring Cloud Config：分布式配置。 Spring Cloud 对配置管理、服务发现、熔断、路由、微代理、控制总线、一次性 token、全局锁、leader 选举、分布式 session 和集群管理等问题都提供了相应的解决方案。 Spring Cloud 注册中心Spring Cloud 使用 eureka server 作为注册中心。 引入 Spring Cloud eureka server 依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>eureka-server&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>eureka-server&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.RELEASE&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置 eureka server 信息 server: port: 8761 eureka: instance: hostname: eureka-server client: # 是否注册到 eureka 服务器，此处没必要自己注册自己到服务器 register-with-eureka: false # 不从 eureka 上获取服务的注册信息 fetch-registry: false # 设置注册中心地址 service-url: defaultZone: http://localhost:${server.port}/eureka/ 通过@EnableEurekaServer注解标注主程序启用 eureka server。 /** * @Author 喵粮都输光了 * @Date 2019/12/6 12:39 * @Description 注册中心主程序 */ @EnableEurekaServer @SpringBootApplication public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } provider 服务提供者 引入 Spring Cloud Eureka Discovery Client 依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>provider-ticket&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>provider-ticket&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.RELEASE&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置 eureka client provider 信息 server: port: 8001 spring: application: name: provider-ticket eureka: instance: # 注册服务时使用服务的IP地址作为前缀 prefer-ip-address: true client: service-url: # 必须要和 eureka server 相同 defaultZone: http://localhost:8761/eureka/ eureka 提供服务 /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:12 * @Description 出票 service */ public interface TicketService { /** * 出票功能 * @return 出票String */ String getTicket(); } /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:08 * @Description 出票 service 实现 */ @Service public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"出票了！！\"; } } /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:10 * @Description 出票 controller */ @RestController public class TicketController { @Resource private TicketServiceImpl ticketService; @GetMapping(\"/ticket\") public String getTicket() { return ticketService.getTicket(); } } consumer 服务使用者 引入 Spring Cloud Eureka Discovery Client 依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>consumer-user&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>consumer-user&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.RELEASE&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 配置 eureka client consumer 信息 server: port: 8002 spring: application: name: consumer-user eureka: instance: # 注册服务时使用服务的IP地址作为前缀 prefer-ip-address: true client: service-url: # 必须要和 eureka server 相同 defaultZone: http://localhost:8761/eureka/ 通过@EnableDiscoveryClient注解开启发现服务功能 /** * @Author 喵粮都输光了 * @Date 2019/12/6 12:43 * @Description consumer 主程序 */ @EnableDiscoveryClient @SpringBootApplication public class ConsumerUserApplication { public static void main(String[] args) { SpringApplication.run(ConsumerUserApplication.class, args); } /** * \"@LoadBalanced\"启用负载均衡机制。 * \"RestTemplate\"是Spring提供的用于访问Rest服务的客户端，提供了多种便捷访问远程Http服务的方法。 * 此处用于远程引用provider的服务。 * @return Rest服务客户端对象 */ @LoadBalanced @Bean public RestTemplate restTemplate() { return new RestTemplate(); } } consumer 调用 provider 服务 /** * @Author 喵粮都输光了 * @Date 2019/12/6 13:53 * @Description 用户 controller */ @RestController public class UserController { @Resource private RestTemplate restTemplate; @GetMapping(\"/buy\") public String buyTicket() { // getForObject根据URL获取服务（此处填写需要获取的provider名和服务名），第二个参数为返回类型。 return restTemplate.getForObject(\"http://PROVIDER-TICKET/ticket\", String.class); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十一）：安全","date":"2019-12-04T09:54:41.000Z","path":"posts/f4c26338/","text":"安全机制安全机制主要包含认证（注册主体）和授权（访问权限控制）两个区域的控制。 认证：是建立一个声明主体的过程（主体通常指用户、设备或一些可以在应用程序中执行动作的其他系统）。 授权：确定一个主体是否允许在应用程序中执行一个动作的过程(授权前主体的身份必须通过了认证过程的建立)。 Spring SecuritySpring Security 是针对 Spring 项目的安全框架，也是 Spring Boot 底层安全模块默认的技术选型。对于安全控制，只需引入 Security 模块并进行少量的配置即可实现安全管理。Spring Security 通过WebSecurityConfigurerAdapter和AuthenticationManagerBuilder两个类提供自定义 Security 策略和认证策略功能。 引入 Security 依赖。 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-security&lt;/artifactId> &lt;/dependency> 编写 SpringSecurity 配置类，需要通过@EnableWebSecurity注解开启 SpringSecurity 支持。 /** * @Author 喵粮都输光了 * @Date 2019/12/4 19:22 * @Description Security 配置类 */ @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Resource private DataSource dataSource; @Override protected void configure(HttpSecurity http) throws Exception { /* * 自定义授权规则： * 1.放行静态资源。 * 2.管理员页面需要管理员身份。 * 3.来宾页面需要来宾身份。 * 4.开启自动配置的登陆功能，如未登陆将自动跳转`/login`登陆界面，登陆失败将跳转至`/login?error`页面; * `successForwardUrl`自定义登陆成功跳转页面，`failureForwardUrl`自定义登陆失败跳转页面； * 默认'POST'请求'/login'表示进行登陆验证，'GET'请求'/login'表示跳转登陆页面； * `loginPage`自定义登陆界面，此时该页面的`GET`和`POST`分别成为了登陆验证和跳转登陆页面功能， * 可以通过`loginProcessingUrl`设置成默认的登陆验证； * `usernameParameter`可以自定义账号参数名，`passwordParameter`可以自定义密码参数名。 * 5.开启自动配置的注销功能，访问`/logout`表示用户注销，清空session，如果注销成功跳转至`/login?logout`页面； * `logoutSuccessUrl`设置注销成功跳转页面。 * 6.开启记住我功能，即自动帮忙登陆（该功能会保存cookie，注销会删除该cookie）， * 通过`rememberMeParameter()`可以自定义HTML中`checkbox`表单的`name`实现该功能。 */ http.authorizeRequests() .antMatchers(\"/css/**\", \"/\").permitAll() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"guest/**\").hasRole(\"GUEST\") .and() .formLogin() .and() .logout().logoutSuccessUrl(\"/\") .and() .rememberMe(); } /* @Bean @Override protected UserDetailsService userDetailsService() { // 使用默认的加密方式 bcrypt，PasswordEncoderFactories.createDelegatingPasswordEncoder()中实现了 10 种加密方式。 PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder(); UserDetails root = User.withUsername(\"root\") .password(passwordEncoder.encode(\"root\")).roles(\"GUEST\", \"ADMIN\").build(); UserDetails guest = User.withUsername(\"guest\") .password(passwordEncoder.encode(\"guest\")).roles(\"GUEST\").build(); // 用户信息存储于内存中 return new InMemoryUserDetailsManager(root, guest); }*/ @Bean @Override protected UserDetailsService userDetailsService() { // 使用自定义的加密方式 Map&lt;String, PasswordEncoder> encoders = new HashMap&lt;>(); encoders.put(\"MD5\", new org.springframework.security.crypto.password.MessageDigestPasswordEncoder(\"MD5\")); PasswordEncoder passwordEncoder = new DelegatingPasswordEncoder(\"MD5\", encoders); // 项目启动时默认创建两个用户 UserDetails root = User.withUsername(\"root\") .password(passwordEncoder.encode(\"root\")).roles(\"GUEST\", \"ADMIN\").build(); UserDetails guest = User.withUsername(\"guest\") .password(passwordEncoder.encode(\"guest\")).roles(\"GUEST\").build(); JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager(dataSource); jdbcUserDetailsManager.createUser(root); jdbcUserDetailsManager.createUser(guest); // 用户信息持久化 return jdbcUserDetailsManager; } } 在 HTML 界面显示授权信息，需要先整合 thymeleaf 和 security，即引入相关依赖即可。 &lt;!-- spring security 和 thymeleaf 整合--> &lt;dependency> &lt;groupId>org.thymeleaf.extras&lt;/groupId> &lt;artifactId>thymeleaf-extras-springsecurity5&lt;/artifactId> &lt;/dependency> &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/extras/spring-security\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>首页&lt;/title> &lt;link rel=\"stylesheet\" th:href=\"@{/css/bootstrap.min.css}\"> &lt;/head> &lt;body> &lt;!-- 是否认证，如果认证成功了则不显示登陆超链接 --> &lt;div sec:authorize=\"!isAuthenticated()\"> &lt;a href=\"/login\">登陆页面&lt;/a> &lt;/div> &lt;!-- 是否认证，如果认证成功了则显示注销超链接和认证信息 --> &lt;div sec:authorize=\"isAuthenticated()\"> &lt;h2>账号：&lt;span sec:authentication=\"name\">&lt;/span>&lt;/h2> &lt;h2>所有身份信息：&lt;span sec:authentication=\"principal.authorities\">&lt;/span>&lt;/h2> &lt;a href=\"/logout\">注销&lt;/a> &lt;/div> &lt;!-- 是否拥有管理员权限，有则显示管理员信息超链接 --> &lt;div sec:authorize=\"hasRole('ADMIN')\"> &lt;a href=\"/admin/info\">管理员信息&lt;/a> &lt;/div> &lt;!-- 是否拥有来宾权限，有则显示来宾信息超链接 --> &lt;div sec:authorize=\"hasRole('GUEST')\"> &lt;a href=\"/guest/info\">来宾信息&lt;/a> &lt;/div> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（十）：任务","date":"2019-12-04T06:16:25.000Z","path":"posts/454051ae/","text":"异步任务spring 提供了异步任务的功能。 在主程序类上开启异步注解支持@EnableAsync。 @EnableAsync @SpringBootApplication public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } 在方法上使用异步注解@Async。 /** * @Author 喵粮都输光了 * @Date 2019/12/4 14:20 * @Description 异步任务 service */ @Service public class AsyncService { @Async public void hello() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"处理数据中...\"); } } 定时任务Spring 通过TaskExecutor和TaskScheduler接口提供了异步执行任务调度的方式。 在主程序类上开启定时任务注解支持@EnableScheduling。 @EnableScheduling @SpringBootApplication public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } 在方法上使用异步注解@Scheduled。 /** * @Author 喵粮都输光了 * @Date 2019/12/4 14:52 * @Description 定时任务 service */ public class ScheduledService { @Scheduled(cron = \"0 * * * * MON-FRI\") public void hello() { System.out.println(\"hello\"); } } cron 表达式cron表达式一共有六个字段，分别为秒，分，时，日，月和周几，每个字段之间通过空格来间隔。 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 时 0-23 , - * / 日 1-31 , - * ? / L W C 月 1-12 , - * / 星期 0-7 或 SUN-SAT(0和7都是周日) , - * ? / L C # 特殊字符 含义 , 枚举，例如0,1,2代表这几个值都会被匹配。 - 区间，例如0-2代表0,1,2这几个值都会被匹配。 * 任意，所有允许值都会被匹配。 / 步长，例如0-2，在秒字段代表从0开始每2秒就会被匹配。 ? 日和星期冲突时，在日或者星期上标?表示按照另一个未标?的时间来匹配。 L 最后，具体看标识字段。例如0 0 2 ? * 6L表每个月最后一个周六，0 0 2 LW * ?表每个月最后一个工作日。 W 工作日，匹配工作日，只能标识在日上。 C 和 calendar 联系后计算过的值 # 第几个星期，如4#2表示第二个星期四，只能标识在星期上。 邮件任务SpringBoot 使用了jakarta-mail作为默认的邮件模块，通过引入相应的 starter 并配置些许配置即可使用邮件功能。 引入 mail 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-mail&lt;/artifactId> &lt;/dependency> application.yml中配置 mail 相关配置 spring: mail: username: 账号 password: 授权码 host: smtp.qq.com # 如果不加 port 则无需配置 properties。（此处为使用 SSL 加密方式发送邮件） port: 465 properties: mail: smtp: ssl: enable: true 简单邮件发送 @Resource private JavaMailSender javaMailSender; @Test public void send() { SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setSubject(\"邮件标题\"); simpleMailMessage.setText(\"邮件内容\"); simpleMailMessage.setTo(\"目标邮箱\"); simpleMailMessage.setFrom(\"发送邮箱\"); javaMailSender.send(simpleMailMessage); } 复杂邮件发送 @Resource private JavaMailSender javaMailSender; @Test public void send() throws MessagingException { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); // 第二个参数为是否要上传文件编码。 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); mimeMessageHelper.setSubject(\"邮件标题\"); // 第二个参数为是否开启 html 支持。 mimeMessageHelper.setText(\"&lt;b style='color: red'>邮件内容&lt;/b>\", true); mimeMessageHelper.setTo(\"目标邮箱\"); mimeMessageHelper.setFrom(\"发送邮箱\"); // 上传附件 mimeMessageHelper.addAttachment(\"1.jpg\", new File(\"附件地址\")); mimeMessageHelper.addAttachment(\"2.jpg\", new File(\"附件地址\")); javaMailSender.send(mimeMessage); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（九）：检索","date":"2019-12-02T15:02:04.000Z","path":"posts/8146c289/","text":"ElasticSearch ElasticSearch 是一个开源的分布式搜索服务，且提供 Restful API，底层基于 Lucene，采用多 shard（分片）的方式保证数据安全，并且提供自动 Resharding 的功能。SpringBoot 通过整合 Spring Data ElasticSearch 提供了便捷的检索功能支持。 ElasticSearch 概念 它是面向文档的，意味着它存储整个对象或文档，并索引每个文档的内容使之可以被检索。 将 JSON 作为文档的序列化格式。 将存储数据至 ElasticSearch 的行为称之为索引。一个 ElasticSearch 集群可以包含多个索引，每个索引可以包含多个类型，每个类型可以包含多个文档，而每个文档又可以有多个属性（例如雇员文档，一个文档代表一个雇员）。索引文档前需要确定文档存储位置。 在 ElasticSearch 中通过PUT、DELETE、PUT和HEAD请求来对文档进行增删改查（增加修改都用PUT）。 ElasticSearch 采用 Restful 风格请求处理数据（例如GET /index/type/id）。 ElasticSearch 相关文档查看ElasticSearch 官方权威指南。 SpringBoot 整合 ElasticSearchSpringBoot 默认支持两种技术来和 ElasticSearch 交互：Jest（需要引入依赖） 和 SpringData Elasticsearch（默认使用）。 Jest 引入 Jest 依赖 &lt;dependency> &lt;groupId>io.searchbox&lt;/groupId> &lt;artifactId>jest&lt;/artifactId> &lt;/dependency> 存储和查询数据 /** * @Author 喵粮都输光了 * @Date 2019/12/4 12:49 * @Description 文章 entity（JestId标识主键） */ @Data public class Article { @JestId private Integer id; private String title; private String author; private String content; } @Resource private JestClient jestClient; @Test void index() { Article article = new Article(); article.setId(1); article.setTitle(\"新闻标题\"); article.setAuthor(\"张三\"); article.setContent(\"新闻内容！！！！\"); // 构建一个索引功能。索引构建器，索引位置，类型，[.id()文档id]，构建 Index index = new Index.Builder(article).index(\"article\").type(\"news\").build(); try { // 执行存储操作（出现读取时间超时，在application.yml中设置读取时间） jestClient.execute(index); } catch (IOException e) { e.printStackTrace(); } } @Test void search() { String json = \"{\\n\" + \" \\\"query\\\": {\\n\" + \" \\\"match\\\": {\\n\" + \" \\\"content\\\": \\\"内容\\\"\\n\" + \" }\\n\" + \" }\\n\" + \"}\"; // 构建一个检索功能。检索构建器，索引位置，类型，[.id()文档id]，构建 Search search = new Search.Builder(json).addIndex(\"article\").addType(\"news\").build(); try { SearchResult searchResult = jestClient.execute(search); System.out.println(searchResult.getJsonString()); } catch (IOException e) { e.printStackTrace(); } } SpringData Elasticsearch 引入 SpringData Elasticsearch 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-elasticsearch&lt;/artifactId> &lt;/dependency> 通过 ElasticsearchRepository 调用 Elasticsearch /** * @Author 喵粮都输光了 * @Date 2019/12/4 12:32 * @Description 书本 entity */ @Data @Document(indexName = \"kuukokawaii\", type = \"book\") public class Book { private Integer id; private String bookName; private String author; } @Resource private BookRepository bookRepository; @Test void index() { Book book = new Book(); book.setId(1); book.setBookName(\"书本名\"); book.setAuthor(\"书本作者\"); bookRepository.index(book); } @Test void search() { for (Book book : bookRepository.findBooksByBookNameLike(\"书\")) { System.out.println(book); } } 通过 ElasticsearchTemplate 调用 Elasticsearch /** * @Author 喵粮都输光了 * @Date 2019/12/4 12:32 * @Description 书本 entity */ @Data @Document(indexName = \"kuukokawaii\", type = \"book\") public class Book { private Integer id; private String bookName; private String author; } @Resource private ElasticsearchRestTemplate elasticsearchRestTemplate; @Test void index() { Book book = new Book(); book.setId(1); book.setBookName(\"书本名\"); book.setAuthor(\"书本作者\"); // 构建索引构建器 IndexQuery indexQuery = new IndexQueryBuilder().withObject(book).build(); // 存储数据 elasticsearchRestTemplate.index(indexQuery); } @Test void search() { // 查询语句 MatchQueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(\"bookName\", \"书本\"); // 根据查询语句构建查询构建器 SearchQuery searchQuery = new NativeSearchQueryBuilder().withQuery(matchQueryBuilder).build(); // 进行查询，查询构建器，查询的类 for (Book book : elasticsearchRestTemplate.queryForList(searchQuery, Book.class)) { System.out.println(book); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://blog.kuukokawaii.com/tags/elasticsearch/"}]},{"title":"SpringBoot（八）：消息队列","date":"2019-12-01T02:51:55.000Z","path":"posts/2b1dfb69/","text":"消息队列大多应用中可通过消息服务中间件来提升系统异步通信、扩展解耦能力。在消息服务中有消息代理和目的地两个重要的概念，即当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。在消息队列中主要拥有两种形式的目的地，分别为队列和主题，前者用于点对点消息通信，后者用于发布/订阅消息通信。 JMS 和 AMQP 比对 JMS AMQP 定义 Java api 网络线级协议 跨语言 否 是 跨平台 否 是 Model 提供两种消息模型：1.Peer-2-Peer2.Pub/Sub 提供五种消息模型：1.direct exchange2.fanout exchange3.topic exchange4.headers exchange5.system exchange本质来讲，后四种和 JMS 的 Pub/Sub 模型没有太大差别，仅是在路由机制上做了更详细的划分。 支持消息类型 多种消息类型：1.TextMessage2.MapMessage3.BytesMessage4.StreamMessage5.ObjectMessage6.Message（只有消息头和属性） byte[]当实际应用时，有复杂的消息，可以将消息序列化后发送。 综合评价 JMS 定义了 JAVA API 层面的标准。在 JAVA 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。 AMQP 定义了 wire-level 层的协议标准，天然具有跨平台、跨语言特性。 SpringBoot 中的消息队列 spring-jms 提供了对 JMS 的支持。 spring-rabbit 提供了对 AMQP 的支持。 需要ConnectionFactory的实现来连接消息代理。 提供JmsTemplate和RabbitTemplate来发送消息。 将@JmsListener（JMS）和@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息。 @EnableJms和@EnableRabbit开启注解支持。 RabbitMQ 简介RabbitMQ 是一个由 erlang 开发的 AMQP（Advanced Message Queue Protocol） 的开源实现。 核心概念 组件 作用 Message 消息由消息头和消息体组成。其中消息体是不透明的，消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键，决定消息目的地）、priority（相对于其他消息的优先权）和delivery-mode（标明该消息是否需要持久性存储）等。 Publisher 消息的生产者，用于向交换器发布消息，即向消息代理发送消息。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列（根据路由键选择队列）。 Queue 消息队列，用来保存消息直到发送给消费者，一个消息可投入一个或多个队列。 Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列l连接起来的又有规则，Exchange 和 Queue 的绑定可以是多对多的关系。 Connection 网络连接，比如一个 TCP 连接。 Channel 信道是建立在真实的 TCP 连接内的虚拟连接，AMQP 的命令都是通过信道发送出去。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。（类似线程与进程） Consumer 消息的消费者，用于从消息队列中获取消息。 Virtual Host 虚拟主机（简称 vhost），是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个缩小版的 RabbitMQ 服务器，消息代理中可以有多个 vhost 。在连接时，必须指定具体的 vhost，RabbitMQ 默认的 vhost 是 / Broker 消息代理，表示消息队列服务器的实体 Exchange 类型 direct：当消息中的路由键和 Binding 中的 binding key 一致时，交换器就将消息发到对应的队列中。 fanout：交换器会将消息发送到所有与自己绑定的队列上，速度是交换器中最快的（类似广播）。 topic：交换器通过模式匹配分配消息的路由键属性，将路由器和某一个模式进行匹配，此时队列需要绑定到一个模式上。通过识别两个通配符#和*对路由键和绑定键的字符串进行切分，其中前者匹配0个或多个单词，后者匹配一个单词。 header：header 匹配 AMQP 消息的 header 而不是路由键，与 direct 交换器类似但性能差许多，通常不用。 整合 RabbitMQ 引入 RabbitMQ 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-amqp&lt;/artifactId> &lt;/dependency> application.yml中配置 RabbitMQ 相关配置 spring: rabbitmq: username: 账号 password: 密码 virtual-host: \"/\" RabbitTemplate 用于发送和接收消息 @Resource private RabbitTemplate rabbitTemplate; @Test void sendMessage() { // 自动序列化发送消息（使用send方法不会自动序列化） rabbitTemplate.convertAndSend(\"study.direct\", \"study.news\", \"消息体可以是对象\"); } @Test void receiveMessage() { // 自动反序列化转化接收的消息 Object message = rabbitTemplate.receiveAndConvert(\"study.news\"); System.out.println(message); } 配置消息转换器序列化方式 /** * @Author 喵粮都输光了 * @Date 2019/12/2 22:04 * @Description AMQP 配置 */ @Configuration public class AmqpConfig { @Bean public MessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); } } @EnableRabbit+@RabbitListener注解用于监听消息队列 /** * @Author 喵粮都输光了 * @Date 2019/11/21 22:07 * @Description SpringBoot应用主程序 */ @EnableRabbit @SpringBootApplication public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } /** * @Author 喵粮都输光了 * @Date 2019/12/2 22:14 * @Description 书 service */ @Service public class BookService { @RabbitListener(queues = \"study.news\") public void receive(Book book) { System.out.println(\"收到的消息：\" + book); } @RabbitListener(queues = \"study\") public void receive1(Message message) { // 获取消息体 System.out.println(Arrays.toString(message.getBody())); // 获取消息头 System.out.println(message.getMessageProperties()); } } AmqpAdmin 系统管理功能组件，用于创建删除 exchange，queue 和 binding。 @Resource private AmqpAdmin amqpAdmin; @Test void createExchange() { // 创建 exchange amqpAdmin.declareExchange(new DirectExchange(\"study.direct\")); // 创建 queue，是否开启持久化 amqpAdmin.declareQueue(new Queue(\"study.queue\", true)); // 创建 binding （绑定目的地名[此处队列名]，绑定目的地类型[此处队列]，交换名，路由键，参数） amqpAdmin.declareBinding(new Binding(\"study.queue\", Binding.DestinationType.QUEUE, \"study.direct\", \"study\", null)); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（七）：缓存","date":"2019-11-30T04:06:19.000Z","path":"posts/676006d6/","text":"JSR-107Java Caching 定义了5个核心接口，分别为： CachingProvider：定义了创建、配置、获取、管理和控制多个 CacheManager。一个应用可以在运行期间访问多个 CachingProvider。 CacheManager：定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cache 存在于 CacheManager 的上下文中。且一个 CacheManager 仅被一个 CachingProvider 所拥有。 Cache：类似 Map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 所拥有。 Entry： 存储在 Cache 中的 Key-Value 对。 Expiry： 每一个存储在 Cache 中的条目有一个定义的有效期。一旦超过这个时间，Entry 就变为了过期状态。一旦过期，Entry 将不可访问、更新和删除。缓存有效期可以通过 ExpiryPolicy设置。 JSR-107 只需引入如下依赖即可使用： &lt;dependency> &lt;groupId>javax.cache&lt;/groupId> &lt;artifactId>cache-api&lt;/artifactId> &lt;/dependency> Spring 缓存抽象为了简化开发，Spring 定义了 Cache 和 CacheManager 接口来统一不同的缓存技术，同时 Spring 也支持使用 JCache（JSR-107）注解简化开发。 Spring 缓存注解 注解及参数 作用 参数 @Cacheable 根据方法的请求参数对其结果进行缓存，常用于创建。 1.cacheNames/value：指定缓存组件名（可以多个）。2.key：缓存数据使用的 Key（默认使用方法参数的值，可以使用 SpEL 表达式）。3.keyGenerator：Key 的生成器，可以指定 Key 生成器的组件 id（与key二选一）。4.cacheManager：指定缓存管理器。5.cacheResolver：指定获取解析器（与cacheManager二选一）。6.condition：指定符合条件的情况下才缓存。unless：指定符合条件的情况下不进行缓存，并且可以获取缓存结果进行判断。7.sync：是否使用异步模式，此时不支持unless参数。 @CachePut 保证方法一定会被调用且结果会被缓存，常用于更新，如果指定 key 被更新则需要同时更新 key。 @CacheEvict 清空缓存，常用于删除，需要指定删除的 key。 1.key：如未指定则会使用默认策略生成的 key。2.allEntries：是否删除指定 cache 中的所有数据。3.beforeInvocation：缓存的清除是否在方法之前执行（默认 false）。 @EnableCaching 开启基于注解的缓存。 @Caching 是@Cacheable、@CachePut和@CacheEvict的组合注解。 @CacheConfig 抽取缓存的公共配置，标注于类上，类中的缓存注解会默认使用公共配置的参数。 keyGenerator 缓存数据时 Key 的生成策略。 serialize 缓存数据时 Value 序列化策略。 @Cacheable可用 SpEL 表达式 名字 位置 作用 示例 methodName root object 当前被调用的方法名。 #root.methodName method root object 当前被调用的方法。 #root.method.name target root object 当前被调用的目标对象。 #root.target targetClass root object 当前被调用的目标对象类。 #root.targetClass args root object 当前被调用的方法的参数列表。 #root.args[0] caches root object 当前方法调用的缓存列表（如@Cacheable(cacheNames={\"cache1\",\"cache2\"})）。 #root.caches[0].name argument name evaluation context 方法参数的名字，可以直接#参数名，也可以使用#p0或#a0的形式，其中0代表参数的的索引。 #iban、#a0、#p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效）。 #result 缓存使用注意事项 缓存注解不能定义在接口上。 加缓存注解的方法必须为公有（public）的。 @Cahcheable必须指定至少一个cacheNames。 注解使用示例 @Cacheable @Override @Cacheable(cacheNames = \"employee\") public Employee getEmployee(Integer id) { return employeeMapper.getEmployeeById(id); } @CachePut @Override @CachePut(cacheNames = \"employee\", key = \"#result.id\") public Employee updateEmployee(@RequestBody Employee employee) { return employeeMapper.updateEmployee(employee); } @CacheEvict @Override @CacheEvict(cacheNames = \"employee\", key = \"#id\") public int removeEmployee(Integer id) { return employeeMapper.removeEmployeeById(id); } @Caching @Override @Caching( cacheable = { @Cacheable(cacheNames = \"employee\", key = \"#lastName\") }, put = { @CachePut(cacheNames = \"employee\", key = \"#result.id\"), @CachePut(cacheNames = \"employee\", key = \"#result.email\") } ) public Employee getEmployee(String lastName) { return employeeMapper.getEmployeeByLastName(lastName); } @CacheConfig @Service @CacheConfig(cacheNames = \"employee\") public class EmployeeServiceImpl implements EmployeeService { @Resource private EmployeeMapper employeeMapper; @Override @Cacheable public Employee getEmployee(Integer id) { return employeeMapper.getEmployeeById(id); } } 整合 RedisRedis 是一个开源的，内存中的数据结构存储系统，可以用作数据库、缓存和消息中间件。 引入 Redis 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId> &lt;/dependency> application.yml中配置 Redis 相关配置 spring: redis: host: xxx.xxx.xxx.xxx 使用RedisTemplate或StringRedisTemplate操作 Redis RedisTemplate用于操作 K-V 都是字符串的数据。 StringRedisTemplate用于操作 K-V 都是对象的数据。 Redis 常见的五大数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）和ZSet（有序集合）。分别通过五类方法操作：opsForValue()、opsForList()、opsForSet()、opsForHash()和opsForZSet()。 Redis 命令查询 配置RedisCacheManager，并修改 Key 和 Value 的保存格式。之后便可使用 Spring 缓存抽象操作 Redis。 @Configuration public class RedisConfig { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { // Key 使用 StringRedisSerializer 的方式保存 RedisSerializer&lt;String> redisSerializer = new StringRedisSerializer(); // Value 使用 Jackson2JsonRedisSerializer 的方式保存 Jackson2JsonRedisSerializer&lt;Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;>(Object.class); // 解决查询缓存反序列化出错问题 ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); // entryTtl(Duration.ofHours(1))设置生存周期 RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofHours(1)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)).disableCachingNullValues(); return RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(redisCacheConfiguration).build(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（六）：数据访问","date":"2019-11-27T05:15:47.000Z","path":"posts/fd098bd4/","text":"SpringDataSpringData 主要用于简化数据库的访问，开发者只需声明持久层接口即可。SpringData 支持 NoSQL 和关系数据库存储。 JDBC 引入 JDBC 依赖。 &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> application.yml 配置数据源。 spring: datasource: username: 账号 password: 密码 url: jdbc:mysql://localhost:3306/表名?serverTimezone=UTC driver-class-name: 数据库驱动 # 表初始化，默认加载schema.sql（冒号后无空格，不使用请注释） schema: - classpath:sql/department.sql # 数据初始化，默认加载data.sql（冒号后无空格，不使用请注释） data: - classpath:sql/department_data.sql # 初始化模式（不使用请注释） initialization-mode: always # department.sql DROP TABLE IF EXISTS department; CREATE TABLE department( id INT PRIMARY KEY NOT NULL, departmentName varchar(45) NOT NULL ); # department_data.sql INSERT INTO department (id, departmentName) SELECT '1', 'AA' FROM dual WHERE NOT EXISTS(SELECT id from department WHERE id = '1'); 使用 JdbcTemplate 进行查询。 /** * @Author 喵粮都输光了 * @Date 2019/11/27 14:50 * @Description 查询 controller */ @Controller public class QueryController { private final JdbcTemplate jdbcTemplate; @Autowired public QueryController(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @GetMapping(\"/query\") @ResponseBody public Map&lt;String, Object> map() { List&lt;Map&lt;String, Object>> list = jdbcTemplate.queryForList(\"SELECT id, departmentName FROM department\"); return list.get(0); } } 配置 druid 连接池。（在spring.datasource下配置） druid: # 初始化大小，最小，最大 initial-size: 5 min-idle: 10 max-active: 20 # 配置获取连接等待超时的时间 max-wait: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 min-evictable-idle-time-millis: 300000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 time-between-eviction-runs-millis: 600000 validation-query: SELECT 1 test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙。（stat,wall,log4j） filters: stat,wall # 通过connection-properties属性来打开mergeSql功能；慢SQL记录 connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 use-global-data-source-stat: true # 配置DruidStatFilter web-stat-filter: enabled: true url-pattern: \"/*\" exclusions: \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\" # 配置DruidStatViewServlet stat-view-servlet: enabled: true url-pattern: \"/druid/*\" # IP白名单(没有配置或者为空，则允许所有访问) allow: 127.0.0.1 # IP黑名单 (存在共同时，deny优先于allow) deny: # 禁用HTML页面上的“Reset All”功能 reset-enable: false # 登录名 login-username: root # 登录密码 login-password: root MyBatis 引入 Mybatis 依赖。 &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>2.1.0&lt;/version> &lt;/dependency> 注解的方式进行 dao 操作。（可以去掉@Mapper注解，应用入口程序处添加@MapperScan注解批量扫描包。） /** * @Author 喵粮都输光了 * @Date 2019/11/27 19:00 * @Description 部门 dao */ @Mapper public interface DepartmentDao { /** * 根据部门id查询部门对象 * * @param id 部门id * @return 部门对象 */ @Select(\"SELECT id, departmentName FROM department WHERE id = #{id}\") Department getDepartmentById(Integer id); /** * 根据部门id删除部门 * * @param id 部门id * @return 更新条数 */ @Delete(\"DELETE FROM department WHERE id = #{id}\") int removeDepartmentById(Integer id); /** * 根据部门对象增加部门。（useGeneratedKeys 注解让自增的主键会重新封装入 Department 对象中。） * * @param department 部门对象 * @return 更新条数 */ @Insert(\"INSERT INTO department (departmentName) value (#{departmentName})\") @Options(useGeneratedKeys = true, keyProperty = \"id\", keyColumn = \"id\") int createDepartment(Department department); /** * 根据id更新部门信息 * * @param department 部门对象 * @return 更新条数 */ @Update(\"UPDATE department set departmentName = #{department} WHERE id = #{id}\") int updateDepartment(Department department); } 配置文件的方式进行 dao 操作。再配置注解扫描的基础上配置 xml 文件所在位置，即通过在application.yml中配置 xml 文件的位置，例如mybatis.mapper-locations: com/kuukokawaii/springbootstudy/**/dao/**.xml，即可实现配置文件的方式进行 dao 操作。 mybatis: # 下划线转驼峰命名 configuration: map-underscore-to-camel-case: true # xml 配置文件路径 mapper-locations: com/kuukokawaii/springbootstudy/**/dao/**.xml /** * @Author 喵粮都输光了 * @Date 2019/11/29 14:34 * @Description 员工 dao */ @Mapper public interface EmployeeMapper { /** * 根据 id 查找对应的员工信息。 * @param id 员工id * @return 员工对象 */ Employee getEmployeeById(int id); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.kuukokawaii.springbootstudy.employee.dao.EmployeeMapper\"> &lt;resultMap id=\"BaseResultMap\" type=\"com.kuukokawaii.springbootstudy.employee.entity.Employee\"> &lt;!--@mbg.generated--> &lt;!--@Table employee--> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"last_name\" jdbcType=\"VARCHAR\" property=\"lastName\"/> &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\"/> &lt;result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\"/> &lt;result column=\"d_id\" jdbcType=\"INTEGER\" property=\"dId\"/> &lt;/resultMap> &lt;sql id=\"Base_Column_List\"> &lt;!--@mbg.generated--> id, last_name, email, gender, d_id &lt;/sql> &lt;select id=\"getEmployeeById\" resultMap=\"BaseResultMap\"> select &lt;include refid=\"Base_Column_List\"/> from employee where id = #{id,jdbcType=INTEGER} &lt;/select> &lt;/mapper> Spring Data JPA 基本功能 JpaRepository 基本功能。 Spring Data JPA 具有统一的 Repository 接口，通过继承该接口可以实现 CRUD 和分页等操作。 定义符合规范的方法命名。 在接口中只需要声明符合规范的方法，即拥有对应的功能。 通过@Query自定义查询，定制查询 SQL。 支持动态查询（Specifications 查询）。 引入 JPA 依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId> &lt;/dependency> 使用 JPA 根据 entity 自动建表，在application.yml中加入如下配置。 spring: jpa: hibernate: # 根据 entity 更新或者创建数据表结构 ddl-auto: update # 控制台显示 SQL show-sql: true 新建 entity。 @Entity用于标注该类是实体类。 @Table可以标明该表的表名和所属 schema。 @Id用于标注该属性是主键。 @GeneratedValue包含strategy和generator两个参数。前者包含AUTO、IDENTITY、SEQUENCE和Table四个属性，其作用分别为主键由程序控制（默认值）、主键由数据库生成采用数据库的自增形式（Oracle 不支持）、主键通过数据库的序列生成（Mysql 不支持）和提供特定的数据库产生主键方式（利于数据库移植）；后者用于声明主键生成器的名称。 @Column用于标注数据库列名及该列属性。 /** * @Author 喵粮都输光了 * @Date 2019/11/29 15:53 * @Description 用户 entity */ @Entity @Data @Table(name = \"user\", schema = \"springboot_study\") @JsonIgnoreProperties(value = { \"hibernateLazyInitializer\"}) public class User { /** * 用户id */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; /** * 用户名 */ @Column(name = \"last_name\", length = 45, nullable = false) private String lastName; /** * 用户邮箱 */ @Column(name = \"email\", length = 45, nullable = false) private String email; } 编写接口继承JpaRepository接口。接口上泛型分别写对应的实体类和该实体类的主键。 /** * @Author 喵粮都输光了 * @Date 2019/11/29 16:09 * @Description 用户 repository */ public interface UserRepository extends JpaRepository&lt;User, Integer> {} JpaRepository接口的使用。如果 get 方法出现com.fasterxml.jackson.databind.exc.InvalidDefinitionException:错误，则需要在实体类上加@JsonIgnoreProperties(value={\"hibernateLazyInitializer\"})的注解，防止jsonplugin操作hibernateLazyInitializer属性。 /** * @Author 喵粮都输光了 * @Date 2019/11/29 16:38 * @Description 用户 controller */ @RestController public class UserController { private final UserRepository userRepository; @Autowired public UserController(UserRepository userRepository) { this.userRepository = userRepository; } @GetMapping(\"/user/{id}\") public User getUser(@PathVariable(\"id\") int id) { return userRepository.getOne(id); } @PostMapping(\"/user\") public User createUser(@RequestBody User user) { return userRepository.save(user); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（五）：Docker","date":"2019-11-27T01:45:29.000Z","path":"posts/3096723d/","text":"什么是 DockerDocker 是基于 Go 语言并遵从 Apache 协议开源的一个开源的应用容器引擎，支持将软件编译成一个镜像并设置镜像中各软件的配置，获得镜像的其他使用者可以直接使用镜像。Docker 容器是完全使用沙箱机制的，相互之间不会有任何接口，更重要的是容器性能开销极低。 Docker 核心概念Docker 主机从仓库下载所需镜像并通过 daemon 运行镜像产生容器之后，Docker 客户端就可以连接主机进行操作。 Docker 镜像（Images）：Docker 镜像是用于创建 Docker 容器的模板。 Docker 容器（Container）：容器是独立运行的一个或一组应用。 Docker 客户端（Client）：客户端通过命令行或者其他工具使用 Docker。 Docker 主机（Host）：一个物理或虚拟的机器用于执行 Docker 守护进程和容器。 Docker 仓库（Registry）：Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub提供了庞大的镜像集合供使用。 Docker 常用操作镜像操作| 操作 | 命令 | 说明 | | --- | ---- | ---- | | 检索 | docker search 关键字 | 常用于检索镜像的详细信息，或镜像版本。 | | 拉取 | docker pull 镜像名:tag | `:tag`是可选的，tag 表示标签，多为软件的版本，默认是 latest。 | | 列表 | docker images | 查看所有本地镜像。 | | 删除 | docker rmi image-id | 删除指定的本地镜像。 |容器操作| 操作 | 命令 | 说明 | | --- | ---- | ---- | | 运行 | docker run --name container-name &lt;br&gt; -d image-name | `--name`：自定义容器名; &lt;br&gt;`-d`：后台运行; &lt;br&gt;`image-name`：指定镜像模板（推荐加上版本号）。 | | 列表 | docker ps | 查看运行中容器，加上`-a`可以查看所有容器。 | | 停止 | docker stop container-name/container-id | 停止指定的运行中容器。 | | 启动 | docker start container-name/container-id | 启动指定的容器。 | | 删除 | docker rm container-id | 删除指定容器。 | | 端口映射 | 输入运行容器命令时添加`-p`命令 &lt;br&gt;例：docker run -d -p 6379:6379 镜像名 | `-p`主机端口映射至容器内部的端口。 | | 容器日志 | docker logs container-name/container-id | 查看容器日志。 | document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"},{"name":"docker","slug":"docker","permalink":"https://blog.kuukokawaii.com/tags/docker/"}]},{"title":"SpringBoot（四）：WEB 开发","date":"2019-11-24T06:27:09.000Z","path":"posts/4fa653eb/","text":"静态资源映射规则SpringBoot 的静态资源与 SSM 框架整合的静态资源所在位置不同，SSM 框架静态资源存储于 webapp 的 static 中，而 SpringBoot 的静态资源存储于 resources 中。SpringBoot 默认有两种静态资源映射模式： webjars 模式 应用使用 MAVEN 导入 webjars 的静态资源依赖，则所有通过该方法导入的静态资源都存储于classpath:/META-INF/resources/webjars/中。需要访问时，只需要通过类似http://localhost:8080/webjars/所需资源名的方式即可完成调用。 自定义模式 通过查看 SpringBoot 源码中的WebMvcAutoConfiguration和ResourceProperties类的SERVLET_LOCATIONS和CLASSPATH_RESOURCE_LOCATIONS常量，可以得出静态资源的默认存储位置为classpath:/META-INF/resources/、classpath:/resources/、classpath:/static/、classpath:/public/和/。调用方式与 webjars 模式类似，例如静态文件存储于classpath:/static/，则调用方式如http://localhost:8080/所需资源名即可。 欢迎页静态资源文件夹下的所有index.html页面都会被映射为/，也就是说当你输入http://localhost:8080/时，就会自动跳转至index.html页面。 修改静态资源位置可以在application.yml中通过spring.resources.static-locations设置默认的静态资源位置，使用该条命令会使 SpringBoot 本身的默认静态资源位置失效，因此不推荐修改。 Thymeleaf 模板引擎 模板引擎用于将视图和数据进行整合解析，而不同的模板引擎之间的区别仅在于模板引擎获取数据的语法不同。 SpringBoot 推荐使用 Thymeleaf 模板引擎，因为其语法更简洁，功能共强大。通过 MAVEN 引入 Thymeleaf 模板引擎的依赖。（如需修改 thymeleaf 版本则需注意thymeleaf-layout-dialect.version） &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> Thymeleaf 将classpath:/templates/作为默认的视图存储位置，只需将 HTML 页面放入该文件夹中，Thymeleaf 就能自动渲染。 Thymeleaf 的使用&amp;语法： 导入 Thymeleaf 的命名空间。(不导入不会出错，但是 HTML 页面不会有 Thymeleaf 语法提示。) &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> 后端通过Model、ModelMap、ModelAndView或Map向前端传输数据。 @RequestMapping(\"/helloPage\") public String hello(ModelMap modelMap) { modelMap.addAttribute(\"hello\", \"helloValue\"); return \"hello\"; } 在对应的 HTML 中使用 Thymeleaf 语法。 &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;p th:text=\"${hello}\">&lt;/p> &lt;/body> &lt;/html> WebMvc 扩展与全面接管SpringBoot 在自动配置组件时，会先扫描容器中是否有用户自定义的配置，如果有则使用用户自定义的配置文件或将用户自定义的配置文件与默认的自动配置文件组合起来，没有则执行 SpringBoot 的自动配置。例如&lt;mvc:view-controller path=\"/hello\" view-name=\"hello\"/&gt;映射/hello至hello.html页面。而在 SpringBoot 中可以通过@Configuration注解 + 实现WebMvcConfigurer接口中addViewControllers方法的形式实现该功能，SpringBoot 不仅保留了所有的自动配置，而且还加载了自定义的扩展功能。 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/hello\").setViewName(\"hello\"); } } 当需要对 WebMvc 进行全面接管时（即使得 SpringBoot 不进行自动配置，而是按照自定义的配置加载），通过使用@EnableWebMvc注解即可实现该效果，此时 SpringBoot 自动配置将失效且仅保留 SpringMVC 最进本的效果。 错误处理机制SpringBoot 错误的默认处理机制是通过ErrorMvcAutoConfiguration为容器添加了DefaultErrorAttributes、BasicErrorController、ErrorPageCustomizer和DefaultErrorViewResolver组件。一旦应用出现错误，ErrorPageCustomizer就会向/error/控制器发起请求（类似web.xml注册错误页面的规则），此时会进入BasicErrorController控制器。该控制器根据请求头向用户发送错误 HTML 页面或 JSON 数据，最终通过DefaultErrorAttributes中的错误状态码响应至特定的页面。 定制错误 HTML 页面 在拥有模板引擎的情况下，将错误状态码.html放置在模板引擎文件夹下的 error 文件夹中，SpringBoot 就会自动进行错误页面的配置。也可以将错误页面命名为4xx.html或5xx.html等，表示匹配所有 4 开头或者 5 开头的错误状态码，当项目下同时拥有类似4xx.html和404.html时，则会按精确优先的方式响应至404.html的错误页面。 在没有模板引擎的情况下，SpringBoot 将会在静态资源文件夹下的 error 文件夹中寻找错误页面。 如上述两处都没有发现错误页面，将跳转至 SpringBoot 默认的错误提示页面。 使用模板引擎的错误页面可以通过语法获取页面的错误信息，如timestamp：时间戳、status：状态码、error：错误提示、exception：异常对象、message：异常消息和errors：JSR303 数据校验错误。（如获取不到exception，则需要在application.yml中将server.error.include-exception开启） 定制错误 JSON 数据 自定义异常处理数据，浏览器和客户端返回的都是 JSON 数据。 /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:42 * @Description 异常处理器 */ @ControllerAdvice public class CustomExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String, Object> handleException(Exception e) { Map&lt;String, Object> map = new HashMap&lt;>(2); map.put(\"code\", \"userNotExist\"); map.put(\"message\", e.getMessage()); return map; } } 将异常请求转发至/error页面，通过 SpringBoot 自行产生自适应 /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:42 * @Description 异常处理器 */ @ControllerAdvice public class CustomExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public String handleException(HttpServletRequest request, Exception e) { // 设置错误状态码 request.setAttribute(\"javax.servlet.error.status_code\", 500); return \"/error\"; } } 拥有自适应效果且能携带定制数据 /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:36 * @Description 自定义 ErrorAttributes */ @Component public class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map&lt;String, Object> errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace); errorAttributes.put(\"customError\", webRequest.getAttribute(\"customError\", 0)); return errorAttributes; } } /** * @Author 喵粮都输光了 * @Date 2019/11/26 16:42 * @Description 异常处理器 */ @ControllerAdvice public class CustomExceptionHandler { @ExceptionHandler(UserNotExistException.class) public String handleException(HttpServletRequest request, Exception e) { // 设置错误状态码 request.setAttribute(\"javax.servlet.error.status_code\", 500); Map&lt;String, Object> map = new HashMap&lt;>(2); map.put(\"code\", \"userNotExist\"); map.put(\"message\", e.getMessage()); request.setAttribute(\"customError\", map); return \"/error\"; } } SpringBoot 嵌入式 Servlet 容器 SpringBoot 默认使用 Tomcat 作为嵌入式的 Servlet 容器，需要对 Servlet 容器进行修改可以通过如下两种方式： 在application.yml中通过server.xxxx修改，如需修改 Tomcat 配置则通过server.tomcat.xxx进行修改。 编写一个嵌入式的 Servlet 容器定制器WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;来修改 Servlet 容器的配置。（优先级高于配置文件） @Bean public WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory> webServerFactoryCustomizer() { return new WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory>() { @Override public void customize(ConfigurableServletWebServerFactory factory) { factory.setPort(8081); } }; } SpringBoot 默认时以 Jar 包的方式启动嵌入式的 Servlet 容器来启动 Web 应用，没有 web.xml 文件，因此提供ServletRegistrationBean、FilterRegistrationBean和ServletListenerRegistrationBean三大组件用于注册 Servlet、Filter 和Listener。 ServletRegistrationBean /** * @Author 喵粮都输光了 * @Date 2019/11/26 17:17 * @Description 自定义 servlet */ public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().write(\"Hello Servlet！！！\"); } } @Bean public ServletRegistrationBean&lt;MyServlet> servletRegistrationBean() { return new ServletRegistrationBean&lt;>(new MyServlet(), \"/myServlet\"); } FilterRegistrationBean /** * @Author 喵粮都输光了 * @Date 2019/11/26 17:31 * @Description 自定义 filter */ public class MyFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"MyFilter process...\"); chain.doFilter(request, response); } } @Bean public FilterRegistrationBean&lt;MyFilter> filterFilterRegistrationBean() { FilterRegistrationBean&lt;MyFilter> filterFilterRegistrationBean = new FilterRegistrationBean&lt;>(); filterFilterRegistrationBean.setFilter(new MyFilter()); // 设置要拦截的请求 filterFilterRegistrationBean.setUrlPatterns(Arrays.asList(\"/hello\", \"/\")); return filterFilterRegistrationBean; } ServletListenerRegistrationBean /** * @Author 喵粮都输光了 * @Date 2019/11/26 17:40 * @Description 自定义 listener */ public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"web 应用启动\"); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\"web 应用销毁\"); } } @Bean public ServletListenerRegistrationBean&lt;MyListener> servletListenerRegistrationBean() { return new ServletListenerRegistrationBean&lt;>(new MyListener()); } 其他内嵌式的 Servlet 容器 Jetty 适用于长连接应用。 Undertow 高性能非阻塞，并发性能非常强，但不支持 JSP。 内嵌式的 Servlet 容器切换方法：只需将默认的 Tomcat 依赖排除，然后引入其他内嵌式 Servlet 容器依赖即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（三）：日志","date":"2019-11-23T02:39:48.000Z","path":"posts/1d79677f/","text":"日志框架市场上存在多种日志框架，日志接口有 JCL、SLF4j 和 jboss-logging，日志具体实现有 Log4j、Logback、JUL 和 Log4j2。其中 JUL 是 JAVA 官方日志；JCL 和 Log4j2 是 apache 开发的日志接口；SLF4j、Log4j 和 Logback 是由同一作者开发完成，所以适配性较好，当中的 Log4j 存在性能问题，其升级版为 Logback。 SLF4j SLF4j 是针对日志框架开发的一个统一接口层，因此只需实现 SLF4j 即可使用日志功能，这样分层的好处是更改日志接口的实现框架依赖便可完成日志框架的升级。 SpringBoot 的底层是 Spring 框架，而 Spring 框架默认是用 JCL 日志接口，但是 SpringBoot 默认排除了 JCL 依赖，使用 SLF4j 和 Logback 作为自己的日志框架。 SLF4j 针对按自己接口实现的日志框架只需导入日志实现框架依赖即可，而针对不是按自己接口的日志实现框架则需要额外导入一个适配依赖，才能完成日志功能。适配依赖的原理即实现 SLF4j 接口，实现方式就是包装对应的日志实现框架方法。 每个日志实现框架都有自己的配置文件，即使使用了 SLF4j，配置文件还是使用日志实现框架的配置文件。 统一日志框架SpringBoot 整合了许多框架，而每一个框架使用的可能都不是同一个日志框架，因此需要对这些框架的日志框架进行统一。将日志框架统一成 SLF4j 的步骤如下： 先排除系统中其他日志实现框架的依赖。 用中间包来替换排除的日志实现框架依赖，否则会报错。中间包的原理即覆写排除了的日志实现框架，将其所有方法的原有调用都转为调用 SLF4j 的方法，这样即可防止报错并实现功能。 之后导入 SLF4j 和日志实现框架依赖。（根据日志实现框架选择是否需要添加适配依赖） 日志默认配置全局常规设置SpringBoot 自配配置了默认的日志配置，可以在application.yml中修改部分配置。 修改日志输出文件位置在application.yml中可以通过logging.file和logging.path指定配置文件位置。（只能二选一，两个都写默认生效logging.file） logging.file在不指定路径时则在当前项目下生成 springboot.log 日志文件，指定路径时则按指定的完整路径存放日志文件。例如：logging.file: G:/springboot.log。 logging.path在指定路径下创建文件夹并使用 spring.log 作为默认日志文件。例如：logging.path: /spring/log则表示在项目所在磁盘的根目录下创建 spring 文件夹和其中的 log 文件夹并生成一个 spring.log 的日志文件。 自定义日志配置文件当要使用自定义日志配置文件而非 SpringBoot 的默认日志配置时，可以通过在类路径下放上相应的日志实现框架的配置文件即可。| 日志系统 | 自定义配置文件 || ——- | ————————————– || Logback | logback-spring.xml 或 logback.xml || Log4j2 | log4j2-spring.xml 或 log4j2.xml || JUL | logging.properties | 其中没有加spring尾缀的配置会跳过 SpringBoot 直接被日志实现框架识别；增加了尾缀的日志实现框架不直接加载日志配置，而是由 SpringBoot 解析日志配置，因此可以在日志的配置文件中使用 SpringBoot 的高级 Profile 功能。 &lt;springProfile name=\"dev\"> &lt;!-- 可以指定该日志配置只在 dev 应该环境下才被加载。修改 dev 可以修改为其它应用环境。 --> &lt;/springProfile> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（二）：配置文件","date":"2019-11-22T01:43:31.000Z","path":"posts/2250b4d3/","text":"YAMLSpringBoot 可以使用 YAML 进行全局配置。YAML 是以数据为中心的标记语言，比 JSON、XML 等更适合做配置文件。YAML 通过缩进表示层级关系，且支持三种数据结构：对象（键值对集合）、数组和字面量（单个、不可再分的值）。 字面量即数字、字符串和布尔值。通过k: v的方式书写，字符串默认不用加上引号。也可以使用单引号或双引号，其中单引号会转义特殊字符。字符串也可以写成多行，但从第二行开始必须有一个空格缩进，换行符会被转义为空格。 对象假设有一对象为 student，其中有 lastName 和 age 的属性，其 YAML 写法如下： student: lastName: xx age: 12 也可以采用行内写法：student: {lastName: xx, age: 12} 数组用连线词-来表示数组中的一个元素，一组-开头的行构成一个数组，其写法如下: pets: - cat - dog - pig 也可以采用行内写法：pets: [cat, dog, pig] 复合结构即字面量、对象和数组的复合使用。 将配置文件中的属性值映射至 bean/** * @Author 喵粮都输光了 * @Date 2019/11/22 10:50 * @Description dog entity */ @Data public class Dog { private String name; private Integer age; } person: lastName: LaoZhang age: 11 boss: false birth: 2019/5/5 map: key1: value1 key2: value2 list: - LaoWang - LaoLi dog: name: 小狗 age: 2 可以在 resources 下新建 META-INF 文件夹，并新建 additional-spring-configuration-metadata.json 输入如下代码为 yaml 添加 person。 { \"properties\": [ { \"name\": \"person.dog.name\", \"type\": \"java.lang.String\", \"description\": \"Description for person.dog.name.\" }, { \"name\": \"person.dog.age\", \"type\": \"java.lang.Integer\", \"description\": \"Description for person.dog.age.\" } ] } 使用@ConfigurationProperties注解，需要添加依赖spring-boot-configuration-processor。 /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component @ConfigurationProperties(\"person\") public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object> map; private List&lt;Object> list; private Dog dog; } 使用@Value()注解获取值，其中可以用SpEL表达式获取值，不支持复杂类型封装。 /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component public class Person { @Value(\"${person.lastName}\") private String lastName; @Value(\"#{11*2}\") private Integer age; @Value(\"false\") private Boolean boss; private Date birth; private Map&lt;String, Object> map; private List&lt;Object> list; private Dog dog; } @ConfigurationProperties支持 JSR303 数据校验。在类上添加注解@validated用于支持 JSR303，在需要接收的数据上加上需要校验格式的注解，例如@Email。 /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component @ConfigurationProperties(\"person\") @validated public class Person { @Email private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object> map; private List&lt;Object> list; private Dog dog; } 自定义配置文件加载@PropertySource通过组合@PropertySource和@ConfigurationProperties可以读取指定 properties 文件中的属性值并映射至 bean。 person.lastName=LaoZhang person.age=11 person.boss=false person.birth=2019/5/5 person.map.key1=value1 person.map.key2=value2 person.list=LaoWang, LaoLi person.dog.name=小狗 person.dog.age=2 /** * @Author 喵粮都输光了 * @Date 2019/11/22 10:45 * @Description Person entity */ @Data @Component @PropertySource(\"classpath:person.properties\") @ConfigurationProperties(\"person\") public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object> map; private List&lt;Object> list; private Dog dog; } @ImportResource该注解用于导入自定义的 Spring 的配置文件，将注解添加至 SpringBoot 应用主程序类上即可，可添加多个 Spring 配置文件。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"helloService\" class=\"com.kuukokawaii.springbootstudy.service.HelloService\"/> &lt;/beans> @SpringBootApplication @ImportResource(locations = {\"classpath:beans.xml\"}) public class SpringBootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringBootStudyApplication.class, args); } } @ConfigurationSpringBoot 推荐使用全注解的方式添加组件代替配置文件，只需要在类上加@Configuration的注解即可指明该类是配置类。 /** * @Author 喵粮都输光了 * @Date 2019/11/22 12:42 * @Description 应用注解配置 */ @Configuration public class MyApplicationConfig { /** * 将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名。相当于&lt;bean id=\"helloService\", clas==\"\">&lt;/bean> * @return 返回 HelloService 对象。 */ @Bean public HelloService helloService() { System.out.println(1); return new HelloService(); } } 配置文件占位符配置文件中可以使用随机数和占位符，且占位符可设置默认值。例如：person.dog.name引用了person.lastName的值，而person.dog.age引用了hello.age的值，因没有定义hello.age的值，会使用默认值10，最终person.dog.age的值为10。 person: lastName: LaoZhang${random.uuid} age: ${random.int} boss: false birth: 2019/5/5 map: key1: value1 key2: value2 list: - ${random.value} - LaoLi dog: name: ${person.lastName}的小狗 age: ${hello.age:10} 环境配置选择多文件形式SpringBoot 可以在application.yml/properties中通过spring.profiles.active = {profile}来选择应用环境，其中其他配置文件名应为application-{profile}.yml/properties的形式。例如此处应用的主配置应用端口号为 8080，dev 配置文件中应用端口号为 8081，在主配制中激活 dev 配置，则应用端口号变为 8081。 #application-dev.yml server: port: 8081 #application.yml server: port: 8080 spring: profiles: active: dev 多文档块形式（仅 YAML 支持）在application.yml中可以通过三横杠---的方式划分文档块，每一个文档块相当于一个自定义的配置文件，可以通过spring.profiles = {profile}定义文档块的名字，并使用spring.profiles.active = {profile}的形式激活选定的文档块。 server: port: 8080 spring: profiles: active: dev --- server: port: 8081 spring: profiles: dev --- server: port: 8082 spring: profiles: prod 激活 profile 通过配置文件指定，如上。 通过命令行参数指定，如在Program arguments中输入--spring.profiles.active=dev或java -jar xxx.jar --spring.profiles.active=dev 通过虚拟机参数指定，如在VM options中输入-Dspring.profiles.active=dev。 配置文件加载位置SpringBoot 会自定扫描如下位置的application.properties/yml文件作为默认配置文件。配置加载优先级高低从上至下，其中高优先级的配置会覆盖低优先级的内容。所有位置的文件都会被加载，当配置项相同时会按优先级进行覆盖，而配置项不同时则会全部加载，也就是所谓的配置互补。 file:./config/即项目根目录下的config文件夹。 file:./即项目根目录。 classpath:/config/即resources文件夹下的config文件夹。 classpath:/即resources文件夹。 SpringBoot 允许通过spring.config.location来改变默认的配置文件位置。如java -jar xxx.jar --spring.config.location=G:/application.yml。（只能在命令行运行 Jar 包时通过该参数改变默认的配置文件位置，会遵循优先级和互补原则） 外部配置文件加载顺序SpringBoot 也可以从以下位置加载配置（优先级从高到低），会遵循优先级和互补原则。 命令行参数。 来自java:comp/env的JNDI属性。 JAVA 系统属性。 操作系统环境变量。 RandomValuePropertySource 配置的random.*属性值。 JAR 包外部的application-{profile}.properties或application.yml（带Spring.profile）配置文件。 JAR 包内部的application-{profile}.properties或application.yml（带Spring.profile）配置文件。 JAR 包外部的application.properties或application.yml（带Spring.profile）配置文件。 JAR 包内部的application.properties或application.yml（带Spring.profile）配置文件。 @Configuration注解类上的@PropertySource。 通过 SpringApplication.setDefaultProperties 指定的默认属性。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SpringBoot（一）：简介","date":"2019-11-21T04:31:51.000Z","path":"posts/1bc2c8b5/","text":"服务架构 传统 WEB 应用服务架构是单体应用模式，即一个 WAR 包包含了项目所有功能，其所带来的优势是使得项目的开发，测试和部署极其方便。但是所带来的缺陷也是极其明显的，当某一功能进行修改时，项目需要重新进行部署。 微服务架构即一个应用便是一组小型服务的集合，并且各个服务之间可以通过 HTTP 协议进行互通。当使用微服务架构时，每一个功能元素最终都是一个可独立替换或独立升级的软件单元，而 SpringBoot 可以快速的开发每一个软件单元，之后可通过 SpringCloud 将所开发软件单元联系起来。 SpringBoot 优点 无需手动管理依赖 JAR 包的版本 无须配置XML，自动配置，简化开发且可修改默认值 使用嵌入式的 Servlet 容器，应用无需达成 WAR 包 外部化配置SpringBoot 可以使用 properties 文件，YAML文件，环境变量，命令行参数等来外部化配置。 无缝集成 Spring 技术栈SpringBoot 通过stater pom来导入这些依赖，且自动进行配置。 devtools提供的开发时特性SpringBoot 的 devtools 模块可以为应用增加开发时特性，例如开发环境属性默认值。 Actuator提供的生产特性Actuator 提供准生产环境的运行时应用监控。 天然集成云计算 SpringBoot 环境搭建 搭建完成的目录层级。 通过 IDEA 创建 MAVEN 项目。 配置 pom.xml 文件（可参考 SpringBoot 构建 RESTful 项目）。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>spring-boot&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;properties> &lt;!-- jdk版本 --> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;!-- 用于管理SpringBoot应用中所有的依赖版本 --> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;/parent> &lt;dependencies> &lt;!-- 导入WEB模块正常运行所依赖的组件 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;!-- 导入测试模块正常运行所依赖的组件 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- 导入JSON模块正常运行所依赖的组件 --> &lt;dependency> &lt;groupId>com.jayway.jsonpath&lt;/groupId> &lt;artifactId>json-path&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;!-- 将程序打包成可执行的JAR包 --> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 编写 SpringBoot 应用运行主程序。 /** * @Author 喵粮都输光了 * @Date 2019/11/21 20:32 * @Description SpringBoot主程序 */ @SpringBootApplication public class Main { public static void main(String[] args) { // 运行SpringBoot应用(SpringBootApplication会自动扫描该类所在包及其下所有子包内的组件添加入Spring容器) SpringApplication.run(Main.class, args); } } 编写简单 Controller 类向页面返回数据。 /** * @Author 喵粮都输光了 * @Date 2019/11/21 20:34 * @Description HelloController */ @Controller public class HelloController { @RequestMapping(\"/hello\") @ResponseBody public String hello() { return \"Hello world!\"; } } SpringBoot 应用快速构建此处以 IDEA 为例通过 Spring Initializr 快速构建 SpringBoot 项目。 通过 New -&gt; Project -&gt; Spring Initializr 单击下一步。 填写项目配置之后单击下一步。 勾选项目所需服务之后单击下一步后，IDEA 自动从 Spring 官网下载快速构建的项目。 SpringBoot 配置原理SpringBoot 将所有的功能场景抽取成为一个个 Starter，只需要在项目中引入这些 Starters，其相关环境的所有依赖都会导入进来。 @SpringBootApplication该注解应用于某一个 JAVA 类上是指该类是 SpringBoot 的主配置类，SpringBoot 将会运行该类的 main 方法来启动 SpringBoot 应用。 @SpringBootConfiguration该注解是@SpringBootApplication所包含的注解之一，标注在某一个 JAVA 类上是指该类是 SpringBoot 的配置类。该注解中包含 @Configuration 用于表明该类是一个配置类（即配置文件），通过@Component注解表明配置类是一个组件并能被 Spring 容器扫描到。 @EnableAutoConfiguration该注解是@SpringBootApplication所包含的注解之一，用于扫描组件并进行自动配置。该注解通过@AutoConfigurationPackage中的@Import(\"AutoConfigurationPackages.Registrar.class\")将@SpringBootApplication标注的类所在包及其下所有子包内的所有组件扫描入 Spring 容器中，最后通过@Import(EnableAutoConfigurationImportSelector.class)获取需要导入组件的选择器全限定类名添加入 Spring 容器中，并通过自动配置类（xxxAutoConfiguration）为组件自动配置。自动配置类文件包含在 spring-boot-autoconfiguration.jar 包下。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.kuukokawaii.com/tags/springboot/"}]},{"title":"SSM整合","date":"2019-11-20T02:54:59.000Z","path":"posts/12cc57d7/","text":"目录层级 web.xml 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!-- spring容器监听器 --> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:applicationContext.xml&lt;/param-value> &lt;/context-param> &lt;!-- 前端控制器 --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 加载springMVC配置文件 --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springMVC.xml&lt;/param-value> &lt;/init-param> &lt;!-- 服务器启动时初始化该servlet --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;!-- 编码过滤器 --> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;/web-app> spring 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 注解扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii\"> &lt;!-- 不扫描controller --> &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &lt;!-- aop --> &lt;aop:aspectj-autoproxy/> &lt;!-- 事务管理 --> &lt;tx:annotation-driven/> &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- mybatis start --> &lt;!-- 加载jdbc.properties --> &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/> &lt;!-- alibaba druid --> &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"> &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> &lt;property name=\"url\" value=\"${jdbc.url}\"/> &lt;property name=\"username\" value=\"${jdbc.username}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;!-- 配置初始化大小、最小、最大 --> &lt;property name=\"initialSize\" value=\"1\"/> &lt;property name=\"minIdle\" value=\"1\"/> &lt;property name=\"maxActive\" value=\"20\"/> &lt;!-- 配置获取连接等待超时的时间 --> &lt;property name=\"maxWait\" value=\"10000\"/> &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --> &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/> &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --> &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/> &lt;!-- 这里建议配置为TRUE，防止取到的连接不可用 --> &lt;property name=\"testWhileIdle\" value=\"true\"/> &lt;property name=\"testOnBorrow\" value=\"true\"/> &lt;property name=\"testOnReturn\" value=\"false\"/> &lt;!-- 这里配置提交方式，默认就是TRUE，可以不用配置 --> &lt;property name=\"defaultAutoCommit\" value=\"true\"/> &lt;!-- 验证连接有效与否的SQL，不同的数据配置不同 --> &lt;property name=\"validationQuery\" value=\"${validationQuery}\"/> &lt;property name=\"filters\" value=\"stat\"/> &lt;!-- 打开removeAbandoned功能 --> &lt;property name=\"removeAbandoned\" value=\"true\"/> &lt;!-- 1800s --> &lt;property name=\"removeAbandonedTimeout\" value=\"1800\"/> &lt;!-- 关闭abandoned链接时输出错误日志 --> &lt;property name=\"logAbandoned\" value=\"true\"/> &lt;/bean> &lt;!-- sqlSessionFactory --> &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;property name=\"mapperLocations\" value=\"classpath:com/kuukokawaii/**/**.xml\"/> &lt;/bean> &lt;!-- dao接口所在包 --> &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"> &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/> &lt;property name=\"basePackage\" value=\"com.kuukokawaii.**.dao\"/> &lt;/bean> &lt;!-- mybatis end --> &lt;/beans> jdbc.driverClassName=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC jdbc.username=账号 jdbc.password=密码 validationQuery=SELECT 1 springMVC 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 注解扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii\"> &lt;!-- 只扫描controller --> &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &lt;!-- 视图解析器 thymeleaf start --> &lt;bean id=\"templateResolver\" class=\"org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"/> &lt;property name=\"suffix\" value=\".html\"/> &lt;property name=\"templateMode\" value=\"HTML\"/> &lt;property name=\"characterEncoding\" value=\"UTF-8\"/> &lt;property name=\"cacheable\" value=\"false\"/> &lt;/bean> &lt;bean id=\"templateEngine\" class=\"org.thymeleaf.spring5.SpringTemplateEngine\"> &lt;property name=\"templateResolver\" ref=\"templateResolver\"/> &lt;/bean> &lt;bean class=\"org.thymeleaf.spring5.view.ThymeleafViewResolver\"> &lt;property name=\"templateEngine\" ref=\"templateEngine\"/> &lt;property name=\"characterEncoding\" value=\"UTF-8\"/> &lt;/bean> &lt;!-- 视图解析器 thymeleaf end --> &lt;!-- 过滤静态资源 --> &lt;mvc:resources mapping=\"/static/css/\" location=\"/static/css/**\"/> &lt;mvc:resources mapping=\"/static/js/\" location=\"/static/js/**\"/> &lt;mvc:resources mapping=\"/static/images/\" location=\"/static/images/**\"/> &lt;!-- FAST_JSON解析 --> &lt;mvc:annotation-driven> &lt;mvc:message-converters> &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"/> &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\"> &lt;property name=\"supportedMediaTypes\"> &lt;list> &lt;value>text/html;charset=UTF-8&lt;/value> &lt;value>application/json;charset=UTF-8&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;/mvc:message-converters> &lt;/mvc:annotation-driven> &lt;!-- 注解支持 --> &lt;mvc:annotation-driven/> &lt;/beans> log4j 配置文件###################################### # log4j配置相关说明 ###################################### #%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL #%r 输出自应用启动到输出该log信息耗费的毫秒数 #%c 输出所属的类目，通常就是所在类的全名 #%t 输出产生该日志事件的线程名 #%m 输出代码中指定的信息 #%n 输出一个回车换行符，Windows平台为“\\r\\n”，Unix平台为“\\n” #%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MM dd HH:mm:ss,SSS}，输出类似： 2002年10月18日 22：10：28，921 #%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) #log4j提供4种布局: #org.apache.log4j.HTMLLayout（以HTML表格形式布局） #org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， #org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， #org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息 #log4j中有五级logger 输出级别: #FATAL 0 #ERROR 3 #WARN 4 #INFO 6 #DEBUG 7 ###################################### # log4j相关配置 ###################################### #日志输出级别 log4j.rootLogger=INFO,stdout,other #设置stdout的日志输出控制台 log4j.appender.stdout=org.apache.log4j.ConsoleAppender #输出日志到控制台的方式，默认为System.out log4j.appender.stdout.Target=System.out #设置使用灵活布局 log4j.appender.stdout.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.stdout.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %m %n #设置other的日志输出控制台(RollingFileAppender)/每天生产一个日志文件(DailyRollingFileAppender) log4j.appender.other=org.apache.log4j.DailyRollingFileAppender #设置other的输出日志 log4j.appender.other.File=src/main/webapp/WEB-INF/logs/ssm.log #设置other的日志最大限制 log4j.appender.other.MaxFileSize=1024KB #最多只保存20个备份文件 log4j.appender.other.MaxBackupIndex=1000 #输出INFO级别以上的日志 log4j.appender.other.Threshold=INFO #设置使用灵活布局 log4j.appender.other.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.other.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %t %m %n ###显示SQL语句部分 log4j.logger.com.mybatis=DEBUG log4j.logger.com.mybatis.common.jdbc.SimpleDataSource=DEBUG log4j.logger.com.mybatis.common.jdbc.ScriptRunner=DEBUG log4j.logger.com.mybatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG JAVA 类controller/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:28 * @Description 账户Controller */ @Controller(\"accountController\") @RequestMapping(\"/account\") public class AccountController { private final AccountService accountService; @Autowired public AccountController(AccountService accountService) { this.accountService = accountService; } @RequestMapping(\"/findAll\") public String findAll(ModelMap modelMap) { modelMap.put(\"list\", accountService.findAllAccount()); return \"list\"; } } dao/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:21 * @Description 账户dao */ @Repository public interface AccountMapper { /** * 查找所有账户 * @return 账户集合 */ List&lt;Account> findAllAccount(); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.kuukokawaii.account.dao.AccountMapper\"> &lt;resultMap id=\"accountResultMap\" type=\"com.kuukokawaii.account.entity.Account\"> &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/> &lt;result column=\"name\" property=\"name\" jdbcType=\"VARCHAR\"/> &lt;result column=\"money\" property=\"money\" jdbcType=\"DOUBLE\"/> &lt;/resultMap> &lt;sql id=\"account_column_List\"> &lt;!--@sql SELECT --> account.id, account.name, account.money &lt;!--@sql FROM account --> &lt;/sql> &lt;select id=\"findAllAccount\" resultMap=\"accountResultMap\"> SELECT &lt;include refid=\"account_column_List\"/> FROM account &lt;/select> &lt;/mapper> entity/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:19 * @Description 账户实体 */ @Data public class Account implements Serializable { private int id; private String name; private double money; } service/** * @Author 喵粮都输光了 * @Date 2019/11/20 13:25 * @Description 账号Service */ public interface AccountService { /** * 查找所有账户 * @return 账户集合 */ List&lt;Account> findAllAccount(); } /** * @Author 喵粮都输光了 * @Date 2019/11/20 13:27 * @Description 账号Service实现 */ @Service(\"accountService\") public class AccountServiceImpl implements AccountService { private final AccountMapper accountMapper; @Autowired public AccountServiceImpl(AccountMapper accountMapper) { this.accountMapper = accountMapper; } @Override public List&lt;Account> findAllAccount() { return accountMapper.findAllAccount(); } } HTML 页面&lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>list&lt;/title> &lt;/head> &lt;body> &lt;!--/*@thymesVar id=\"list\" type=\"java.util.List\"*/--> &lt;div th:each=\"account : ${list}\"> &lt;p th:text=\"${account.id}\">&lt;/p> &lt;p th:text=\"${account.name}\">&lt;/p> &lt;p th:text=\"${account.money}\">&lt;/p> &lt;/div> &lt;/body> &lt;/html> pom.xml 配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.kuukokawaii&lt;/groupId> &lt;artifactId>ssm&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;packaging>war&lt;/packaging> &lt;name>ssm Maven Webapp&lt;/name> &lt;url>http://www.example.com&lt;/url> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;spring.version>5.1.9.RELEASE&lt;/spring.version> &lt;/properties> &lt;dependencies> &lt;!-- Spring --> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-beans&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-core&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.aspectj&lt;/groupId> &lt;artifactId>aspectjweaver&lt;/artifactId> &lt;version>1.9.4&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-aop&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-tx&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-test&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-jdbc&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;!-- SpringMVC --> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-web&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-webmvc&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;!-- Mybatis --> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis-spring&lt;/artifactId> &lt;version>2.0.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.17&lt;/version> &lt;/dependency> &lt;!-- thymeleaf --> &lt;dependency> &lt;groupId>org.thymeleaf&lt;/groupId> &lt;artifactId>thymeleaf&lt;/artifactId> &lt;version>3.0.11.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.thymeleaf&lt;/groupId> &lt;artifactId>thymeleaf-spring5&lt;/artifactId> &lt;version>3.0.11.RELEASE&lt;/version> &lt;/dependency> &lt;!-- alibaba --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.1.20&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>fastjson&lt;/artifactId> &lt;version>1.2.61&lt;/version> &lt;/dependency> &lt;!-- junit --> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.13-beta-3&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- lombok --> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;version>1.18.10&lt;/version> &lt;/dependency> &lt;!-- servlet --> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>javax.servlet-api&lt;/artifactId> &lt;version>4.0.1&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> &lt;!-- log --> &lt;dependency> &lt;groupId>log4j&lt;/groupId> &lt;artifactId>log4j&lt;/artifactId> &lt;version>1.2.17&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.slf4j&lt;/groupId> &lt;artifactId>slf4j-api&lt;/artifactId> &lt;version>2.0.0-alpha0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.slf4j&lt;/groupId> &lt;artifactId>slf4j-log4j12&lt;/artifactId> &lt;version>2.0.0-alpha0&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;finalName>ssm&lt;/finalName> &lt;!-- 编译java目录下的mapper文件 --> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>true&lt;/filtering> &lt;/resource> &lt;/resources> &lt;pluginManagement> &lt;plugins> &lt;plugin> &lt;artifactId>maven-clean-plugin&lt;/artifactId> &lt;version>3.1.0&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-resources-plugin&lt;/artifactId> &lt;version>3.0.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.8.0&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-surefire-plugin&lt;/artifactId> &lt;version>2.22.1&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-war-plugin&lt;/artifactId> &lt;version>3.2.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-install-plugin&lt;/artifactId> &lt;version>2.5.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-deploy-plugin&lt;/artifactId> &lt;version>2.8.2&lt;/version> &lt;/plugin> &lt;/plugins> &lt;/pluginManagement> &lt;/build> &lt;/project> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"},{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"Mybatis（六）：注解开发","date":"2019-10-14T05:26:13.000Z","path":"posts/13944/","text":"CRUD 注解写法在 Mybatis 中如果使用注解，那么在该 DAO 下就不能使用 XML 的方式进行开发。 select 的注解写法/** * 查询指定的user * * @param id 需要查询的user id * @return 返回查找到的user */ @Select(\"select * from user where id = #{id};\") User getUser(Integer id); /** * 查找所有User * * @return 返回User集合 */ @Select(\"select * from user\") List&lt;User> findUsers(); insert 的注解写法/** * 插入一个User * * @param user 需要插入的user * @return 返回插入结果 */ @Insert(\"insert into user (id, name, birthday, sex, address) values (#{id}, #{name}, #{birthday}, #{sex}, #{address});\") int createUser(User user); update 的注解写法 /** * 更新已给user * @param user 需要更新的user * @return 返回更新结果 */ @Update(\"update user set id = #{id}, name = #{name}, birthday = #{birthday}, sex = #{sex}, address = #{address} where id = #{id};\") int updateUser(User user); delete 的注解写法/** * 删除指定用户 * * @param id 需要删除用户的id * @return 返回删除结果 */ @Delete(\"delete from user where id = #{id};\") int deleteUser(Integer id); resultMap 注解写法Mybatis 提供了 @Results、@Result 和 @ResultMap 三个注解用于调用和实现 XML 配置中的 ResultMap 标签。其中 @Results 相当于 XML 配置中的 ResultMap 标签；@Result 相当于 XML 配置中 ResultMap 的子标签 result；而 @ResultMap 相当于 XML 配置中 CRUD 标签中的 resultMap 属性，通过填入 ResultMap 的 id 与之对应。 /** * 查找所有User * * @return 返回User集合 */ @Select(\"select * from user\") @Results(id = \"UserResultMap\", value = { @Result(id = true, column = \"id\", jdbcType = JdbcType.INTEGER, property = \"id\"), @Result(column = \"name\", jdbcType = JdbcType.VARCHAR, property = \"name\"), @Result(column = \"birthday\", jdbcType = JdbcType.DATE, property = \"birthday\"), @Result(column = \"sex\", jdbcType = JdbcType.VARCHAR, property = \"sex\"), @Result(column = \"address\", jdbcType = JdbcType.VARCHAR, property = \"address\") }) List&lt;User> findUsers(); /** * 查询指定的user * * @param id 需要查询的user id * @return 返回查找到的user */ @Select(\"select * from user where id = #{id};\") @ResultMap(\"UserResultMap\") User getUser(Integer id); 多表查询与延迟加载注解写法Mybatis 提供了 @One 和 @Many 两个注解用于实现 XML 配置中的 association 标签 和 collection 标签。其中 fetchType 属性可以选择快速加载或延迟加载。 一对一查询/** * 查找所有Account（立即加载） * * @return 返回Account集合 */ @Select(\"select * from account\") @Results(id = \"AccountResultMap\", value = { @Result(id = true, column = \"id\", jdbcType = JdbcType.INTEGER, property = \"id\"), @Result(column = \"username\", jdbcType = JdbcType.VARCHAR, property = \"username\"), @Result(column = \"password\", jdbcType = JdbcType.DATE, property = \"password\"), @Result(column = \"id\", jdbcType = JdbcType.INTEGER, property = \"user\", one = @One( select = \"com.kuukokawaii.user.dao.UserDao.getUser\", fetchType = FetchType.EAGER )) }) List&lt;Account> findAccounts(); 一对多查询/** * 查找所有User（延迟加载） * * @return 返回User集合 */ @Select(\"select * from user\") @Results(id = \"UserResultMap\", value = { @Result(id = true, column = \"id\", jdbcType = JdbcType.INTEGER, property = \"id\"), @Result(column = \"name\", jdbcType = JdbcType.VARCHAR, property = \"name\"), @Result(column = \"birthday\", jdbcType = JdbcType.DATE, property = \"birthday\"), @Result(column = \"sex\", jdbcType = JdbcType.VARCHAR, property = \"sex\"), @Result(column = \"address\", jdbcType = JdbcType.VARCHAR, property = \"address\"), @Result(column = \"id\", property = \"accounts\", many = @Many( select = \"com.kuukokawaii.user.dao.AccountDao.getAccount\", fetchType = FetchType.LAZY )) }) List&lt;User> findUsers(); 二级缓存注解写法Mybatis 提供了 @CacheNamespace 用于实现 XML 配置中 cache 标签的功能，需要注意的是该注解使用于 Dao 类上而非方法上。二级缓存可以在 SqlMapConfig.xml 中进行开启（默认开启）。 注解说明： readWrite：读写模式，True：必须实现序列化接口； flushInterval：刷新时间，单位：毫秒；这里的刷新是指缓存数据的有效期； implementation：缓存实现自定义对象； eviction：缓存策略的算法； size：是引用的缓存结果，这里是指1024次查询的结果，是序列化之后的结果； blocking：防止缓存击穿，对应的实现类：BlockingCache.putObject； 代码演示： &lt;settings> &lt;!-- 开启二级缓存支持。（可以不进行配置，默认 true。） --> &lt;setting name=\"cacheEnabled\" value=\"true\"/> &lt;/settings> @CacheNamespace(blocking = true) public interface UserDao { // 内容省略 } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（五）：缓存","date":"2019-10-13T09:42:50.000Z","path":"posts/2305/","text":"缓存适用性 经常查询且不经常改变的数据适用于缓存。 数据的正确与否对最终结果影响不大适用于缓存。相反，商品的库存、银行的汇率和股市的牌价等皆不适用于缓存。 一级缓存Mybatis 的一级缓存指的是 SqlSession 对象的缓存。当执行查询之后，查询的结果会同时存入到 SqlSession 中的一块 Map 结构的存储区域中。当我们再次执行查询同样的数据时，Mybatis 会先去 SqlSession 中查询是否拥有该数据，有则直接从缓存中获取。需要注意的是当调用 SqlSession 对象的修改、添加、删除、commit()、close()等方法时，Mybatis 的一级缓存将会被清空。 二级缓存Mybatis 的二级缓存指的是 SqlSessionFactory 对象的缓存。由同一个 SqlSessionFactory 对象创建的 SqlSession 对象将共享该缓存。不同于一级缓存，二级缓存需要手动配置。 二级缓存配置方法 让 Mybatis 框架支持二级缓存（在 SqlMapConfig.xml 中配置）。 让当前的映射文件支持二级缓存（在 UserMapper.xml 中配置）。 让当前的操作支持二级缓存（在 select 标签中配置）。 代码演示： SqlMapConfig.xml &lt;settings> &lt;!-- 开启二级缓存支持。（可以不进行配置，默认 true。） --> &lt;setting name=\"cacheEnabled\" value=\"true\"/> &lt;/settings> UserMapper.xml &lt;!-- 在 mapper 标签下开启二级缓存支持 --> &lt;cache/> select 标签 &lt;!-- 通过 userCache 属性开启二级缓存 --> &lt;select id=\"findUsers\" resultMap=\"UserResultMap\" useCache=\"true\"> select &lt;include refid=\"User_Column_List\"/> from user &lt;/select> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（四）：延迟加载","date":"2019-10-11T11:56:30.000Z","path":"posts/4576/","text":"立即加载和延迟加载 疑问在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候，要不要查询关联的账户。 在查询账户的时候，是否需要查询关联的用户。 解决 在查询用户的时候，是否查询关联的账户是按需查询。因此此处采用延迟加载（按需加载、懒加载），即数据只在需要的时候进行加载。 在查询账户的时候，关联的用户信息会随着账户查询一并查询显示。因此此处采用立即加载，即无论数据是否需要，再发起查询的时候都立即加载。 总结 一对多，多对多：通常情况下都是采用延迟加载。 一对一（多对一）：通常情况下都是采用立即加载。 代码演示/** * @Author 喵粮都输光了 * @Date 2019/9/30 14:53 * @Description 账户实体 */ public class Account implements Serializable { // 此处省略 get 和 set private Integer id; private String username; private String password; private User user; @Override public String toString() { return \"Account{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 此处省略 get 和 set private Integer id; private String name; private Date birthday; private String sex; private String address; private List&lt;Account> accounts; @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '}'; } } /** * @Author 喵粮都输光了 * @Date 2019/9/23 17:12 * @Description 用户持久层接口 */ public interface UserDao { /** * 查找指定的User * @param id 通过id查找User * @return 返回找到的User对象 */ User getUser(String id); /** * 查找所有User * @return 返回User集合 */ List&lt;User> findUsers(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 15:37 * @Description 账号持久层接口 */ public interface AccountDao { /** * 查找指定的Account * @param id 通过id查找Account * @return 返回找到的Account对象 */ Account getAccount(String id); /** * 查找所有Account * @return 返回Account集合 */ List&lt;Account> findAccounts(); } 在 SqlMapConfig.xml 中开启延迟加载 &lt;settings> &lt;!-- 开启延迟加载开关 --> &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/> &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/> &lt;/settings> 一对多延迟加载：一个 User 拥有多个 Account，通过 UserMapper 中的 collection 标签的 select 调用 Account 中的 getAccount 方法进行延迟加载。 &lt;sql id=\"Account_Column_List\"> &lt;!--@sql select --> account.id, username, password &lt;!--@sql from account --> &lt;/sql> &lt;select id=\"getAccount\" parameterType=\"string\" resultType=\"com.kuukokawaii.user.entity.Account\"> select &lt;include refid=\"Account_Column_List\"/> from account where account.id = #{id}; &lt;/select> &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;!-- 延迟加载一对多。 select：表示调用其他查询（可以是其他mapper中的查询），此处为查询用户的唯一标识。 column：用户根据 id 查询时，所需要的参数的值。即为 select 中查询提供所需的 id 进行查询。 --> &lt;collection column=\"id\" property=\"accounts\" select=\"com.kuukokawaii.user.dao.AccountDao.getAccount\"/> &lt;/resultMap> &lt;sql id=\"User_Column_List\"> &lt;!--@sql select --> user.id, name, birthday, sex, address &lt;!--@sql from user --> &lt;/sql> &lt;select id=\"findUsers\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/> from user &lt;/select> 一对一（多对一）延迟加载：多个 Account 对应一个 User，通过 AccountMapper 中的 association 标签的 select 调用 User 中的 getUser 方法进行延迟加载。 &lt;sql id=\"User_Column_List\"> &lt;!--@sql select --> user.id, name, birthday, sex, address &lt;!--@sql from user --> &lt;/sql> &lt;select id=\"getUser\" parameterType=\"string\" resultType=\"com.kuukokawaii.user.entity.User\"> select &lt;include refid=\"User_Column_List\"/> from user where user.id = #{id}; &lt;/select> &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;!-- 延迟加载一对一（多对一）。 select：表示调用其他查询（可以是其他mapper中的查询），此处为查询用户的唯一标识。 column：用户根据 id 查询时，所需要的参数的值。即为 select 中查询提供所需的 id 进行查询。 --> &lt;association column=\"id\" property=\"user\" select=\"com.kuukokawaii.user.dao.UserDao.getUser\"/> &lt;/resultMap> &lt;sql id=\"Account_Column_List\"> &lt;!--@sql select --> account.id, username, password &lt;!--@sql from account --> &lt;/sql> &lt;select id=\"findAccounts\" resultMap=\"AccountResultMap\"> select &lt;include refid=\"Account_Column_List\"/> from account &lt;/select> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"设计模式之策略模式","date":"2019-10-09T09:19:54.000Z","path":"posts/36970/","text":"策略模式 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。即将各个功能拆分封装成模块，最终通过组合的方式实现效果。 设计原则： 1.找出应用中可能需要变化之处，把它们独立出来，不要和哪些不需要变化的代码混在一起。 2.针对接口编程，而不是针对实现编程。 3.多用组合，少用继承。 原型根据 OO 标准，设计一个鸭子超类，并让各类鸭子继承此超类。 新增飞行功能 问题：在超类上新增功能飞行，导致子类不能飞行的鸭子也能够飞行。 解决：覆盖不能飞行的鸭子的飞行方法，让不能飞行的鸭子不再拥有飞行功能。如此修改代码的话会导致以后每增加一个继承鸭子超类的子类都需要检查并可能覆盖飞行方法，这是非常痛苦的一件事情！因此将飞行方法抽取出来，让需要该功能的鸭子实现接口即可。 实现飞行接口 问题：当抽取了飞行功能时，发现每次新增子类时都需要实现一次飞行接口，这造成了大量代码的重复！ 解决：这里可以对飞行接口进行实现，让能飞、不能飞的鸭子在初始化实例变量时调用所需接口即可。 UML图： 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/10/9 17:46 * @Description 鸭子超类 */ abstract class AbstractDuck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; /** * 执行飞行功能 */ void performFly() { flyBehavior.fly(); } /** * 执行叫声功能 */ void performQuack() { quackBehavior.quack(); } /** * 游泳功能 */ void swim() { System.out.println(\"会游泳。\"); } /** * 外观 */ abstract void display(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:35 * @Description 飞行接口 */ public interface FlyBehavior { /** * 飞行功能。 */ void fly(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:58 * @Description 飞行接口实现类：不能飞 */ public class FlyNowayImpl implements FlyBehavior { @Override public void fly() { System.out.println(\"不能飞。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:59 * @Description 飞行接口实现类：能飞 */ public class FlyWithWingsImpl implements FlyBehavior{ @Override public void fly() { System.out.println(\"能飞。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:35 * @Description 叫声接口 */ public interface QuackBehavior { /** * 叫声功能。 */ void quack(); } /** * @Author 喵粮都输光了 * @Date 2019/10/9 19:01 * @Description 叫声接口实现类：呱呱叫 */ public class QuackImpl implements QuackBehavior{ @Override public void quack() { System.out.println(\"呱呱叫。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 19:01 * @Description 叫声接口实现类：吱吱叫 */ public class SqueakImpl implements QuackBehavior { @Override public void quack() { System.out.println(\"吱吱叫。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 17:48 * @Description 红头鸭 */ public class RedheadDuck extends AbstractDuck { public RedheadDuck() { quackBehavior = new QuackImpl(); flyBehavior = new FlyWithWingsImpl(); } @Override void display() { System.out.println(\"外观是红头鸭。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/10/9 18:20 * @Description 橡皮鸭 */ public class RubberDuck extends AbstractDuck { public RubberDuck() { quackBehavior = new SqueakImpl(); flyBehavior = new FlyNowayImpl(); } @Override void display() { System.out.println(\"外观是橡皮鸭。\"); } } 遗留的小问题 问题：实现飞行功能的解决方法在构造器中制造了一个具体的实现类实例，该行为违反了不对具体实现编程的设计原则。 解决：可以通过其他设计模式解决。 动态设定行为 需求：实现飞行接口的方案可以动态的设定行为，即在运行时修改鸭子的功能，而不是通过构造器实例化。 代码演示（主要代码）： 在 Duck 类新增 setFlyBehavior 和 setQuackBehavior 方法。 /** * @Author 喵粮都输光了 * @Date 2019/10/9 17:46 * @Description 鸭子超类 */ abstract class AbstractDuck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; /** * 执行飞行功能 */ void performFly() { flyBehavior.fly(); } /** * 执行叫声功能 */ void performQuack() { quackBehavior.quack(); } /** * 设置具体飞行功能。 * * @param flyBehavior 具体飞行功能 */ void setFlyBehavior(FlyBehavior flyBehavior) { this.flyBehavior = flyBehavior; } /** * 设置具体叫声功能。 * * @param quackBehavior 具体叫声功能 */ void setQuackBehavior(QuackBehavior quackBehavior) { this.quackBehavior = quackBehavior; } /** * 游泳功能 */ void swim() { System.out.println(\"会游泳。\"); } /** * 外观 */ abstract void display(); } 在运行中修改橡皮鸭的叫声为呱呱叫。 /** * @Author 喵粮都输光了 * @Date 2019/10/9 19:18 * @Description 主函数 */ public class Main { public static void main(String[] args) { AbstractDuck rubberDuck = new RubberDuck(); rubberDuck.swim(); rubberDuck.display(); rubberDuck.performFly(); rubberDuck.performQuack(); System.out.println(\"--------改变了橡皮鸭的叫声为呱呱叫--------\"); rubberDuck.setQuackBehavior(new QuackImpl()); rubberDuck.performQuack(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.kuukokawaii.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Mybatis（三）：多表操作","date":"2019-10-09T04:58:18.000Z","path":"posts/44025/","text":"一对多、一对一 案例说明：用户和账户 一个用户可以有多个账户，使用 collection。 一个账户只能属于一个用户，使用 association。（多个账户也可以属于同一个用户） 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 此处省略 get 和 set private Integer id; private String name; private Date birthday; private String sex; private String address; private List&lt;Account> accounts; } /** * @Author 喵粮都输光了 * @Date 2019/9/30 14:53 * @Description 账户实体 */ public class Account implements Serializable { // 此处省略 get 和 set private Integer id; private String username; private String password; private User user; } UserMapper（一对多） &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;collection property=\"accounts\" resultMap=\"AccountResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;/resultMap> AccountMapper（一对一） &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;association property=\"user\" resultMap=\"AccountResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;/resultMap> 多对多 案例说明：用户和角色 一个用户可以有多个角色。 一个角色可以赋予多个用户。 数据库中需要一个中间表来记录角色和用户之间的对应关系。（需要中间表） 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 此处省略 get 和 set private Integer id; private String name; private Date birthday; private String sex; private String address; private List&lt;Role> roles; } /** * @Author 喵粮都输光了 * @Date 2019/10/9 16:50 * @Description 角色实体 */ public class Role implements Serializable { // 此处省略 get 和 set private Integer id; private String roleName; private String roleDesc; private List&lt;User> users; } UserMapper（一对多） &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;collection property=\"roles\" resultMap=\"RoleResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"RoleResultMap\" type=\"com.kuukokawaii.user.entity.Role\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/> &lt;result column=\"role_desc\" jdbcType=\"VARCHAR\" property=\"roleDesc\"/> &lt;/resultMap> AccountMapper（一对多） &lt;resultMap id=\"RoleResultMap\" type=\"com.kuukokawaii.user.entity.Role\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/> &lt;result column=\"role_desc\" jdbcType=\"VARCHAR\" property=\"roleDesc\"/> &lt;collection property=\"users\" resultMap=\"UserResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;/resultMap> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（二）：mapper.xml 文件语法","date":"2019-09-29T10:24:31.000Z","path":"posts/30243/","text":"resultMap resultMap 可以实现将查询结果映射为复杂类型的pojo。 id：用于定义 resultMap 的 id。 type：复杂类型的实体全限定名。 result：对数据库字段和 java 变量进行映射。 column：数据库字段。 jdbcType：数据库字段类型。 property：java 变量。 collection：一个复杂类型的关联，可以关联另一个 resultMap。 案例说明： 创建一个 Account 类，包含 username 和 password。 创建一个 User 类，包含 id、name、birthday、sex 和 address。 定义 User 类的 resultMap。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/30 14:53 * @Description 账户实体 */ public class Account { // 此处省略了 set 和 get。 private String username; private String password; private Integer id; } /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ @Data public class User implements Serializable { // 此处省略了 set 和 get。 private Integer id; private String name; private Date birthday; private String sex; private String address; private Account account; } &lt;resultMap id=\"UserResultMap\" type=\"com.kuukokawaii.user.entity.User\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/> &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/> &lt;result column=\"sex\" jdbcType=\"VARCHAR\" property=\"sex\"/> &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/> &lt;association property=\"account\" resultMap=\"AccountResultMap\"/> &lt;/resultMap> &lt;resultMap id=\"AccountResultMap\" type=\"com.kuukokawaii.user.entity.Account\"> &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/> &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/> &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/> &lt;/resultMap> sql sql 被用来定义可重用的 sql 代码段，可以通过&lt;include&gt;标签进行调用。 案例说明：用 sql 定义 user 和 account 表的字段集。 代码演示： &lt;sql id=\"User_Column_List\"> &lt;!--@sql select --> user.id, name, birthday, sex, address &lt;!--@sql from user --> &lt;/sql> &lt;sql id=\"Account_Column_List\"> &lt;!--@sql select --> account.id, username, password &lt;!--@sql from account --> &lt;/sql> if if 提供了一种可选的查找文本功能，符合条件即执行。 案例说明：当 sex 非 null 时语句查询指定的 name 和 sex 条件，否则只查询 name。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id where name = #{name} &lt;if test=\"sex != null\"> and sex = #{sex} &lt;/if> &lt;/select> choose, when, otherwise choose 从多个条件中挑选一个，类似于 switch 语句。 案例说明：当 sex 非空时根据 name 和 sex 查询，当 birthday 非空时根据 name 和 birthday 查询，当 address 非空时根据 name 和 address 查询，否则仅根据 name 查询。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id where name = #{name} &lt;choose> &lt;when test=\"sex != null\"> and sex = #{sex} &lt;/when> &lt;when test=\"birthday != null\"> and birthday = #{birthday} &lt;/when> &lt;otherwise> and address = #{address} &lt;/otherwise> &lt;/choose> &lt;/select> trim, where, set 当使用 if 进行条件匹配时，如果一个条件都不匹配则语句末尾可能以 where 结尾导致 sql 报错。若匹配的条件非第一项而是其他项则会导致 where and xxx 的语句情况同样会报错。因此 mybatis 的 where 标签会自动处理该情况。set 同理。当 where 和 set 标签没有发挥作用时可以通过 trim 自定义格式执行。 案例说明： 当条件非空时查询指定条件否则查询所有。 当条件非空时更新非空条件。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id &lt;where> &lt;if test=\"name != null\"> name = #{name} &lt;/if> &lt;if test=\"sex != null\"> and sex = #{sex} &lt;/if> &lt;/where> &lt;/select> &lt;!-- where 等价于 trim 的如下情形 --> &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"> &lt;!-- 内容 --> &lt;/trim> &lt;update id=\"updateUser\" parameterType=\"com.kuukokawaii.user.entity.User\"> update user, account &lt;set> &lt;if test=\"id != null\"> user.id = #{id}, &lt;/if> &lt;if test=\"name != null\"> name = #{name}, &lt;/if> &lt;if test=\"birthday != null\"> birthday = #{birthday}, &lt;/if> &lt;if test=\"sex != null\"> sex = #{sex}, &lt;/if> &lt;if test=\"address != null\"> address = #{address}, &lt;/if> &lt;if test=\"account.id != null\"> account.id = #{account.id}, &lt;/if> &lt;if test=\"account.username != null\"> account.username = #{account.username}, &lt;/if> &lt;if test=\"account.password != null\"> account.password = #{account.password}, &lt;/if> &lt;/set> where user.id = account.id and user.id = #{id} &lt;/update> &lt;!-- set 等价于 trim 的如下情形 --> &lt;trim prefix=\"SET\" prefixOverrides=\",\"> &lt;!-- 内容 --> &lt;/trim> foreach 通常是在构建 IN 条件语句的时候使用，对一个集合进行遍历操作。 案例说明：搜索 id 在列表中的 user。 代码演示： &lt;select id=\"selectUserIn\" resultMap=\"UserResultMap\"> select * from user where user.id in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"> #{item} &lt;/foreach> &lt;/select> bind bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。 案例说明：搜索符合条件的 user。 代码演示： &lt;select id=\"selectUsersLike\" resultMap=\"UserResultMap\"> &lt;bind name=\"pattern\" value=\"'%' + _parameter.getTitle() + '%'\" /> select * from user where name like #{pattern} &lt;/select> select select 是 mybatis 的查询语句。 id：用于定义 select 的 id，需要与 DAO 中的方法名对应。方法名为 get 表获取单个元素，find 表获取元素集。 parameterType：表传入的参数类型。 resultType：表示返回类型（与 resultMap 二选一），如果返回的是集合则填写集合所包含的类型。 resultMap：表示返回类型（与 resultType 二选一），返回定义的 resultMap。 案例说明： 查找一个指定名称的 User 对象。 查找所有 User 对象。 代码演示： &lt;select id=\"getUser\" parameterType=\"string\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id where name = #{name}; &lt;/select> &lt;select id=\"findUser\" resultMap=\"UserResultMap\"> select &lt;include refid=\"User_Column_List\"/>, &lt;include refid=\"Account_Column_List\"/> from user left join account on user.id = account.id &lt;/select> delete delete 是 mybatis 的删除语句。 案例说明：删除一个指定 id 的 User 和 Account 对象。 代码演示： &lt;delete id=\"deleteUser\" parameterType=\"int\"> delete from user, account using user, account where user.id = account.id and user.id = #{id}; &lt;/delete> update update 是 mybatis 的更新语句。 useGeneratedKeys：更新后返回主键（默认 false）。 keyProperty：指定在 Java 实体中对应的主键变量名。 keyColumn：当主键列不是表中的第一列的时候需要设置，用于指定数据库的主键（默认数据库第一列为主键）。 案例说明：更新指定User对象。 代码演示： &lt;update id=\"updateUser\" parameterType=\"com.kuukokawaii.user.entity.User\"> update user, account &lt;set> &lt;if test=\"id != null\"> user.id = #{id}, &lt;/if> &lt;if test=\"name != null\"> name = #{name}, &lt;/if> &lt;if test=\"birthday != null\"> birthday = #{birthday}, &lt;/if> &lt;if test=\"sex != null\"> sex = #{sex}, &lt;/if> &lt;if test=\"address != null\"> address = #{address}, &lt;/if> &lt;if test=\"account.id != null\"> account.id = #{account.id}, &lt;/if> &lt;if test=\"account.username != null\"> account.username = #{account.username}, &lt;/if> &lt;if test=\"account.password != null\"> account.password = #{account.password}, &lt;/if> &lt;/set> where user.id = account.id and user.id = #{id} &lt;/update> insert insert 是 mybatis 的插入语句。 案例说明：插入一个User对象。(如果在插入一个 User 对象的同时插入 Account 对象，需要在 Service 中开启事务并调用 User 插入和 Account 插入语句。) 代码演示： &lt;insert id=\"createUser\" parameterType=\"com.kuukokawaii.user.entity.User\" useGeneratedKeys=\"true\" keyProperty=\"id\"> insert into user &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\"> &lt;if test=\"name != null\"> name, &lt;/if> &lt;if test=\"birthday != null\"> birthday, &lt;/if> &lt;if test=\"sex != null\"> sex, &lt;/if> &lt;if test=\"address != null\"> address, &lt;/if> &lt;/trim> &lt;trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\"> &lt;if test=\"name != null\"> #{name}, &lt;/if> &lt;if test=\"birthday != null\"> #{birthday}, &lt;/if> &lt;if test=\"sex != null\"> #{sex}, &lt;/if> &lt;if test=\"address != null\"> #{address}, &lt;/if> &lt;/trim> &lt;/insert> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"Mybatis（一）：简介","date":"2019-09-22T04:12:57.000Z","path":"posts/13712/","text":"Mybatis 概述 Mybatis 封装了 jdbc，让开发无需花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 Mybatis 通过 XML 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象 和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 Mybatis 框架执行 sql 并将结果映射为 java 对象并返回。 Mybatis 采用 ORM 思想解决了实体和数据库映射的问题，因此不需要直接操作 JDBC API 便可以完成对数据库的持久化操作。 案例说明 在 mysql 数据库中建立 user 表。 创建 User 实体和 dao 接口。 创建映射配置文件（UserMapper.xml），注意 mybatis 的映射位置文件位置必须和 dao 接口的包结构相同。 配置 mybatis 配置文件（SqlMapConfig.xml）。 Demo 目录层级如下： 使用到的 Jar 包 mybatis.jar log4j.jar junit.jar mysql-connector-java.jar 代码演示use mybatis; create table user( id int(11) not null primary key auto_increment, username varchar(30) not null comment '用户名称', birthday datetime default null comment '生日', sex char(1) default null comment '性别', address varchar(256) default null comment '地址' ) engine=innodb default charset=utf8mb4; insert into user (username, birthday, sex, address) values('update user clear cache', '2018-02-10', '男', '北京xx1'); insert into user (username, birthday, sex, address) values('123', '2018-03-10', '女', '北京xx81'); insert into user (username, birthday, sex, address) values('13535', '2018-05-10', '女', '北京xx71'); insert into user (username, birthday, sex, address) values('456436', '2018-07-10', '男', '北京xx19'); insert into user (username, birthday, sex, address) values('asda', '2018-02-15', '女', '北京xx1'); insert into user (username, birthday, sex, address) values('啊沙发沙发', '2018-08-20', '男', '北京xx12'); insert into user (username, birthday, sex, address) values('让他人', '2018-09-10', '女', '北京xx17'); insert into user (username, birthday, sex, address) values('啊实打实的', '2018-10-01', '男', '北京xx21'); /** * @Author 喵粮都输光了 * @Date 2019/9/23 16:28 * @Description 用户实体 */ public class User implements Serializable { // 省略了 get 和 set。 private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() { return \"User{id=\" + id + \", username='\" + username + \", birthday=\" + birthday + \", sex='\" + sex + \", address\" + \"='\" + address + \"}\"; } } ###################################### # log4j配置相关说明 ###################################### #%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL #%r 输出自应用启动到输出该log信息耗费的毫秒数 #%c 输出所属的类目，通常就是所在类的全名 #%t 输出产生该日志事件的线程名 #%m 输出代码中指定的信息 #%n 输出一个回车换行符，Windows平台为“\\r\\n”，Unix平台为“\\n” #%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MM dd HH:mm:ss,SSS}，输出类似： 2002年10月18日 22：10：28，921 #%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) #log4j提供4种布局: #org.apache.log4j.HTMLLayout（以HTML表格形式布局） #org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， #org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， #org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息 #log4j中有五级logger 输出级别: #FATAL 0 #ERROR 3 #WARN 4 #INFO 6 #DEBUG 7 ###################################### # log4j相关配置 ###################################### #日志输出级别 log4j.rootLogger=INFO,stdout,other #设置stdout的日志输出控制台 log4j.appender.stdout=org.apache.log4j.ConsoleAppender #输出日志到控制台的方式，默认为System.out log4j.appender.stdout.Target=System.out #设置使用灵活布局 log4j.appender.stdout.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.stdout.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %m %n #设置other的日志输出控制台(RollingFileAppender)。/每天生产一个日志文件(DailyRollingFileAppender),没有MaxFileSize和MaxBackupIndex属性。 #log4j.appender.other=org.apache.log4j.DailyRollingFileAppender log4j.appender.other=org.apache.log4j.RollingFileAppender #设置other的输出日志 log4j.appender.other.File=设置输出位置，例如 D:\\\\JetBrains。 #设置other的日志最大限制 log4j.appender.other.MaxFileSize=1024KB #最多只保存20个备份文件 log4j.appender.other.MaxBackupIndex=1000 #输出INFO级别以上的日志 log4j.appender.other.Threshold=INFO #设置使用灵活布局 log4j.appender.other.layout=org.apache.log4j.PatternLayout #灵活定义输出格式 log4j.appender.other.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %t %m %n ###显示SQL语句部分 log4j.logger.com.mybatis=DEBUG log4j.logger.com.mybatis.common.jdbc.SimpleDataSource=DEBUG log4j.logger.com.mybatis.common.jdbc.ScriptRunner=DEBUG log4j.logger.com.mybatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG /** * @Author 喵粮都输光了 * @Date 2019/9/25 14:33 * @Description mybatis demo 测试 */ public class UserDaoTest { public static void main(String[] args) throws IOException { // 读取配置文件。 InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建 sqlSessionFactory 工厂 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); // 使用工厂生产 sqlSession 对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 使用 sqlSession 创建 Dao 接口的代理对象 UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User> userList = userDao.findAllUser(); for (User user : userList) { System.out.println(user); } // 释放资源 sqlSession.close(); inputStream.close(); } } XML 配置方式/** * @Author 喵粮都输光了 * @Date 2019/9/23 17:12 * @Description 用户持久层接口 */ public interface UserDao { /** * 查询所有用户 * @return 返回用户 list */ List&lt;User> findAllUser(); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.kuukokawaii.user.dao.UserDao\"> &lt;!-- 配置查询所有用户 --> &lt;select id=\"findAllUser\" resultType=\"com.kuukokawaii.user.entity.User\"> select * from user &lt;/select> &lt;/mapper> &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 配置环境 --> &lt;environments default=\"mysql\"> &lt;!-- 配置 mysql 的环境 --> &lt;environment id=\"mysql\"> &lt;!-- 配置事务的类型 --> &lt;transactionManager type=\"JDBC\"/> &lt;!-- 配置数据源（连接池） --> &lt;dataSource type=\"POOLED\"> &lt;!-- 配置连接数据库的基本信息 --> &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC\"/> &lt;property name=\"username\" value=\"账号\"/> &lt;property name=\"password\" value=\"密码\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个 dao 独立的配置文件 --> &lt;mappers> &lt;mapper resource=\"com/kuukokawaii/user/dao/UserMapper.xml\"/> &lt;/mappers> &lt;/configuration> 注解方式/** * @Author 喵粮都输光了 * @Date 2019/9/23 17:12 * @Description 用户持久层接口 */ public interface UserDao { /** * 查询所有用户 * * @return 返回用户 list */ @Select(\"select * from user\") List&lt;User> findAllUser(); } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 配置环境 --> &lt;environments default=\"mysql\"> &lt;!-- 配置 mysql 的环境 --> &lt;environment id=\"mysql\"> &lt;!-- 配置事务的类型 --> &lt;transactionManager type=\"JDBC\"/> &lt;!-- 配置数据源（连接池） --> &lt;dataSource type=\"POOLED\"> &lt;!-- 配置连接数据库的基本信息 --> &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC\"/> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"qwe123\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个 dao 独立的配置文件。如果使用注解方式来配置则此处应该使用 class 属性指定被注解的 dao 全限定类名 --> &lt;mappers> &lt;mapper class=\"com.kuukokawaii.user.dao.UserDao\"/> &lt;/mappers> &lt;/configuration> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://blog.kuukokawaii.com/tags/mybatis/"}]},{"title":"SpringMVC（八）：拦截器","date":"2019-09-21T11:18:43.000Z","path":"posts/27588/","text":"Filter 与 Interceptor 的区别FilterFilter 依赖于 Servlet 容器，它的实现基于函数回调，几乎可以对所有的请求进行过滤，通常于容器初始化时调用。 InterceptorInterceptor 依赖于 SpringMVC 框架，它的实现基于 Java 的反射机制，属于 AOP 的一种运用。通常对处理器方法进行预处理和后处理。 案例说明 编写两个拦截器类，实现 HandlerInterceptor 接口。其中预处理方法中返回值为布尔型，作用分别如下： true：表放行，执行下一个拦截器，没有则执行 controller 中的方法。 false：表不放行，会执行 preHandle() 和 afterCompletion() 方法，但不对 controller 中的方法和 postHandle() 进行执行。 两个拦截器分别为拦截器1和拦截器2，执行顺序为：1pre()→2pre()→controller方法→2post()→1post()→2after()→1after() SpringMVC 配置文件中配置拦截器。 代码演示/** * @Author 喵粮都输光了 * @Date 2019/9/21 19:44 * @Description 自定义拦截器类1 */ public class MyInterceptor1 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"1拦截器预处理，controller 方法执行前运行\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"1拦截器后处理，controller 方法执行后运行\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"1在视图渲染之后运行，还要再拦截器后处理方法运行之后。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/21 19:44 * @Description 自定义拦截器类2 */ public class MyInterceptor2 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"2拦截器预处理，controller 方法执行前运行\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"2拦截器后处理，controller 方法执行后运行\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"2在视图渲染之后运行，还要再拦截器后处理方法运行之后。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 拦截器 */ @Controller @RequestMapping(\"/user\") public class UserController { @RequestMapping(\"/testInterceptor\") String testInterceptor() { System.out.println(\"controller 方法\"); return \"success\"; } } &lt;!-- 配置拦截器 --> &lt;mvc:interceptors> &lt;mvc:interceptor> &lt;!-- 配置需要拦截的方法。&lt;mvc:mapping>表需要拦截的方法，&lt;mvc:exclude-mapping>表不需要拦截的方法。path 填写需要拦截的 URI --> &lt;mvc:mapping path=\"/user/*\"/> &lt;!-- 配置拦截器对象 --> &lt;bean id=\"myInterceptor1\" class=\"com.kuukokawaii.springmvc.interceptor.MyInterceptor1\"/> &lt;/mvc:interceptor> &lt;mvc:interceptor> &lt;mvc:mapping path=\"/**\"/> &lt;bean id=\"myInterceptor2\" class=\"com.kuukokawaii.springmvc.interceptor.MyInterceptor2\"/> &lt;/mvc:interceptor> &lt;/mvc:interceptors> index 界面 拦截器 拦截器 success 界面 执行成功 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（七）：异常处理","date":"2019-09-21T08:28:18.000Z","path":"posts/47299/","text":"异常处理方式SpringMVC 常用的异常处理方式有两种： 使用 SpringMVC 提供的 HandlerExceptionResolver 接口自定义异常处理器。 使用 @ControllerAdvice + @ExceptionHandler 注解实现异常处理。 接口方式 案例说明： 编写自定义异常种类。 编写异常处理器。 配置异常处理器并编写异常跳转页面。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/21 17:06 * @Description 自定义异常 */ public class CustomException extends Exception { /** * 存储提示信息（此处省略了 get 和 set） */ private String message; public CustomException(String message) { this.message = message; } } /** * @Author 喵粮都输光了 * @Date 2019/9/21 17:14 * @Description 自定义异常处理器 */ public class CustomExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { // 获取异常对象 CustomException customException; if (ex instanceof CustomException) { customException = (CustomException) ex; } else { customException = new CustomException(\"系统维护中。\"); } // 创建 ModelAndView 存储异常信息并设置返回页面。 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"errorMsg\", customException.getMessage()); modelAndView.setViewName(\"error\"); return modelAndView; } } /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 异常处理 */ @Controller @RequestMapping(\"/user\") public class UserController{ @RequestMapping(\"/testException\") String testException() throws CustomException { try { // 模拟异常 int i = 1 / 0; } catch (Exception e) { // 打印异常信息 e.printStackTrace(); // 抛出自定义异常信息 throw new CustomException(\"除数不能为0。\"); } return \"success\"; } } &lt;!-- 配置异常处理器 --> &lt;bean id=\"customExceptionResolver\" class=\"com.kuukokawaii.springmvc.exception.CustomExceptionResolver\"/> 异常处理界面 ${errorMsg} index 界面 异常处理 异常处理 注解方式 案例说明： 编写自定义异常种类。(CustomException、Controller 类同上) 使用 @ControllerAdvice + @ExceptionHandler(xx.class) 注解编写全局异常处理器。其中有 @ControllerAdvice 这个注解的类中的方法的某些注解会应用到所有的 Controller 里，例如 @ExceptionHandler。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/21 17:37 * @Description 基于 @ExceptionHandler 处理异常。 */ @ControllerAdvice public class CustomExceptionHandler { /** * 基于 @ExceptionHandler 的异常处理。 * @param exception 异常信息 * @return 返回视图模型 */ @ExceptionHandler(Exception.class) ModelAndView exceptionHandler(Exception exception) { // 获取异常对象 CustomException customException; if (exception instanceof CustomException) { customException = (CustomException) exception; } else { customException = new CustomException(\"系统维护中。\"); } // 创建 ModelAndView 存储异常信息并设置返回页面。 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"errorMsg\", customException.getMessage()); modelAndView.setViewName(\"error\"); return modelAndView; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（六）：文件上传","date":"2019-09-20T06:31:37.000Z","path":"posts/2009/","text":"前提 form 表单的 enctype 取值必须是 multipart/form-data。（enctype 默认值为 application/x-www-form-urlencoded） enctype：表单请求正文的类型。 method 取值必须是 Post。 提供文件选择域&lt;input type=\"file\" name=\"\"&gt;，该标签 name 属性必须有，否者会导致 fileItem 获取不到值。 原理 当 form 表单的 enctype 取值不是默认值后，request.getParameter()将失效。 当enctype=\"application/x-www-form-urlencoded\"时，form 表单的正文内容是：key=value&amp;key=value。 当enctype=\"multipart/form-data\"时， form 表单的正文内容就变成每一部分都是 MIME 类型描述的正文。 后端解析请求体获取 MIME 类型描述的正文（即上传的文件），并将上传文件写回磁盘存储。 传统方式 案例说明： 通过 commons-fileupload.jar 原生 API 解析请求体。 代码演示： index 界面 文件上传 选择文件： /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 文件上传 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 利用 fileupload 解析请求体。 * @param request 请求 * @return 返回到 success 页面。 * @throws Exception 异常 */ @RequestMapping(\"/testOldFileUpload\") String testOldFileUpload(HttpServletRequest request) throws Exception { // 1.上传位置创建文件夹。 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); File file = new File(path); if (!file.exists()) { file.mkdirs(); } // 2.创建 DiskFileItemFactory 存储大于 10kb 的临时文件。 DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory(); // 3.创建 ServletFileUpload 负责处理上传的文件数据。 ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory); List&lt;FileItem> fileItems = servletFileUpload.parseRequest(request); for (FileItem fileItem : fileItems) { // 判断当前 fileItem 对象是否是上传文件项,true 不是，false 是。 if (!fileItem.isFormField()) { // 设置文件名称为唯一值 uuid。 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 获取上传文件的名称，并与 uuid 组合。 String fileName = uuid + \"_\" + fileItem.getName(); // 上传文件 fileItem.write(new File(path, fileName)); // 删除临时 fileItem 文件。 fileItem.delete(); } } return \"success\"; } } SpringMVC 方式 案例说明： 在 SpringMVC 的配置文件中配置文件解析器，要求 id 名称必须为 multipartResolver。 SpringMVC 框架提供了 MultipartFile 对象表示上传的对象，该对象要求变量名称和表单 file 标签的 name 属性名称相同。 代码演示： 选择文件： &lt;!-- 文件解析器，要求 id 名称必须为 multipartResolver --> &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"> &lt;property name=\"maxUploadSize\" value=\"10485760\"/> &lt;/bean> /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 文件上传 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 使用 MultipartFile 对象上传文件。 * @param upload 参数名称必须与文件上传 input 标签的 name 相同。 * @return 返回到 success 页面。 * @throws IOException io 异常 */ @RequestMapping(\"/testSpringMvcFileUpload\") String testSpringMvcFileUpload(MultipartFile upload) throws IOException { // 1.上传位置创建文件夹。 String path = \"D:\\\\JetBrains\\\\IdeaProjects\\\\springmvc\\\\target\\\\springmvc\\\\uploads\\\\\"; File file = new File(path); if (!file.exists()) { file.mkdirs(); } // 设置文件名称为唯一值 uuid。 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 获取上传文件的名称，并与 uuid 组合。 String fileName = uuid + \"_\" + upload.getOriginalFilename(); // 上传文件 upload.transferTo(new File(path, fileName)); return \"success\"; } } 跨服务器上传文件 案例说明： 新建一个 maven 的 webapp 项目，在 webapp 目录下新建 uploads 目录，启动该项目的 Tomcat（注意端口不要重复）。 在客户端项目下导入 com.sun.jersey 下的 jersey-core.jar 和 jersey-client.jar 包，编写服务程序并启动 Tomcat。 如果报错的话，需要注意第一个项目的 Tomcat 中的 webapp 中以及 target 或 out 目录下适当位置是否有创建 uploads 目录。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/20 15:07 * @Description 文件上传 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 跨服务器上传文件。 * @param upload 参数名称必须与文件上传 input 标签的 name 相同。 * @return 返回到 success 页面。 * @throws IOException io 异常 */ @RequestMapping(\"/testCrossServerFileUpload\") String testCrossServerFileUpload(MultipartFile upload) throws IOException { // 1.定义上传文件服务器路径。 String path = \"http://127.0.0.1:8081/uploads/\"; // 设置文件名称为唯一值 uuid。 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 获取上传文件的名称，并与 uuid 组合。 String fileName = uuid + \"_\" + upload.getOriginalFilename(); // 创建客户端对象 Client client = Client.create(); // 和图片服务器进行连接（文件名可能中文转码） WebResource webResource = client.resource(path + URLEncoder.encode(fileName, \"UTF-8\")); // 上传文件 webResource.put(upload.getBytes()); return \"success\"; } } 选择文件： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（五）：响应数据和结果视图","date":"2019-09-19T05:32:01.000Z","path":"posts/46928/","text":"响应数据返回值类型 String 案例说明： 创建一个拥有姓名、密码和年龄的 User 类。 通过在 JSP 页面发起请求，控制器类中返回一个封装好了数据的 User 类。 在跳转成功的界面获取 User 类中封装的数据。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:43 * @Description 用户类 */ public class User implements Serializable { // 此处省略了 get 和 set private String username; private String password; private Integer age; } /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 测试返回字符串 * @param model 模型 * @return 返回 */ @RequestMapping(\"/testString\") String testString(Model model) { // 模拟从数据库中查询出 User 对象 User user = new User(); user.setUsername(\"12\"); user.setPassword(\"123\"); user.setAge(11); model.addAttribute(\"user\", user); return \"success\"; } } index 界面 响应数据和结果视图 testString success 界面 跳转成功 账户：${user.username} 密码：${user.password} 年龄：${user.age} 返回值类型 void 案例说明： 创建一个拥有姓名、密码和年龄的 User 类。 通过在 JSP 页面发起请求，控制器类中分别进行转发、重定向和直接响应的方法响应视图页面。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 测试无返回值类型。1、转发 2、重定向 3、直接响应 * @param request Servlet 原生API request * @param response Servlet 原生API response */ @RequestMapping(\"/testVoid\") void testVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1、转发（不会使用视图解析器） request.getRequestDispatcher(\"/WEB-INF/pages/success2.jsp\").forward(request, response); /*2、重定向（无法跳转至 WEB-INF 下，且不会使用视图解析器） response.sendRedirect(\"/success2.jsp\");*/ /*3、直接响应 // 设置中文编码，防止中文乱码。 response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=UTF-8\"); response.getWriter().print(\"你好\");*/ } } index 界面 testVoid success 界面 跳转成功 success2 界面 跳转成功 返回值类型 ModelAndView 案例说明： 创建一个拥有姓名、密码和年龄的 User 类。 通过在 JSP 页面发起请求，控制器类中返回一个封装好了数据的 User 类。 在跳转成功的界面获取 User 类中封装的数据。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 测试 ModelAndView * @param modelAndView 模型与视图 * @return 返回 modelAndView 对象 */ @RequestMapping(\"/testModelAndView\") ModelAndView testModelAndView(ModelAndView modelAndView) { User user = new User(); user.setUsername(\"12\"); user.setPassword(\"123\"); user.setAge(11); modelAndView.addObject(\"user\", user); modelAndView.setViewName(\"success\"); return modelAndView; } } index 界面 testModelAndView success 界面 跳转成功 账号：${user.username} 密码：${user.password} 年龄：${user.age} 使用 forward 和 redirect 关键字 案例说明： 通过在 JSP 页面发起请求，控制器类中分别使用 SpringMVC 的关键字进行转发和重定向的方法响应视图页面。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 使用关键字的方式进行转发或重定向（不会使用视图解析器）。 * @return 转发或重定向的目标位置 */ @RequestMapping(\"/testForwardOrRedirect\") String testForwardOrRedirect() { /*1、转发（不会使用视图解析器） return \"forward:/WEB-INF/pages/success.jsp\";*/ // 2、重定向（无法跳转至 WEB-INF 下，且不会使用视图解析器） return \"redirect:success2.jsp\"; } } index 界面 testForwardOrRedirect success 界面 跳转成功 success2 界面 跳转成功 JSON 数据处理过滤静态资源 案例说明： 由于 dispatcherServlet 会拦截所有的资源，导致在请求静态资源时也会被拦截。为此需要通过 SpringMVC 的配置文件配置对静态资源不进行拦截。 代码演示： &lt;!-- 设置不拦截的资源（静态资源），静态资源在 WEB-INF 的 static 文件夹下。 --> &lt;mvc:resources mapping=\"/static/**\" location=\"/static/\"/> index 界面 $(function () { $(\"#testAjax\").click(function () { alert(\"hello\"); }); }); JSON 数据处理 发送 AJAX 发送 AJAX 请求 案例说明： 通过 AJAX 携带 JSON 格式的数据发送 POST 请求给后端。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 模拟异步请求响应。 * @param user 获得封装好的 User 类数据。 */ @RequestMapping(\"/testAjax\") void testAjax(@RequestBody String user) { System.out.println(user); } } index 界面 $(function () { $(\"#testAjax\").click(function () { $.ajax({ url: \"/user/testAjax\", contentType: \"application/json;charset=UTF-8\", data: '{\"username\": \"你\",\"password\": 123,\"age\": 11}', dataType: \"json\", type: \"POST\", success: function (data) { //此处 data 是服务器端响应的 json 格式的数据。 } }); }); }); JSON 数据处理 发送 AJAX 响应 JSON 格式数据 案例说明： 使用 @RequestBody 将接收到的前端 JSON 格式的数据转换成 User 对象进行操作。SpringMVC 默认使用 MappingJacksonHttpMessageConverter 对 JSON 格式的数据进行转换，其中需要加入三个 jackson 的包。 jackson-annotation.jar jackson-databind.jar jackson-core.jar 使用 @ResponseBody 将 User 对象转换成 JSON 格式的数据响应给前端。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/19 13:40 * @Description 响应数据和结果视图控制器 */ @Controller @RequestMapping(\"/user\") public class UserController { /** * 模拟异步请求响应。 * @param user 获得封装好的 User 类数据。 */ @RequestMapping(\"/testAjax\") @ResponseBody User testAjax(@RequestBody User user) { // 客户端发送 AJAX 请求传送的是 JSON 格式的数据，后端把 JSON 格式的数据封装到对应的对象中（此处为 User）。 System.out.println(user); // 将获得的对象修改其中姓名属性并返回。 user.setUsername(\"我\"); return user; } } index 界面 $(function () { $(\"#testAjax\").click(function () { $.ajax({ url: \"/user/testAjax\", contentType: \"application/json;charset=UTF-8\", data: '{\"username\": \"你\",\"password\": 123,\"age\": 11}', dataType: \"json\", type: \"POST\", success: function (data) { //此处 data 是服务器端响应的 json 格式的数据。 console.log(\"username:\" + data.username); console.log(\"password\" + data.password); console.log(\"age\" + data.age); } }); }); }); JSON 数据处理 发送 AJAX document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（四）：常用注解","date":"2019-09-19T05:19:32.000Z","path":"posts/54418/","text":"RequestParam 作用：把请求中指定名称的参数赋值给控制器中的形参。 属性： value：请求参数中的名称。 required：请求参数中是否必须提供此参数。（默认 true） 关键代码演示： @requestParam /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试 */ @Controller @RequestMapping(\"/annotation\") public class AnnotationController { /** * 测试 @RequestParam * @param username 账户名 * @param password 密码 * @return 返回到 success 页面 */ @RequestMapping(\"/testRequestParam\") String testRequestParam(@RequestParam String username, @RequestParam(\"pw\") String password) { // 此处前端必须提供 username 和 pw 的值，此处将前端 username 的值传给 username，而 pw 的值传给 password。 System.out.println(\"username=\" + username + \";password=\" + password); return \"success\"; } } RequestBody 作用：用于获取请求体内容，得到 key = value 格式的数据，不适用于 get 请求。 属性： required：请求参数中是否必须提供此参数（默认 true）。为 true 时，get 请求方式报错；为 false 时，get 请求得到 null 值。 关键代码演示： 账号： 密码： /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试 */ @Controller @RequestMapping(\"/annotation\") public class AnnotationController { /** * 测试 @RequestBody * @param requestBody 请求参数体 * @return 返回到 success 页面 */ @RequestMapping(\"/testRequestBody\") String testRequestBody(@RequestBody String requestBody) { System.out.println(requestBody); return \"success\"; } } PathVariable 作用：用于绑定 URL 中的占位符，常用于 REST 风格URL。例如：/delete/{id}，其中{id}就是 URL 占位符。 属性： value：用于指定 URL 中占位符名称。 required：是否必须提供占位符。 关键代码演示： @PathVariable /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试 */ @Controller @RequestMapping(\"/annotation\") public class AnnotationController { /** * 测试 @PathVariable * @param username REST 风格 URL 参数 * @return 返回到 success 页面 */ @RequestMapping(\"/testPathVariable/{username}\") String testPathVariable(@PathVariable String username) { System.out.println(username); return \"success\"; } } 衍生问题：form 只支持 GET 与 POST 请求，因此可以使用 HiddenHttpMethodFilter 过滤器更改指定的请求。如果 controller 方法上不添加 @ResponseBody 会报 jsp 不支持该方法，这是因为在tomcat8以上版本是不支持 delete 和 post 请求，此时可以通过 @ResponseBody 注解解决问题，但后端无法直接跳转页面。 解决方法： &lt;!-- 支持更多的表单提交方式，出现 web-app 报错需要升级 xml 的头部信息 --> &lt;filter> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> 账号： /** * 测试 @PathVariable。 * * @param username REST 风格 URL 参数 * @return 返回到 success 页面 */ @RequestMapping(value = \"/testPathVariable/{username}\", method = RequestMethod.DELETE) @ResponseBody String testPathVariable(@PathVariable String username) { System.out.println(\"删除：\" + username); return \"success\"; } RequestHeader 作用：用于获取请求消息头。 属性： 提供消息头名称。 是否必须有此消息头。 关键代码演示： @RequestHeader /** * 测试 @RequestHeader * @param header 获取某个具体头属性的值。 * @return 返回到 success 页面。 */ @RequestMapping(\"testRequestHeader\") String testRequestHeader(@RequestHeader(\"Accept\") String header) { System.out.println(header); return \"success\"; } CookieValue 作用：用于把指定 cookie 名称的值传入控制器方法参数。 属性： value：指定 cookie 的名称。 required：是否必须有此 cookie。 关键代码演示： @CookieValue /** * 测试 @CookieValue * @param cookieValue 获取某个具体 cookie 的值。 * @return 返回到 success 页面。 */ @RequestMapping(\"testCookieValue\") String testCookieValue(@CookieValue(\"JSESSIONID\") String cookieValue) { System.out.println(cookieValue); return \"success\"; } ModelAttribute 作用：可以作用于参数和方法上。作用于参数上时，获取指定的数据给参数赋值；作用于方法上时，表示当前方法会在控制器的其它方法执行前执行。 属性： value：用于获取数据的 key。key 可以是 POJO的属性名称，也可以是 map 结构的 key。 应用场景：当表单提交的数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原有的数据。例如用户类拥有账号和密码两个字段，而对数据库用户进行更新时规定账号不能进行修改，只能对密码进行修改，因此一旦进行更新时账号字段就会变为 null，此时就可以使用此注解解决该问题。 案例说明：提交的 User 类是没有被填充 Date 属性的，在 controller 方法中将 Date 属性进行填充。 关键代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/16 22:03 * @Description 用户实体 */ public class User implements Serializable { // 省略了 get 和 set private String userName; private Integer age; private Date date; @Override public String toString() { return \"User{userName=\" + userName + \", age=\" + age + \", date=\" + date + \"}\"; } } 姓名： 年龄： ModelAttribute 修饰方法带返回值constUserName() 会先获得一个拥有 Date 属性的 User 类，然后将 testModelAttribute() 获得的 User 类其他属性填充入之前的 User 类。 /** * 测试 @ModelAttribute * @param user 获取用户设置好名字和年龄的 User 类属性，并将该 User 类的属性填充入之前 constUserName 的 User 类中，最终获得的是在 constUserName * 返回的类上填充了名字和年龄的 User 类。 * @return 返回到 success 页面。 */ @RequestMapping(\"testModelAttribute\") String testModelAttribute(User user) { System.out.println(user); return \"success\"; } /** * 提前获取到 User 类，并为 User 类填充 Date 属性。 * @param user 不带 Date 的 User 封装类。 * @return 将设置了 Date 的 User 封装类返回。 */ @ModelAttribute User constUserName(User user) { user.setDate(new Date()); return user; } ModelAttribute 修饰方法不带返回值 /** * 测试 @ModelAttribute * @param user 从 map 获取 User 类，并将从请求中获得的 User 类属性封装入该 User 类中。 * @return 返回到 success 页面。 */ @RequestMapping(\"testModelAttribute\") String testModelAttribute(@ModelAttribute(\"user\") User user) { System.out.println(user); return \"success\"; } /** * 提前获取到 User 类，并为 User 类填充 Date 属性，将封装好的 User 装入 map 中。 * @param user 不带 Date 的 User 封装类。 * @param map 用于存储封装好的 User 类。 */ @ModelAttribute void constUserName(User user, Map&lt;String, User> map) { user.setDate(new Date()); map.put(\"user\", user); } SessionAttributes 作用：用于多次执行控制器方法间的参数共享，作用于类上。（SessionAttribute 作用于参数前，为形参赋值。） 属性： value：用于指定存入的属性名称。 type：用于指定存入的数据类型。 关键代码演示： index 界面 SpringMVC 常用注解 @SessionAttribute Get @SessionAttribute Delete @SessionAttribute /** * @Author 喵粮都输光了 * @Date 2019/9/18 14:35 * @Description SpringMVC 常用注解测试。 @SessionAttributes(\"test\") 表示将request 域中的 key 为 test 的值存一份在 session 域中。 */ @Controller @RequestMapping(\"/annotation\") @SessionAttributes(\"test\") public class AnnotationController { /** * 测试 @SessionAttribute * @param model 可以将值存入 request 域，map 格式。 * @return 返回到 success 页面。 */ @RequestMapping(\"testSessionAttributes\") String testSessionAttributes(Model model) { // 此处将值存入 request 域。 model.addAttribute(\"test\", \"测试用数据。\"); return \"success\"; } /** * 测试获取 session 域中的值。 * @param modelMap 可以从 session 域获取值，map 格式。 * @return 返回到 success 页面。 */ @RequestMapping(\"testGetSessionAttributes\") String testGetSessionAttributes(ModelMap modelMap) { String test = (String) modelMap.get(\"test\"); System.out.println(test); return \"success\"; } /** * 清空 session 域。 * @param sessionStatus 获得 session 域的状态。 * @return 返回到 success 页面。 */ @RequestMapping(\"testDeleteSessionAttributes\") String testDeleteSessionAttributes(SessionStatus sessionStatus) { sessionStatus.setComplete(); return \"success\"; } } success 界面 跳转成功 request:${requestScope.get(\"test\")} session:${sessionScope.get(\"test\")} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（三）：请求参数绑定","date":"2019-09-16T13:02:47.000Z","path":"posts/25820/","text":"请求参数绑定机制 请求的数据都是 key = value 格式的。 SpringMVC 的参数绑定过程是把请求的参数绑定至控制器中方法的参数上。 提交数据的 key 和参数的名称必须相同。 支持的数据类型有三种： 基本数据类型和字符串类型。 实体类型。 集合数据类型。 GET 请求参数绑定 案例说明：通过 JSP 页面&lt;a&gt;标签向 controller 发起 GET 请求（携带 username 和 password 两参数）。 代码演示：基本数据类型和字符串类型。 /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * GET 请求基本类型参数绑定测试 * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/testGetParam\") String testGetParam(String username, String password) { System.out.println(\"执行成功。username = \" + username + \";password = \" + password); return \"success\"; } } index 界面 SpringMVC 请求参数绑定 请求参数绑定测试 POST 请求参数绑定 案例说明： Account 实体类中包含 User 实体类。 JSP 页面通过表单向 controller 发起 POST 请求（携带 Account 实体）。 使用 POST 提交数据中如果有中文会导致 controller 获得的数据是乱码。此处可以通过在 web.xml 中配置 filter 解决乱码问题(filter 标签必须在 servlet 标签之前）。 代码演示1：实体类型。 &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" > &lt;web-app> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!-- 中文乱码解决过滤器，filter 需要放置在 servlet 前，否则&lt;/web-app>标签会报错。 --> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;!-- 该类存在 servlet-api.jar 中，用于直接配置 servlet 拦截请求（前端控制器） --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 配置 springmvc 启动 --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring-mvc.xml&lt;/param-value> &lt;/init-param> &lt;!-- 启动服务器就创建了 servlet 对象。（不配置时，只有请求过来时才会进行创建。） --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> /** * @Author 喵粮都输光了 * @Date 2019/9/16 22:03 * @Description 用户实体 */ public class User implements Serializable { // 省略了 get 和 set private String userName; private Integer age; @Override public String toString() { return \"User{userName=\" + userName + \", age=\" + age + \"}\"; } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:42 * @Description 账户实体类 */ public class Account implements Serializable { // 省略了 get 和 set private String username; private String password; private Double money; private User user; @Override public String toString() { return \"Account{username=\" + username + \", password=\" + password + \", money=\" + money + \", \" + user + \"}\"; } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * POST 请求实体参数绑定测试 * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/testPOSTParam\") String testPOSTParam(Account account) { System.out.println(account); return \"success\"; } } index 界面 SpringMVC 请求参数绑定 账号： 密码： 金额： 姓名： 年龄： 代码演示2：集合类型。（与上区别仅在 Account、ParamController 类和 index.jsp 页面。且在开发中，前端使用这样的方法进行传值会遭成高耦合性，因此都是通过 json 的格式来传递参数。） /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:42 * @Description 账户实体类 */ public class Account implements Serializable { private String username; private String password; private Double money; private List&lt;User> list; private Map&lt;String, User> map; // 省略了 get 和 set @Override public String toString() { return \"Account{username=\" + username + \", password=\" + password + \", money=\" + money + \", list=\" + list + \", map=\" + map + \"}\"; } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * POST 请求集合类型参数绑定测试 * * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/testPostCollectionsParam\") String testPostCollectionsParam(Account account) { System.out.println(account); return \"success\"; } } index 界面 SpringMVC 请求参数绑定 账号： 密码： 金额： 姓名（list）： 年龄（list）： 姓名（map）： 年龄（map）： 自定义类型转换器 案例说明： User 实体类包含姓名、年龄和生日日期。 JSP 页面通过表单向 controller 发起 POST 请求（携带 User 实体）。 使用 POST 提交数据如果日期的格式不是yyyy/MM/dd会发生格式转换错误，此时新建自定义类型转换器类实现 Converter 并在 spring-mvc.xml 中配置转换器解决该问题。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/18 12:00 * @Description 字符串转换日期的自定义类型转换器。（String 表示传入进来的值，Date 是需要将String 转换成的目标类型。） */ public class StringToDateConverter implements Converter&lt;String, Date> { @Override public Date convert(String source) { if (source != null) { // 自定义需要转换成的格式。 DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); // 进行转换。 try { return dateFormat.parse(source); } catch (ParseException e) { throw new RuntimeException(\"数据类型转换出现异常。\"); } } else { throw new RuntimeException(\"请您传入数据。\"); } } } /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * POST 请求自定义类型转换器测试 * * @return 返回到 success.jpg 页面 */ @RequestMapping(\"/customTypeConverter\") String customTypeConverter(User user) { System.out.println(user); return \"success\"; } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.springmvc\"/> &lt;!-- 视图解析器对象 --> &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> &lt;!-- 配置自定义类型转换器（需要在 SpringMVC 框架注解支持上填入配置的 ConversionServiceFactoryBean 的 id。 --> &lt;bean id=\"conversionServiceFactoryBean\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"> &lt;property name=\"converters\"> &lt;set> &lt;bean class=\"com.kuukokawaii.utils.StringToDateConverter\"/> &lt;/set> &lt;/property> &lt;/bean> &lt;!-- 开启 SpringMVC 框架注解的支持 --> &lt;mvc:annotation-driven conversion-service=\"conversionServiceFactoryBean\"/> &lt;/beans> index 界面 SpringMVC 请求参数绑定 姓名： 年龄： 生日： Servlet 原生 API 案例说明：在 controller 中使用 servlet 的原生 API。 关键代码演示： Servlet 原生 API 测试 /** * @Author 喵粮都输光了 * @Date 2019/9/16 21:11 * @Description 参数请求绑定测试 Controller */ @Controller @RequestMapping(\"/param\") public class ParamController { /** * 测试 servlet 原生 API * @param request servlet 请求 * @param response servlet 响应 * @return 返回到 success 页面 */ @RequestMapping(\"/testServlet\") String testServlet(HttpServletRequest request, HttpServletResponse response) { HttpSession session = request.getSession(); System.out.println(request); System.out.println(session); System.out.println(response); return \"success\"; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"SpringMVC（二）：环境搭建","date":"2019-09-14T02:42:03.000Z","path":"posts/39549/","text":"案例说明 启动服务器时加载一些配置文件。 DispatcherServlet 对象创建。 SpringMVC 配置文件加载。 HelloController 对象创建。 发送请求，通过 HelloController 处理请求并跳转至 success.jsp 页面。 使用到的 Jar 包 spring-context.jar spring-web.jar（Spring Web 整合） spring-webmvc.jar（SpringMVC 核心） servlet-api.jar(用于提供 DispatcherServlet 类) jsp-api.jar（servlet-api 的依赖） 注解作用@RequestMapping(path\\value = \"\", method = {RequestMethod.POST}, params = {\"\"}, headers = {\"\"\"})：用于建立请求 URL 和处理请求方法之间的对应关系。 可作用于方法和类上。作用于类上便相当于请求 URL 的第一级访问目录，需要以/开头；而作用于方法就相当于请求 URL 的第二级访问目录。 path 和 value 作用是相同的，都是请求路径的映射（如果只有 value 单个属性则可省略）。 method：用于指定请求的方法（GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE）。 params：用于指定限制请求参数的条件。要求请求的参数的 key 和 value 必须和配置的一模一样。 headers：用于指定限制请求消息头的条件，即发送的请求中必须包含的请求头。 代码演示&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.springmvc\"/> &lt;!-- 视图解析器对象 --> &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> &lt;!-- 开启 SpringMVC 框架注解的支持 --> &lt;mvc:annotation-driven/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/13 13:36 * @Description a 标签跳转 controller 类 */ @Controller public class HelloController { /** * 输出测跳转 * @return 返回到 success.jpg 页面 */ @RequestMapping(path = \"/hello\") String sayHello() { System.out.println(\"Hello SpringMVC\"); return \"success\"; } } &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" > &lt;web-app> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!-- 该类存在 servlet-api.jar 中，用于直接配置 servlet 拦截请求（前端控制器） --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 配置 springmvc 启动 --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring-mvc.xml&lt;/param-value> &lt;/init-param> &lt;!-- 启动服务器就创建了 servlet 对象。（不配置时，只有请求过来时才会进行创建。） --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> index 界面 SpringMVC 测试 跳转小程序 success 界面 跳转成功 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"Maven：No Archetype Found","date":"2019-09-12T13:53:17.000Z","path":"posts/6576/","text":"问题在创建 maven 项目时，选择 org.apache.maven.archetypes:maven-archetype-webapp 的 archetype 时，出现项目初始化失败的情况。报错情况如下： 解决方法在创建项目时，配置 archetypeCatalog 的属性为 internal 即可解决问题。 分析给 maven 配置了阿里源导致了如上问题，可能是阿里源的 archetype-catalog.xml 文件出现了问题。其中 archetype-catalog.xml 能提供 Archetype 的信息，常用的属性有 internal、local 和 remote 三个属性。 internal：maven-archetype-plugin 内置的 Archetype Catalog。 local：指向本地的 Archetype Catalog ，其位置为~/.m2/archetype-catalog.xml。需要注意的是，该文件默认是不存在的。 remote：指向了Maven中央仓库的Archetype Catalog。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"problem","slug":"problem","permalink":"https://blog.kuukokawaii.com/tags/problem/"},{"name":"maven","slug":"maven","permalink":"https://blog.kuukokawaii.com/tags/maven/"}]},{"title":"SpringMVC（一）：简介","date":"2019-09-09T06:44:00.000Z","path":"posts/18696/","text":"服务器三层架构JavaEE 常基于 B/S 架构进行开发，而在 B/S 架构中系统标准的三层架构包括：表现层、业务层和持久层。 表现层（web 层）表现层用于接收客户端请求，并向客户端响应结果。它包括展示层和控制层，其中展示层负责展示结果，而控制层负责接收请求。因此表现层依赖于业务层，当接收到客户端的请求时一般会调用业务层进行处理，并将处理结果返回给客户端。 业务层（service 层）业务层负责业务逻辑的处理，当需要对数据进行持久化操作时需要保证事务的一致性，因此业务层可能依赖于持久层，且事务应该在业务层进行控制。 持久层（dao 层）持久层负责数据持久化操作，包括数据层即数据库和数据访问层，其中数据库是对数据进行持久化的载体，而数据访问层是业务层和持久层交互的接口。业务层需要通过数据访问层将数据持久化到数据库中。 MVC 设计模型MVC（Model View Controller）是一种用于设计创建 Web 应用程序表现层的模式，它包括 Model、View 和 Controller 三部分： Model（模型）：常指数据模型，一般用于封装数据。例如 JavaBean。 View（视图）：常指前端视图，一般用于显示数据。例如 Html。 Controller（控制器）：是应用程序中处理用户交互的部分，一般用于处理程序逻辑。例如 Servlet。 SpringMVC 架构 SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架。它通过一套注解让一个简单的 Java 类成为处理请求的控制器，而无需实现任何接口。同时它还支持 RESTful 编程风格的请求。 SpringMVC 拥有诸多优势，例如： 是基于模块化开发的架构，拥有清晰的角色划分。 可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 可定制，通过 HandlerMapping、ViewResolver 等能够非常简单的进行定制。 功能强大的数据验证、格式化、绑定机制。 利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 SpringMVC 工作流程 概念DispatcherServlet：Spring 前端控制器（中央调度器），它是整个请求响应的控制中心，组件的调用由它统一调度。HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler。HandlerAdapter：处理器适配器，它调用 Handler 执行具体的业务操作并返回逻辑视图 ModelAndView 对象。Handler：Handler，对用户具体请求进行处理（相当于 controller 类）。ModelAndView 对象：逻辑视图。ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图。 工作流程如图工作流程可以大致划分为如下步骤： 用户向服务器发送请求，请求被 DispatcherServlet 捕获。 DispatcherServlet 对请求的 URL 进行解析，得到 URI。然后根据 URI 调用 HandlerMapping 获得具体的处理器 Handler 并返回给 DispatcherServlet。 DispatcherServlet 根据获取的 Handler，选择一个合适的 HandlerAdapter。 提取 Request 中的模型数据作为 Handler 的参数并执行。（此处可做 HttpMessageConverter，数据转换、数据格式化和数据验证等操作。） Handler 执行完成后，HandlerAdapter向 DispatcherServlet 返回一个 ModelAndView 对象，其中 view 是视图名称，并不是真正的视图对象。 根据返回的 ModelAndView 对象选择一个合适的 ViewResolver 返回给 DispatcherServlet（必须是已经注册到Spring容器中的 ViewResolver）。 DispatcherServlet 将 ModelAndView 对象传给 ViewResolver。 ViewResolver 解析后返回具体的 View（例如 html、JSP 等）。 DispatcherServlet 对 View 进行渲染视图，即将数据模型填充到视图中。 DispatcherServlet 对用户进行响应。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://blog.kuukokawaii.com/tags/springmvc/"}]},{"title":"Spring（七）：Transaction","date":"2019-09-05T07:36:22.000Z","path":"posts/37736/","text":"什么是事务（Transaction）事务是逻辑上的一组操作，要么都执行，要么都不执行。例如某人要在商店使用电子货币购买100元的东西，当中至少包括两个操作：1.该人账户减少100元；2.商店账户增加100元。这两操作需要同时进行，否则就会出现100元平白消失或出现的情况。因此可以得知事务具有 ACID 的性质。 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）：执行事务前后，数据保持一致； 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 事务隔离 事务隔离级别即定义一个事务可能受其他并发时间事务影响的程度。例如多个用户对统一数据操作会导致如下问题的发生： 脏读（Dirty read）：当一个事务读取到另一个事务正在进行修改却还没有提交到数据库中的数据便称为脏读，而读取到的数据被称为脏数据，依据脏数据所作的操作可能是不对的。 丢失修改（Lost to modify）：两个事务同时读取修改同一数据，后提交事务的修改结果破坏了先提交事务的修改结果，导致先提交事务的修改被丢失。 不可重复读（Unrepeatable read）：指在一个事务内多次读同一数据。当事务 A 读取了数据还未进行提交操作时，而事务 B 也读取了该数据并对其数据进行了修改、提交。此时事务 A 再次读取数据时会发现第一次读取的数据可能与第二次读取的数据是不一样的。即同一个事务内两次读取同一数据其结果却不一样，这样的情况称为不可重复度。常发生于 update 操作之上。 幻读（Phantom read）：幻读与不可重复读相似，其区别在于幻读发生于 insert 操作之上。即事务 A 读取了数据还未进行提交操作时，事务 B 也读取了该数据并对其数据进行了插入、提交操作。导致事务 A 再次读取该数据时发现多出了一些不存在的记录，因此称为幻读。 事务隔离级别的出现就是为了解决如上四个问题的发生，常用事务隔离级别作用如下： 读未提交（Read uncommitted）：一个事务可以读取另一个未提交事务的数据。没有解决上述任何问题。 读已提交（Read committed）：一个事务要等另一个事务提交后才能读取数据。解决了脏读的问题。 可重复读（Repeatable read）：在事务开始读取数据时不再允许修改操作。解决了丢失修改、不可重复读和脏读的问题。 序列化（Serializable）：序列化是最高的事务隔离级别，在该级别下事务串行化顺序执行。解决了上述所有问题。 Spring 事务管理接口 PlatformTransactionManager（平台事务管理器）：Spring 必须使用事务管理器才能管理事务。 常用的事务管理器DataSourceTransactionManager：Jdbc 或 Mybatis 开发使用，采用 JdbcTemplate 或 整合 Mybatis。HibernateTransactionManager：Hibernate 开发使用，整合 Hibernate。 TransactionDefinition（事务属性）：Spring 用于确定事务具体详情。例如事务隔离级别、传播行为、超时、只读、回滚规则等。当进行事务配置时必须配置详情，Spring 会将配置项封装到该对象实例。 传播行为事务的传播行为规定了事务方法和事务方法发生嵌套调用时事务是如何进行传播，Spring 为其定义了七种类型的事务传播行为：1. PROPAGATION_REQUIRES（传播行为默认值）：如果当前有事务则加入该事务（即支持当前事务）;如果当前没事务则新建一个事务。 2. PROPAGATION_SUPPORTS：支持当前事务，如果当前没事务则以非事务方式执行。 3. PROPAGATION_MANDATORY：支持当前事务，如果当前没事务则抛出异常。 4. PROPAGATION_REQUIRES_NEW：无论有无事务都新建一个事务且如果当前有事务则挂起该事务（即不支持当前事务）。 5. PROPAGATION_NOT_SUPPORTED：无论有无事务都以非事务方式执行且不支持当前事务。 6. PROPAGATION_NEVER：如果当前有事务则抛出异常；如果当前没事务则以非事务方式执行。 7. PROPAGATION_NESTED：如果当前有事务则在该事务内嵌套一个事务执行；如果当前没事务则新建一个事务。 TransactionStatus（事务运行状态）：Spring 用于记录当前事务运行状态。例如事务是否有保存点、是否回滚、是否完成等。Spring 底层会根据状态进行相应的操作。 案例说明 通过事务模板 TransactionTemplate 进行操作（手动管理事务）。 Spring 配置 TransactionTemplate，并注入给 Service。 配置事务管理器（注入 TransactionTemplate，即注入 DataSource）。 工厂 bean 生成代理（半自动）。Spring 提供管理事务的代理工厂 bean：TransactionProxyFactoryBean。 获取代理对象。 Spring 配置代理。 AOP 配置基于 xml在 Spring XML 中配置 AOP 自动生成代理，并进行事务的管理。 配置事务管理器。 配置事务属性。 配置 AOP。 AOP 配置基于注解 配置事务管理器并交予 Spring。 在目标类或目标方法添加注解（@Transactional）。 使用到的部分 Jar 包 spring-tx.jar spring-jdbc.jar spring-orm.jar：Spring 提供对部分 ORM（对象关系映射将关系数据库中表的数据映射成为对象）框架的支持。 代码演示/** * @Author 喵粮都输光了 * @Date 2019/9/7 15:26 * @Description 账户持久层接口 */ public interface AccountDao { /** * 支出 * @param outer 支出者 * @param money 支出金额 */ void expense(String outer, Integer money); /** * 收入 * @param inner 收入者 * @param money 收入金额 */ void income(String inner, Integer money); } /** * @Author 喵粮都输光了 * @Date 2019/9/7 15:22 * @Description 账户持久层实现类 */ public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao { @Override public void expense(String outer, Integer money) { Objects.requireNonNull(this.getJdbcTemplate()).update(\"UPDATE account SET money = money - ? WHERE username = ?\", money, outer); } @Override public void income(String inner, Integer money) { Objects.requireNonNull(this.getJdbcTemplate()).update(\"UPDATE account SET money = money + ? WHERE username = ?\", money, inner); } } jdbc.driverClass=com.mysql.cj.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql://localhost:3306/所使用的库名 jdbc.user=账号 jdbc.password=密码 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- dao --> &lt;bean id=\"accountDao\" class=\"com.kuukokawaii.transaction.account.dao.AccountDaoImpl\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- service --> &lt;bean id=\"accountService\" class=\"com.kuukokawaii.transaction.account.service.AccountServiceImpl\"> &lt;property name=\"accountDao\" ref=\"accountDao\"/> &lt;property name=\"transactionTemplate\" ref=\"transactionTemplate\"/> &lt;/bean> &lt;!-- 创建 TransactionTemplate --> &lt;bean id=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\"> &lt;property name=\"transactionManager\" ref=\"txManager\"/> &lt;/bean> &lt;!-- 配置事务管理器，管理器管理事务，事务存在于 service、dao 等中，它们都可以从 Connection 中获得，而连接从连接池获得，所以需要配置的是连接池。 --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/7 15:34 * @Description Account Service */ public interface AccountService { /** * 转账 * @param outer 支出者 * @param inner 收入者 * @param money 金额 */ void transfer(String outer, String inner, Integer money); } 手动管理事务/** * @Author 喵粮都输光了 * @Date 2019/9/7 15:36 * @Description AccountService实现类 */ public class AccountServiceImpl implements AccountService { private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) { this.transactionTemplate = transactionTemplate; } @Override public void transfer(String outer, String inner, Integer money) { transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus status) { accountDao.expense(outer, money); accountDao.income(inner, money); } }); } } /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ public class AccountServiceImplTest { /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); AccountService accountService = applicationContext.getBean(\"accountService\", AccountService.class); accountService.transfer(\"jack\", \"r\", 1000); } } 半自动&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- dao --> &lt;bean id=\"accountDao\" class=\"com.kuukokawaii.transaction.account.dao.AccountDaoImpl\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- service --> &lt;bean id=\"accountService\" class=\"com.kuukokawaii.transaction.account.service.AccountServiceImpl\"> &lt;property name=\"accountDao\" ref=\"accountDao\"/> &lt;/bean> &lt;!-- service proxy： proxyInterfaces：目标类接口 target：目标类 transactionManager：事务管理器 transactionAttributes：配置 transactionDefinition key：确定哪些方法使用当前事务配置。（一般方法名） value：用于配置事务属性。即 transactionDefinition 格式：PROPAGATION, ISOLATION, readOnly, -Exception, +Exception（其中-Exception为发生这些异常就回滚，+Exception为发生这些异常仍然提交。） --> &lt;bean id=\"proxyAccountService\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"> &lt;property name=\"proxyInterfaces\" value=\"com.kuukokawaii.transaction.account.service.AccountService\"/> &lt;property name=\"target\" ref=\"accountService\"/> &lt;property name=\"transactionManager\" ref=\"txManager\"/> &lt;property name=\"transactionAttributes\"> &lt;props> &lt;prop key=\"transfer\">PROPAGATION_REQUIRED, ISOLATION_DEFAULT&lt;/prop> &lt;/props> &lt;/property> &lt;/bean> &lt;!-- dataSourceTransactionManager --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ public class AccountServiceImplTest { /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); AccountService accountService = applicationContext.getBean(\"proxyAccountService\", AccountService.class); accountService.transfer(\"jack\", \"r\", 1000); } } AOP 配置基于 xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd\"> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- dao --> &lt;bean id=\"accountDao\" class=\"com.kuukokawaii.transaction.account.dao.AccountDaoImpl\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- service --> &lt;bean id=\"accountService\" class=\"com.kuukokawaii.transaction.account.service.AccountServiceImpl\"> &lt;property name=\"accountDao\" ref=\"accountDao\"/> &lt;/bean> &lt;!-- dataSourceTransactionManager --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 事务通知（事务属性）：&lt;tx:method name=\"transfer\" propagation=\"REQUIRES_NEW\" isolation=\"DEFAULT\"/> --> &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"> &lt;tx:attributes> &lt;tx:method name=\"transfer\"/> &lt;/tx:attributes> &lt;/tx:advice> &lt;!-- AOP --> &lt;aop:config> &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.kuukokawaii.transaction.account.service.*.*(..))\"/> &lt;/aop:config> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ public class AccountServiceImplTest { /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); AccountService accountService = applicationContext.getBean(\"accountService\", AccountService.class); accountService.transfer(\"jack\", \"r\", 1000); } } AOP 配置基于注解此处Service层添加了@Service注解。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.transaction.account\"/> &lt;!-- jdbc properties --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- c3p0 datasource --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- jdbcTemplate --> &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- dataSourceTransactionManager --> &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 事务注解开启： transaction-manager：将事务管理器交予 Spring。 proxy-target-class： true：底层强制使用 CGLIB 代理。 false：自动选择。 --> &lt;tx:annotation-driven transaction-manager=\"txManager\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/7 15:22 * @Description 账户持久层实现类 */ @Repository public class AccountDaoImpl implements AccountDao { private final JdbcTemplate jdbcTemplate; @Autowired public AccountDaoImpl(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @Override public void expense(String outer, Integer money) { jdbcTemplate.update(\"UPDATE account SET money = money - ? WHERE username = ?\", money, outer); } @Override public void income(String inner, Integer money) { jdbcTemplate.update(\"UPDATE account SET money = money + ? WHERE username = ?\", money, inner); } } /** * @Author 喵粮都输光了 * @Date 09/07/2019 * @Description AccountServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class AccountServiceImplTest { @Autowired private AccountService accountService; /** * Method: transfer(String outer, String inner, Integer money) */ @Test public void testTransfer() throws Exception { accountService.transfer(\"jack\", \"r\", 1000); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（六）：JDBCTemplate","date":"2019-09-04T08:49:50.000Z","path":"posts/63918/","text":"什么是 JDBCTemplateSpring 为传统的 JDBC 进行封装,简化持久层操作。通过使用 Spring 的注入功能，可以把 DataSource 注册到 JDBCTemplate 之中。 案例说明 通过 API 对 dbcp 进行操作。 通过 Spring 配置使用 DBCP。 使用 C3P0 连接池。 通过 JdbcDaoSupport 直接获取 JdbcTemplate，并用 properties 文件存储连接池属性。 使用到的部分 Jar 包 spring-tx.jar：负责在 Spring 框架中实现事务管理功能。 c3p0.jar：开源的 JDBC 连接池。 commons-dbcp.jar： 用于管理数据库连接池。依赖于 commons-pool。 commons-pool.jar： 数据库连接池。 mysql-connector-java.jar：Java 通过 JDBC 访问 mysql 数据库时使用。 commons-collections.jar：提供更多的接口。 spring-jdbc.jar：Spring 对 JDBC 数据访问进行封装的包。 代码演示直接使用 DBCP 方式/** * @Author 喵粮都输光了 * @Date 2019/9/4 18:33 * @Description 用户类 */ public class User { /** * 用户 id */ private Integer id; /** * 用户姓名 */ private String username; /** * 用户密码 */ private String password; } /** * @Author 喵粮都输光了 * @Date 09/04/2019 * @Description jdbc test */ public class UserTest { @Test public void test() throws Exception { // 创建数据源（连接池）：此处使用 dbcp BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/所使用的库名\"); dataSource.setUsername(\"账号\"); dataSource.setPassword(\"密码\"); // 创建模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); // 通过 api 操作 jdbcTemplate.update(\"INSERT INTO t_user(username, password) VALUES(?, ?);\", \"tom\", \"998\"); } } 通过 Spring 配置使用 DBCP/** * @Author 喵粮都输光了 * @Date 2019/9/4 19:15 * @Description 用户持久层类 */ public class UserDao { /** * jdbc 模板由 spring 注入。 */ private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public void update(User user) { String sql = \"UPDATE t_user SET username = ?, password = ? WHERE id = ?\"; Object[] args = {user.getUsername(), user.getPassword(), user.getId()}; jdbcTemplate.update(sql, args); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 创建数据源 --> &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"> &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/所使用的库名\"/> &lt;property name=\"username\" value=\"账号\"/> &lt;property name=\"password\" value=\"密码\"/> &lt;/bean> &lt;!-- 创建模板，需要注入数据源 --> &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 配置 dao --> &lt;bean id=\"userDao\" class=\"com.kuukokawaii.jdbctemplate.user.dao.UserDao\"> &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/04/2019 * @Description jdbc test */ public class UserTest { @Test public void test() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); UserDao userDao = applicationContext.getBean(\"userDao\", UserDao.class); User user = new User(); user.setId(1); user.setUsername(\"isolation\"); user.setPassword(\"998\"); userDao.update(user); } } C3P0仅 xml 数据池配置方式不同。 &lt;!-- 创建数据源 --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/所使用的库名\"/> &lt;property name=\"user\" value=\"账号\"/> &lt;property name=\"password\" value=\"密码\"/> &lt;/bean> JdbcDaoSupport如上述所示，那么每一个 dao 中都需要进行setJdbcTemplate的操作，造成代码的重复。而通过使用 JdbcDaoSupport，可以通过 JdbcDaoSupport 直接获取 JdbcTemplate 并对其进行应用。此处通过 properties 配置 jdbc 属性。 /** * @Author 喵粮都输光了 * @Date 2019/9/4 19:15 * @Description 用户持久层类 */ public class UserDao extends JdbcDaoSupport { public void update(User user) { String sql = \"UPDATE t_user SET username = ?, password = ? WHERE id = ?\"; Object[] args = {user.getUsername(), user.getPassword(), user.getId()}; assert this.getJdbcTemplate() != null; this.getJdbcTemplate().update(sql, args); } } jdbc.driverClass=com.mysql.cj.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql://localhost:3306/所使用的库名 jdbc.user=账号 jdbc.password=密码 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 加载配置文件 --> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;!-- 创建数据源 --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/> &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/> &lt;property name=\"user\" value=\"${jdbc.user}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;!-- 配置 dao，JdbcDaoSupport 通过给定的数据源自动创建模板。 --> &lt;bean id=\"userDao\" class=\"com.kuukokawaii.jdbctemplate.user.dao.UserDao\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;/beans> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（五）：AOP","date":"2019-09-02T05:52:48.000Z","path":"posts/43723/","text":"什么是 AOPAOP 是 OOP（Object Oriented Programming，缩写为OOP）的延续，利用 AOP 可以对业务逻辑的各个部件进行隔离，从而使得业务逻辑之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 假设有一需求如下：为 A 类中的所有方法开启事务且不修改 A 类的代码。为此需要再编写一个 B 类继承 A 类并且 B 类的所有方法都要调用 A 类的方法，且在调用方法的上下对事务进行开启和提交，这样做会发现一直在重复的编写开启提交事务的代码。而 AOP 采取横向抽取机制，取代了传统的纵向继承体系重复性代码，也就是说可以提取上述代码中的重复部分达到重复利用的效果。 手动代理JDK 动态代理JDK 动态代理即对装饰器设计模式的简化。 案例说明： 目标类：需要被代理的类，JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。 切面类：用于存放通知 MyAspect。 工厂类：用于生成代理。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:44 * @Description UserService 接口类。 */ public interface UserService { /** * 增加用户 */ void addUser(); /** * 更新用户 */ void updateUser(); /** * 删除用户 */ void deleteUser(); } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:46 * @Description UserService 实现类。 */ public class UserServiceImpl implements UserService { @Override public void addUser() { System.out.println(\"增加用户\"); } @Override public void updateUser() { System.out.println(\"更新用户\"); } @Override public void deleteUser() { System.out.println(\"删除用户\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ public class MyAspect { /** * 代理目标方法前运行。 */ public void before() { System.out.println(\"方法运行前\"); } /** * 代理目标方法后运行。 */ public void after() { System.out.println(\"方法运行后\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:49 * @Description 工厂类，用于生成代理类。 */ class MyBeanFactory { /** * 生成代理过的 UserService 对象。 * * @return 返回代理生成的 UserService 对象。 */ static UserService createProxy() { // 目标类 UserService userService = new UserServiceImpl(); // 切面类 MyAspect myAspect = new MyAspect(); /* * 代理类 = 目标类 + 切面类 * newProxyInstance参数： * 1.loader：类加载器，动态代理类运行时创建，任何类都需要类加载器将其加载到内存。一般情况使用→当前类.class.getClassLoader()。 * 2.Class[] interfaces：代理类需要实现的所有接口。 * 方式1：目标类实例.getClass().getInterfaces。该方法只能获得自己的接口，无法获得父元素的接口。 * 方式2：new Class[]{UserService.class}。该方法可以获得自己和父元素的接口。 * 3.InvocationHandler：处理类，是一个接口，必须进行实现，一般采用匿名内部类（推荐使用 lambda)。其中代理类的每一个方法执行时，都将调用一次 invoke。 * invoke参数:1.proxy： 代理对象。 * 2.method： 代理对象当前执行的方法的描述对象（反射）。 * 执行方法名：method.getName()； * 执行方法：method.invoke(对象，实际参数）； * 3.Object[] args： 方法实际参数。 */ return (UserService) Proxy.newProxyInstance(MyBeanFactory.class.getClassLoader(), userService.getClass().getInterfaces(), (proxy, method, args) -> { // 前执行 myAspect.before(); // 执行目标类的方法 Object obj = method.invoke(userService, args); // 后执行 myAspect.after(); return obj; }); } } /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { @Test public void test() throws Exception { UserService userService = MyBeanFactory.createProxy(); userService.addUser(); userService.updateUser(); userService.deleteUser(); } } 输出结果如下： CGLIB 字节码增强CGLIB 代理主要通过对字节码进行操作以控制对象的访问。CGLIB 在运行时创建目标类的子类，从而对目标类进行增强，因此无需接口便可以实现代理。 案例说明： 目标类：需要被代理的类，而 JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。 切面类：用于存放通知 MyAspect。 工厂类：用于生成代理。 使用到的 Jar 包： cglib.jar 或 spring-core.jar（Spring 核心包中整合了 cglib）。 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:46 * @Description UserService 类。 */ class UserService { void addUser() { System.out.println(\"增加用户\"); } void updateUser() { System.out.println(\"更新用户\"); } void deleteUser() { System.out.println(\"删除用户\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:49 * @Description 工厂类，用于生成代理类。 */ class MyBeanFactory { /** * 生成代理后的 UserService 对象。 * * @return 返回代理生成的 UserService 对象。 */ static UserService createProxy() { // 目标类 UserService userService = new UserService(); // 切面类 MyAspect myAspect = new MyAspect(); /* * 代理类 = 目标类 + 切面类 * 1.创建核心类 Enhancer。 * 2.设置 Enhancer 需要代理的目标类。 * 3.设置 Enhancer 的回调函数。MethodInterceptor等效 InvocationHandler。 * o:代理对象。 * method:代理对象当前执行的方法的描述对象（反射）。 * objects:方法实际参数。 * methodProxy:方法的代理。 * 4.创建代理。 */ Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(userService.getClass()); enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -> { // 前执行 myAspect.before(); // 执行目标类的方法。该句等效于 methodProxy.invokeSuper(o, objects)。执行代理类的父类，执行目标类（目标类和代理类父子关系）。 Object obj = method.invoke(userService, objects); // 后执行 myAspect.after(); return obj; }); return (UserService) enhancer.create(); } } Spring AOP 代理Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强代码。 半自动需要手动再 Spring 配置文件中配置代理。 案例说明： 目标类：需要被代理的类，JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。（此处代码与JDK 动态代理代码同） 切面类：用于存放通知 MyAspect。 工厂类：工厂类由 Spring 容器管理（配置文件配置）。 使用到的部分 Jar 包： spring-aop.jar（AOP 的实现） aopalliance.jar（AOP 联盟的规范） 代码演示： /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ public class MyAspect implements MethodInterceptor { @Override public Object invoke(MethodInvocation invocation) throws Throwable { // 代理目标方法前运行 System.out.println(\"方法运行前\"); // 手动执行目标方法 Object obj = invocation.proceed(); // 代理目标方法后运行。 System.out.println(\"方法运行后\"); return obj; } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 目标类 --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.aop.UserServiceImpl\"/> &lt;!-- 切面类 --> &lt;bean id=\"myAspect\" class=\"com.kuukokawaii.aop.MyAspect\"/> &lt;!-- 代理类：使用工厂 bean，底层调用 getObject()，返回特殊 bean。 ProxyFactoryBean：用于创建代理工厂 bean，生成特殊代理对象。 interfaces：确定接口类。 通过&lt;array>可以设置多个值，单值可以仅使用&lt;value>。 target：确定目标类。 interceptorNames：通知切面类的名称，类型 String[]。 optimize：boolean true 意思为强制使用 cglib（无论有无接口）。（如果有接口默认使用 jdk 动态代理，没有则使用 cglib 字节码增强） --> &lt;bean id=\"proxyUserService\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"> &lt;property name=\"interfaces\" value=\"com.kuukokawaii.aop.UserService\"/> &lt;property name=\"target\" ref=\"userService\"/> &lt;property name=\"interceptorNames\" value=\"myAspect\"/> &lt;/bean> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { /** * Method: addUser() */ @Test public void test() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); // 获取代理类 UserService userService = applicationContext.getBean(\"proxyUserService\", UserService.class); userService.addUser(); userService.updateUser(); userService.deleteUser(); } } 全自动在配置文件中标识所使用到的类，Spring 自动配置代理。 案例说明： 目标类：需要被代理的类，JDK 代理需要采用接口 + 实现类的方法完成，接口是必须的。（此处代码与半自动代码同） 切面类：用于存放通知 MyAspect。（此处代码与半自动代码同） 工厂类：工厂类又 Spring 容器管理（配置文件配置）。 使用到的部分 Jar 包： spring-aop.jar（AOP 的实现） aopalliance.jar（AOP 联盟的规范） aspectjweaver.jar（Spring 切入点表达式的实现） 代码演示： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 目标类 --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.aop.UserServiceImpl\"/> &lt;!-- 切面类 --> &lt;bean id=\"myAspect\" class=\"com.kuukokawaii.aop.MyAspect\"/> &lt;!-- AOP编程： 1.导入命名空间。 2.使用&lt;aop:config>进行配置。proxy-target-class=\"true\"，true：cglib；false：jdk动态代理 &lt;aop:pointcut>：切入点，从目标对象获得具体方法。 切入点表达式：execution(* com.kuukokawaii.aop.*.*(..))：修饰符(可省略) 返回值 包(可省略).类(可省略).方法(参数) throws(可省略)；expression=\"execution()||execution()\" 可匹配多个。 within：匹配包或子包中的方法。 this：匹配实现接口的代理对象中的方法。 target：匹配实现接口的目标对象中的方法。 args：匹配参数格式符合标准的方法。 bean：匹配指定 bean 中的方法。 &lt;aop:advisor>：特殊切面，包含一个通知和切入点。 advice-ref：通知引用， pointcut-ref：切入点引用。 --> &lt;aop:config> &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.kuukokawaii.aop.*.*(..))\"/> &lt;aop:advisor advice-ref=\"myAspect\" pointcut-ref=\"myPointcut\"/> &lt;/aop:config> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { /** * Method: addUser() */ @Test public void test() throws Exception { String xml = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xml); // 获取目标类 UserService userService = applicationContext.getBean(\"userService\", UserService.class); userService.addUser(); userService.updateUser(); userService.deleteUser(); } } AspectJAspectJ 是一个基于 Java 语言的 AOP 框架，它扩展了 Java 语言并提供了一个专门的编译器，在编译时提供横向代码的植入。Spring AOP 引入了对 AspectJ 的支持。 案例说明： 目标类：采用接口 + 实现类的方法。（此处代码与全自动代码同） 切面类：编写多个通知，采用 AspectJ 通知名称任意（方法名任意）。 使用到的部分 Jar 包： spring-aop.jar（AOP 的实现） aopalliance.jar（AOP 联盟的规范） aspectjweaver.jar（Spring 切入点表达式的实现） spring-aspects.jar（提供对 AspectJ 的支持） 代码演示： 基于 XML 配置 /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ public class MyAspect { /** * 前置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ void myBefore(JoinPoint joinPoint) { System.out.println(\"前置通知。\" + joinPoint.getSignature().getName()); } /** * 后置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 * @param returning 用于获取返回值。 */ void myAfterReturning(JoinPoint joinPoint, Object returning) { System.out.println(\"后置通知。\" + joinPoint.getSignature().getName() + \"，返回值：\" + returning); } /** * 环绕通知。 * * @param proceedingJoinPoint 连接点 * @return 返回目标方法。 * @throws Throwable 方法执行异常。 */ Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // 前 System.out.println(\"环绕前\"); // 手动执行目标方法。 Object obj = proceedingJoinPoint.proceed(); // 后 System.out.println(\"环绕后\"); return obj; } /** * 抛出异常通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ void myAfterThrowing(JoinPoint joinPoint, Throwable throwable) { System.out.println(\"抛出异常通知。\" + throwable.getMessage()); } /** * 最终通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ void myAfter(JoinPoint joinPoint) { System.out.println(\"最终通知。\" + joinPoint.getSignature().getName()); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 目标类 --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.aop.UserServiceImpl\"/> &lt;!-- 切面类 --> &lt;bean id=\"myAspect\" class=\"com.kuukokawaii.aop.MyAspect\"/> &lt;!-- aop编程： &lt;aop:aspect>：将切面类声明成“切面”，从而获得通知（方法）。 ref：引用切面类。 &lt;aop:pointcut>：声明一个切入点，所有的通知都可以使用。 expression：切入点表达式。 id：用于其他通知使用。 &lt;aop:before>: 前置通知，目标方法前执行。 method：通知及方法名。 pointcut：切入点表达式，此表达式只能当前通知使用。 pointcut-ref：切入点的引用，可以与其他通知共享切入点。 &lt;aop:after-returning>：后置通知，目标方法后执行，可获得返回值。 returning：类型 Object, 用于获取返回值，需要与方法中的参数名相对应。类型 Object。 &lt;aop:around>：环绕通知。前置通知优先环绕通知执行。 &lt;aop:after-throwing>：抛出异常通知。抛出异常之后的语句不再执行。 throwing：用于获取异常信息，需要与方法中的参数名相对应。类型 Throwable。 &lt;aop:after>：最终通知。相当于 try/catch 中的 finally，抛出异常也会执行。方法执行后执行，优先级高于环绕（后）通知 --> &lt;aop:config> &lt;aop:aspect ref=\"myAspect\"> &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.kuukokawaii.aop.*.*(..))\"/> &lt;aop:before method=\"myBefore\" pointcut-ref=\"myPointcut\"/> &lt;aop:after-returning method=\"myAfterReturning\" pointcut-ref=\"myPointcut\" returning=\"returning\"/> &lt;aop:around method=\"myAround\" pointcut-ref=\"myPointcut\"/> &lt;aop:after-throwing method=\"myAfterThrowing\" pointcut-ref=\"myPointcut\" throwing=\"throwable\"/> &lt;aop:after method=\"myAfter\" pointcut-ref=\"myPointcut\"/> &lt;/aop:aspect> &lt;/aop:config> &lt;/beans> 基于注解配置UserServiceImpl 类需要加上 @Service 注解。@Aspect 用于声明切面类。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!-- 包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii.aop\"/> &lt;!-- aop 注解扫描，自动代理 --> &lt;aop:aspectj-autoproxy/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/9/2 15:47 * @Description 切面类。 */ @Component @Aspect public class MyAspect { /** * 声明公共切入点 */ @Pointcut(\"execution(* com.kuukokawaii.aop.UserServiceImpl.*(..))\") private void myPointcut() { } /** * 前置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ @Before(\"myPointcut()\") void myBefore(JoinPoint joinPoint) { System.out.println(\"前置通知。\" + joinPoint.getSignature().getName()); } /** * 后置通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 * @param returning 用于获取返回值。 */ @AfterReturning(value = \"myPointcut()\", returning = \"returning\") void myAfterReturning(JoinPoint joinPoint, Object returning) { System.out.println(\"后置通知。\" + joinPoint.getSignature().getName() + \"，返回值：\" + returning); } /** * 环绕通知。 * * @param proceedingJoinPoint 连接点 * @return 返回目标方法。 * @throws Throwable 方法执行异常。 */ @Around(\"myPointcut()\") Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // 前 System.out.println(\"环绕前\"); // 手动执行目标方法。 Object obj = proceedingJoinPoint.proceed(); // 后 System.out.println(\"环绕后\"); return obj; } /** * 抛出异常通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ @AfterThrowing(value = \"myPointcut()\", throwing = \"throwable\") void myAfterThrowing(JoinPoint joinPoint, Throwable throwable) { System.out.println(\"抛出异常通知。\" + throwable.getMessage()); } /** * 最终通知。 * * @param joinPoint 用于描述连接点（目标方法），用于获得当前目标方法的方法名等。 */ @After(\"myPointcut()\") void myAfter(JoinPoint joinPoint) { System.out.println(\"最终通知。\" + joinPoint.getSignature().getName()); } } /** * @Author 喵粮都输光了 * @Date 09/02/2019 * @Description UserServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class UserServiceImplTest { @Autowired private UserService userService; /** * Method: addUser() */ @Test public void test() throws Exception { userService.addUser(); userService.updateUser(); userService.deleteUser(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（四）：bean 装配","date":"2019-09-01T05:36:41.000Z","path":"posts/4364/","text":"实例化方式bean 有3种实例化的方式：默认构造、静态工厂和实例化工厂。 默认构造通过&lt;bean id=\"\" class=\"要装配的实现类全限定类名\" /&gt;的方式装配 bean 便是自动使用了默认构造。 静态工厂静态工厂用于生成实例对象，且所有的方法必须是静态的。常用于 Spring 整合其他框架（工具）。通过&lt;bean id=\"\" class=\"要整合的工厂实现类全限定类名\" factory-method=\"静态方法名\" /&gt;进行 bean 的装配。代码演示如下： /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:07 * @Description StaticFactoryService 接口类 */ public interface StaticFactoryService { /** * 测试输出语句 */ void test(); } /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:07 * @Description StaticFactoryService 实现类 */ public class StaticFactoryServiceImpl implements StaticFactoryService { @Override public void test() { System.out.println(\"静态工厂输出成功。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:08 * @Description 自定义 bean 静态工厂 */ public class MyStaticBeanFactory { /** * 创建 StaticFactoryService 实例。 * @return 返回 StaticFactoryService 实例对象。 */ public static StaticFactoryService createService(){ return new StaticFactoryServiceImpl(); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 将静态工厂创建的实例交予 Spring 管理。 class：输入静态工厂的全限定类名。 factory-method：输入需要获取的静态工厂中所存在的静态方法名。 --> &lt;bean id=\"staticFactoryService\" class=\"com.kuukokawaii.di.MyStaticBeanFactory\" factory-method=\"createService\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/01/2019 * @Description StaticFactoryServiceImpl test */ public class StaticFactoryServiceImplTest { /** * Method: test() */ @Test public void testTest() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 StaticFactoryService staticFactoryService = applicationContext.getBean(\"staticFactoryService\", StaticFactoryService.class); staticFactoryService.test(); } } 实例化工厂实例化工厂通过工厂实例对象创建对象，且所有的方法都是非静态的。代码演示如下： 此处代码与上述静态工厂共用 StaticFactoryService 、 StaticFactoryServiceImpl 和 测试类。 /** * @Author 喵粮都输光了 * @Date 2019/9/1 14:08 * @Description 自定义 bean 实例工厂 */ public class MyBeanFactory { /** * 创建 StaticFactoryService 实例。 * @return 返回 StaticFactoryService 实例对象。 */ public StaticFactoryService createService(){ return new StaticFactoryServiceImpl(); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 1.将自定义实例工厂交予 Spring 管理。 class：输入实例工厂的全限定类名。 2.通过实例工厂配置 bean。 factory-bean：配置好的实例工厂的 bean 的 id。 factory-method：输入需要获取的实例工厂中所存在的方法名。 --> &lt;bean id=\"myBeanFactory\" class=\"com.kuukokawaii.di.MyBeanFactory\"/> &lt;bean id=\"staticFactoryService\" factory-bean=\"myBeanFactory\" factory-method=\"createService\"/> &lt;/beans> 作用域Spring 的作用域用于确定创建的 bean 的实例个数。通过 XML 配置 bean 时，添加scope属性进行配置（如&lt;bean id=\"\" class=\"\" scope=\"\" /&gt;）。常用的scope属性有singleton（单例）和prototype（多例）。 生命周期可以将 bean 的生命周期划分为11个部分，具体如下图所示：图中各部分效用如下： Instantiate：初始化 bean，调用构造函数创建实例。 Populate properties：封装属性，即进行 DI 操作。 BeanNameAware's setBeanName()：调用 BeanNameAware 接口的 setBeanName 方法获取 BeanName。 BeanFactoryAware's setBeanFactory()：调用 BeanFactoryAware 接口的 setBeanFactory 方法获取 BeanFactory。 Pre-initialization BeanPostProcessors：如果存在类实现 BeanPostProcessor,则执行 postProcessBeforeInitialization 方法进行预处理。 InitializingBean's afterPropertiesSet()：如果 bean 实现 InitializingBean，则执行 afterPropertiesSet 方法。 Call custom init-method：调用自定义的 init-method 方法。 Post-initialization BeanPostProcessors：如果存在类实现 BeanPostProcessor,执行 postProcessAfterInitialization 方法进行后处理。 Bean is ready to use / Container is Shutdown：执行业务处理。 DisposableBean's destroy()：如果 bean 实现 DisposableBean，则执行 destroy 方法。 Call custom destroy-method：调用自定义的 destroy-method。 bean 生命周期常用操作： 初始化和摧毁 如果需要进行初始化或摧毁的操作，可以通过使用init-method和destroy-method属性进行设置，其中destroy-method 只有在 scope=singleton 的时候才会生效。（如&lt;bean id=\"\" class=\"\" init-method=\"\" destory-method=\"\"/&gt;）。 1.在 beans 标签下的default-init-method可以设置所有默认的属性。2.优先级：InitializationBean 和 DisposableBean &gt; init-method 和 destroy-method &gt; default。 后处理 在 Spring 中实现 BeanPostProcessor 接口，并将实现类提供给 Spring 容器，Spring 容器就会自动的执行该实现类。在初始化方法前执行 before()，在初始化方法后执行 after()。 代码演示如下： /** * @Author 喵粮都输光了 * @Date 2019/9/1 16:13 * @Description 后处理 bean 实现类 */ public class MyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"初始化前\"); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"初始化后\"); return bean; } } /** * @Author 喵粮都输光了 * @Date 2019/9/1 16:16 * @Description BeanPostProcessorService 接口类 */ public interface BeanPostProcessorService { /** * 测试输出语句 */ void test(); } /** * @Author 喵粮都输光了 * @Date 2019/9/1 16:16 * @Description BeanPostProcessorService 实现类 */ public class BeanPostProcessorServiceImpl implements BeanPostProcessorService { @Override public void test() { System.out.println(\"测试方法内容。\"); } public void init() { System.out.println(\"初始化\"); } public void destroy(){ System.out.println(\"摧毁\"); } } &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"beanPostProcessorService\" class=\"com.kuukokawaii.di.BeanPostProcessorServiceImpl\" init-method=\"init\" destroy-method=\"destroy\"/> &lt;bean class=\"com.kuukokawaii.di.MyBeanPostProcessor\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 09/01/2019 * @Description BeanPostProcessorServiceImpl test */ public class BeanPostProcessorServiceImplTest { /** * Method: test() */ @Test public void testTest() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 BeanPostProcessorService beanPostProcessorService = applicationContext.getBean(\"beanPostProcessorService\", BeanPostProcessorService.class); beanPostProcessorService.test(); applicationContext.close(); } } 输出结果如下： 属性依赖注入setter 方法关键代码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- setter 方法注入： &lt;bean id=\"\" class=\"\"> // 普通数据： &lt;property name=\"\" value=\"值\"/> // 引用数据： &lt;property name=\"\" ref=\"另一个 bean\"/> &lt;/bean> --> &lt;bean id=\"person\" class=\"com.kuukokawaii.setter.Person\"> &lt;property name=\"name\" value=\"老大\"/> &lt;property name=\"address\" ref=\"address\"/> &lt;/bean> &lt;bean id=\"address\" class=\"com.kuukokawaii.setter.Address\"> &lt;property name=\"companyAddress\" value=\"学校地址\"/> &lt;property name=\"homeAddress\" value=\"家庭地址\"/> &lt;/bean> &lt;/beans> P 命名空间对 setter 方法注入进行简化，替换&lt;property name=\"属性名\"/&gt;为&lt;bean p:属性名=\"值\" p:属性名-ref=\"引用值\"。P 命名空间需要在 xml 头部增加xmlns:p=\"http://www.springframework.org/schema/p\"。关键代码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"person\" class=\"com.kuukokawaii.setter.Person\" p:name=\"老大\" p:address-ref=\"address\"/> &lt;bean id=\"address\" class=\"com.kuukokawaii.setter.Address\" p:companyAddress=\"学校地址\" p:homeAddress=\"家庭地址\"/> &lt;/beans> SpEL对&lt;property&gt;进行统一编程，所有内容都使用value（如`&lt;property name=”” value=”#{表达式}”。表达式详情参考：Spring Expression Language 集合注入集合的注入就是给&lt;property&gt;添加子标签。数组使用&lt;array&gt;、List 使用&lt;list&gt;、Set 使用&lt;set&gt;、Map 使用&lt;map&gt;、Properties使用&lt;props&gt;。其中 Map 和 Properties 存放键值对时分别需要使用&lt;entry&gt;和&lt;prop&gt;描述。关键代码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"collData\" class=\"com.kuukokawaii.setter.CollData\"> &lt;property name=\"arrayData\"> &lt;array> &lt;value>array1&lt;/value> &lt;value>array2&lt;/value> &lt;/array> &lt;/property> &lt;property name=\"listData\"> &lt;list> &lt;value>list1&lt;/value> &lt;value>list2&lt;/value> &lt;/list> &lt;/property> &lt;property name=\"setData\"> &lt;set> &lt;value>set1&lt;/value> &lt;value>set2&lt;/value> &lt;/set> &lt;/property> &lt;property name=\"mapData\"> &lt;map> &lt;entry key=\"mk1\" value=\"mv1\"/> &lt;entry key=\"mk2\" value=\"mv2\"/> &lt;/map> &lt;/property> &lt;property name=\"propsData\"> &lt;props> &lt;prop key=\"pk1\">pv1&lt;/prop> &lt;prop key=\"pk2\">pv2&lt;/prop> &lt;/props> &lt;/property> &lt;/bean> &lt;/beans> 基于注解配置 注解就是一个使用了@注解名称的类，比 XML 使用起来更方便。使用注解前需要配置 Spring 包扫描，扫描含有注解的类。 在 web 开发中，常用3个 @Component 注解衍生注解 @Repository：用于 Dao 层。 @Service：用于 Service 层。 @Controller：用于 Web 层。 依赖注入（可以给私有字段设置，也可以给 setter 方法设置。） 普通值：@Value(“需要设置的值”) 引用值： 按照类型注入：@Autowired。 按照名称注入1：@Autowired 和 @Qualifier(“名称”)联合使用。 按照名称注入2：@Resource(“名称”)。 生命周期初始化：@PostConstruct销毁：@PreDestroy 作用域：@Scope(“属性”) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（三）：DI","date":"2019-08-30T13:07:35.000Z","path":"posts/639/","text":"什么是 DI在依赖注入中，如果对象 A 中使用到对象 B，则称对象 A 依赖于对象 B；而当你创建对象 A 时，由于对象 A 依赖于对象 B 需要额外创建一个对象 B，并调用对象 A 的 set 方法进行对象 B 的实例设置，这便称为注入。 案例说明 创建 BookService 接口和实现类。 创建 BookDao 接口和实现类。 通过依赖注入获得 dao 和 service。 通过 xml 配置的方式。 通过注解的方式。 使用到的 Jar 包 spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar commons-logging.jar junit.jar spring-test.jar 代码演示/** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookDao 接口类 */ public interface BookDao { /** * 增加书本 */ void insertBook(); } /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:21 * @Description BookDao 实现类 */ public class BookDaoImpl implements BookDao { @Override public void insertBook() { System.out.println(\"书本添加成功。\"); } } /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookService 接口类 */ public interface BookService { /** * 增加书本 */ void addBook(); } /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookService 实现类 */ public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDaoImpl bookDao) { this.bookDao = bookDao; } @Override public void addBook() { bookDao.insertBook(); } } XML 文件配置方式从 Spring 容器中获得实例对象。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 以下配置其实就执行了三个步骤： 1.BookService bookService = new BookServiceImpl(); 2.BookDao bookDao = new BookDaoImpl(); 3.bookService.setBookDao(bookDao); 其中&lt;property name=\"\" ref=\"\"/>就相当于上述的 set 方法。 --> &lt;bean id=\"bookService\" class=\"com.kuukokawaii.di.BookServiceImpl\"> &lt;property name=\"bookDao\" ref=\"bookDao\"/> &lt;/bean> &lt;bean id=\"bookDao\" class=\"com.kuukokawaii.di.BookDaoImpl\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 08/30/2019 * @Description BookServiceImpl test */ public class BookServiceImplTest { /** * Method: addBook() */ @Test public void testAddBook() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 BookService bookService = (BookService) applicationContext.getBean(\"bookService\"); bookService.addBook(); } } 注解方式从 Spring 容器中获得实例对象。（需要在 BookServiceImpl 类加上 @Service 注解以及 BookDaoImpl 类加上 @Repository 注解，让包扫描能够扫描到。） 此处修改了 BookServiceImpl 类 和 XML 配置。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;context:component-scan base-package=\"com.kuukokawaii\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 2019/8/30 15:16 * @Description BookService 实现类 */ @Service public class BookServiceImpl implements BookService { private final BookDao bookDao; @Autowired public BookServiceImpl(BookDao bookDao) { this.bookDao = bookDao; } @Override public void addBook() { bookDao.insertBook(); } } /** * @Author 喵粮都输光了 * @Date 08/30/2019 * @Description BookServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class BookServiceImplTest { @Autowired private BookService bookService; /** * Method: addBook() */ @Test public void testAddBook() throws Exception { bookService.addBook(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（二）：IoC","date":"2019-08-29T04:48:33.000Z","path":"posts/6802/","text":"什么是 IoCIoC 可以理解为借助于“第三方”实现对象之间的解耦。Spring IoC 通过使用 IoC 容器调控系统内所有的对象，使得对象之间没有了耦合关系，而 IoC 容器成为了整个项目的核心部分，当 IoC 容器失效时，所有对象彼此之间都会失去联系。 案例说明 创建 UserService 接口和实现类。 获得 UserService 实现类的实例。 通过 XML 文件配置的方式，从 Spring 容器中获得实例对象。 通过注解的方式从 Spring 容器中获得实例对象。 使用到的 Jar 包 spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar commons-logging.jar junit.jar spring-test.jar 代码演示/** * @Author 喵粮都输光了 * @Date 2019/8/29 18:05 * @Description UserService 接口类 */ public interface UserService { /** * 增加用户 */ void addUser(); } /** * @Author 喵粮都输光了 * @Date 2019/8/29 18:06 * @Description UserService 实现类 */ public class UserServiceImpl implements UserService { @Override public void addUser() { System.out.println(\"增加用户。\"); } } XML 文件配置方式从 Spring 容器中获得实例对象。（Spring配置文件常用 ApplicationContext 命名。） &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 需要配置的 bean --> &lt;bean id=\"userService\" class=\"com.kuukokawaii.ioc.UserServiceImpl\" /> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 08/29/2019 * @Description UserServiceImpl test */ public class UserServiceImplTest { @Test public void testAddUser() throws Exception { // spring 配置文件路径。 String xmlPath = \"applicationContext.xml\"; // spring 工厂（spring 容器）。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 从工厂内获取对象。 UserService userService = (UserService) applicationContext.getBean(\"userService\"); userService.addUser(); } } 注解方式通过注解从 Spring 容器中获得实例对象。（需要在 UserServiceImpl 类加上 @Service 注解，让包扫描能够扫描到。） 需要注意的是用 spring 进行 Junit 测试时，需要引入 spring-test.jar，并在测试类上加入 @RunWith 和 @ContextConfiguration 的注解配置。如果还有错误可以尝试更新 Junit.jar 的版本。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 配置包扫描 --> &lt;context:component-scan base-package=\"com.kuukokawaii\"/> &lt;/beans> /** * @Author 喵粮都输光了 * @Date 08/29/2019 * @Description UserServiceImpl test */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class UserServiceImplTest { @Autowired private UserService userService; /** * Method: addUser() */ @Test public void testAddUser() throws Exception { userService.addUser(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]},{"title":"Spring（一）：简介","date":"2019-08-28T07:07:50.000Z","path":"posts/14546/","text":"Spring 优点 方便解耦，简化开发可以将所有对象的创建和依赖关系的维护交给 Spring 管理。 AOP 编程的支持Spring 提供面向切面的编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 声明式事务的支持无需手动编程，只需要通过配置就可以完成对事物的管理。 方便程序的测试Spring 支持 Junit，可以通过注解方便的测试 Spring 程序。 方便集成各种优秀框架Spring 内部提供了对各种优秀框架（Struts、Hibernate、MyBatis、Quartz……）的直接支持。 降低 JavaEE API 的使用难度Spring 封装了 JavaEE 开发中一些非常难用的 API(JDBC、JavaMail、远程调用……)，降低了这些 API 的应用难度。 Spring 体系结构Spring 框架是一个分层架构，它将一系列的功能要素分为 Data Access/Integration，Web，AOP，Core Container，Instrumentation 和 Test 等几大模块。 Core Container Beans：用于管理 Bean。 Core：Spring 的核心，主要用于实现反向控制 IoC（Inversion of Control）与依赖注入 DI（Dependency Injection）、Bean 配置以及加载。 Context：上下文，相当于配置文件。 Expression Language：即 SpEL，是 Spring 的一种表达式，用来动态的获取值、对象等。 AOP AOP：切面编程（Aspect Oriented Programming）。 Aspects：一个切面编程的框架。 Data Access/Integration JDBC：用于链接数据库，向数据库发送 sql 语句。 ORM：对象关系映射，用于整合持久层框架（Mybatis，Hibernate……）。 OXM：即 O/X 映射器，用于将 Java 对象和 XML 文档之间进行互相转换。 JMS：即 Java消息服务，用于两个应用程序之间传送消息，进行异步通信。 Transactions：事务管理。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"spring","slug":"spring","permalink":"https://blog.kuukokawaii.com/tags/spring/"}]}]